"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[668],{3905:(e,a,t)=>{t.d(a,{Zo:()=>u,kt:()=>b});var n=t(67294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=n.createContext({}),d=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},u=function(e){var a=d(e.components);return n.createElement(s.Provider,{value:a},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},y=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=d(t),y=r,b=c["".concat(s,".").concat(y)]||c[y]||p[y]||i;return t?n.createElement(b,l(l({ref:a},u),{},{components:t})):n.createElement(b,l({ref:a},u))}));function b(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=y;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o[c]="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=t[d];return n.createElement.apply(null,l)}return n.createElement.apply(null,t)}y.displayName="MDXCreateElement"},71969:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var n=t(83117),r=(t(67294),t(3905));const i={},l="Using Binary Data",o={unversionedId:"developer-guide/binary-data",id:"developer-guide/binary-data",title:"Using Binary Data",description:"Binary data support in deck.gl is actively being developed. This article provides information on current state and some hints about what may come.",source:"@site/../docs/developer-guide/binary-data.md",sourceDirName:"developer-guide",slug:"/developer-guide/binary-data",permalink:"/docs/developer-guide/binary-data",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/binary-data.md",tags:[],version:"current",frontMatter:{}},s={},d=[{value:"Binary Data",id:"binary-data",level:2},{value:"CPU vs GPU memory",id:"cpu-vs-gpu-memory",level:3},{value:"Endianness",id:"endianness",level:3},{value:"Flattened vs. Nested Data",id:"flattened-vs-nested-data",level:3},{value:"Interleaved Data",id:"interleaved-data",level:3},{value:"Binary Table Formats",id:"binary-table-formats",level:2},{value:"Row-Based Tables (non-Binary)",id:"row-based-tables-non-binary",level:3},{value:"Columnar Tables",id:"columnar-tables",level:2},{value:"Chunked Columnar Tables",id:"chunked-columnar-tables",level:2},{value:"Using Binary Data",id:"using-binary-data-1",level:2},{value:"Using Binary Data directly in GPU",id:"using-binary-data-directly-in-gpu",level:2},{value:"Using Binary Data to Calculate Attributes in GPU/GLSL",id:"using-binary-data-to-calculate-attributes-in-gpuglsl",level:2},{value:"Use Binary Data to Generate Attributes in CPU/JavaScript",id:"use-binary-data-to-generate-attributes-in-cpujavascript",level:2}],u={toc:d},c="wrapper";function p(e){let{components:a,...t}=e;return(0,r.kt)(c,(0,n.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"using-binary-data"},"Using Binary Data"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Binary data support in deck.gl is actively being developed. This article provides information on current state and some hints about what may come.")),(0,r.kt)("h2",{id:"binary-data"},"Binary Data"),(0,r.kt)("p",null,"If you plan to work with binary data, you will want to make sure you are up to speed on JavaScript typed arrays as well as GPU buffers, both in terms of general concepts as well as a basic grasp of the API."),(0,r.kt)("p",null,"JavaScript has a number of different ways to represent binary data (Browser ",(0,r.kt)("inlineCode",{parentName:"p"},"Blob"),", Node.js Buffers, base64 etc), however deck.gl primarily accepts typed arrays. deck.gl should accept GPU buffers (luma.gl ",(0,r.kt)("inlineCode",{parentName:"p"},"Buffer")," instances)."),(0,r.kt)("h3",{id:"cpu-vs-gpu-memory"},"CPU vs GPU memory"),(0,r.kt)("p",null,'Ultimately all deck.gl rendering is done on the GPU, and all memory must be available to the GPU by being "uploaded" into GPU memory ',(0,r.kt)("inlineCode",{parentName:"p"},"Buffers"),". By pre-creating GPU buffers and passing these to deck.gl layers you exercise the maximum amount of control of memory management."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {Buffer} from 'luma.gl';\nconst buffer = new Buffer(gl, {data: });\n")),(0,r.kt)("p",null,"Note that GPU buffers have many advanced features. They can be interleaved etc. The luma.gl ",(0,r.kt)("inlineCode",{parentName:"p"},"Accessor")," class lets you describe how GPU Buffers should be accessed."),(0,r.kt)("h3",{id:"endianness"},"Endianness"),(0,r.kt)("p",null,'In most cases, when working with binary data, care must be taken to properly define and respect "endianness" which essentially describes the order of bytes when larger numbers are stored in memory. However, essentially all of the current web is little endian, so potential big-endian issues are ignored for now.'),(0,r.kt)("h3",{id:"flattened-vs-nested-data"},"Flattened vs. Nested Data"),(0,r.kt)("p",null,"Binary data is flat, whereas JavaScript Arrays can have structure"),(0,r.kt)("h3",{id:"interleaved-data"},"Interleaved Data"),(0,r.kt)("p",null,"Binary data can be interleaved. Working directly with interleaved data requires working with  luma.gl ",(0,r.kt)("inlineCode",{parentName:"p"},"Buffer")," instances and attribute accessor objects and is considered an advanced topic."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// lon1, lat1, radius1, red1, green1, blue1, lon2, lat2, ...\nconst binaryData = new Float32Array([-122.4, 37.78, 1000, 255, 200, 0, -122.41, 37.775, 500, 200, 0, 0, -122.39, 37.8, 500, 0, 40, 200]);\n")),(0,r.kt)("h2",{id:"binary-table-formats"},"Binary Table Formats"),(0,r.kt)("p",null,'deck.gl layers are designed to accept "tables" of data as input (the ',(0,r.kt)("inlineCode",{parentName:"p"},"data")," prop). Tables can be organized in several different ways. For binary data you will be working with columnar tables."),(0,r.kt)("h3",{id:"row-based-tables-non-binary"},"Row-Based Tables (non-Binary)"),(0,r.kt)("p",null,"Row-based tables are the most common and generally the easiest to work with (each row is typically a JavaScript object with fields representing the values of various columns at that row)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"new Layer({\n  data: [\n    {value: 1, time: 1.00},\n    {value: 2, time: 1.10},\n  ]\n})\n")),(0,r.kt)("h2",{id:"columnar-tables"},"Columnar Tables"),(0,r.kt)("p",null,"Organizing values by column instead of row creates a columnar table. Columnar tables can be significantly more efficient. In particular, because each value is of the same type, columnar tables can be stored as binary data."),(0,r.kt)("p",null,'To use a columnar table as layer data, provide a bundle of typed arrays (a "vector bundle"?) as your ',(0,r.kt)("inlineCode",{parentName:"p"},"data")," prop:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"new Layer({\n  data: {\n    value: new Int32Array([1, 2]),\n    time: new Float32Array([1.00, 1.10])\n  }\n});\n")),(0,r.kt)("h2",{id:"chunked-columnar-tables"},"Chunked Columnar Tables"),(0,r.kt)("p",null,"A disadvantage of columnar tables is that columns can get very long, blocking incremental reads/writes of tables and even exceeding platform's allocation limits."),(0,r.kt)("p",null,'More advanced binary columnar table formats like Apache Arrow solves this by breaking logical arrays into chunks. An additional benefit of chunked arrays can support remarkably efficient data-frame operations (slicing/dicing and filtering multi-gigabyte data set with "zero cost").'),(0,r.kt)("p",null,"Another complication when using binary columnar tables is that it may not be possible to represent e.g. the lack of a value. In some libraries (e.g. Apache Arrow) this is solved through an additional ",(0,r.kt)("inlineCode",{parentName:"p"},"null map"),"."),(0,r.kt)("p",null,"Thus, a downside of chunked arrays is that they are complex to work with that they typically require an API (such as Apache Arrow)."),(0,r.kt)("p",null,"Chunked Arrow Arrays follows a more complicated relationship with ",(0,r.kt)("inlineCode",{parentName:"p"},"Vector")," instances representing chunks:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Table ---* Column (Chunked) ---* Vector")),(0,r.kt)("p",null,"Note: These cannot currently be used in deck.gl without pre-concatenating the chunks."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"There is an RFC (chunked-data-rfc) that would enable chunked data tables (data frames) to be directly consumed by deck.gl (and then sliced and diced at zero cost).")),(0,r.kt)("h2",{id:"using-binary-data-1"},"Using Binary Data"),(0,r.kt)("p",null,"It is sometimes desirable for applications to work directly with binary data and to be able to pass such binary data directly to layers. The motivation is often performance-related but it could just be that the application is able to load data directly in a binary format."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Using typed arrays as layer input data")," - Using The input data is in binary form, perhaps it is delivered this way from the back-end, and it would be preferable to not have to unpack it."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Using typed arrays or GPU buffers directly as layer attributes")," - The input data is already formatted in the memory format expected by the GPU and deck.gl's shaders.")),(0,r.kt)("h2",{id:"using-binary-data-directly-in-gpu"},"Using Binary Data directly in GPU"),(0,r.kt)("p",null,"The simplest way to supply binary data to deck.gl layers is to override normal attribute calculation and feed in a binary typed array to be used directly as the attribute."),(0,r.kt)("p",null,"This requires that the binary data columns are formatted in exactly the way that the layer expects. This is often fairly straight forward for ",(0,r.kt)("em",{parentName:"p"},"fixed primitive layers")," but not often practical for ",(0,r.kt)("em",{parentName:"p"},"variable primitive layers"),", as the number of vertices per primitive depends on the details of the tesselation algorithm which can be hard for the data provided to anticipate."),(0,r.kt)("h2",{id:"using-binary-data-to-calculate-attributes-in-gpuglsl"},"Using Binary Data to Calculate Attributes in GPU/GLSL"),(0,r.kt)("p",null,"This would mean passing binary data into the vertex shader and there use it to calculate the values the layer needs (colors, elevations etc). This use case would involve writing custom accessor functions. It is currently not directly supported in deck.gl, but could be achieved by creating a custom layer."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"There are RFCs (glsl accessors, texture attributes) that if implemented, would dramatically improve deck.gl's ability to use provided binary data attributes without pre-processing them in JavaScript.")),(0,r.kt)("h2",{id:"use-binary-data-to-generate-attributes-in-cpujavascript"},"Use Binary Data to Generate Attributes in CPU/JavaScript"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"JavaScript iteration approaches for binary data bundles are under development for v7")))}p.isMDXComponent=!0}}]);