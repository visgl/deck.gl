"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7079],{90375:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"developer-guide/custom-layers/primitive-layers","title":"Primitive Layers","description":"If you want to draw something completely different and you are comfortable around WebGL2/WebGPU shaders, you may consider implementing a new layer by directly extending the Layer class.","source":"@site/../docs/developer-guide/custom-layers/primitive-layers.md","sourceDirName":"developer-guide/custom-layers","slug":"/developer-guide/custom-layers/primitive-layers","permalink":"/docs/developer-guide/custom-layers/primitive-layers","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/custom-layers/primitive-layers.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Creating Layer Extensions","permalink":"/docs/developer-guide/custom-layers/layer-extensions"},"next":{"title":"Property Types","permalink":"/docs/developer-guide/custom-layers/prop-types"}}');var i=n(74848),s=n(28453);const a={},o="Primitive Layers",l={},d=[{value:"Implementing the Layer Lifecycle Functions",id:"implementing-the-layer-lifecycle-functions",level:2},{value:"Initializing Layer",id:"initializing-layer",level:3},{value:"Creating The Model",id:"creating-the-model",level:4},{value:"Defining Attributes",id:"defining-attributes",level:4},{value:"Handling property updates",id:"handling-property-updates",level:3},{value:"Rendering Layer",id:"rendering-layer",level:3},{value:"Destroying Layer",id:"destroying-layer",level:3},{value:"Handling Coordinate Systems",id:"handling-coordinate-systems",level:2},{value:"Making Shaders Work with deck.gl&#39;s Coordinate Systems",id:"making-shaders-work-with-deckgls-coordinate-systems",level:3},{value:"Implement Picking",id:"implement-picking",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"primitive-layers",children:"Primitive Layers"})}),"\n",(0,i.jsxs)(t.p,{children:["If you want to draw something completely different and you are comfortable around WebGL2/WebGPU shaders, you may consider implementing a new layer by directly extending the ",(0,i.jsx)(t.a,{href:"/docs/api-reference/core/layer",children:(0,i.jsx)(t.code,{children:"Layer"})})," class."]}),"\n",(0,i.jsx)(t.h2,{id:"implementing-the-layer-lifecycle-functions",children:"Implementing the Layer Lifecycle Functions"}),"\n",(0,i.jsxs)(t.p,{children:["To describe how a layer's properties relate to shader attributes and uniforms you need to implement the layer's ",(0,i.jsx)(t.a,{href:"/docs/developer-guide/custom-layers/layer-lifecycle",children:"lifecycle functions"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"initializing-layer",children:"Initializing Layer"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/api-reference/core/layer#initializestate",children:(0,i.jsx)(t.code,{children:"initializeState()"})})," - This is the one method that you must implement to create any GPU resources you need for rendering your layer."]}),"\n",(0,i.jsx)(t.h4,{id:"creating-the-model",children:"Creating The Model"}),"\n",(0,i.jsxs)(t.p,{children:["A layer should create its model during this phase. A model is a ",(0,i.jsx)(t.a,{href:"https://github.com/visgl/luma.gl",children:"luma.gl"})," ",(0,i.jsx)(t.a,{href:"https://github.com/visgl/luma.gl/blob/8.0-release/docs/api-reference/engine/model.md",children:"Model"})," instance that defines what will be drawn to the WebGL2/WebGPU context."]}),"\n",(0,i.jsxs)(t.p,{children:["Most layers are ",(0,i.jsx)(t.strong,{children:"Single-model layers"})," - this is the predominant form among all core layers that deck.gl currently provides. In these layers, a single geometry model is created for each layer and saved to ",(0,i.jsx)(t.code,{children:"state.model"})," during initialization. The default implementation of the rest of the lifecycle methods will then look for this model for rendering and picking etc., meaning that you don't have to do anything more to get a working layer."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"import {Layer} from '@deck.gl/core';\n\nexport default class CubeLayer extends Layer {\n\n  initializeState() {\n    const {gl} = this.context;\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  _getModel(gl) {\n    // TODO: create Model here\n  }\n\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"A choice to make is whether your GPU primitives (draw calls) should be instanced, or use dynamic geometry:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Instanced layer"})," - This type of layer renders the same geometry many times. Usually the simplest way to go when creating a layer that renders a lot of similar objects (think ScatterplotLayer, ArcLayers etc)."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"import {Model, CubeGeometry} from '@luma.gl/core';\n\nexport default class CubeLayer extends Layer {\n  ...\n  _getModel(gl) {\n    return new Model(gl, Object.assign({}, this.getShaders(), {\n      id: this.props.id,\n      geometry: new CubeGeometry(),\n      isInstanced: true\n    }));\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Dynamic geometry layer"})," - This is needed when dealing with data that needs to be rendered using multiple similar but unique geometries, such as polygons (i.e. the geometries are not copies of each other that that only differ in terms of parameters)."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"import {Model, Geometry} from '@luma.gl/core';\n\nexport default class MyLayer extends Layer {\n  ...\n  _getModel(gl) {\n    return new Model(gl, Object.assign({}, this.getShaders(), {\n      id: this.props.id,\n      geometry: new Geometry({\n        id: this.props.id,\n        topology: 'line-list',\n      }),\n      vertexCount: 0,\n      isIndexed: true\n    });\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It is sometimes desirable to have a single layer render using multiple geometry primitives (e.g both circles and lines, or triangles and textured meshes etc), rather than creating separate layers. The custom ",(0,i.jsx)(t.a,{href:"https://github.com/visgl/deck.gl/tree/9.1-release/examples/website/plot/plot-layer/axes-layer.js",children:"AxesLayer example"})," uses this technique to share attributes between grids and labels."]}),"\n",(0,i.jsx)(t.h4,{id:"defining-attributes",children:"Defining Attributes"}),"\n",(0,i.jsxs)(t.p,{children:["A layer should also define its attributes during initialization. This allows the ",(0,i.jsx)(t.a,{href:"/docs/api-reference/core/attribute-manager",children:(0,i.jsx)(t.code,{children:"attribute manager"})})," to do the heavy lifting for ",(0,i.jsx)(t.a,{href:"/docs/developer-guide/custom-layers/attribute-management",children:"Attribute Management"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Define attributes by calling ",(0,i.jsx)(t.a,{href:"/docs/api-reference/core/attribute-manager#add",children:(0,i.jsx)(t.code,{children:"attributeManager.add"})}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"initializeState() {\n  const {gl} = this.context;\n  this.setState({\n    model: this._getModel(gl)\n  });\n\n  this.state.attributeManager.add({\n    /* this attribute is automatically filled by the return value of `props.getPosition` */\n    instancePositions: {size: 3, accessor: 'getPosition'},\n    /* this attribute is populated by calling `layer.calculateInstanceColors` */\n    instanceColors: {size: 4, type: GL.UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors}\n  });\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"handling-property-updates",children:"Handling property updates"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/api-reference/core/layer#updatestate",children:(0,i.jsx)(t.code,{children:"updateState()"})})," - This is the method that you may want to implement to handle property changes."]}),"\n",(0,i.jsx)(t.p,{children:"The key to writing good, performant deck.gl layers lies in understanding how to minimize updates of any calculated data, such as GPU buffers."}),"\n",(0,i.jsx)(t.p,{children:"The ideas used here are very similar to (and directly inspired by) those used in the React/Redux/Flux/Immutable.js communities, and learning more about those frameworks can be helpful as a way to get a better understanding of how to use these concepts in the best way."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"data"})," - Typically if a layer is re-rendered with a changed ",(0,i.jsx)(t.code,{children:"data"})," prop, all GPU attributes must be regenerated and the layer needs to be redrawn. The default is to do exactly that, but sometimes a layer can be smarter and limit updates, or more work needs to be done."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"If the viewport has changed, the layer will automatically be re-rendered. Many layers can thus ignore viewport changes, however, if the layer has any dependencies on the viewport (such as a layer that calculates extents or positions in screen space rather than world space) it would need to update state or uniforms whenever the viewport changes."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"If other props change, it would typically mean that the layer needs to update some uniform or state so that rendering is affected appropriately."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"rendering-layer",children:"Rendering Layer"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/api-reference/core/layer#draw",children:(0,i.jsx)(t.code,{children:"draw()"})})," - If you want to use custom uniforms or settings when drawing, you would typically implement the ",(0,i.jsx)(t.code,{children:"draw"})," method and pass those to your render call. Note that ",(0,i.jsx)(t.code,{children:"draw"})," is called with viewport uniforms that you need to pass to your shader, but you can of course add any layer specific uniforms to that."]}),"\n",(0,i.jsxs)(t.p,{children:["Note: the reason that the supplied uniforms need to be passed on to your shaders is to enable your shader to use deck.gl's GLSL shaderlibs (such as ",(0,i.jsx)(t.code,{children:"project"})," or ",(0,i.jsx)(t.code,{children:"project64"})," etc.). If you don't use these shaderlibs, you would obviously not need to supply these uniforms, but you would have to implement features like cartographic projection etc. on your own."]}),"\n",(0,i.jsx)(t.h3,{id:"destroying-layer",children:"Destroying Layer"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/api-reference/core/layer#finalizestate",children:(0,i.jsx)(t.code,{children:"finalizeState()"})})," - If implemented, this method is called when your layer state is discarded. This is a good time to destroy non-shared GPU resources directly, rather than waiting for the garbage collector to do it."]}),"\n",(0,i.jsx)(t.h2,{id:"handling-coordinate-systems",children:"Handling Coordinate Systems"}),"\n",(0,i.jsx)(t.p,{children:"While you have the freedom to create any type of layer you want, with any type of coordinate system that suits your application, a common characteristic of the layers provided by deck.gl is that they work seamlessly as map overlays, both with positions specified as longitude and latitude coordinates, as well as with positions specified in meters."}),"\n",(0,i.jsx)(t.h3,{id:"making-shaders-work-with-deckgls-coordinate-systems",children:"Making Shaders Work with deck.gl's Coordinate Systems"}),"\n",(0,i.jsxs)(t.p,{children:["By supplying the ",(0,i.jsx)(t.code,{children:"modules: ['project']"})," parameter when you create your layer's luma.gl ",(0,i.jsx)(t.code,{children:"Model"})," you get access to deck.gl's ",(0,i.jsx)(t.a,{href:"/docs/developer-guide/custom-layers/writing-shaders#projection",children:"family of GLSL projection methods"})," that support all three deck.gl projection modes: latlon (default), meters and neutral."]}),"\n",(0,i.jsx)(t.p,{children:"By always using the following shader functions for handling projections and scaling, a single layer class can support all projection modes for free:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["All positions must be passed through the ",(0,i.jsx)(t.code,{children:"project_position"}),' function (available both in JavaScript and GLSL) to convert non-linear web-mercator coordinates to linear mercator "world" or "pixel" coordinates, that can be passed to the projection matrix.']}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["All offsets must be passed through the ",(0,i.jsx)(t.code,{children:"project_scale"})," function (available both in JavaScript and GLSL) to convert distances to world coordinates. Note that that distance scales are latitude dependent under web mercator projection (see ",(0,i.jsx)(t.a,{href:"http://wiki.openstreetmap.org/wiki/Zoom_levels",children:"http://wiki.openstreetmap.org/wiki/Zoom_levels"})," for more details), so scaling will depend on the viewport center and should only be expected to be locally correct."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"implement-picking",children:"Implement Picking"}),"\n",(0,i.jsxs)(t.p,{children:["If your layer is instanced (",(0,i.jsx)(t.code,{children:"data"})," prop is an array and each element is rendered as one primitive), then you may take advantage of the default implementation of the ",(0,i.jsx)(t.a,{href:"/docs/api-reference/core/layer#layer-picking-methods",children:"layer picking methods"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["By default, each layer creates an ",(0,i.jsx)(t.code,{children:"instancePickingColors"})," attribute and automatically calculates it using the length of the ",(0,i.jsx)(t.code,{children:"data"})," array."]}),"\n",(0,i.jsxs)(t.p,{children:["For custom picking, read about ",(0,i.jsx)(t.a,{href:"/docs/developer-guide/custom-layers/picking#implementing-custom-picking",children:"Implementing Custom Picking"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(96540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);