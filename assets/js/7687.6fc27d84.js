"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7687],{78331:(t,e,s)=>{s.d(e,{A:()=>a});var n=s(97983);const r={id:"request-scheduler",throttleRequests:!0,maxRequests:6,debounceTime:0};class a{props;stats;activeRequestCount=0;requestQueue=[];requestMap=new Map;updateTimer=null;constructor(t={}){this.props={...r,...t},this.stats=new n.A({id:this.props.id}),this.stats.get("Queued Requests"),this.stats.get("Active Requests"),this.stats.get("Cancelled Requests"),this.stats.get("Queued Requests Ever"),this.stats.get("Active Requests Ever")}scheduleRequest(t,e=()=>0){if(!this.props.throttleRequests)return Promise.resolve({done:()=>{}});if(this.requestMap.has(t))return this.requestMap.get(t);const s={handle:t,priority:0,getPriority:e},n=new Promise((t=>(s.resolve=t,s)));return this.requestQueue.push(s),this.requestMap.set(t,n),this._issueNewRequests(),n}_issueRequest(t){const{handle:e,resolve:s}=t;let n=!1;const r=()=>{n||(n=!0,this.requestMap.delete(e),this.activeRequestCount--,this._issueNewRequests())};return this.activeRequestCount++,s?s({done:r}):Promise.resolve({done:r})}_issueNewRequests(){null!==this.updateTimer&&clearTimeout(this.updateTimer),this.updateTimer=setTimeout((()=>this._issueNewRequestsAsync()),this.props.debounceTime)}_issueNewRequestsAsync(){null!==this.updateTimer&&clearTimeout(this.updateTimer),this.updateTimer=null;const t=Math.max(this.props.maxRequests-this.activeRequestCount,0);if(0!==t){this._updateAllRequests();for(let e=0;e<t;++e){const t=this.requestQueue.shift();t&&this._issueRequest(t)}}}_updateAllRequests(){const t=this.requestQueue;for(let e=0;e<t.length;++e){const s=t[e];this._updateRequest(s)||(t.splice(e,1),this.requestMap.delete(s.handle),e--)}t.sort(((t,e)=>t.priority-e.priority))}_updateRequest(t){return t.priority=t.getPriority(t.handle),!(t.priority<0)||(t.resolve(null),!1)}}},72734:(t,e,s)=>{s.d(e,{B$:()=>i,IU:()=>r,Ix:()=>n,Pq:()=>a});const n=.1,r=1e-12,a=1e-15,i=1e-20;Math.PI,Math.PI,Math.PI,Math.PI},67733:(t,e,s)=>{s.d(e,{dO:()=>c,ie:()=>d,R2:()=>K,CB:()=>_,Zc:()=>V,ZZ:()=>it});const n=-1,r=0,a=1;var i=s(87597);const o=new i.P,u=new i.P;class c{constructor(t=[0,0,0],e=[0,0,0],s){s=s||o.copy(t).add(e).scale(.5),this.center=new i.P(s),this.halfDiagonal=new i.P(e).subtract(this.center),this.minimum=new i.P(t),this.maximum=new i.P(e)}clone(){return new c(this.minimum,this.maximum,this.center)}equals(t){return this===t||Boolean(t)&&this.minimum.equals(t.minimum)&&this.maximum.equals(t.maximum)}transform(t){return this.center.transformAsPoint(t),this.halfDiagonal.transform(t),this.minimum.transform(t),this.maximum.transform(t),this}intersectPlane(t){const{halfDiagonal:e}=this,s=u.from(t.normal),i=e.x*Math.abs(s.x)+e.y*Math.abs(s.y)+e.z*Math.abs(s.z),o=this.center.dot(s)+t.distance;return o-i>0?a:o+i<0?n:r}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=o.from(t).subtract(this.center),{halfDiagonal:s}=this;let n,r=0;return n=Math.abs(e.x)-s.x,n>0&&(r+=n*n),n=Math.abs(e.y)-s.y,n>0&&(r+=n*n),n=Math.abs(e.z)-s.z,n>0&&(r+=n*n),r}}var h=s(90218);const l=new i.P,m=new i.P;class d{constructor(t=[0,0,0],e=0){this.radius=-0,this.center=new i.P,this.fromCenterRadius(t,e)}fromCenterRadius(t,e){return this.center.from(t),this.radius=e,this}fromCornerPoints(t,e){return e=l.from(e),this.center=(new i.P).from(t).add(e).scale(.5),this.radius=this.center.distance(e),this}equals(t){return this===t||Boolean(t)&&this.center.equals(t.center)&&this.radius===t.radius}clone(){return new d(this.center,this.radius)}union(t){const e=this.center,s=this.radius,n=t.center,r=t.radius,a=l.copy(n).subtract(e),i=a.magnitude();if(s>=i+r)return this.clone();if(r>=i+s)return t.clone();const o=.5*(s+i+r);return m.copy(a).scale((-s+o)/i).add(e),this.center.copy(m),this.radius=o,this}expand(t){const e=l.from(t).subtract(this.center).magnitude();return e>this.radius&&(this.radius=e),this}transform(t){this.center.transform(t);const e=h.IL(l,t);return this.radius=Math.max(e[0],Math.max(e[1],e[2]))*this.radius,this}distanceSquaredTo(t){const e=this.distanceTo(t);return e*e}distanceTo(t){const e=l.from(t).subtract(this.center);return Math.max(0,e.len()-this.radius)}intersectPlane(t){const e=this.center,s=this.radius,i=t.normal.dot(e)+t.distance;return i<-s?n:i<s?r:a}}var f=s(35567),p=s(11633);const w=new i.P,P=new i.P,M=new i.P,g=new i.P,y=new i.P,x=new i.P,q=new i.P,b=0,A=1,I=2,T=3,C=4,E=5,N=6,R=7,S=8;class _{constructor(t=[0,0,0],e=[0,0,0,0,0,0,0,0,0]){this.center=(new i.P).from(t),this.halfAxes=new f.d(e)}get halfSize(){const t=this.halfAxes.getColumn(0),e=this.halfAxes.getColumn(1),s=this.halfAxes.getColumn(2);return[new i.P(t).len(),new i.P(e).len(),new i.P(s).len()]}get quaternion(){const t=this.halfAxes.getColumn(0),e=this.halfAxes.getColumn(1),s=this.halfAxes.getColumn(2),n=new i.P(t).normalize(),r=new i.P(e).normalize(),a=new i.P(s).normalize();return(new p.P).fromMatrix3(new f.d([...n,...r,...a]))}fromCenterHalfSizeQuaternion(t,e,s){const n=new p.P(s),r=(new f.d).fromQuaternion(n);return r[0]=r[0]*e[0],r[1]=r[1]*e[0],r[2]=r[2]*e[0],r[3]=r[3]*e[1],r[4]=r[4]*e[1],r[5]=r[5]*e[1],r[6]=r[6]*e[2],r[7]=r[7]*e[2],r[8]=r[8]*e[2],this.center=(new i.P).from(t),this.halfAxes=r,this}clone(){return new _(this.center,this.halfAxes)}equals(t){return this===t||Boolean(t)&&this.center.equals(t.center)&&this.halfAxes.equals(t.halfAxes)}getBoundingSphere(t=new d){const e=this.halfAxes,s=e.getColumn(0,M),n=e.getColumn(1,g),r=e.getColumn(2,y),a=w.copy(s).add(n).add(r);return t.center.copy(this.center),t.radius=a.magnitude(),t}intersectPlane(t){const e=this.center,s=t.normal,i=this.halfAxes,o=s.x,u=s.y,c=s.z,h=Math.abs(o*i[b]+u*i[A]+c*i[I])+Math.abs(o*i[T]+u*i[C]+c*i[E])+Math.abs(o*i[N]+u*i[R]+c*i[S]),l=s.dot(e)+t.distance;return l<=-h?n:l>=h?a:r}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=P.from(t).subtract(this.center),s=this.halfAxes,n=s.getColumn(0,M),r=s.getColumn(1,g),a=s.getColumn(2,y),i=n.magnitude(),o=r.magnitude(),u=a.magnitude();n.normalize(),r.normalize(),a.normalize();let c,h=0;return c=Math.abs(e.dot(n))-i,c>0&&(h+=c*c),c=Math.abs(e.dot(r))-o,c>0&&(h+=c*c),c=Math.abs(e.dot(a))-u,c>0&&(h+=c*c),h}computePlaneDistances(t,e,s=[-0,-0]){let n=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;const a=this.center,i=this.halfAxes,o=i.getColumn(0,M),u=i.getColumn(1,g),c=i.getColumn(2,y),h=x.copy(o).add(u).add(c).add(a),l=q.copy(h).subtract(t);let m=e.dot(l);return n=Math.min(m,n),r=Math.max(m,r),h.copy(a).add(o).add(u).subtract(c),l.copy(h).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),h.copy(a).add(o).subtract(u).add(c),l.copy(h).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),h.copy(a).add(o).subtract(u).subtract(c),l.copy(h).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),a.copy(h).subtract(o).add(u).add(c),l.copy(h).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),a.copy(h).subtract(o).add(u).subtract(c),l.copy(h).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),a.copy(h).subtract(o).subtract(u).add(c),l.copy(h).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),a.copy(h).subtract(o).subtract(u).subtract(c),l.copy(h).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),s[0]=n,s[1]=r,s}transform(t){this.center.transformAsPoint(t);const e=this.halfAxes.getColumn(0,M);e.transformAsPoint(t);const s=this.halfAxes.getColumn(1,g);s.transformAsPoint(t);const n=this.halfAxes.getColumn(2,y);return n.transformAsPoint(t),this.halfAxes=new f.d([...e,...s,...n]),this}getTransform(){throw new Error("not implemented")}}var v=s(4990),z=s(54901);const D=new i.P,B=new i.P;class V{constructor(t=[0,0,1],e=0){this.normal=new i.P,this.distance=-0,this.fromNormalDistance(t,e)}fromNormalDistance(t,e){return(0,v.v)(Number.isFinite(e)),this.normal.from(t).normalize(),this.distance=e,this}fromPointNormal(t,e){t=D.from(t),this.normal.from(e).normalize();const s=-this.normal.dot(t);return this.distance=s,this}fromCoefficients(t,e,s,n){return this.normal.set(t,e,s),(0,v.v)((0,z.aI)(this.normal.len(),1)),this.distance=n,this}clone(){return new V(this.normal,this.distance)}equals(t){return(0,z.aI)(this.distance,t.distance)&&(0,z.aI)(this.normal,t.normal)}getPointDistance(t){return this.normal.dot(t)+this.distance}transform(t){const e=B.copy(this.normal).transformAsVector(t).normalize(),s=this.normal.scale(-this.distance).transform(t);return this.fromPointNormal(s,e)}projectPointOntoPlane(t,e=[0,0,0]){const s=D.from(t),n=this.getPointDistance(s),r=B.copy(this.normal).scale(n);return s.subtract(r).to(e)}}const U=[new i.P([1,0,0]),new i.P([0,1,0]),new i.P([0,0,1])],L=new i.P,Q=new i.P;class K{constructor(t=[]){this.planes=t}fromBoundingSphere(t){this.planes.length=2*U.length;const e=t.center,s=t.radius;let n=0;for(const r of U){let t=this.planes[n],a=this.planes[n+1];t||(t=this.planes[n]=new V),a||(a=this.planes[n+1]=new V);const i=L.copy(r).scale(-s).add(e);t.fromPointNormal(i,r);const o=L.copy(r).scale(s).add(e),u=Q.copy(r).negate();a.fromPointNormal(o,u),n+=2}return this}computeVisibility(t){let e=a;for(const s of this.planes){switch(t.intersectPlane(s)){case n:return n;case r:e=r}}return e}computeVisibilityWithPlaneMask(t,e){if((0,v.v)(Number.isFinite(e),"parentPlaneMask is required."),e===K.MASK_OUTSIDE||e===K.MASK_INSIDE)return e;let s=K.MASK_INSIDE;const a=this.planes;for(let i=0;i<this.planes.length;++i){const o=i<31?1<<i:0;if(i<31&&!(e&o))continue;const u=a[i],c=t.intersectPlane(u);if(c===n)return K.MASK_OUTSIDE;c===r&&(s|=o)}return s}}K.MASK_OUTSIDE=4294967295,K.MASK_INSIDE=0,K.MASK_INDETERMINATE=2147483647;new i.P,new i.P,new i.P,new i.P,new i.P;new i.P,new i.P,new i.P,new i.P,new i.P,new i.P,new i.P,new i.P,new i.P,new i.P,new i.P,new i.P;var k=s(72734);const O=new f.d,X=new f.d,F=new f.d,j=new f.d,Y=new f.d;function Z(t,e={}){const s=k.B$;let n=0,r=0;const a=X,i=F;a.identity(),i.copy(t);const o=s*function(t){let e=0;for(let s=0;s<9;++s){const n=t[s];e+=n*n}return Math.sqrt(e)}(i);for(;r<10&&H(i)>o;)W(i,j),Y.copy(j).transpose(),i.multiplyRight(j),i.multiplyLeft(Y),a.multiplyRight(j),++n>2&&(++r,n=0);return e.unitary=a.toTarget(e.unitary),e.diagonal=i.toTarget(e.diagonal),e}const $=[1,0,0],G=[2,2,1];function H(t){let e=0;for(let s=0;s<3;++s){const n=t[O.getElementIndex(G[s],$[s])];e+=2*n*n}return Math.sqrt(e)}function W(t,e){const s=k.Pq;let n=0,r=1;for(let c=0;c<3;++c){const e=Math.abs(t[O.getElementIndex(G[c],$[c])]);e>n&&(r=c,n=e)}const a=$[r],i=G[r];let o=1,u=0;if(Math.abs(t[O.getElementIndex(i,a)])>s){const e=(t[O.getElementIndex(i,i)]-t[O.getElementIndex(a,a)])/2/t[O.getElementIndex(i,a)];let s;s=e<0?-1/(-e+Math.sqrt(1+e*e)):1/(e+Math.sqrt(1+e*e)),o=1/Math.sqrt(1+s*s),u=s*o}return f.d.IDENTITY.to(e),e[O.getElementIndex(a,a)]=e[O.getElementIndex(i,i)]=o,e[O.getElementIndex(i,a)]=u,e[O.getElementIndex(a,i)]=-u,e}const J=new i.P,tt=new i.P,et=new i.P,st=new i.P,nt=new i.P,rt=new f.d,at={diagonal:new f.d,unitary:new f.d};function it(t,e=new _){if(!t||0===t.length)return e.halfAxes=new f.d([0,0,0,0,0,0,0,0,0]),e.center=new i.P,e;const s=t.length,n=new i.P(0,0,0);for(const i of t)n.add(i);const r=1/s;n.multiplyByScalar(r);let a=0,o=0,u=0,c=0,h=0,l=0;for(const i of t){const t=J.copy(i).subtract(n);a+=t.x*t.x,o+=t.x*t.y,u+=t.x*t.z,c+=t.y*t.y,h+=t.y*t.z,l+=t.z*t.z}a*=r,o*=r,u*=r,c*=r,h*=r,l*=r;const m=rt;m[0]=a,m[1]=o,m[2]=u,m[3]=o,m[4]=c,m[5]=h,m[6]=u,m[7]=h,m[8]=l;const{unitary:d}=Z(m,at),p=e.halfAxes.copy(d);let w=p.getColumn(0,et),P=p.getColumn(1,st),M=p.getColumn(2,nt),g=-Number.MAX_VALUE,y=-Number.MAX_VALUE,x=-Number.MAX_VALUE,q=Number.MAX_VALUE,b=Number.MAX_VALUE,A=Number.MAX_VALUE;for(const i of t)J.copy(i),g=Math.max(J.dot(w),g),y=Math.max(J.dot(P),y),x=Math.max(J.dot(M),x),q=Math.min(J.dot(w),q),b=Math.min(J.dot(P),b),A=Math.min(J.dot(M),A);w=w.multiplyByScalar(.5*(q+g)),P=P.multiplyByScalar(.5*(b+y)),M=M.multiplyByScalar(.5*(A+x)),e.center.copy(w).add(P).add(M);const I=tt.set(g-q,y-b,x-A).multiplyByScalar(.5),T=new f.d([I[0],0,0,0,I[1],0,0,0,I[2]]);return e.halfAxes.multiplyRight(T),e}}}]);