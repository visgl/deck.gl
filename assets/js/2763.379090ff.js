"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[2763],{9959:(e,t,n)=>{n.d(t,{V:()=>r});const r={dataType:null,batchType:null,name:"Draco",id:"draco",module:"draco",version:n(65790).x,worker:!0,extensions:["drc"],mimeTypes:["application/octet-stream"],binary:!0,tests:["DRACO"],options:{draco:{decoderType:"object"==typeof WebAssembly?"wasm":"js",libraryPath:"libs/",extraAttributes:{},attributeNameEntry:void 0}}}},53618:(e,t,n)=>{n.d(t,{Vl:()=>_});var r=n(9959),o=n(35983),s=n(91532);function i(e,t,n){const r=(0,s.UE)(t.value),o=n||function(e){const t={};"byteOffset"in e&&(t.byteOffset=e.byteOffset.toString(10));"byteStride"in e&&(t.byteStride=e.byteStride.toString(10));"normalized"in e&&(t.normalized=e.normalized.toString());return t}(t);return{name:e,type:{type:"fixed-size-list",listSize:t.size,children:[{name:"value",type:r}]},nullable:!1,metadata:o}}function a(e,t,n){return i(e,t,n?c(n.metadata):void 0)}function c(e){Object.entries(e);const t={};for(const n in e)t[`${n}.string`]=JSON.stringify(e[n]);return t}const A={POSITION:"POSITION",NORMAL:"NORMAL",COLOR:"COLOR_0",TEX_COORD:"TEXCOORD_0"},f={1:Int8Array,2:Uint8Array,3:Int16Array,4:Uint16Array,5:Int32Array,6:Uint32Array,9:Float32Array};class l{draco;decoder;metadataQuerier;constructor(e){this.draco=e,this.decoder=new this.draco.Decoder,this.metadataQuerier=new this.draco.MetadataQuerier}destroy(){this.draco.destroy(this.decoder),this.draco.destroy(this.metadataQuerier)}parseSync(e,t={}){const n=new this.draco.DecoderBuffer;n.Init(new Int8Array(e),e.byteLength),this._disableAttributeTransforms(t);const r=this.decoder.GetEncodedGeometryType(n),s=r===this.draco.TRIANGULAR_MESH?new this.draco.Mesh:new this.draco.PointCloud;try{let e;switch(r){case this.draco.TRIANGULAR_MESH:e=this.decoder.DecodeBufferToMesh(n,s);break;case this.draco.POINT_CLOUD:e=this.decoder.DecodeBufferToPointCloud(n,s);break;default:throw new Error("DRACO: Unknown geometry type.")}if(!e.ok()||!s.ptr){const t=`DRACO decompression failed: ${e.error_msg()}`;throw new Error(t)}const i=this._getDracoLoaderData(s,r,t),A=this._getMeshData(s,i,t),f=(0,o.l)(A.attributes),l=function(e,t,n){const r=c(t.metadata),o=[],s=function(e){const t={};for(const n in e){const r=e[n];t[r.name||"undefined"]=r}return t}(t.attributes);for(const i in e){const t=a(i,e[i],s[i]);o.push(t)}if(n){const e=a("indices",n);o.push(e)}return{fields:o,metadata:r}}(A.attributes,i,A.indices);return{loader:"draco",loaderData:i,header:{vertexCount:s.num_points(),boundingBox:f},...A,schema:l}}finally{this.draco.destroy(n),s&&this.draco.destroy(s)}}_getDracoLoaderData(e,t,n){const r=this._getTopLevelMetadata(e),o=this._getDracoAttributes(e,n);return{geometry_type:t,num_attributes:e.num_attributes(),num_points:e.num_points(),num_faces:e instanceof this.draco.Mesh?e.num_faces():0,metadata:r,attributes:o}}_getDracoAttributes(e,t){const n={};for(let r=0;r<e.num_attributes();r++){const o=this.decoder.GetAttribute(e,r),s=this._getAttributeMetadata(e,r);n[o.unique_id()]={unique_id:o.unique_id(),attribute_type:o.attribute_type(),data_type:o.data_type(),num_components:o.num_components(),byte_offset:o.byte_offset(),byte_stride:o.byte_stride(),normalized:o.normalized(),attribute_index:r,metadata:s};const i=this._getQuantizationTransform(o,t);i&&(n[o.unique_id()].quantization_transform=i);const a=this._getOctahedronTransform(o,t);a&&(n[o.unique_id()].octahedron_transform=a)}return n}_getMeshData(e,t,n){const r=this._getMeshAttributes(t,e,n);if(!r.POSITION)throw new Error("DRACO: No position attribute found.");return e instanceof this.draco.Mesh?"triangle-strip"===n.topology?{topology:"triangle-strip",mode:4,attributes:r,indices:{value:this._getTriangleStripIndices(e),size:1}}:{topology:"triangle-list",mode:5,attributes:r,indices:{value:this._getTriangleListIndices(e),size:1}}:{topology:"point-list",mode:0,attributes:r}}_getMeshAttributes(e,t,n){const r={};for(const o of Object.values(e.attributes)){const e=this._deduceAttributeName(o,n);o.name=e;const s=this._getAttributeValues(t,o);if(s){const{value:t,size:n}=s;r[e]={value:t,size:n,byteOffset:o.byte_offset,byteStride:o.byte_stride,normalized:o.normalized}}}return r}_getTriangleListIndices(e){const t=3*e.num_faces(),n=4*t,r=this.draco._malloc(n);try{return this.decoder.GetTrianglesUInt32Array(e,n,r),new Uint32Array(this.draco.HEAPF32.buffer,r,t).slice()}finally{this.draco._free(r)}}_getTriangleStripIndices(e){const t=new this.draco.DracoInt32Array;try{return this.decoder.GetTriangleStripsFromMesh(e,t),function(e){const t=e.size(),n=new Int32Array(t);for(let r=0;r<t;r++)n[r]=e.GetValue(r);return n}(t)}finally{this.draco.destroy(t)}}_getAttributeValues(e,t){const n=f[t.data_type];if(!n)return console.warn(`DRACO: Unsupported attribute type ${t.data_type}`),null;const r=t.num_components,o=e.num_points()*r,s=o*n.BYTES_PER_ELEMENT,i=function(e,t){switch(t){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32;default:return e.DT_INVALID}}(this.draco,n);let a;const c=this.draco._malloc(s);try{const r=this.decoder.GetAttribute(e,t.attribute_index);this.decoder.GetAttributeDataArrayForAllPoints(e,r,i,s,c),a=new n(this.draco.HEAPF32.buffer,c,o).slice()}finally{this.draco._free(c)}return{value:a,size:r}}_deduceAttributeName(e,t){const n=e.unique_id;for(const[s,i]of Object.entries(t.extraAttributes||{}))if(i===n)return s;const r=e.attribute_type;for(const s in A){if(this.draco[s]===r)return A[s]}const o=t.attributeNameEntry||"name";return e.metadata[o]?e.metadata[o].string:`CUSTOM_ATTRIBUTE_${n}`}_getTopLevelMetadata(e){const t=this.decoder.GetMetadata(e);return this._getDracoMetadata(t)}_getAttributeMetadata(e,t){const n=this.decoder.GetAttributeMetadata(e,t);return this._getDracoMetadata(n)}_getDracoMetadata(e){if(!e||!e.ptr)return{};const t={},n=this.metadataQuerier.NumEntries(e);for(let r=0;r<n;r++){const n=this.metadataQuerier.GetEntryName(e,r);t[n]=this._getDracoMetadataField(e,n)}return t}_getDracoMetadataField(e,t){const n=new this.draco.DracoInt32Array;try{this.metadataQuerier.GetIntEntryArray(e,t,n);const r=function(e){const t=e.size(),n=new Int32Array(t);for(let r=0;r<t;r++)n[r]=e.GetValue(r);return n}(n);return{int:this.metadataQuerier.GetIntEntry(e,t),string:this.metadataQuerier.GetStringEntry(e,t),double:this.metadataQuerier.GetDoubleEntry(e,t),intArray:r}}finally{this.draco.destroy(n)}}_disableAttributeTransforms(e){const{quantizedAttributes:t=[],octahedronAttributes:n=[]}=e,r=[...t,...n];for(const o of r)this.decoder.SkipAttributeTransform(this.draco[o])}_getQuantizationTransform(e,t){const{quantizedAttributes:n=[]}=t,r=e.attribute_type();if(n.map((e=>this.decoder[e])).includes(r)){const t=new this.draco.AttributeQuantizationTransform;try{if(t.InitFromAttribute(e))return{quantization_bits:t.quantization_bits(),range:t.range(),min_values:new Float32Array([1,2,3]).map((e=>t.min_value(e)))}}finally{this.draco.destroy(t)}}return null}_getOctahedronTransform(e,t){const{octahedronAttributes:n=[]}=t,r=e.attribute_type();if(n.map((e=>this.decoder[e])).includes(r)){const t=new this.draco.AttributeQuantizationTransform;try{if(t.InitFromAttribute(e))return{quantization_bits:t.quantization_bits()}}finally{this.draco.destroy(t)}}return null}}var u=n(17316);const B="https://www.gstatic.com/draco/versioned/decoders/1.5.6",d="draco_wasm_wrapper.js",C="draco_decoder.wasm",m="draco_decoder.js",b="draco_encoder.js",h={[d]:`${B}/${d}`,[C]:`${B}/${C}`,[m]:`${B}/${m}`,[b]:`https://raw.githubusercontent.com/google/draco/1.4.1/javascript/${b}`};let p;async function g(e){const t=e.modules||{};return t.draco3d?p||=t.draco3d.createDecoderModule({}).then((e=>({draco:e}))):p||=async function(e){let t,n;if("js"===(e.draco&&e.draco.decoderType))t=await(0,u._)(h[m],"draco",e,m);else[t,n]=await Promise.all([await(0,u._)(h[d],"draco",e,d),await(0,u._)(h[C],"draco",e,C)]);return t=t||globalThis.DracoDecoderModule,await function(e,t){const n={};t&&(n.wasmBinary=t);return new Promise((t=>{e({...n,onModuleLoaded:e=>t({draco:e})})}))}(t,n)}(e),await p}n(65790).x;const _={...r.V,parse:async function(e,t){const{draco:n}=await g(t),r=new l(n);try{return r.parseSync(e,t?.draco)}finally{r.destroy()}}}},65790:(e,t,n)=>{n.d(t,{x:()=>r});const r="4.2.1"},78750:(e,t,n)=>{n.d(t,{B:()=>Ht});var r={};n.r(r),n.d(r,{decode:()=>$,name:()=>q});var o={};n.r(o),n.d(o,{decode:()=>re,name:()=>ne});var s={};n.r(s),n.d(s,{decode:()=>Ee,name:()=>_e});var i={};n.r(i),n.d(i,{name:()=>De,preprocess:()=>ve});var a={};n.r(a),n.d(a,{name:()=>ye,preprocess:()=>He});var c={};n.r(c),n.d(c,{decode:()=>Je,encode:()=>we,name:()=>Ue,preprocess:()=>Le});var A={};n.r(A),n.d(A,{decode:()=>qe,name:()=>We});var f={};n.r(f),n.d(f,{decode:()=>ot,encode:()=>st,name:()=>rt});var l={};n.r(l),n.d(l,{decode:()=>ct,encode:()=>At,name:()=>at});var u={};n.r(u),n.d(u,{decode:()=>ut,encode:()=>Bt,name:()=>lt});var B={};n.r(B),n.d(B,{decode:()=>bt,name:()=>mt});function d(e,t,n){if(e.byteLength<=t+n)return"";const r=new DataView(e);let o="";for(let s=0;s<n;s++)o+=String.fromCharCode(r.getUint8(t+s));return o}function C(e){try{return JSON.parse(e)}catch(t){throw new Error(`Failed to parse JSON from data starting with "${function(e,t=5){if("string"==typeof e)return e.slice(0,t);if(ArrayBuffer.isView(e))return d(e.buffer,e.byteOffset,t);if(e instanceof ArrayBuffer)return d(e,0,t);return""}(e)}"`)}}var m=n(10048),b=n(38925),h=n(8045),p=n(77067),g=n(6143),_=n(52840),E=n(94976);function R(e,t){return(0,E.v)(e>=0),(0,E.v)(t>0),e+(t-1)&~(t-1)}function I(e,t,n){let r;if(e instanceof ArrayBuffer)r=new Uint8Array(e);else{const t=e.byteOffset,n=e.byteLength;r=new Uint8Array(e.buffer||e.arrayBuffer,t,n)}return t.set(r,n),n+R(r.byteLength,4)}const S=!0,M=1735152710,G=1313821514,F=5130562;function D(e,t,n=0,r={}){const o=new DataView(t),s=function(e,t=0){return`${String.fromCharCode(e.getUint8(t+0))}${String.fromCharCode(e.getUint8(t+1))}${String.fromCharCode(e.getUint8(t+2))}${String.fromCharCode(e.getUint8(t+3))}`}(o,n+0),i=o.getUint32(n+4,S),a=o.getUint32(n+8,S);switch(Object.assign(e,{header:{byteOffset:n,byteLength:a,hasBinChunk:!1},type:s,version:i,json:{},binChunks:[]}),n+=12,e.version){case 1:return function(e,t,n){(0,E.v)(e.header.byteLength>20);const r=t.getUint32(n+0,S),o=t.getUint32(n+4,S);return n+=8,(0,E.v)(0===o),v(e,t,n,r),n+=r,n+=T(e,t,n,e.header.byteLength),n}(e,o,n);case 2:return function(e,t,n,r){return(0,E.v)(e.header.byteLength>20),function(e,t,n,r){for(;n+8<=e.header.byteLength;){const o=t.getUint32(n+0,S),s=t.getUint32(n+4,S);switch(n+=8,s){case G:v(e,t,n,o);break;case F:T(e,t,n,o);break;case 0:r.strict||v(e,t,n,o);break;case 1:r.strict||T(e,t,n,o)}n+=R(o,4)}}(e,t,n,r),n+e.header.byteLength}(e,o,n,{});default:throw new Error(`Invalid GLB version ${e.version}. Only supports version 1 and 2.`)}}function v(e,t,n,r){const o=new Uint8Array(t.buffer,n,r),s=new TextDecoder("utf8").decode(o);return e.json=JSON.parse(s),R(r,4)}function T(e,t,n,r){return e.header.hasBinChunk=!0,e.binChunks.push({byteOffset:n,byteLength:r,arrayBuffer:t.buffer}),R(r,4)}function y(e,t){if(e.startsWith("data:")||e.startsWith("http:")||e.startsWith("https:"))return e;const n=t.baseUri||t.uri;if(!n)throw new Error(`'baseUri' must be provided to resolve relative url ${e}`);return n.substr(0,n.lastIndexOf("/")+1)+e}var H=n(27885);function O(e,t,n){const r=e.bufferViews[n];(0,_.v)(r);const o=t[r.buffer];(0,_.v)(o);const s=(r.byteOffset||0)+o.byteOffset;return new Uint8Array(o.arrayBuffer,s,r.byteLength)}var x=n(72501);class P{gltf;sourceBuffers;byteLength;constructor(e){this.gltf={json:e?.json||{asset:{version:"2.0",generator:"loaders.gl"},buffers:[],extensions:{},extensionsRequired:[],extensionsUsed:[]},buffers:e?.buffers||[],images:e?.images||[]},this.sourceBuffers=[],this.byteLength=0,this.gltf.buffers&&this.gltf.buffers[0]&&(this.byteLength=this.gltf.buffers[0].byteLength,this.sourceBuffers=[this.gltf.buffers[0]])}get json(){return this.gltf.json}getApplicationData(e){return this.json[e]}getExtraData(e){return(this.json.extras||{})[e]}hasExtension(e){const t=this.getUsedExtensions().find((t=>t===e)),n=this.getRequiredExtensions().find((t=>t===e));return"string"==typeof t||"string"==typeof n}getExtension(e){const t=this.getUsedExtensions().find((t=>t===e)),n=this.json.extensions||{};return t?n[e]:null}getRequiredExtension(e){return this.getRequiredExtensions().find((t=>t===e))?this.getExtension(e):null}getRequiredExtensions(){return this.json.extensionsRequired||[]}getUsedExtensions(){return this.json.extensionsUsed||[]}getRemovedExtensions(){return this.json.extensionsRemoved||[]}getObjectExtension(e,t){return(e.extensions||{})[t]}getScene(e){return this.getObject("scenes",e)}getNode(e){return this.getObject("nodes",e)}getSkin(e){return this.getObject("skins",e)}getMesh(e){return this.getObject("meshes",e)}getMaterial(e){return this.getObject("materials",e)}getAccessor(e){return this.getObject("accessors",e)}getTexture(e){return this.getObject("textures",e)}getSampler(e){return this.getObject("samplers",e)}getImage(e){return this.getObject("images",e)}getBufferView(e){return this.getObject("bufferViews",e)}getBuffer(e){return this.getObject("buffers",e)}getObject(e,t){if("object"==typeof t)return t;const n=this.json[e]&&this.json[e][t];if(!n)throw new Error(`glTF file error: Could not find ${e}[${t}]`);return n}getTypedArrayForBufferView(e){const t=(e=this.getBufferView(e)).buffer,n=this.gltf.buffers[t];(0,_.v)(n);const r=(e.byteOffset||0)+n.byteOffset;return new Uint8Array(n.arrayBuffer,r,e.byteLength)}getTypedArrayForAccessor(e){const t=this.getAccessor(e);return function(e,t,n){const r="number"==typeof n?e.accessors?.[n]:n;if(!r)throw new Error(`No gltf accessor ${JSON.stringify(n)}`);const o=e.bufferViews?.[r.bufferView||0];if(!o)throw new Error(`No gltf buffer view for accessor ${o}`);const{arrayBuffer:s,byteOffset:i}=t[o.buffer],a=(i||0)+(r.byteOffset||0)+(o.byteOffset||0),{ArrayType:c,length:A,componentByteSize:f,numberOfComponentsInElement:l}=(0,H.aF)(r,o),u=f*l,B=o.byteStride||u;if(void 0===o.byteStride||o.byteStride===u)return new c(s,a,A);const d=new c(A);for(let C=0;C<r.count;C++){const e=new c(s,a+C*B,l);d.set(e,C*l)}return d}(this.gltf.json,this.gltf.buffers,t)}getTypedArrayForImageData(e){e=this.getAccessor(e);const t=this.getBufferView(e.bufferView),n=this.getBuffer(t.buffer).data,r=t.byteOffset||0;return new Uint8Array(n,r,t.byteLength)}addApplicationData(e,t){return this.json[e]=t,this}addExtraData(e,t){return this.json.extras=this.json.extras||{},this.json.extras[e]=t,this}addObjectExtension(e,t,n){return e.extensions=e.extensions||{},e.extensions[t]=n,this.registerUsedExtension(t),this}setObjectExtension(e,t,n){(e.extensions||{})[t]=n}removeObjectExtension(e,t){const n=e?.extensions||{};if(n[t]){this.json.extensionsRemoved=this.json.extensionsRemoved||[];const e=this.json.extensionsRemoved;e.includes(t)||e.push(t)}delete n[t]}addExtension(e,t={}){return(0,_.v)(t),this.json.extensions=this.json.extensions||{},this.json.extensions[e]=t,this.registerUsedExtension(e),t}addRequiredExtension(e,t={}){return(0,_.v)(t),this.addExtension(e,t),this.registerRequiredExtension(e),t}registerUsedExtension(e){this.json.extensionsUsed=this.json.extensionsUsed||[],this.json.extensionsUsed.find((t=>t===e))||this.json.extensionsUsed.push(e)}registerRequiredExtension(e){this.registerUsedExtension(e),this.json.extensionsRequired=this.json.extensionsRequired||[],this.json.extensionsRequired.find((t=>t===e))||this.json.extensionsRequired.push(e)}removeExtension(e){if(this.json.extensions?.[e]){this.json.extensionsRemoved=this.json.extensionsRemoved||[];const t=this.json.extensionsRemoved;t.includes(e)||t.push(e)}this.json.extensions&&delete this.json.extensions[e],this.json.extensionsRequired&&this._removeStringFromArray(this.json.extensionsRequired,e),this.json.extensionsUsed&&this._removeStringFromArray(this.json.extensionsUsed,e)}setDefaultScene(e){this.json.scene=e}addScene(e){const{nodeIndices:t}=e;return this.json.scenes=this.json.scenes||[],this.json.scenes.push({nodes:t}),this.json.scenes.length-1}addNode(e){const{meshIndex:t,matrix:n}=e;this.json.nodes=this.json.nodes||[];const r={mesh:t};return n&&(r.matrix=n),this.json.nodes.push(r),this.json.nodes.length-1}addMesh(e){const{attributes:t,indices:n,material:r,mode:o=4}=e,s={primitives:[{attributes:this._addAttributes(t),mode:o}]};if(n){const e=this._addIndices(n);s.primitives[0].indices=e}return Number.isFinite(r)&&(s.primitives[0].material=r),this.json.meshes=this.json.meshes||[],this.json.meshes.push(s),this.json.meshes.length-1}addPointCloud(e){const t={primitives:[{attributes:this._addAttributes(e),mode:0}]};return this.json.meshes=this.json.meshes||[],this.json.meshes.push(t),this.json.meshes.length-1}addImage(e,t){const n=(0,x.m)(e),r=t||n?.mimeType,o={bufferView:this.addBufferView(e),mimeType:r};return this.json.images=this.json.images||[],this.json.images.push(o),this.json.images.length-1}addBufferView(e,t=0,n=this.byteLength){const r=e.byteLength;(0,_.v)(Number.isFinite(r)),this.sourceBuffers=this.sourceBuffers||[],this.sourceBuffers.push(e);const o={buffer:t,byteOffset:n,byteLength:r};return this.byteLength+=R(r,4),this.json.bufferViews=this.json.bufferViews||[],this.json.bufferViews.push(o),this.json.bufferViews.length-1}addAccessor(e,t){const n={bufferView:e,type:(0,H.v7)(t.size),componentType:t.componentType,count:t.count,max:t.max,min:t.min};return this.json.accessors=this.json.accessors||[],this.json.accessors.push(n),this.json.accessors.length-1}addBinaryBuffer(e,t={size:3}){const n=this.addBufferView(e);let r={min:t.min,max:t.max};r.min&&r.max||(r=this._getAccessorMinMax(e,t.size));const o={size:t.size,componentType:(0,H.rA)(e),count:Math.round(e.length/t.size),min:r.min,max:r.max};return this.addAccessor(n,Object.assign(o,t))}addTexture(e){const{imageIndex:t}=e,n={source:t};return this.json.textures=this.json.textures||[],this.json.textures.push(n),this.json.textures.length-1}addMaterial(e){return this.json.materials=this.json.materials||[],this.json.materials.push(e),this.json.materials.length-1}createBinaryChunk(){this.gltf.buffers=[];const e=this.byteLength,t=new ArrayBuffer(e),n=new Uint8Array(t);let r=0;for(const o of this.sourceBuffers||[])r=I(o,n,r);this.json?.buffers?.[0]?this.json.buffers[0].byteLength=e:this.json.buffers=[{byteLength:e}],this.gltf.binary=t,this.sourceBuffers=[t]}_removeStringFromArray(e,t){let n=!0;for(;n;){const r=e.indexOf(t);r>-1?e.splice(r,1):n=!1}}_addAttributes(e={}){const t={};for(const n in e){const r=e[n],o=this._getGltfAttributeName(n),s=this.addBinaryBuffer(r.value,r);t[o]=s}return t}_addIndices(e){return this.addBinaryBuffer(e,{size:1})}_getGltfAttributeName(e){switch(e.toLowerCase()){case"position":case"positions":case"vertices":return"POSITION";case"normal":case"normals":return"NORMAL";case"color":case"colors":return"COLOR_0";case"texcoord":case"texcoords":return"TEXCOORD_0";default:return e}}_getAccessorMinMax(e,t){const n={min:null,max:null};if(e.length<t)return n;n.min=[],n.max=[];const r=e.subarray(0,t);for(const o of r)n.min.push(o),n.max.push(o);for(let o=t;o<e.length;o+=t)for(let r=0;r<t;r++)n.min[0+r]=Math.min(n.min[0+r],e[o+r]),n.max[0+r]=Math.max(n.max[0+r],e[o+r]);return n}}var U=n(53905);function L(e){return(e%1+1)%1}const J={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16,BOOLEAN:1,STRING:1,ENUM:1},w={INT8:Int8Array,UINT8:Uint8Array,INT16:Int16Array,UINT16:Uint16Array,INT32:Int32Array,UINT32:Uint32Array,INT64:BigInt64Array,UINT64:BigUint64Array,FLOAT32:Float32Array,FLOAT64:Float64Array},N={INT8:1,UINT8:1,INT16:2,UINT16:2,INT32:4,UINT32:4,INT64:8,UINT64:8,FLOAT32:4,FLOAT64:8};function K(e,t){return N[t]*J[e]}function j(e,t,n,r){if("UINT8"!==n&&"UINT16"!==n&&"UINT32"!==n&&"UINT64"!==n)return null;const o=X(e.getTypedArrayForBufferView(t),"SCALAR",n,r+1);return o instanceof BigInt64Array||o instanceof BigUint64Array?null:o}function X(e,t,n,r=1){const o=J[t],s=w[n],i=N[n],a=r*o,c=a*i;let A=e.buffer,f=e.byteOffset;if(f%i!=0){A=new Uint8Array(A).slice(f,f+c).buffer,f=0}return new s(A,f,a)}function Q(e,t,n){const r=`TEXCOORD_${t.texCoord||0}`,o=n.attributes[r],s=e.getTypedArrayForAccessor(o),i=e.gltf.json,a=t.index,c=i.textures?.[a]?.source;if(void 0!==c){const n=i.images?.[c]?.mimeType,r=e.gltf.images?.[c];if(r&&void 0!==r.width){const e=[];for(let o=0;o<s.length;o+=2){const i=Y(r,n,s,o,t.channels);e.push(i)}return e}}return[]}function V(e,t,n,r,o){if(!n?.length)return;const s=[];for(const f of n){let e=r.findIndex((e=>e===f));-1===e&&(e=r.push(f)-1),s.push(e)}const i=new Uint32Array(s),a=e.gltf.buffers.push({arrayBuffer:i.buffer,byteOffset:i.byteOffset,byteLength:i.byteLength})-1,c=e.addBufferView(i,a,0),A=e.addAccessor(c,{size:1,componentType:(0,H.rA)(i),count:i.length});o.attributes[t]=A}function Y(e,t,n,r,o=[0]){const s={r:{offset:0,shift:0},g:{offset:1,shift:8},b:{offset:2,shift:16},a:{offset:3,shift:24}},i=n[r],a=n[r+1];let c=1;!t||-1===t.indexOf("image/jpeg")&&-1===t.indexOf("image/png")||(c=4);const A=function(e,t,n,r=1){const o=n.width,s=L(e)*(o-1),i=Math.round(s),a=n.height,c=L(t)*(a-1),A=Math.round(c),f=n.components?n.components:r,l=(A*o+i)*f;return l}(i,a,e,c);let f=0;for(const l of o){const t="number"==typeof l?Object.values(s)[l]:s[l],n=A+t.offset,r=(0,U.M5)(e);if(r.data.length<=n)throw new Error(`${r.data.length} <= ${n}`);f|=r.data[n]<<t.shift}return f}function W(e,t,n,r,o){const s=[];for(let i=0;i<t;i++){const t=n[i],a=n[i+1]-n[i];if(a+t>r)break;const c=t/o,A=a/o;s.push(e.slice(c,c+A))}return s}function k(e,t,n){const r=[];for(let o=0;o<t;o++){const t=o*n;r.push(e.slice(t,t+n))}return r}function Z(e,t,n,r){if(n)throw new Error("Not implemented - arrayOffsets for strings is specified");if(r){const n=[],o=new TextDecoder("utf8");let s=0;for(let i=0;i<e;i++){const e=r[i+1]-r[i];if(e+s<=t.length){const r=t.subarray(s,e+s),i=o.decode(r);n.push(i),s+=e}}return n}return[]}const z="EXT_mesh_features",q=z;async function $(e,t){!function(e,t){const n=e.gltf.json;if(!n.meshes)return;for(const r of n.meshes)for(const n of r.primitives)ee(e,n,t)}(new P(e),t)}function ee(e,t,n){if(!n?.gltf?.loadBuffers)return;const r=t.extensions?.[z],o=r?.featureIds;if(o)for(const s of o){let r;if(void 0!==s.attribute){const n=`_FEATURE_ID_${s.attribute}`,o=t.attributes[n];r=e.getTypedArrayForAccessor(o)}else r=void 0!==s.texture&&n?.gltf?.loadImages?Q(e,s.texture,t):[];s.data=r}}const te="EXT_structural_metadata",ne=te;async function re(e,t){!function(e,t){if(!t.gltf?.loadBuffers)return;const n=e.getExtension(te);if(!n)return;t.gltf?.loadImages&&function(e,t){const n=t.propertyTextures,r=e.gltf.json;if(n&&r.meshes)for(const o of r.meshes)for(const r of o.primitives)se(e,n,r,t)}(e,n);!function(e,t){const n=t.schema;if(!n)return;const r=n.classes,o=t.propertyTables;if(r&&o)for(const s in r){const t=oe(o,s);t&&ae(e,n,t)}}(e,n)}(new P(e),t)}function oe(e,t){for(const n of e)if(n.class===t)return n;return null}function se(e,t,n,r){if(!t)return;const o=n.extensions?.[te],s=o?.propertyTextures;if(s)for(const i of s){ie(e,t[i],n,r)}}function ie(e,t,n,r){if(!t.properties)return;r.dataAttributeNames||(r.dataAttributeNames=[]);const o=t.class;for(const s in t.properties){const i=`${o}_${s}`,a=t.properties?.[s];if(!a)continue;a.data||(a.data=[]);const c=a.data,A=Q(e,a,n);null!==A&&(V(e,i,A,c,n),a.data=c,r.dataAttributeNames.push(i))}}function ae(e,t,n){const r=t.classes?.[n.class];if(!r)throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);const o=n.count;for(const s in r.properties){const i=r.properties[s],a=n.properties?.[s];if(a){const n=ce(e,t,i,o,a);a.data=n}}}function ce(e,t,n,r,o){let s=[];const i=o.values,a=e.getTypedArrayForBufferView(i),c=function(e,t,n,r){if(t.array&&void 0===t.count&&void 0!==n.arrayOffsets)return j(e,n.arrayOffsets,n.arrayOffsetType||"UINT32",r);return null}(e,n,o,r),A=function(e,t,n){if(void 0!==t.stringOffsets)return j(e,t.stringOffsets,t.stringOffsetType||"UINT32",n);return null}(e,o,r);switch(n.type){case"SCALAR":case"VEC2":case"VEC3":case"VEC4":case"MAT2":case"MAT3":case"MAT4":s=function(e,t,n,r){const o=e.array,s=e.count,i=K(e.type,e.componentType),a=n.byteLength/i;let c;c=e.componentType?X(n,e.type,e.componentType,a):n;if(o)return r?W(c,t,r,n.length,i):s?k(c,t,s):[];return c}(n,r,a,c);break;case"BOOLEAN":throw new Error(`Not implemented - classProperty.type=${n.type}`);case"STRING":s=Z(r,a,c,A);break;case"ENUM":s=function(e,t,n,r,o){const s=t.enumType;if(!s)throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");const i=e.enums?.[s];if(!i)throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${s}`);const a=i.valueType||"UINT16",c=K(t.type,a),A=r.byteLength/c;let f=X(r,t.type,a,A);f||(f=r);if(t.array){if(o)return function(e){const{valuesData:t,numberOfElements:n,arrayOffsets:r,valuesDataBytesLength:o,elementSize:s,enumEntry:i}=e,a=[];for(let c=0;c<n;c++){const e=r[c],n=r[c+1]-r[c];if(n+e>o)break;const A=Ae(t,e/s,n/s,i);a.push(A)}return a}({valuesData:f,numberOfElements:n,arrayOffsets:o,valuesDataBytesLength:r.length,elementSize:c,enumEntry:i});const e=t.count;return e?function(e,t,n,r){const o=[];for(let s=0;s<t;s++){const t=Ae(e,n*s,n,r);o.push(t)}return o}(f,n,e,i):[]}return Ae(f,0,n,i)}(t,n,r,a,c);break;default:throw new Error(`Unknown classProperty type ${n.type}`)}return s}function Ae(e,t,n,r){const o=[];for(let s=0;s<n;s++)if(e instanceof BigInt64Array||e instanceof BigUint64Array)o.push("");else{const n=fe(r,e[t+s]);n?o.push(n.name):o.push("")}return o}function fe(e,t){for(const n of e.values)if(n.value===t)return n;return null}const le="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",ue="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",Be=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),de=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]),Ce={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},me={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};let be;async function he(){return be||(be=async function(){let e=le;WebAssembly.validate(Be)&&(e=ue,console.log("Warning: meshopt_decoder is using experimental SIMD support"));const t=await WebAssembly.instantiate(function(e){const t=new Uint8Array(e.length);for(let r=0;r<e.length;++r){const n=e.charCodeAt(r);t[r]=n>96?n-71:n>64?n-65:n>47?n+4:n>46?63:62}let n=0;for(let r=0;r<e.length;++r)t[n++]=t[r]<60?de[t[r]]:64*(t[r]-60)+t[++r];return t.buffer.slice(0,n)}(e),{});return await t.instance.exports.__wasm_call_ctors(),t.instance}()),be}function pe(e,t,n,r,o,s,i){const a=e.exports.sbrk,c=r+3&-4,A=a(c*o),f=a(s.length),l=new Uint8Array(e.exports.memory.buffer);l.set(s,f);const u=t(A,r,o,f,s.length);if(0===u&&i&&i(A,c,o),n.set(l.subarray(A,A+r*o)),a(A-a(0)),0!==u)throw new Error(`Malformed buffer data: ${u}`)}const ge="EXT_meshopt_compression",_e=ge;async function Ee(e,t){const n=new P(e);if(!t?.gltf?.decompressMeshes||!t.gltf?.loadBuffers)return;const r=[];for(const o of e.json.bufferViews||[])r.push(Re(n,o));await Promise.all(r),n.removeExtension(ge)}async function Re(e,t){const n=e.getObjectExtension(t,ge);if(n){const{byteOffset:r=0,byteLength:o=0,byteStride:s,count:i,mode:a,filter:c="NONE",buffer:A}=n,f=e.gltf.buffers[A],l=new Uint8Array(f.arrayBuffer,f.byteOffset+r,o),u=new Uint8Array(e.gltf.buffers[t.buffer].arrayBuffer,t.byteOffset,t.byteLength);await async function(e,t,n,r,o,s="NONE"){const i=await he();pe(i,i.exports[me[o]],e,t,n,r,i.exports[Ce[s||"NONE"]])}(u,i,s,l,a,c),e.removeObjectExtension(t,ge)}}var Ie=n(47612);const Se={};function Me(e){if(void 0===Se[e]){const t=Ie.Bd?function(e){switch(e){case"image/avif":case"image/webp":return function(e){try{const t=document.createElement("canvas");return 0===t.toDataURL(e).indexOf(`data:${e}`)}catch{return!1}}(e);default:return!0}}(e):Ge(e);Se[e]=t}return Se[e]}function Ge(e){const t=globalThis.loaders?.imageFormatsNode||["image/png","image/jpeg","image/gif"],n=globalThis.loaders?.parseImageNode;return Boolean(n)&&t.includes(e)}const Fe="EXT_texture_webp",De=Fe;function ve(e,t){const n=new P(e);if(!Me("image/webp")){if(n.getRequiredExtensions().includes(Fe))throw new Error(`gltf: Required extension ${Fe} not supported by browser`);return}const{json:r}=n;for(const o of r.textures||[]){const e=n.getObjectExtension(o,Fe);e&&(o.source=e.source),n.removeObjectExtension(o,Fe)}n.removeExtension(Fe)}const Te="KHR_texture_basisu",ye=Te;function He(e,t){const n=new P(e),{json:r}=n;for(const o of r.textures||[]){const e=n.getObjectExtension(o,Te);e&&(o.source=e.source,n.removeObjectExtension(o,Te))}n.removeExtension(Te)}var Oe=n(53618);function xe(e){const{buffer:t,size:n,count:r}=function(e){let t=e,n=1,r=0;e&&e.value&&(t=e.value,n=e.size||1);t&&(ArrayBuffer.isView(t)||(t=function(e,t,n=!1){if(!e)return null;if(Array.isArray(e))return new t(e);if(n&&!(e instanceof t))return new t(e);return e}(t,Float32Array)),r=t.length/n);return{buffer:t,size:n,count:r}}(e);return{value:t,size:n,byteOffset:0,count:r,type:(0,H.v7)(n),componentType:(0,H.rA)(t)}}const Pe="KHR_draco_mesh_compression",Ue=Pe;function Le(e,t,n){const r=new P(e);for(const o of je(r))r.getObjectExtension(o,Pe)}async function Je(e,t,n){if(!t?.gltf?.decompressMeshes)return;const r=new P(e),o=[];for(const s of je(r))r.getObjectExtension(s,Pe)&&o.push(Ne(r,s,t,n));await Promise.all(o),r.removeExtension(Pe)}function we(e,t={}){const n=new P(e);for(const r of n.json.meshes||[])Ke(r,t),n.addRequiredExtension(Pe)}async function Ne(e,t,n,r){const o=e.getObjectExtension(t,Pe);if(!o)return;const s=e.getTypedArrayForBufferView(o.bufferView),i=(0,m._m)(s.buffer,s.byteOffset),a={...n};delete a["3d-tiles"];const c=await(0,b.N9)(i,Oe.Vl,a,r),A=function(e){const t={};for(const n in e){const r=e[n];if("indices"!==n){const e=xe(r);t[n]=e}}return t}(c.attributes);for(const[f,l]of Object.entries(A))if(f in t.attributes){const n=t.attributes[f],r=e.getAccessor(n);r?.min&&r?.max&&(l.min=r.min,l.max=r.max)}t.attributes=A,c.indices&&(t.indices=xe(c.indices)),e.removeObjectExtension(t,Pe),function(e){if(!e.attributes&&Object.keys(e.attributes).length>0)throw new Error("glTF: Empty primitive detected: Draco decompression failure?")}(t)}function Ke(e,t,n=4,r,o){if(!r.DracoWriter)throw new Error("options.gltf.DracoWriter not provided");const s=r.DracoWriter.encodeSync({attributes:e}),i=o?.parseSync?.({attributes:e}),a=r._addFauxAttributes(i.attributes),c=r.addBufferView(s);return{primitives:[{attributes:a,mode:n,extensions:{[Pe]:{bufferView:c,attributes:a}}}]}}function*je(e){for(const t of e.json.meshes||[])for(const e of t.primitives)yield e}var Xe=n(87597),Qe=n(35567),Ve=n(77897);const Ye="KHR_texture_transform",We=Ye,ke=new Xe.P,Ze=new Qe.d,ze=new Qe.d;async function qe(e,t){if(!new P(e).hasExtension(Ye)||!t.gltf?.loadBuffers)return;const n=e.json.materials||[];for(let r=0;r<n.length;r++)$e(r,e)}function $e(e,t){const n=t.json.materials?.[e],r=[n?.pbrMetallicRoughness?.baseColorTexture,n?.emissiveTexture,n?.normalTexture,n?.occlusionTexture,n?.pbrMetallicRoughness?.metallicRoughnessTexture],o=[];for(const s of r)s&&s?.extensions?.[Ye]&&et(t,e,s,o)}function et(e,t,n,r){const o=function(e,t){const n=e.extensions?.[Ye],{texCoord:r=0}=e,{texCoord:o=r}=n,s=-1!==t.findIndex((([e,t])=>e===r&&t===o));if(!s){const s=function(e){const{offset:t=[0,0],rotation:n=0,scale:r=[1,1]}=e,o=(new Qe.d).set(1,0,0,0,1,0,t[0],t[1],1),s=Ze.set(Math.cos(n),Math.sin(n),0,-Math.sin(n),Math.cos(n),0,0,0,1),i=ze.set(r[0],0,0,0,r[1],0,0,0,1);return o.multiplyRight(s).multiplyRight(i)}(n);return r!==o&&(e.texCoord=o),t.push([r,o]),{originalTexCoord:r,texCoord:o,matrix:s}}return null}(n,r);if(!o)return;const s=e.json.meshes||[];for(const i of s)for(const n of i.primitives){const r=n.material;Number.isFinite(r)&&t===r&&tt(e,n,o)}}function tt(e,t,n){const{originalTexCoord:r,texCoord:o,matrix:s}=n,i=t.attributes[`TEXCOORD_${r}`];if(Number.isFinite(i)){const n=e.json.accessors?.[i];if(n&&n.bufferView){const i=e.json.bufferViews?.[n.bufferView];if(i){const{arrayBuffer:a,byteOffset:c}=e.buffers[i.buffer],A=(c||0)+(n.byteOffset||0)+(i.byteOffset||0),{ArrayType:f,length:l}=(0,H.aF)(n,i),u=Ve.E9[n.componentType],B=Ve.$j[n.type],d=i.byteStride||u*B,C=new Float32Array(l);for(let e=0;e<n.count;e++){const t=new f(a,A+e*d,2);ke.set(t[0],t[1],1),ke.transformByMatrix3(s),C.set([ke[0],ke[1]],e*B)}r===o?function(e,t,n,r){e.componentType=5126,n.push({arrayBuffer:r.buffer,byteOffset:0,byteLength:r.buffer.byteLength}),t.buffer=n.length-1,t.byteLength=r.buffer.byteLength,t.byteOffset=0,delete t.byteStride}(n,i,e.buffers,C):function(e,t,n,r,o){r.buffers.push({arrayBuffer:o.buffer,byteOffset:0,byteLength:o.buffer.byteLength});const s=r.json.bufferViews;if(!s)return;s.push({buffer:r.buffers.length-1,byteLength:o.buffer.byteLength,byteOffset:0});const i=r.json.accessors;if(!i)return;i.push({bufferView:s?.length-1,byteOffset:0,componentType:5126,count:t.count,type:"VEC2"}),n.attributes[`TEXCOORD_${e}`]=i.length-1}(o,n,t,e,C)}}}}const nt="KHR_lights_punctual",rt=nt;async function ot(e){const t=new P(e),{json:n}=t,r=t.getExtension(nt);r&&(t.json.lights=r.lights,t.removeExtension(nt));for(const o of n.nodes||[]){const e=t.getObjectExtension(o,nt);e&&(o.light=e.light),t.removeObjectExtension(o,nt)}}async function st(e){const t=new P(e),{json:n}=t;if(n.lights){const e=t.addExtension(nt);(0,_.v)(!e.lights),e.lights=n.lights,delete n.lights}if(t.json.lights){for(const e of t.json.lights){const n=e.node;t.addObjectExtension(n,nt,e)}delete t.json.lights}}const it="KHR_materials_unlit",at=it;async function ct(e){const t=new P(e),{json:n}=t;for(const r of n.materials||[]){r.extensions&&r.extensions.KHR_materials_unlit&&(r.unlit=!0),t.removeObjectExtension(r,it)}t.removeExtension(it)}function At(e){const t=new P(e),{json:n}=t;if(t.materials)for(const r of n.materials||[])r.unlit&&(delete r.unlit,t.addObjectExtension(r,it,{}),t.addExtension(it))}const ft="KHR_techniques_webgl",lt=ft;async function ut(e){const t=new P(e),{json:n}=t,r=t.getExtension(ft);if(r){const e=function(e,t){const{programs:n=[],shaders:r=[],techniques:o=[]}=e,s=new TextDecoder;return r.forEach((e=>{if(!Number.isFinite(e.bufferView))throw new Error("KHR_techniques_webgl: no shader code");e.code=s.decode(t.getTypedArrayForBufferView(e.bufferView))})),n.forEach((e=>{e.fragmentShader=r[e.fragmentShader],e.vertexShader=r[e.vertexShader]})),o.forEach((e=>{e.program=n[e.program]})),o}(r,t);for(const r of n.materials||[]){const n=t.getObjectExtension(r,ft);n&&(r.technique=Object.assign({},n,e[n.technique]),r.technique.values=dt(r.technique,t)),t.removeObjectExtension(r,ft)}t.removeExtension(ft)}}async function Bt(e,t){}function dt(e,t){const n=Object.assign({},e.values);return Object.keys(e.uniforms||{}).forEach((t=>{e.uniforms[t].value&&!(t in n)&&(n[t]=e.uniforms[t].value)})),Object.keys(n).forEach((e=>{"object"==typeof n[e]&&void 0!==n[e].index&&(n[e].texture=t.getTexture(n[e].index))})),n}const Ct="EXT_feature_metadata",mt=Ct;async function bt(e,t){!function(e,t){if(!t.gltf?.loadBuffers)return;const n=e.getExtension(Ct);if(!n)return;t.gltf?.loadImages&&function(e,t){const n=t.schema;if(!n)return;const r=n.classes,{featureTextures:o}=t;if(r&&o)for(const s in r){const t=r[s],n=pt(o,s);n&&_t(e,n,t)}}(e,n);!function(e,t){const n=t.schema;if(!n)return;const r=n.classes,o=t.featureTables;if(r&&o)for(const s in r){const t=ht(o,s);t&&gt(e,n,t)}}(e,n)}(new P(e),t)}function ht(e,t){for(const n in e){const r=e[n];if(r.class===t)return r}return null}function pt(e,t){for(const n in e){const r=e[n];if(r.class===t)return r}return null}function gt(e,t,n){if(!n.class)return;const r=t.classes?.[n.class];if(!r)throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);const o=n.count;for(const s in r.properties){const i=r.properties[s],a=n.properties?.[s];if(a){const n=Et(e,t,i,o,a);a.data=n}}}function _t(e,t,n){const r=t.class;for(const o in n.properties){const n=t?.properties?.[o];if(n){const t=Rt(e,n,r);n.data=t}}}function Et(e,t,n,r,o){let s=[];const i=o.bufferView,a=e.getTypedArrayForBufferView(i),c=function(e,t,n,r){if("ARRAY"===t.type&&void 0===t.componentCount&&void 0!==n.arrayOffsetBufferView)return j(e,n.arrayOffsetBufferView,n.offsetType||"UINT32",r);return null}(e,n,o,r),A=function(e,t,n,r){if(void 0!==n.stringOffsetBufferView)return j(e,n.stringOffsetBufferView,n.offsetType||"UINT32",r);return null}(e,0,o,r);return"STRING"===n.type||"STRING"===n.componentType?s=Z(r,a,c,A):function(e){const t=["UINT8","INT16","UINT16","INT32","UINT32","INT64","UINT64","FLOAT32","FLOAT64"];return t.includes(e.type)||void 0!==e.componentType&&t.includes(e.componentType)}(n)&&(s=function(e,t,n,r){const o="ARRAY"===e.type,s=e.componentCount,i="SCALAR",a=e.componentType||e.type,c=K(i,a),A=n.byteLength/c,f=X(n,i,a,A);if(o)return r?W(f,t,r,n.length,c):s?k(f,t,s):[];return f}(n,r,a,c)),s}function Rt(e,t,n){const r=e.gltf.json;if(!r.meshes)return[];const o=[];for(const s of r.meshes)for(const r of s.primitives)It(e,n,t,o,r);return o}function It(e,t,n,r,o){const s=Q(e,{channels:n.channels,...n.texture},o);s&&V(e,t,s,r,o)}const St=[o,r,s,i,a,c,f,l,u,A,B];function Mt(e,t){const n=t?.gltf?.excludeExtensions||{};return!(e in n&&!n[e])}const Gt="KHR_binary_glTF";const Ft={accessors:"accessor",animations:"animation",buffers:"buffer",bufferViews:"bufferView",images:"image",materials:"material",meshes:"mesh",nodes:"node",samplers:"sampler",scenes:"scene",skins:"skin",textures:"texture"},Dt={accessor:"accessors",animations:"animation",buffer:"buffers",bufferView:"bufferViews",image:"images",material:"materials",mesh:"meshes",node:"nodes",sampler:"samplers",scene:"scenes",skin:"skins",texture:"textures"};class vt{idToIndexMap={animations:{},accessors:{},buffers:{},bufferViews:{},images:{},materials:{},meshes:{},nodes:{},samplers:{},scenes:{},skins:{},textures:{}};json;normalize(e,t){this.json=e.json;const n=e.json;switch(n.asset&&n.asset.version){case"2.0":return;case void 0:case"1.0":break;default:return void console.warn(`glTF: Unknown version ${n.asset.version}`)}if(!t.normalize)throw new Error("glTF v1 is not supported.");console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."),this._addAsset(n),this._convertTopLevelObjectsToArrays(n),function(e){const t=new P(e),{json:n}=t;for(const r of n.images||[]){const e=t.getObjectExtension(r,Gt);e&&Object.assign(r,e),t.removeObjectExtension(r,Gt)}n.buffers&&n.buffers[0]&&delete n.buffers[0].uri,t.removeExtension(Gt)}(e),this._convertObjectIdsToArrayIndices(n),this._updateObjects(n),this._updateMaterial(n)}_addAsset(e){e.asset=e.asset||{},e.asset.version="2.0",e.asset.generator=e.asset.generator||"Normalized to glTF 2.0 by loaders.gl"}_convertTopLevelObjectsToArrays(e){for(const t in Ft)this._convertTopLevelObjectToArray(e,t)}_convertTopLevelObjectToArray(e,t){const n=e[t];if(n&&!Array.isArray(n)){e[t]=[];for(const r in n){const o=n[r];o.id=o.id||r;const s=e[t].length;e[t].push(o),this.idToIndexMap[t][r]=s}}}_convertObjectIdsToArrayIndices(e){for(const t in Ft)this._convertIdsToIndices(e,t);"scene"in e&&(e.scene=this._convertIdToIndex(e.scene,"scene"));for(const t of e.textures)this._convertTextureIds(t);for(const t of e.meshes)this._convertMeshIds(t);for(const t of e.nodes)this._convertNodeIds(t);for(const t of e.scenes)this._convertSceneIds(t)}_convertTextureIds(e){e.source&&(e.source=this._convertIdToIndex(e.source,"image"))}_convertMeshIds(e){for(const t of e.primitives){const{attributes:e,indices:n,material:r}=t;for(const t in e)e[t]=this._convertIdToIndex(e[t],"accessor");n&&(t.indices=this._convertIdToIndex(n,"accessor")),r&&(t.material=this._convertIdToIndex(r,"material"))}}_convertNodeIds(e){e.children&&(e.children=e.children.map((e=>this._convertIdToIndex(e,"node")))),e.meshes&&(e.meshes=e.meshes.map((e=>this._convertIdToIndex(e,"mesh"))))}_convertSceneIds(e){e.nodes&&(e.nodes=e.nodes.map((e=>this._convertIdToIndex(e,"node"))))}_convertIdsToIndices(e,t){e[t]||(console.warn(`gltf v1: json doesn't contain attribute ${t}`),e[t]=[]);for(const n of e[t])for(const e in n){const t=n[e],r=this._convertIdToIndex(t,e);n[e]=r}}_convertIdToIndex(e,t){const n=Dt[t];if(n in this.idToIndexMap){const r=this.idToIndexMap[n][e];if(!Number.isFinite(r))throw new Error(`gltf v1: failed to resolve ${t} with id ${e}`);return r}return e}_updateObjects(e){for(const t of this.json.buffers)delete t.type}_updateMaterial(e){for(const t of e.materials){t.pbrMetallicRoughness={baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1};const n=t.values?.tex||t.values?.texture2d_0||t.values?.diffuseTex,r=e.textures.findIndex((e=>e.id===n));-1!==r&&(t.pbrMetallicRoughness.baseColorTexture={index:r})}}}async function Tt(e,t,n=0,r,o){return function(e,t,n,r){r.uri&&(e.baseUri=r.uri);if(t instanceof ArrayBuffer&&!function(e,t=0,n={}){const r=new DataView(e),{magic:o=M}=n,s=r.getUint32(t,!1);return s===o||s===M}(t,n,r)){t=(new TextDecoder).decode(t)}if("string"==typeof t)e.json=C(t);else if(t instanceof ArrayBuffer){const o={};n=D(o,t,n,r.glb),(0,_.v)("glTF"===o.type,`Invalid GLB magic string ${o.type}`),e._glb=o,e.json=o.json}else(0,_.v)(!1,"GLTF: must be ArrayBuffer or string");const o=e.json.buffers||[];if(e.buffers=new Array(o.length).fill(null),e._glb&&e._glb.header.hasBinChunk){const{binChunks:t}=e._glb;e.buffers[0]={arrayBuffer:t[0].arrayBuffer,byteOffset:t[0].byteOffset,byteLength:t[0].byteLength}}const s=e.json.images||[];e.images=new Array(s.length).fill({})}(e,t,n,r),function(e,t={}){(new vt).normalize(e,t)}(e,{normalize:r?.gltf?.normalize}),function(e,t={},n){const r=St.filter((e=>Mt(e.name,t)));for(const o of r)o.preprocess?.(e,t,n)}(e,r,o),r?.gltf?.loadBuffers&&e.json.buffers&&await async function(e,t,n){const r=e.json.buffers||[];for(let o=0;o<r.length;++o){const s=r[o];if(s.uri){const{fetch:r}=n;(0,_.v)(r);const i=y(s.uri,t),a=await(n?.fetch?.(i)),c=await(a?.arrayBuffer?.());e.buffers[o]={arrayBuffer:c,byteOffset:0,byteLength:c.byteLength},delete s.uri}else null===e.buffers[o]&&(e.buffers[o]={arrayBuffer:new ArrayBuffer(s.byteLength),byteOffset:0,byteLength:s.byteLength})}}(e,r,o),r?.gltf?.loadImages&&await async function(e,t,n){const r=function(e){const t=new Set,n=e.json.textures||[];for(const r of n)void 0!==r.source&&t.add(r.source);return Array.from(t).sort()}(e),o=e.json.images||[],s=[];for(const i of r)s.push(yt(e,o[i],i,t,n));return await Promise.all(s)}(e,r,o),await async function(e,t={},n){const r=St.filter((e=>Mt(e.name,t)));for(const o of r)await(o.decode?.(e,t,n))}(e,r,o),e}async function yt(e,t,n,r,o){let s;if(t.uri&&!t.hasOwnProperty("bufferView")){const e=y(t.uri,r),{fetch:n}=o,i=await n(e);s=await i.arrayBuffer(),t.bufferView={data:s}}if(Number.isFinite(t.bufferView)){const n=O(e.json,e.buffers,t.bufferView);s=(0,m._m)(n.buffer,n.byteOffset,n.byteLength)}(0,_.v)(s,"glTF image has no data");let i=await(0,b.N9)(s,[h.$,p.E],{...r,mimeType:t.mimeType,basis:r.basis||{format:(0,g.a)()}},o);i&&i[0]&&(i={compressed:!0,mipmaps:!1,width:i[0].width,height:i[0].height,data:i[0]}),e.images=e.images||[],e.images[n]=i}const Ht={dataType:null,batchType:null,name:"glTF",id:"gltf",module:"gltf",version:"4.2.1",extensions:["gltf","glb"],mimeTypes:["model/gltf+json","model/gltf-binary"],text:!0,binary:!0,tests:["glTF"],parse:async function(e,t={},n){(t={...Ht.options,...t}).gltf={...Ht.options.gltf,...t.gltf};const{byteOffset:r=0}=t;return await Tt({},e,r,t,n)},options:{gltf:{normalize:!0,loadBuffers:!0,loadImages:!0,decompressMeshes:!0},log:console}}},59737:(e,t,n)=>{n.d(t,{R:()=>b});var r=n(52840),o=n(27885);const s={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},i={5120:1,5121:1,5122:2,5123:2,5125:4,5126:4},a=10240,c=10241,A=10242,f=10243,l=10497,u=9729,B=9986,d={magFilter:a,minFilter:c,wrapS:A,wrapT:f},C={[a]:u,[c]:B,[A]:l,[f]:l};class m{baseUri="";jsonUnprocessed;json;buffers=[];images=[];postProcess(e,t={}){const{json:n,buffers:o=[],images:s=[]}=e,{baseUri:i=""}=e;return(0,r.v)(n),this.baseUri=i,this.buffers=o,this.images=s,this.jsonUnprocessed=n,this.json=this._resolveTree(e.json,t),this.json}_resolveTree(e,t={}){const n={...e};return this.json=n,e.bufferViews&&(n.bufferViews=e.bufferViews.map(((e,t)=>this._resolveBufferView(e,t)))),e.images&&(n.images=e.images.map(((e,t)=>this._resolveImage(e,t)))),e.samplers&&(n.samplers=e.samplers.map(((e,t)=>this._resolveSampler(e,t)))),e.textures&&(n.textures=e.textures.map(((e,t)=>this._resolveTexture(e,t)))),e.accessors&&(n.accessors=e.accessors.map(((e,t)=>this._resolveAccessor(e,t)))),e.materials&&(n.materials=e.materials.map(((e,t)=>this._resolveMaterial(e,t)))),e.meshes&&(n.meshes=e.meshes.map(((e,t)=>this._resolveMesh(e,t)))),e.nodes&&(n.nodes=e.nodes.map(((e,t)=>this._resolveNode(e,t))),n.nodes=n.nodes.map(((e,t)=>this._resolveNodeChildren(e)))),e.skins&&(n.skins=e.skins.map(((e,t)=>this._resolveSkin(e,t)))),e.scenes&&(n.scenes=e.scenes.map(((e,t)=>this._resolveScene(e,t)))),"number"==typeof this.json.scene&&n.scenes&&(n.scene=n.scenes[this.json.scene]),n}getScene(e){return this._get(this.json.scenes,e)}getNode(e){return this._get(this.json.nodes,e)}getSkin(e){return this._get(this.json.skins,e)}getMesh(e){return this._get(this.json.meshes,e)}getMaterial(e){return this._get(this.json.materials,e)}getAccessor(e){return this._get(this.json.accessors,e)}getCamera(e){return this._get(this.json.cameras,e)}getTexture(e){return this._get(this.json.textures,e)}getSampler(e){return this._get(this.json.samplers,e)}getImage(e){return this._get(this.json.images,e)}getBufferView(e){return this._get(this.json.bufferViews,e)}getBuffer(e){return this._get(this.json.buffers,e)}_get(e,t){if("object"==typeof t)return t;const n=e&&e[t];return n||console.warn(`glTF file error: Could not find ${e}[${t}]`),n}_resolveScene(e,t){return{...e,id:e.id||`scene-${t}`,nodes:(e.nodes||[]).map((e=>this.getNode(e)))}}_resolveNode(e,t){const n={...e,id:e?.id||`node-${t}`};return void 0!==e.mesh&&(n.mesh=this.getMesh(e.mesh)),void 0!==e.camera&&(n.camera=this.getCamera(e.camera)),void 0!==e.skin&&(n.skin=this.getSkin(e.skin)),void 0!==e.meshes&&e.meshes.length&&(n.mesh=e.meshes.reduce(((e,t)=>{const n=this.getMesh(t);return e.id=n.id,e.primitives=e.primitives.concat(n.primitives),e}),{primitives:[]})),n}_resolveNodeChildren(e){return e.children&&(e.children=e.children.map((e=>this.getNode(e)))),e}_resolveSkin(e,t){const n="number"==typeof e.inverseBindMatrices?this.getAccessor(e.inverseBindMatrices):void 0;return{...e,id:e.id||`skin-${t}`,inverseBindMatrices:n}}_resolveMesh(e,t){const n={...e,id:e.id||`mesh-${t}`,primitives:[]};return e.primitives&&(n.primitives=e.primitives.map((e=>{const t={...e,attributes:{},indices:void 0,material:void 0},n=e.attributes;for(const r in n)t.attributes[r]=this.getAccessor(n[r]);return void 0!==e.indices&&(t.indices=this.getAccessor(e.indices)),void 0!==e.material&&(t.material=this.getMaterial(e.material)),t}))),n}_resolveMaterial(e,t){const n={...e,id:e.id||`material-${t}`};if(n.normalTexture&&(n.normalTexture={...n.normalTexture},n.normalTexture.texture=this.getTexture(n.normalTexture.index)),n.occlusionTexture&&(n.occlusionTexture={...n.occlusionTexture},n.occlusionTexture.texture=this.getTexture(n.occlusionTexture.index)),n.emissiveTexture&&(n.emissiveTexture={...n.emissiveTexture},n.emissiveTexture.texture=this.getTexture(n.emissiveTexture.index)),n.emissiveFactor||(n.emissiveFactor=n.emissiveTexture?[1,1,1]:[0,0,0]),n.pbrMetallicRoughness){n.pbrMetallicRoughness={...n.pbrMetallicRoughness};const e=n.pbrMetallicRoughness;e.baseColorTexture&&(e.baseColorTexture={...e.baseColorTexture},e.baseColorTexture.texture=this.getTexture(e.baseColorTexture.index)),e.metallicRoughnessTexture&&(e.metallicRoughnessTexture={...e.metallicRoughnessTexture},e.metallicRoughnessTexture.texture=this.getTexture(e.metallicRoughnessTexture.index))}return n}_resolveAccessor(e,t){const n=(r=e.componentType,i[r]);var r;const a=(c=e.type,s[c]);var c;const A=n*a,f={...e,id:e.id||`accessor-${t}`,bytesPerComponent:n,components:a,bytesPerElement:A,value:void 0,bufferView:void 0,sparse:void 0};if(void 0!==e.bufferView&&(f.bufferView=this.getBufferView(e.bufferView)),f.bufferView){const e=f.bufferView.buffer,{ArrayType:t,byteLength:n}=(0,o.aF)(f,f.bufferView),r=(f.bufferView.byteOffset||0)+(f.byteOffset||0)+e.byteOffset;let s=e.arrayBuffer.slice(r,r+n);f.bufferView.byteStride&&(s=this._getValueFromInterleavedBuffer(e,r,f.bufferView.byteStride,f.bytesPerElement,f.count)),f.value=new t(s)}return f}_getValueFromInterleavedBuffer(e,t,n,r,o){const s=new Uint8Array(o*r);for(let i=0;i<o;i++){const o=t+i*n;s.set(new Uint8Array(e.arrayBuffer.slice(o,o+r)),i*r)}return s.buffer}_resolveTexture(e,t){return{...e,id:e.id||`texture-${t}`,sampler:"number"==typeof e.sampler?this.getSampler(e.sampler):{id:"default-sampler",parameters:C},source:"number"==typeof e.source?this.getImage(e.source):void 0}}_resolveSampler(e,t){const n={id:e.id||`sampler-${t}`,...e,parameters:{}};for(const r in n){const e=this._enumSamplerParameter(r);void 0!==e&&(n.parameters[e]=n[r])}return n}_enumSamplerParameter(e){return d[e]}_resolveImage(e,t){const n={...e,id:e.id||`image-${t}`,image:null,bufferView:void 0!==e.bufferView?this.getBufferView(e.bufferView):void 0},r=this.images[t];return r&&(n.image=r),n}_resolveBufferView(e,t){const n=e.buffer,r=this.buffers[n].arrayBuffer;let o=this.buffers[n].byteOffset||0;e.byteOffset&&(o+=e.byteOffset);return{id:`bufferView-${t}`,...e,buffer:this.buffers[n],data:new Uint8Array(r,o,e.byteLength)}}_resolveCamera(e,t){const n={...e,id:e.id||`camera-${t}`};return n.perspective,n.orthographic,n}}function b(e,t){return(new m).postProcess(e,t)}},77897:(e,t,n)=>{n.d(t,{$j:()=>r,E9:()=>o});const r={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},o={5120:1,5121:1,5122:2,5123:2,5125:4,5126:4}},27885:(e,t,n)=>{n.d(t,{S3:()=>C,aF:()=>d,rA:()=>B,v7:()=>u});var r=n(52840),o=n(77897);const s=1.33,i=["SCALAR","VEC2","VEC3","VEC4"],a=[[Int8Array,5120],[Uint8Array,5121],[Int16Array,5122],[Uint16Array,5123],[Uint32Array,5125],[Float32Array,5126],[Float64Array,5130]],c=new Map(a),A={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},f={5120:1,5121:1,5122:2,5123:2,5125:4,5126:4},l={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};function u(e){return i[e-1]||i[0]}function B(e){const t=c.get(e.constructor);if(!t)throw new Error("Illegal typed array");return t}function d(e,t){const n=l[e.componentType],s=A[e.type],i=f[e.componentType],a=e.count*s,c=e.count*s*i;(0,r.v)(c>=0&&c<=t.byteLength);return{ArrayType:n,length:a,byteLength:c,componentByteSize:o.E9[e.componentType],numberOfComponentsInElement:o.$j[e.type]}}function C(e){let{images:t,bufferViews:n}=e;t=t||[],n=n||[];const r=t.map((e=>e.bufferView));n=n.filter((e=>!r.includes(e)));const o=n.reduce(((e,t)=>e+t.byteLength),0),i=t.reduce(((e,t)=>{const{width:n,height:r}=t.image;return e+n*r}),0);return o+Math.ceil(4*i*s)}},52840:(e,t,n)=>{function r(e,t){if(!e)throw new Error(t||"assert failed: gltf")}n.d(t,{v:()=>r})},69035:(e,t,n)=>{function r(e){globalThis.loaders||={},globalThis.loaders.modules||={},Object.assign(globalThis.loaders.modules,e)}function o(e){const t=globalThis.loaders?.modules?.[e];return t||null}n.d(t,{Qz:()=>r,w7:()=>o})},38925:(e,t,n)=>{async function r(e,t,n,r){return r._parse(e,t,n,r)}n.d(t,{N9:()=>r})},35983:(e,t,n)=>{function r(e){let t=1/0,n=1/0,r=1/0,o=-1/0,s=-1/0,i=-1/0;const a=e.POSITION?e.POSITION.value:[],c=a&&a.length;for(let A=0;A<c;A+=3){const e=a[A],c=a[A+1],f=a[A+2];t=e<t?e:t,n=c<n?c:n,r=f<r?f:r,o=e>o?e:o,s=c>s?c:s,i=f>i?f:i}return[[t,n,r],[o,s,i]]}n.d(t,{l:()=>r})},91532:(e,t,n)=>{function r(e){let t=o(e);return"null"!==t?{type:t,nullable:!1}:e.length>0?(t=function(e,t="float32"){return e instanceof Date?"date-millisecond":e instanceof Number?t:"string"==typeof e?"utf8":"null"}(e[0]),{type:t,nullable:!0}):{type:"null",nullable:!0}}function o(e){switch(e.constructor){case Int8Array:return"int8";case Uint8Array:case Uint8ClampedArray:return"uint8";case Int16Array:return"int16";case Uint16Array:return"uint16";case Int32Array:return"int32";case Uint32Array:return"uint32";case Float32Array:return"float32";case Float64Array:return"float64";default:return"null"}}n.d(t,{IT:()=>r,UE:()=>o})},77067:(e,t,n)=>{n.d(t,{E:()=>s});var r=n(78307),o=n(6143);const s={...{dataType:null,batchType:null,name:"Basis",id:"basis",module:"textures",version:r.x,worker:!0,extensions:["basis","ktx2"],mimeTypes:["application/octet-stream","image/ktx2"],tests:["sB"],binary:!0,options:{basis:{format:"auto",libraryPath:"libs/",containerFormat:"auto",module:"transcoder"}}},parse:o.A}},50473:(e,t,n)=>{n.d(t,{b:()=>r});const r={COMPRESSED_RGB_S3TC_DXT1_EXT:33776,COMPRESSED_RGBA_S3TC_DXT1_EXT:33777,COMPRESSED_RGBA_S3TC_DXT3_EXT:33778,COMPRESSED_RGBA_S3TC_DXT5_EXT:33779,COMPRESSED_R11_EAC:37488,COMPRESSED_SIGNED_R11_EAC:37489,COMPRESSED_RG11_EAC:37490,COMPRESSED_SIGNED_RG11_EAC:37491,COMPRESSED_RGB8_ETC2:37492,COMPRESSED_RGBA8_ETC2_EAC:37493,COMPRESSED_SRGB8_ETC2:37494,COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:37495,COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:37496,COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:37497,COMPRESSED_RGB_PVRTC_4BPPV1_IMG:35840,COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:35842,COMPRESSED_RGB_PVRTC_2BPPV1_IMG:35841,COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:35843,COMPRESSED_RGB_ETC1_WEBGL:36196,COMPRESSED_RGB_ATC_WEBGL:35986,COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:35987,COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:34798,COMPRESSED_RGBA_ASTC_4X4_KHR:37808,COMPRESSED_RGBA_ASTC_5X4_KHR:37809,COMPRESSED_RGBA_ASTC_5X5_KHR:37810,COMPRESSED_RGBA_ASTC_6X5_KHR:37811,COMPRESSED_RGBA_ASTC_6X6_KHR:37812,COMPRESSED_RGBA_ASTC_8X5_KHR:37813,COMPRESSED_RGBA_ASTC_8X6_KHR:37814,COMPRESSED_RGBA_ASTC_8X8_KHR:37815,COMPRESSED_RGBA_ASTC_10X5_KHR:37816,COMPRESSED_RGBA_ASTC_10X6_KHR:37817,COMPRESSED_RGBA_ASTC_10X8_KHR:37818,COMPRESSED_RGBA_ASTC_10X10_KHR:37819,COMPRESSED_RGBA_ASTC_12X10_KHR:37820,COMPRESSED_RGBA_ASTC_12X12_KHR:37821,COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR:37840,COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR:37841,COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR:37842,COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR:37843,COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR:37844,COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR:37845,COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR:37846,COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR:37847,COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR:37848,COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR:37849,COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR:37850,COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR:37851,COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR:37852,COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR:37853,COMPRESSED_RED_RGTC1_EXT:36283,COMPRESSED_SIGNED_RED_RGTC1_EXT:36284,COMPRESSED_RED_GREEN_RGTC2_EXT:36285,COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT:36286,COMPRESSED_SRGB_S3TC_DXT1_EXT:35916,COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:35917,COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:35918,COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:35919}},6143:(e,t,n)=>{n.d(t,{A:()=>d,a:()=>g});var r=n(69035),o=n(17316);const s={TRANSCODER:"basis_transcoder.js",TRANSCODER_WASM:"basis_transcoder.wasm",ENCODER:"basis_encoder.js",ENCODER_WASM:"basis_encoder.wasm"};let i,a;async function c(e){(0,r.Qz)(e.modules);const t=(0,r.w7)("basis");return t||(i||=async function(e){let t=null,n=null;return[t,n]=await Promise.all([await(0,o._)(s.TRANSCODER,"textures",e),await(0,o._)(s.TRANSCODER_WASM,"textures",e)]),t=t||globalThis.BASIS,await function(e,t){const n={};t&&(n.wasmBinary=t);return new Promise((t=>{e(n).then((e=>{const{BasisFile:n,initializeBasis:r}=e;r(),t({BasisFile:n})}))}))}(t,n)}(e),await i)}async function A(e){const t=e.modules||{};return t.basisEncoder?t.basisEncoder:(a=a||async function(e){let t=null,n=null;return[t,n]=await Promise.all([await(0,o._)(s.ENCODER,"textures",e),await(0,o._)(s.ENCODER_WASM,"textures",e)]),t=t||globalThis.BASIS,await function(e,t){const n={};t&&(n.wasmBinary=t);return new Promise((t=>{e(n).then((e=>{const{BasisFile:n,KTX2File:r,initializeBasis:o,BasisEncoder:s}=e;o(),t({BasisFile:n,KTX2File:r,BasisEncoder:s})}))}))}(t,n)}(e),await a)}var f=n(50473),l=n(64257),u=n(49332);const B={etc1:{basisFormat:0,compressed:!0,format:f.b.COMPRESSED_RGB_ETC1_WEBGL},etc2:{basisFormat:1,compressed:!0},bc1:{basisFormat:2,compressed:!0,format:f.b.COMPRESSED_RGB_S3TC_DXT1_EXT},bc3:{basisFormat:3,compressed:!0,format:f.b.COMPRESSED_RGBA_S3TC_DXT5_EXT},bc4:{basisFormat:4,compressed:!0},bc5:{basisFormat:5,compressed:!0},"bc7-m6-opaque-only":{basisFormat:6,compressed:!0},"bc7-m5":{basisFormat:7,compressed:!0},"pvrtc1-4-rgb":{basisFormat:8,compressed:!0,format:f.b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG},"pvrtc1-4-rgba":{basisFormat:9,compressed:!0,format:f.b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG},"astc-4x4":{basisFormat:10,compressed:!0,format:f.b.COMPRESSED_RGBA_ASTC_4X4_KHR},"atc-rgb":{basisFormat:11,compressed:!0},"atc-rgba-interpolated-alpha":{basisFormat:12,compressed:!0},rgba32:{basisFormat:13,compressed:!1},rgb565:{basisFormat:14,compressed:!1},bgr565:{basisFormat:15,compressed:!1},rgba4444:{basisFormat:16,compressed:!1}};async function d(e,t){if("auto"===t.basis.containerFormat){if((0,u.e)(e)){return b((await A(t)).KTX2File,e,t)}const{BasisFile:n}=await c(t);return C(n,e,t)}if("encoder"===t.basis.module){const n=await A(t);return"ktx2"===t.basis.containerFormat?b(n.KTX2File,e,t):C(n.BasisFile,e,t)}{const{BasisFile:n}=await c(t);return C(n,e,t)}}function C(e,t,n){const r=new e(new Uint8Array(t));try{if(!r.startTranscoding())throw new Error("Failed to start basis transcoding");const e=r.getNumImages(),t=[];for(let o=0;o<e;o++){const e=r.getNumLevels(o),s=[];for(let t=0;t<e;t++)s.push(m(r,o,t,n));t.push(s)}return t}finally{r.close(),r.delete()}}function m(e,t,n,r){const o=e.getImageWidth(t,n),s=e.getImageHeight(t,n),i=e.getHasAlpha(),{compressed:a,format:c,basisFormat:A}=p(r,i),f=e.getImageTranscodedSizeInBytes(t,n,A),l=new Uint8Array(f);if(!e.transcodeImage(l,t,n,A,0,0))throw new Error("failed to start Basis transcoding");return{width:o,height:s,data:l,compressed:a,format:c,hasAlpha:i}}function b(e,t,n){const r=new e(new Uint8Array(t));try{if(!r.startTranscoding())throw new Error("failed to start KTX2 transcoding");const e=r.getLevels(),t=[];for(let o=0;o<e;o++){t.push(h(r,o,n));break}return[t]}finally{r.close(),r.delete()}}function h(e,t,n){const{alphaFlag:r,height:o,width:s}=e.getImageLevelInfo(t,0,0),{compressed:i,format:a,basisFormat:c}=p(n,r),A=e.getImageTranscodedSizeInBytes(t,0,0,c),f=new Uint8Array(A);if(!e.transcodeImage(f,t,0,0,c,0,-1,-1))throw new Error("Failed to transcode KTX2 image");return{width:s,height:o,data:f,compressed:i,levelSize:A,hasAlpha:r,format:a}}function p(e,t){let n=e&&e.basis&&e.basis.format;return"auto"===n&&(n=g()),"object"==typeof n&&(n=t?n.alpha:n.noAlpha),n=n.toLowerCase(),B[n]}function g(){const e=(0,l.E)();return e.has("astc")?"astc-4x4":e.has("dxt")?{alpha:"bc3",noAlpha:"bc1"}:e.has("pvrtc")?{alpha:"pvrtc1-4-rgba",noAlpha:"pvrtc1-4-rgb"}:e.has("etc1")?"etc1":e.has("etc2")?"etc2":"rgb565"}},49332:(e,t,n)=>{n.d(t,{e:()=>u,V:()=>B});const r=64;class o{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=0,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:0,descriptorBlockSize:0,versionNumber:2,colorModel:0,colorPrimaries:1,transferFunction:2,flags:0,texelBlockDimension:[0,0,0,0],bytesPlane:[0,0,0,0,0,0,0,0],samples:[]}],this.keyValue={},this.globalData=null}}class s{constructor(e,t,n,r){this._dataView=void 0,this._littleEndian=void 0,this._offset=void 0,this._dataView=new DataView(e.buffer,e.byteOffset+t,n),this._littleEndian=r,this._offset=0}_nextUint8(){const e=this._dataView.getUint8(this._offset);return this._offset+=1,e}_nextUint16(){const e=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,e}_nextUint32(){const e=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint64(){const e=this._dataView.getUint32(this._offset,this._littleEndian)+2**32*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,e}_nextInt32(){const e=this._dataView.getInt32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint8Array(e){const t=new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+this._offset,e);return this._offset+=e,t}_skip(e){return this._offset+=e,this}_scan(e,t=0){const n=this._offset;let r=0;for(;this._dataView.getUint8(this._offset)!==t&&r<e;)r++,this._offset++;return r<e&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+n,r)}}new Uint8Array([0]);const i=[171,75,84,88,32,50,48,187,13,10,26,10];function a(e){return(new TextDecoder).decode(e)}var c=n(71530),A=n(50473);const f={131:A.b.COMPRESSED_RGB_S3TC_DXT1_EXT,132:A.b.COMPRESSED_SRGB_S3TC_DXT1_EXT,133:A.b.COMPRESSED_RGBA_S3TC_DXT1_EXT,134:A.b.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,135:A.b.COMPRESSED_RGBA_S3TC_DXT3_EXT,136:A.b.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,137:A.b.COMPRESSED_RGBA_S3TC_DXT5_EXT,138:A.b.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,139:A.b.COMPRESSED_RED_RGTC1_EXT,140:A.b.COMPRESSED_SIGNED_RED_RGTC1_EXT,141:A.b.COMPRESSED_RED_GREEN_RGTC2_EXT,142:A.b.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,147:A.b.COMPRESSED_RGB8_ETC2,148:A.b.COMPRESSED_SRGB8_ETC2,149:A.b.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,150:A.b.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,151:A.b.COMPRESSED_RGBA8_ETC2_EAC,152:A.b.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,153:A.b.COMPRESSED_R11_EAC,154:A.b.COMPRESSED_SIGNED_R11_EAC,155:A.b.COMPRESSED_RG11_EAC,156:A.b.COMPRESSED_SIGNED_RG11_EAC,157:A.b.COMPRESSED_RGBA_ASTC_4x4_KHR,158:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,159:A.b.COMPRESSED_RGBA_ASTC_5x4_KHR,160:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR,161:A.b.COMPRESSED_RGBA_ASTC_5x5_KHR,162:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,163:A.b.COMPRESSED_RGBA_ASTC_6x5_KHR,164:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,165:A.b.COMPRESSED_RGBA_ASTC_6x6_KHR,166:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,167:A.b.COMPRESSED_RGBA_ASTC_8x5_KHR,168:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,169:A.b.COMPRESSED_RGBA_ASTC_8x6_KHR,170:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,171:A.b.COMPRESSED_RGBA_ASTC_8x8_KHR,172:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,173:A.b.COMPRESSED_RGBA_ASTC_10x5_KHR,174:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,175:A.b.COMPRESSED_RGBA_ASTC_10x6_KHR,176:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,177:A.b.COMPRESSED_RGBA_ASTC_10x8_KHR,178:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,179:A.b.COMPRESSED_RGBA_ASTC_10x10_KHR,180:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,181:A.b.COMPRESSED_RGBA_ASTC_12x10_KHR,182:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,183:A.b.COMPRESSED_RGBA_ASTC_12x12_KHR,184:A.b.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,1000054e3:A.b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,1000054001:A.b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,1000066e3:A.b.COMPRESSED_RGBA_ASTC_4x4_KHR,1000066001:A.b.COMPRESSED_RGBA_ASTC_5x4_KHR,1000066002:A.b.COMPRESSED_RGBA_ASTC_5x5_KHR,1000066003:A.b.COMPRESSED_RGBA_ASTC_6x5_KHR,1000066004:A.b.COMPRESSED_RGBA_ASTC_6x6_KHR,1000066005:A.b.COMPRESSED_RGBA_ASTC_8x5_KHR,1000066006:A.b.COMPRESSED_RGBA_ASTC_8x6_KHR,1000066007:A.b.COMPRESSED_RGBA_ASTC_8x8_KHR,1000066008:A.b.COMPRESSED_RGBA_ASTC_10x5_KHR,1000066009:A.b.COMPRESSED_RGBA_ASTC_10x6_KHR,1000066010:A.b.COMPRESSED_RGBA_ASTC_10x8_KHR,1000066011:A.b.COMPRESSED_RGBA_ASTC_10x10_KHR,1000066012:A.b.COMPRESSED_RGBA_ASTC_12x10_KHR,1000066013:A.b.COMPRESSED_RGBA_ASTC_12x12_KHR};const l=[171,75,84,88,32,50,48,187,13,10,26,10];function u(e){const t=new Uint8Array(e);return!(t.byteLength<l.length||t[0]!==l[0]||t[1]!==l[1]||t[2]!==l[2]||t[3]!==l[3]||t[4]!==l[4]||t[5]!==l[5]||t[6]!==l[6]||t[7]!==l[7]||t[8]!==l[8]||t[9]!==l[9]||t[10]!==l[10]||t[11]!==l[11])}function B(e){const t=function(e){const t=new Uint8Array(e.buffer,e.byteOffset,i.length);if(t[0]!==i[0]||t[1]!==i[1]||t[2]!==i[2]||t[3]!==i[3]||t[4]!==i[4]||t[5]!==i[5]||t[6]!==i[6]||t[7]!==i[7]||t[8]!==i[8]||t[9]!==i[9]||t[10]!==i[10]||t[11]!==i[11])throw new Error("Missing KTX 2.0 identifier.");const n=new o,c=17*Uint32Array.BYTES_PER_ELEMENT,A=new s(e,i.length,c,!0);n.vkFormat=A._nextUint32(),n.typeSize=A._nextUint32(),n.pixelWidth=A._nextUint32(),n.pixelHeight=A._nextUint32(),n.pixelDepth=A._nextUint32(),n.layerCount=A._nextUint32(),n.faceCount=A._nextUint32();const f=A._nextUint32();n.supercompressionScheme=A._nextUint32();const l=A._nextUint32(),u=A._nextUint32(),B=A._nextUint32(),d=A._nextUint32(),C=A._nextUint64(),m=A._nextUint64(),b=3*f*8,h=new s(e,i.length+c,b,!0);for(let r=0;r<f;r++)n.levels.push({levelData:new Uint8Array(e.buffer,e.byteOffset+h._nextUint64(),h._nextUint64()),uncompressedByteLength:h._nextUint64()});const p=new s(e,l,u,!0),g={vendorId:p._skip(4)._nextUint16(),descriptorType:p._nextUint16(),versionNumber:p._nextUint16(),descriptorBlockSize:p._nextUint16(),colorModel:p._nextUint8(),colorPrimaries:p._nextUint8(),transferFunction:p._nextUint8(),flags:p._nextUint8(),texelBlockDimension:[p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8()],bytesPlane:[p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8()],samples:[]},_=(g.descriptorBlockSize/4-6)/4;for(let o=0;o<_;o++){const e={bitOffset:p._nextUint16(),bitLength:p._nextUint8(),channelType:p._nextUint8(),samplePosition:[p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8()],sampleLower:-1/0,sampleUpper:1/0};e.channelType&r?(e.sampleLower=p._nextInt32(),e.sampleUpper=p._nextInt32()):(e.sampleLower=p._nextUint32(),e.sampleUpper=p._nextUint32()),g.samples[o]=e}n.dataFormatDescriptor.length=0,n.dataFormatDescriptor.push(g);const E=new s(e,B,d,!0);for(;E._offset<d;){const e=E._nextUint32(),t=E._scan(e),r=a(t);if(n.keyValue[r]=E._nextUint8Array(e-t.byteLength-1),r.match(/^ktx/i)){const e=a(n.keyValue[r]);n.keyValue[r]=e.substring(0,e.lastIndexOf("\0"))}const o=e%4?4-e%4:0;E._skip(o)}if(m<=0)return n;const R=new s(e,C,m,!0),I=R._nextUint16(),S=R._nextUint16(),M=R._nextUint32(),G=R._nextUint32(),F=R._nextUint32(),D=R._nextUint32(),v=[];for(let r=0;r<f;r++)v.push({imageFlags:R._nextUint32(),rgbSliceByteOffset:R._nextUint32(),rgbSliceByteLength:R._nextUint32(),alphaSliceByteOffset:R._nextUint32(),alphaSliceByteLength:R._nextUint32()});const T=C+R._offset,y=T+M,H=y+G,O=H+F,x=new Uint8Array(e.buffer,e.byteOffset+T,M),P=new Uint8Array(e.buffer,e.byteOffset+y,G),U=new Uint8Array(e.buffer,e.byteOffset+H,F),L=new Uint8Array(e.buffer,e.byteOffset+O,D);return n.globalData={endpointCount:I,selectorCount:S,imageDescs:v,endpointsData:x,selectorsData:P,tablesData:U,extendedData:L},n}(new Uint8Array(e)),n=Math.max(1,t.levels.length),A=t.pixelWidth,l=t.pixelHeight,u=(B=t.vkFormat,f[B]);var B;return(0,c.C)(t.levels,{mipMapLevels:n,width:A,height:l,sizeFunction:e=>e.uncompressedByteLength,internalFormat:u})}},71530:(e,t,n)=>{function r(e,t){const n=new Array(t.mipMapLevels);let r=t.width,i=t.height,a=0;for(let c=0;c<t.mipMapLevels;++c){const A=s(t,r,i,e,c),f=o(e,c,a,A);n[c]={compressed:!0,format:t.internalFormat,data:f,width:r,height:i,levelSize:A},r=Math.max(1,r>>1),i=Math.max(1,i>>1),a+=A}return n}function o(e,t,n,r){return Array.isArray(e)?e[t].levelData:new Uint8Array(e.buffer,e.byteOffset+n,r)}function s(e,t,n,r,o){return Array.isArray(r)?e.sizeFunction(r[o]):e.sizeFunction(t,n)}n.d(t,{C:()=>r})},64257:(e,t,n)=>{n.d(t,{E:()=>i});const r=["","WEBKIT_","MOZ_"],o={WEBGL_compressed_texture_s3tc:"dxt",WEBGL_compressed_texture_s3tc_srgb:"dxt-srgb",WEBGL_compressed_texture_etc1:"etc1",WEBGL_compressed_texture_etc:"etc2",WEBGL_compressed_texture_pvrtc:"pvrtc",WEBGL_compressed_texture_atc:"atc",WEBGL_compressed_texture_astc:"astc",EXT_texture_compression_rgtc:"rgtc"};let s=null;function i(e){if(!s){e=e||function(){try{return document.createElement("canvas").getContext("webgl")}catch(e){return null}}()||void 0,s=new Set;for(const t of r)for(const n in o)if(e&&e.getExtension(`${t}${n}`)){const e=o[n];s.add(e)}}return s}},78307:(e,t,n)=>{n.d(t,{x:()=>r});const r="4.2.1"},17316:(e,t,n)=>{n.d(t,{_:()=>a});var r=n(38503),o=n(5993),s=n(55607);const i={};async function a(e,t=null,n={},a=null){return t&&(e=function(e,t,n={},i=null){if(!n.useLocalLibraries&&e.startsWith("http"))return e;i=i||e;const a=n.modules||{};if(a[i])return a[i];if(!r.Bd)return`modules/${t}/dist/libs/${i}`;if(n.CDN)return(0,o.v)(n.CDN.startsWith("http")),`${n.CDN}/${t}@${s.Q}/dist/libs/${i}`;if(r.xD)return`../src/libs/${i}`;return`modules/${t}/src/libs/${i}`}(e,t,n,a)),i[e]=i[e]||async function(e){if(e.endsWith("wasm"))return await async function(e){const{readFileAsArrayBuffer:t}=globalThis.loaders||{};if(r.Bd||!t||e.startsWith("http")){const t=await fetch(e);return await t.arrayBuffer()}return await t(e)}(e);if(!r.Bd)try{const{requireFromFile:t}=globalThis.loaders||{};return await(t?.(e))}catch(n){return console.error(n),null}if(r.xD)return importScripts(e);const t=await async function(e){const{readFileAsText:t}=globalThis.loaders||{};if(r.Bd||!t||e.startsWith("http")){const t=await fetch(e);return await t.text()}return await t(e)}(e);return function(e,t){if(!r.Bd){const{requireFromString:n}=globalThis.loaders||{};return n?.(e,t)}if(r.xD)return eval.call(globalThis,e),null;const n=document.createElement("script");n.id=t;try{n.appendChild(document.createTextNode(e))}catch(o){n.text=e}return document.body.appendChild(n),null}(t,e)}(e),await i[e]}},19475:(e,t,n)=>{n.d(t,{o:()=>a});var r=n(87597),o=n(31886),s=n(29651),i=n(44710);class a extends i.V{children;constructor(e={}){e=Array.isArray(e)?{children:e}:e;const{children:t=[]}=e;s.R.assert(t.every((e=>e instanceof i.V)),"every child must an instance of ScenegraphNode"),super(e),this.children=t}getBounds(){const e=[[1/0,1/0,1/0],[-1/0,-1/0,-1/0]];return this.traverse(((t,{worldMatrix:n})=>{const o=t.getBounds();if(!o)return;const[s,i]=o,a=new r.P(s).add(i).divide([2,2,2]);n.transformAsPoint(a,a);const c=new r.P(i).subtract(s).divide([2,2,2]);n.transformAsVector(c,c);for(let A=0;A<8;A++){const t=new r.P(1&A?-1:1,2&A?-1:1,4&A?-1:1).multiply(c).add(a);for(let n=0;n<3;n++)e[0][n]=Math.min(e[0][n],t[n]),e[1][n]=Math.max(e[1][n],t[n])}})),Number.isFinite(e[0][0])?e:null}destroy(){this.children.forEach((e=>e.destroy())),this.removeAll(),super.destroy()}add(...e){for(const t of e)Array.isArray(t)?this.add(...t):this.children.push(t);return this}remove(e){const t=this.children,n=t.indexOf(e);return n>-1&&t.splice(n,1),this}removeAll(){return this.children=[],this}traverse(e,{worldMatrix:t=new o.k}={}){const n=new o.k(t).multiplyRight(this.matrix);for(const r of this.children)r instanceof a?r.traverse(e,{worldMatrix:n}):e(r,{worldMatrix:n})}}},64493:(e,t,n)=>{n.d(t,{s:()=>o});var r=n(44710);class o extends r.V{model;bounds=null;managedResources;constructor(e){super(e),this.model=e.model,this.managedResources=e.managedResources||[],this.bounds=e.bounds||null,this.setProps(e)}destroy(){this.model&&(this.model.destroy(),this.model=null),this.managedResources.forEach((e=>e.destroy())),this.managedResources=[]}getBounds(){return this.bounds}draw(e){return this.model.draw(e)}}},44710:(e,t,n)=>{n.d(t,{V:()=>i});var r=n(31886),o=n(87597),s=n(4500);class i{id;matrix=new r.k;display=!0;position=new o.P;rotation=new o.P;scale=new o.P(1,1,1);userData={};props={};constructor(e={}){const{id:t}=e;this.id=t||(0,s.L)(this.constructor.name),this._setScenegraphNodeProps(e)}getBounds(){return null}destroy(){}delete(){this.destroy()}setProps(e){return this._setScenegraphNodeProps(e),this}toString(){return`{type: ScenegraphNode, id: ${this.id})}`}setPosition(e){return this.position=e,this}setRotation(e){return this.rotation=e,this}setScale(e){return this.scale=e,this}setMatrix(e,t=!0){t?this.matrix.copy(e):this.matrix=e}setMatrixComponents(e){const{position:t,rotation:n,scale:r,update:o=!0}=e;return t&&this.setPosition(t),n&&this.setRotation(n),r&&this.setScale(r),o&&this.updateMatrix(),this}updateMatrix(){const e=this.position,t=this.rotation,n=this.scale;return this.matrix.identity(),this.matrix.translate(e),this.matrix.rotateXYZ(t),this.matrix.scale(n),this}update(e={}){const{position:t,rotation:n,scale:r}=e;return t&&this.setPosition(t),n&&this.setRotation(n),r&&this.setScale(r),this.updateMatrix(),this}getCoordinateUniforms(e,t){t=t||this.matrix;const n=new r.k(e).multiplyRight(t),o=n.invert(),s=o.transpose();return{viewMatrix:e,modelMatrix:t,objectMatrix:t,worldMatrix:n,worldInverseMatrix:o,worldInverseTransposeMatrix:s}}_setScenegraphNodeProps(e){"position"in e&&this.setPosition(e.position),"rotation"in e&&this.setRotation(e.rotation),"scale"in e&&this.setScale(e.scale),"matrix"in e&&this.setMatrix(e.matrix),Object.assign(this.props,e)}}},5538:(e,t,n)=>{n.d(t,{v:()=>F});var r,o=n(19475),s=n(25337),i=n(31886);!function(e){e[e.POINTS=0]="POINTS",e[e.LINES=1]="LINES",e[e.LINE_LOOP=2]="LINE_LOOP",e[e.LINE_STRIP=3]="LINE_STRIP",e[e.TRIANGLES=4]="TRIANGLES",e[e.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",e[e.TRIANGLE_FAN=6]="TRIANGLE_FAN"}(r||(r={}));var a=n(29651),c=n(291),A=n(8274),f=n(64493);const l="\nlayout(0) positions: vec4; // in vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    in vec4 normals; // in vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n@vertex\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * positions;\n  }\n\n@fragment\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n",u="#version 300 es\n\n  // in vec4 POSITION;\n  in vec4 positions;\n\n  #ifdef HAS_NORMALS\n    // in vec4 NORMAL;\n    in vec4 normals;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;\n  }\n",B="#version 300 es\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n";var d=n(92638);const C={modelOptions:{},pbrDebug:!1,imageBasedLightingEnvironment:void 0,lights:!0,useTangents:!1};function m(e,t,n={}){const r={...C,...n},s=t.scenes.map((n=>function(e,t,n,r){const s=t.nodes||[],i=s.map((t=>b(e,t,n,r))),a=new o.o({id:t.name||t.id,children:i});return a}(e,n,t.nodes,r)));return s}function b(e,t,n,s){if(!t._node){const C=(t.children||[]).map((t=>b(e,t,n,s)));t.mesh&&C.push(function(e,t,n){if(!t._mesh){const s=(t.primitives||[]).map(((o,s)=>function(e,t,n,o,s){const i=t.name||`${o.name||o.id}-primitive-${n}`,C=function(e){switch(e){case r.POINTS:return"point-list";case r.LINES:return"line-list";case r.LINE_STRIP:return"line-strip";case r.TRIANGLES:return"triangle-list";case r.TRIANGLE_STRIP:return"triangle-strip";default:throw new Error(String(e))}}(t.mode||4),m=t.indices?t.indices.count:function(){throw new Error("getVertexCount not implemented")}(t.attributes),b=h(i,t,C),p=(0,d.l)(e,t.material,b.attributes,s),g=function(e,t){const{id:n,geometry:r,parsedPPBRMaterial:o,vertexCount:s,modelOptions:i={}}=t;a.R.info(4,"createGLTFModel defines: ",o.defines)();const d={id:n,source:l,vs:u,fs:B,geometry:r,topology:r.topology,vertexCount:s,modules:[c.s],...i,defines:{...o.defines,...i.defines},parameters:{depthWriteEnabled:!0,depthCompare:"less",depthFormat:"depth24plus",cullMode:"back",...o.parameters,...i.parameters}},C=new A.K(e,d),{camera:m,...b}={...o.uniforms,...i.uniforms,...o.bindings,...i.bindings};return C.shaderInputs.setProps({pbrMaterial:b,pbrProjection:{camera:m}}),new f.s({managedResources:[],model:C})}(e,{id:i,geometry:h(i,t,C),parsedPPBRMaterial:p,modelOptions:s.modelOptions,vertexCount:m});return g.bounds=[t.attributes.POSITION.min,t.attributes.POSITION.max],g}(e,o,s,t,n))),i=new o.o({id:t.name||t.id,children:s});t._mesh=i}return t._mesh}(e,t.mesh,s));const m=new o.o({id:t.name||t.id,children:C});if(t.matrix)m.setMatrix(t.matrix);else{if(m.matrix.identity(),t.translation&&m.matrix.translate(t.translation),t.rotation){const e=(new i.k).fromQuaternion(t.rotation);m.matrix.multiplyRight(e)}t.scale&&m.matrix.scale(t.scale)}t._node=m}return n.find((e=>e.id===t.id))._node=t._node,t._node}function h(e,t,n){const r={};for(const[o,s]of Object.entries(t.attributes)){const{components:e,size:t,value:n}=s;r[o]={size:t??e,value:n}}return new s.V({id:e,topology:n,indices:t.indices.value,attributes:r})}const p=new(n(11633).P);function g(e,{input:t,interpolation:n,output:r},o,s){const i=e%t[t.length-1],c=t.findIndex((e=>e>=i)),A=Math.max(0,c-1);if(!Array.isArray(o[s]))switch(s){case"translation":o[s]=[0,0,0];break;case"rotation":o[s]=[0,0,0,1];break;case"scale":o[s]=[1,1,1];break;default:a.R.warn(`Bad animation path ${s}`)()}const f=t[A],l=t[c];switch(n){case"STEP":!function(e,t,n){if(!e[t])throw new Error;for(let r=0;r<n.length;r++)e[t][r]=n[r]}(o,s,r[A]);break;case"LINEAR":if(l>f){const e=(i-f)/(l-f);!function(e,t,n,r,o){if(!e[t])throw new Error;if("rotation"===t){p.slerp({start:n,target:r,ratio:o});for(let n=0;n<p.length;n++)e[t][n]=p[n]}else for(let s=0;s<n.length;s++)e[t][s]=o*r[s]+(1-o)*n[s]}(o,s,r[A],r[c],e)}break;case"CUBICSPLINE":if(l>f){const e=(i-f)/(l-f),t=l-f;!function(e,t,{p0:n,outTangent0:r,inTangent1:o,p1:s,tDiff:i,ratio:a}){if(!e[t])throw new Error;for(let c=0;c<e[t].length;c++){const A=r[c]*i,f=o[c]*i;e[t][c]=(2*Math.pow(a,3)-3*Math.pow(a,2)+1)*n[c]+(Math.pow(a,3)-2*Math.pow(a,2)+a)*A+(-2*Math.pow(a,3)+3*Math.pow(a,2))*s[c]+(Math.pow(a,3)-Math.pow(a,2))*f}}(o,s,{p0:r[3*A+1],outTangent0:r[3*A+2],inTangent1:r[3*c+0],p1:r[3*c+1],tDiff:t,ratio:e})}break;default:a.R.warn(`Interpolation ${n} not supported`)()}}class _{animation;startTime=0;playing=!0;speed=1;constructor(e){this.animation=e.animation,this.animation.name||="unnamed",Object.assign(this,e)}setTime(e){if(!this.playing)return;const t=(e/1e3-this.startTime)*this.speed;this.animation.channels.forEach((({sampler:e,target:n,path:r})=>{g(t,e,n,r),function(e,t){t.matrix.identity(),e.translation&&t.matrix.translate(e.translation);if(e.rotation){const n=R.fromQuaternion(e.rotation);t.matrix.multiplyRight(n)}e.scale&&t.matrix.scale(e.scale)}(n,n._node)}))}}class E{animations;constructor(e){this.animations=e.animations.map(((e,t)=>{const n=e.name||`Animation-${t}`;return new _({animation:{name:n,channels:e.channels}})}))}animate(e){a.R.warn("GLTFAnimator#animate is deprecated. Use GLTFAnimator#setTime instead")(),this.setTime(e)}setTime(e){this.animations.forEach((t=>t.setTime(e)))}getAnimations(){return this.animations}}const R=new i.k;const I={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},S={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};function M(e){if(!e._animation){const{typedArray:t,components:n}=function(e){const t=S[e.componentType],n=I[e.type],r=n*e.count,{buffer:o,byteOffset:s=0}=e.bufferView?.data??{};return{typedArray:new t(o,s+(e.byteOffset||0),r),components:n}}(e);if(1===n)e._animation=Array.from(t);else{const r=[];for(let e=0;e<t.length;e+=n)r.push(Array.from(t.slice(e,e+n)));e._animation=r}}return e._animation}function G(e){if(ArrayBuffer.isView(e)||e instanceof ArrayBuffer||e instanceof ImageBitmap)return e;if(Array.isArray(e))return e.map(G);if(e&&"object"==typeof e){const t={};for(const n in e)t[n]=G(e[n]);return t}return e}function F(e,t,n){const r=m(e,t=G(t),n),o=function(e){return(e.animations||[]).map(((t,n)=>{const r=t.name||`Animation-${n}`,o=t.samplers.map((({input:t,interpolation:n="LINEAR",output:r})=>({input:M(e.accessors[t]),interpolation:n,output:M(e.accessors[r])})));return{name:r,channels:t.channels.map((({sampler:t,target:n})=>({sampler:o[t],target:e.nodes[n.node??0],path:n.path})))}}))}(t);return{scenes:r,animator:new E({animations:o})}}},92638:(e,t,n)=>{n.d(t,{l:()=>c});var r=n(29651);function o(e){return{addressModeU:s(e.wrapS),addressModeV:s(e.wrapT),magFilter:i(e.magFilter),...a(e.minFilter)}}function s(e){switch(e){case 33071:return"clamp-to-edge";case 10497:return"repeat";case 33648:return"mirror-repeat";default:return}}function i(e){switch(e){case 9728:return"nearest";case 9729:return"linear";default:return}}function a(e){switch(e){case 9728:return{minFilter:"nearest"};case 9729:return{minFilter:"linear"};case 9984:return{minFilter:"nearest",mipmapFilter:"nearest"};case 9985:return{minFilter:"linear",mipmapFilter:"nearest"};case 9986:return{minFilter:"nearest",mipmapFilter:"linear"};case 9987:return{minFilter:"linear",mipmapFilter:"linear"};default:return{}}}function c(e,t,n,o){const s={defines:{MANUAL_SRGB:!0,SRGB_FAST_APPROXIMATION:!0},bindings:{},uniforms:{camera:[0,0,0],metallicRoughnessValues:[1,1]},parameters:{},glParameters:{},generatedTextures:[]};s.defines.USE_TEX_LOD=!0;const{imageBasedLightingEnvironment:i}=o;return i&&(s.bindings.pbr_diffuseEnvSampler=i.diffuseEnvSampler.texture,s.bindings.pbr_specularEnvSampler=i.specularEnvSampler.texture,s.bindings.pbr_BrdfLUT=i.brdfLutTexture.texture,s.uniforms.scaleIBLAmbient=[1,1]),o?.pbrDebug&&(s.defines.PBR_DEBUG=!0,s.uniforms.scaleDiffBaseMR=[0,0,0,0],s.uniforms.scaleFGDSpec=[0,0,0,0]),n.NORMAL&&(s.defines.HAS_NORMALS=!0),n.TANGENT&&o?.useTangents&&(s.defines.HAS_TANGENTS=!0),n.TEXCOORD_0&&(s.defines.HAS_UV=!0),o?.imageBasedLightingEnvironment&&(s.defines.USE_IBL=!0),o?.lights&&(s.defines.USE_LIGHTS=!0),t&&function(e,t,n){n.uniforms.unlit=Boolean(t.unlit),t.pbrMetallicRoughness&&function(e,t,n){t.baseColorTexture&&A(e,t.baseColorTexture,"pbr_baseColorSampler","HAS_BASECOLORMAP",n);n.uniforms.baseColorFactor=t.baseColorFactor||[1,1,1,1],t.metallicRoughnessTexture&&A(e,t.metallicRoughnessTexture,"pbr_metallicRoughnessSampler","HAS_METALROUGHNESSMAP",n);const{metallicFactor:r=1,roughnessFactor:o=1}=t;n.uniforms.metallicRoughnessValues=[r,o]}(e,t.pbrMetallicRoughness,n);if(t.normalTexture){A(e,t.normalTexture,"pbr_normalSampler","HAS_NORMALMAP",n);const{scale:r=1}=t.normalTexture;n.uniforms.normalScale=r}if(t.occlusionTexture){A(e,t.occlusionTexture,"pbr_occlusionSampler","HAS_OCCLUSIONMAP",n);const{strength:r=1}=t.occlusionTexture;n.uniforms.occlusionStrength=r}t.emissiveTexture&&(A(e,t.emissiveTexture,"pbr_emissiveSampler","HAS_EMISSIVEMAP",n),n.uniforms.emissiveFactor=t.emissiveFactor||[0,0,0]);switch(t.alphaMode||"MASK"){case"MASK":const{alphaCutoff:e=.5}=t;n.defines.ALPHA_CUTOFF=!0,n.uniforms.alphaCutoff=e;break;case"BLEND":r.R.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")(),n.parameters.blend=!0,n.parameters.blendColorOperation="add",n.parameters.blendColorSrcFactor="src-alpha",n.parameters.blendColorDstFactor="one-minus-src-alpha",n.parameters.blendAlphaOperation="add",n.parameters.blendAlphaSrcFactor="one",n.parameters.blendAlphaDstFactor="one-minus-src-alpha",n.glParameters.blend=!0,n.glParameters.blendEquation=32774,n.glParameters.blendFunc=[770,771,1,771]}}(e,t,s),s}function A(e,t,n,r,s){const i=t.texture.source.image;let a;a=i.compressed?i:{data:i};const c={wrapS:10497,wrapT:10497,...t?.texture?.sampler},A=e.createTexture({id:t.uniformName||t.id,sampler:o(c),...a});s.bindings[n]=A,r&&(s.defines[r]=!0),s.generatedTextures.push(A)}},291:(e,t,n)=>{n.d(t,{s:()=>s});const r="uniform pbrProjectionUniforms {\n  mat4 modelViewProjectionMatrix;\n  mat4 modelMatrix;\n  mat4 normalMatrix;\n  vec3 camera;\n} pbrProjection;\n",o={name:"pbrProjection",vs:r,fs:r,getUniforms:e=>e,uniformTypes:{modelViewProjectionMatrix:"mat4x4<f32>",modelMatrix:"mat4x4<f32>",normalMatrix:"mat4x4<f32>",camera:"vec3<i32>"}},s={props:{},uniforms:{},name:"pbrMaterial",dependencies:[n(47522).x,o],source:"struct PBRFragmentInputs {\n  pbr_vPosition: vec3f,\n  pbr_vUV: vec2f,\n  pbr_vTBN: mat3f,\n  pbr_vNormal: vec3f\n};\n\nvar fragmentInputs: PBRFragmentInputs;\n\nfn pbr_setPositionNormalTangentUV(position: vec4f, normal: vec4f, tangent: vec4f, uv: vec2f)\n{\n  var pos: vec4f = pbrProjection.modelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  let normalW: vec3f = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));\n  let tangentW: vec3f = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));\n  let bitangentW: vec3f = cross(normalW, tangentW) * tangent.w;\n  fragmentInputs,pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else // HAS_TANGENTS != 1\n  fragmentInputs.pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n\nstruct pbrMaterialUniforms {\n  // Material is unlit\n  unlit: uint32,\n\n  // Base color map\n  baseColorMapEnabled: uint32,\n  baseColorFactor: vec4f,\n\n  normalMapEnabled : uint32,\n  normalScale: f32,  // #ifdef HAS_NORMALMAP\n\n  emissiveMapEnabled: uint32,\n  emissiveFactor: vec3f, // #ifdef HAS_EMISSIVEMAP\n\n  metallicRoughnessValues: vec2f,\n  metallicRoughnessMapEnabled: uint32,\n\n  occlusionMapEnabled: i32,\n  occlusionStrength: f32, // #ifdef HAS_OCCLUSIONMAP\n  \n  alphaCutoffEnabled: i32,\n  alphaCutoff: f32, // #ifdef ALPHA_CUTOFF\n  \n  // IBL\n  IBLenabled: i32,\n  scaleIBLAmbient: vec2f, // #ifdef USE_IBL\n  \n  // debugging flags used for shader output of intermediate PBR variables\n  // #ifdef PBR_DEBUG\n  scaleDiffBaseMR: vec4f,\n  scaleFGDSpec: vec4f\n  // #endif\n} \n  \n@binding(2) @group(0) var<uniform> material : pbrMaterialUniforms;\n\n// Samplers\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D pbr_baseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D pbr_normalSampler;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D pbr_emissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D pbr_metallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D pbr_occlusionSampler;\n#endif\n#ifdef USE_IBL\nuniform samplerCube pbr_diffuseEnvSampler;\nuniform samplerCube pbr_specularEnvSampler;\nuniform sampler2D pbr_brdfLUT;\n#endif\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo {\n  NdotL: f32,                  // cos angle between normal and light direction\n  NdotV: f32,                  // cos angle between normal and view direction\n  NdotH: f32,                  // cos angle between normal and half vector\n  LdotH: f32,                  // cos angle between light direction and half vector\n  VdotH: f32,                  // cos angle between view direction and half vector\n  perceptualRoughness: f32,    // roughness value, as authored by the model creator (input to shader)\n  metalness: f32,              // metallic value at the surface\n  reflectance0: vec3f,            // full reflectance color (normal incidence angle)\n  reflectance90: vec3f,           // reflectance color at grazing angle\n  alphaRoughness: f32,         // roughness mapped to a more linear change in the roughness (proposed by [2])\n  diffuseColor: vec3f,            // color contribution from diffuse lighting\n  specularColor: vec3f,           // color contribution from specular lighting\n  n: vec3f,                       // normal at surface point\n  v: vec3f,                       // vector from surface point to camera\n};\n\nconst M_PI = 3.141592653589793;\nconst c_MinRoughness = 0.04;\n\nfn SRGBtoLINEAR(srgbIn: vec4f ) -> vec4f\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  var linOut: vec3f = pow(srgbIn.xyz,vec3(2.2));\n#else // SRGB_FAST_APPROXIMATION\n  var bLess: vec3f = step(vec3(0.04045),srgbIn.xyz);\n  var linOut: vec3f = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif //SRGB_FAST_APPROXIMATION\n  return vec4f(linOut,srgbIn.w);;\n#else //MANUAL_SRGB\n  return srgbIn;\n#endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nfn getNormal() -> vec3f\n{\n  // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n  var pos_dx: vec3f = dFdx(pbr_vPosition);\n  var pos_dy: vec3f = dFdy(pbr_vPosition);\n  var tex_dx: vec3f = dFdx(vec3(pbr_vUV, 0.0));\n  var tex_dy: vec3f = dFdy(vec3(pbr_vUV, 0.0));\n  var t: vec3f = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  var ng: vec3f = normalize(pbr_vNormal);\n#else\n  var ng: vec3f = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  var b: vec3f = normalize(cross(ng, t));\n  var tbn: mat3f = mat3f(t, b, ng);\n#else // HAS_TANGENTS\n  var tbn: mat3f = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));\n#else\n  // The tbn matrix is linearly interpolated, so we need to re-normalize\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nfn getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection) -> vec3f\n{\n  float mipCount = 9.0; // resolution of 512x512\n  float lod = (pbrInfo.perceptualRoughness * mipCount);\n  // retrieve a scale and bias to F0. See [1], Figure 3\n  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,\n    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;\n  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);\n\n  // For presentation, this allows us to disable IBL terms\n  diffuse *= pbrMaterial.scaleIBLAmbient.x;\n  specular *= pbrMaterial.scaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nfn diffuse(pbrInfo: PBRInfo) -> vec3<f32> {\n  return pbrInfo.diffuseColor / PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nfn specularReflection(pbrInfo: PBRInfo) -> vec3<f32> {\n  return pbrInfo.reflectance0 +\n    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *\n    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfn geometricOcclusion(pbrInfo: PBRInfo) -> f32 {\n  let NdotL: f32 = pbrInfo.NdotL;\n  let NdotV: f32 = pbrInfo.NdotV;\n  let r: f32 = pbrInfo.alphaRoughness;\n\n  let attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  let attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across\n// the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface\n// for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes\n// from EPIC Games [1], Equation 3.\nfn microfacetDistribution(pbrInfo: PBRInfo) -> f32 {\n  let roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;\n  let f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;\n  return roughnessSq / (PI * f * f);\n}\n\nfn PBRInfo_setAmbientLight(pbrInfo: ptr<function, PBRInfo>) {\n  (*pbrInfo).NdotL = 1.0;\n  (*pbrInfo).NdotH = 0.0;\n  (*pbrInfo).LdotH = 0.0;\n  (*pbrInfo).VdotH = 1.0;\n}\n\nfn PBRInfo_setDirectionalLight(pbrInfo: ptr<function, PBRInfo>, lightDirection: vec3<f32>) {\n  let n = (*pbrInfo).n;\n  let v = (*pbrInfo).v;\n  let l = normalize(lightDirection);             // Vector from surface point to light\n  let h = normalize(l + v);                      // Half vector between both l and v\n\n  (*pbrInfo).NdotL = clamp(dot(n, l), 0.001, 1.0);\n  (*pbrInfo).NdotH = clamp(dot(n, h), 0.0, 1.0);\n  (*pbrInfo).LdotH = clamp(dot(l, h), 0.0, 1.0);\n  (*pbrInfo).VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nfn PBRInfo_setPointLight(pbrInfo: ptr<function, PBRInfo>, pointLight: PointLight) {\n  let light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInfo, light_direction);\n}\n\nfn calculateFinalColor(pbrInfo: PBRInfo, lightColor: vec3<f32>) -> vec3<f32> {\n  // Calculate the shading terms for the microfacet specular shading model\n  let F = specularReflection(pbrInfo);\n  let G = geometricOcclusion(pbrInfo);\n  let D = microfacetDistribution(pbrInfo);\n\n  // Calculation of analytical lighting contribution\n  let diffuseContrib = (1.0 - F) * diffuse(pbrInfo);\n  let specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nfn pbr_filterColor(colorUnused: vec4<f32>) -> vec4<f32> {\n  // The albedo may be defined from a base texture or a flat color\n  var baseColor: vec4<f32>;\n  #ifdef HAS_BASECOLORMAP\n  baseColor = SRGBtoLINEAR(textureSample(pbr_baseColorSampler, pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;\n  #else\n  baseColor = pbrMaterial.baseColorFactor;\n  #endif\n\n  #ifdef ALPHA_CUTOFF\n  if (baseColor.a < pbrMaterial.alphaCutoff) {\n    discard;\n  }\n  #endif\n\n  var color = vec3<f32>(0.0, 0.0, 0.0);\n\n  if (pbrMaterial.unlit) {\n    color = baseColor.rgb;\n  } else {\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    var perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;\n    var metallic = pbrMaterial.metallicRoughnessValues.x;\n    #ifdef HAS_METALROUGHNESSMAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    let mrSample = textureSample(pbr_metallicRoughnessSampler, pbr_metallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n    #endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    let alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    let f0 = vec3<f32>(0.04);\n    var diffuseColor = baseColor.rgb * (vec3<f32>(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    let specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    let reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing\n    // reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%),\n    // incrementally reduce grazing reflectance to 0%.\n    let reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    let specularEnvironmentR0 = specularColor;\n    let specularEnvironmentR90 = vec3<f32>(1.0, 1.0, 1.0) * reflectance90;\n\n    let n = getNormal();                          // normal at surface point\n    let v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera\n\n    let NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    let reflection = -normalize(reflect(v, n));\n\n    var pbrInfo = PBRInfo(\n      0.0, // NdotL\n      NdotV,\n      0.0, // NdotH\n      0.0, // LdotH\n      0.0, // VdotH\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n    #ifdef USE_LIGHTS\n    // Apply ambient light\n    PBRInfo_setAmbientLight(&pbrInfo);\n    color += calculateFinalColor(pbrInfo, lighting.ambientColor);\n\n    // Apply directional light\n    for (var i = 0; i < lighting.directionalLightCount; i++) {\n      if (i < lighting.directionalLightCount) {\n        PBRInfo_setDirectionalLight(&pbrInfo, lighting_getDirectionalLight(i).direction);\n        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);\n      }\n    }\n\n    // Apply point light\n    for (var i = 0; i < lighting.pointLightCount; i++) {\n      if (i < lighting.pointLightCount) {\n        PBRInfo_setPointLight(&pbrInfo, lighting_getPointLight(i));\n        let attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));\n        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);\n      }\n    }\n    #endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n    #ifdef USE_IBL\n    if (pbrMaterial.IBLenabled) {\n      color += getIBLContribution(pbrInfo, n, reflection);\n    }\n    #endif\n\n    // Apply optional PBR terms for additional (optional) shading\n    #ifdef HAS_OCCLUSIONMAP\n    if (pbrMaterial.occlusionMapEnabled) {\n      let ao = textureSample(pbr_occlusionSampler, pbr_occlusionSampler, pbr_vUV).r;\n      color = mix(color, color * ao, pbrMaterial.occlusionStrength);\n    }\n    #endif\n\n    #ifdef HAS_EMISSIVEMAP\n    if (pbrMaterial.emissiveMapEnabled) {\n      let emissive = SRGBtoLINEAR(textureSample(pbr_emissiveSampler, pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;\n      color += emissive;\n    }\n    #endif\n\n    // This section uses mix to override final color for reference app visualization\n    // of various parameters in the lighting equation.\n    #ifdef PBR_DEBUG\n    // TODO: Figure out how to debug multiple lights\n\n    // color = mix(color, F, pbr_scaleFGDSpec.x);\n    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);\n    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);\n    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);\n\n    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);\n    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);\n    color = mix(color, vec3<f32>(metallic), pbrMaterial.scaleDiffBaseMR.z);\n    color = mix(color, vec3<f32>(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);\n    #endif\n  }\n\n  return vec4<f32>(pow(color, vec3<f32>(1.0 / 2.2)), baseColor.a);\n}\n",vs:"out vec3 pbr_vPosition;\nout vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nout mat3 pbr_vTBN;\n# else\nout vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = pbrProjection.modelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else // HAS_TANGENTS != 1\n  pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n",fs:"precision highp float;\n\nuniform pbrMaterialUniforms {\n  // Material is unlit\n  bool unlit;\n\n  // Base color map\n  bool baseColorMapEnabled;\n  vec4 baseColorFactor;\n\n  bool normalMapEnabled;  \n  float normalScale; // #ifdef HAS_NORMALMAP\n\n  bool emissiveMapEnabled;\n  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP\n\n  vec2 metallicRoughnessValues;\n  bool metallicRoughnessMapEnabled;\n\n  bool occlusionMapEnabled;\n  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP\n  \n  bool alphaCutoffEnabled;\n  float alphaCutoff; // #ifdef ALPHA_CUTOFF\n  \n  // IBL\n  bool IBLenabled;\n  vec2 scaleIBLAmbient; // #ifdef USE_IBL\n  \n  // debugging flags used for shader output of intermediate PBR variables\n  // #ifdef PBR_DEBUG\n  vec4 scaleDiffBaseMR;\n  vec4 scaleFGDSpec;\n  // #endif\n} pbrMaterial;\n\n// Samplers\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D pbr_baseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D pbr_normalSampler;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D pbr_emissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D pbr_metallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D pbr_occlusionSampler;\n#endif\n#ifdef USE_IBL\nuniform samplerCube pbr_diffuseEnvSampler;\nuniform samplerCube pbr_specularEnvSampler;\nuniform sampler2D pbr_brdfLUT;\n#endif\n\n// Inputs from vertex shader\n\nin vec3 pbr_vPosition;\nin vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nin mat3 pbr_vTBN;\n#else\nin vec3 pbr_vNormal;\n#endif\n#endif\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo {\n  float NdotL;                  // cos angle between normal and light direction\n  float NdotV;                  // cos angle between normal and view direction\n  float NdotH;                  // cos angle between normal and half vector\n  float LdotH;                  // cos angle between light direction and half vector\n  float VdotH;                  // cos angle between view direction and half vector\n  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n  float metalness;              // metallic value at the surface\n  vec3 reflectance0;            // full reflectance color (normal incidence angle)\n  vec3 reflectance90;           // reflectance color at grazing angle\n  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n  vec3 diffuseColor;            // color contribution from diffuse lighting\n  vec3 specularColor;           // color contribution from specular lighting\n  vec3 n;                       // normal at surface point\n  vec3 v;                       // vector from surface point to camera\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else // SRGB_FAST_APPROXIMATION\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif //SRGB_FAST_APPROXIMATION\n  return vec4(linOut,srgbIn.w);;\n#else //MANUAL_SRGB\n  return srgbIn;\n#endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n  // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));\n#else\n  // The tbn matrix is linearly interpolated, so we need to re-normalize\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0; // resolution of 512x512\n  float lod = (pbrInfo.perceptualRoughness * mipCount);\n  // retrieve a scale and bias to F0. See [1], Figure 3\n  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,\n    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;\n  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);\n\n  // For presentation, this allows us to disable IBL terms\n  diffuse *= pbrMaterial.scaleIBLAmbient.x;\n  specular *= pbrMaterial.scaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nvec3 diffuse(PBRInfo pbrInfo)\n{\n  return pbrInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(PBRInfo pbrInfo)\n{\n  return pbrInfo.reflectance0 +\n    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *\n    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfloat geometricOcclusion(PBRInfo pbrInfo)\n{\n  float NdotL = pbrInfo.NdotL;\n  float NdotV = pbrInfo.NdotV;\n  float r = pbrInfo.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across\n// the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface\n// for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes\n// from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(PBRInfo pbrInfo)\n{\n  float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;\n  float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {\n  pbrInfo.NdotL = 1.0;\n  pbrInfo.NdotH = 0.0;\n  pbrInfo.LdotH = 0.0;\n  pbrInfo.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {\n  vec3 n = pbrInfo.n;\n  vec3 v = pbrInfo.v;\n  vec3 l = normalize(lightDirection);             // Vector from surface point to light\n  vec3 h = normalize(l+v);                        // Half vector between both l and v\n\n  pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInfo, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {\n  // Calculate the shading terms for the microfacet specular shading model\n  vec3 F = specularReflection(pbrInfo);\n  float G = geometricOcclusion(pbrInfo);\n  float D = microfacetDistribution(pbrInfo);\n\n  // Calculation of analytical lighting contribution\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);\n  vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n  // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture(pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;\n#else\n  vec4 baseColor = pbrMaterial.baseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < pbrMaterial.alphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbrMaterial.unlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;\n    float metallic = pbrMaterial.metallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture(pbr_metallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing\n    // reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%),\n    // incrementally reduce grazing reflecance to 0%.\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();                          // normal at surface point\n    vec3 v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInfo = PBRInfo(\n      0.0, // NdotL\n      NdotV,\n      0.0, // NdotH\n      0.0, // LdotH\n      0.0, // VdotH\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n\n#ifdef USE_LIGHTS\n    // Apply ambient light\n    PBRInfo_setAmbientLight(pbrInfo);\n    color += calculateFinalColor(pbrInfo, lighting.ambientColor);\n\n    // Apply directional light\n    for(int i = 0; i < lighting.directionalLightCount; i++) {\n      if (i < lighting.directionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInfo, lighting_getDirectionalLight(i).direction);\n        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);\n      }\n    }\n\n    // Apply point light\n    for(int i = 0; i < lighting.pointLightCount; i++) {\n      if (i < lighting.pointLightCount) {\n        PBRInfo_setPointLight(pbrInfo, lighting_getPointLight(i));\n        float attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));\n        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);\n      }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    if (pbrMaterial.IBLenabled) {\n      color += getIBLContribution(pbrInfo, n, reflection);\n    }\n#endif\n\n // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSIONMAP\n    if (pbrMaterial.occlusionMapEnabled) {\n      float ao = texture(pbr_occlusionSampler, pbr_vUV).r;\n      color = mix(color, color * ao, pbrMaterial.occlusionStrength);\n    }\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    if (pbrMaterial.emissiveMapEnabled) {\n      vec3 emissive = SRGBtoLINEAR(texture(pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;\n      color += emissive;\n    }\n#endif\n\n    // This section uses mix to override final color for reference app visualization\n    // of various parameters in the lighting equation.\n#ifdef PBR_DEBUG\n    // TODO: Figure out how to debug multiple lights\n\n    // color = mix(color, F, pbr_scaleFGDSpec.x);\n    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);\n    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);\n    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);\n\n    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);\n    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), pbrMaterial.scaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n",defines:{LIGHTING_FRAGMENT:!0,HAS_NORMALMAP:!1,HAS_EMISSIVEMAP:!1,HAS_OCCLUSIONMAP:!1,HAS_BASECOLORMAP:!1,HAS_METALROUGHNESSMAP:!1,ALPHA_CUTOFF:!1,USE_IBL:!1,PBR_DEBUG:!1},getUniforms:e=>e,uniformTypes:{unlit:"i32",baseColorMapEnabled:"i32",baseColorFactor:"vec4<f32>",normalMapEnabled:"i32",normalScale:"f32",emissiveMapEnabled:"i32",emissiveFactor:"vec3<f32>",metallicRoughnessValues:"vec2<f32>",metallicRoughnessMapEnabled:"i32",occlusionMapEnabled:"i32",occlusionStrength:"f32",alphaCutoffEnabled:"i32",alphaCutoff:"f32",IBLenabled:"i32",scaleIBLAmbient:"vec2<f32>",scaleDiffBaseMR:"vec4<f32>",scaleFGDSpec:"vec4<f32>"}}}}]);