"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[950],{55632:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"api-reference/aggregation-layers/aggregator","title":"Aggregator Interface","description":"The Aggregator interface describes a type of class that performs aggregation.","source":"@site/../docs/api-reference/aggregation-layers/aggregator.md","sourceDirName":"api-reference/aggregation-layers","slug":"/api-reference/aggregation-layers/aggregator","permalink":"/docs/api-reference/aggregation-layers/aggregator","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/deck.gl/tree/master/website/../docs/api-reference/aggregation-layers/aggregator.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"AggregationLayer (Experimental)","permalink":"/docs/api-reference/aggregation-layers/aggregation-layer"},"next":{"title":"CPUAggregator","permalink":"/docs/api-reference/aggregation-layers/cpu-aggregator"}}');var i=r(74848),t=r(28453);const l={},a="Aggregator Interface",d={},c=[{value:"Terminology",id:"terminology",level:2},{value:"Example",id:"example",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>setProps</code>",id:"setprops",level:4},{value:"<code>setNeedsUpdate</code>",id:"setneedsupdate",level:4},{value:"<code>update</code>",id:"update",level:4},{value:"<code>preDraw</code>",id:"predraw",level:4},{value:"<code>getBin</code>",id:"getbin",level:4},{value:"<code>getBins</code>",id:"getbins",level:4},{value:"<code>getResult</code>",id:"getresult",level:4},{value:"<code>getResultDomain</code>",id:"getresultdomain",level:4},{value:"<code>destroy</code>",id:"destroy",level:4},{value:"Members",id:"members",level:2},{value:"<code>binCount</code> (number)",id:"bincount",level:4},{value:"Source",id:"source",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"aggregator-interface",children:"Aggregator Interface"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Aggregator"})," interface describes a type of class that performs aggregation."]}),"\n",(0,i.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Aggregation"})," is a 2-step process:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sort"}),": Group a collection of ",(0,i.jsx)(n.em,{children:"data points"})," by some property into ",(0,i.jsx)(n.em,{children:"bins"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Aggregate"}),": for each ",(0,i.jsx)(n.em,{children:"bin"}),", calculate a numeric output (",(0,i.jsx)(n.em,{children:"result"}),") from some metrics (",(0,i.jsx)(n.em,{children:"values"}),") from all its members. Multiple results can be obtained independently (",(0,i.jsx)(n.em,{children:"channels"}),")."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["An implementation of the ",(0,i.jsx)(n.em,{children:"Aggregator"})," interface takes the following inputs:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The number of data points"}),"\n",(0,i.jsxs)(n.li,{children:["The group that each data point belongs to, by mapping each data point to a ",(0,i.jsx)(n.em,{children:"binId"})," (array of integers)"]}),"\n",(0,i.jsxs)(n.li,{children:["The values to aggregate, by mapping each data point in each channel to one ",(0,i.jsx)(n.em,{children:"value"})," (number)"]}),"\n",(0,i.jsxs)(n.li,{children:["The method (",(0,i.jsx)(n.em,{children:"operation"}),") to reduce a list of values to one number, such as SUM"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"And yields the following outputs:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A list of ",(0,i.jsx)(n.em,{children:"binIds"})," that data points get sorted into"]}),"\n",(0,i.jsxs)(n.li,{children:["The aggregated values (",(0,i.jsx)(n.em,{children:"result"}),") as a list of numbers, comprised of one number per bin per channel"]}),"\n",(0,i.jsxs)(n.li,{children:["The [min, max] among all aggregated values (",(0,i.jsx)(n.em,{children:"domain"}),") for each channel"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsxs)(n.p,{children:["Consider the task of making a ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Histogram",children:"histogram"})," that shows the result of a survey by age distribution."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.em,{children:"data points"})," are the list of participants, and we know the age of each person."]}),"\n",(0,i.jsxs)(n.li,{children:["Suppose we want to group them by 5-year intervals. A 21-year-old participant is assigned to the bin of age 20-25, with ",(0,i.jsx)(n.em,{children:"binId"})," ",(0,i.jsx)(n.code,{children:"[20]"}),". A 35-year-old participant is assigned to the bin of age 35-40, with ",(0,i.jsx)(n.em,{children:"binId"})," ",(0,i.jsx)(n.code,{children:"[35]"}),", and so on."]}),"\n",(0,i.jsxs)(n.li,{children:["For each bin (i.e. age group), we calculate 2 ",(0,i.jsx)(n.em,{children:"values"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The first ",(0,i.jsx)(n.em,{children:"channel"}),' is "number of participants". Each participant in this group yields a ',(0,i.jsx)(n.em,{children:"value"})," of 1, and the result equals all values added together (",(0,i.jsx)(n.em,{children:"operation"}),": SUM)."]}),"\n",(0,i.jsxs)(n.li,{children:["The second ",(0,i.jsx)(n.em,{children:"channel"}),' is "average score". Each participant in this group yields a ',(0,i.jsx)(n.em,{children:"value"})," that is their test score, and the result equals the sum of all scores divided by the number of participants (",(0,i.jsx)(n.em,{children:"operation"}),": MEAN)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["As the outcome of the aggregation, we have:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Bins: ",(0,i.jsx)(n.code,{children:"[15, 20, 25, 30, 35, 40]"})]}),"\n",(0,i.jsxs)(n.li,{children:["Channel 0 result: ",(0,i.jsx)(n.code,{children:"[1, 5, 12, 10, 8, 3]"})]}),"\n",(0,i.jsxs)(n.li,{children:["Channel 0 domain: ",(0,i.jsx)(n.code,{children:"[1, 12]"})]}),"\n",(0,i.jsxs)(n.li,{children:["Channel 1 result: ",(0,i.jsx)(n.code,{children:"[6, 8.2, 8.5, 7.9, 7.75, 8]"})]}),"\n",(0,i.jsxs)(n.li,{children:["Channel 1 domain: ",(0,i.jsx)(n.code,{children:"[6, 8.5]"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsxs)(n.p,{children:["An implementation of ",(0,i.jsx)(n.code,{children:"Aggregator"})," should expose the following methods:"]}),"\n",(0,i.jsx)(n.h4,{id:"setprops",children:(0,i.jsx)(n.code,{children:"setProps"})}),"\n",(0,i.jsx)(n.p,{children:"Set runtime properties of the aggregation."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"aggregator.setProps({\n  pointCount: 10000,\n  attributes: {...},\n  operations: ['SUM', 'MEAN'],\n  binOptions: {groupSize: 5}\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"Arguments:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pointCount"})," (number) - number of data points."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"attributes"})," (",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/attribute",children:"Attribute"}),"[]) - the input data."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"operations"})," (string[]) - How to aggregate the values inside a bin, defined per channel."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"binOptions"})," (object) - arbitrary settings that affect bin sorting."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"onUpdate"})," (Function) - callback when a channel has been recalculated. Receives the following arguments:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"channel"})," (number) - the channel that just updated"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"setneedsupdate",children:(0,i.jsx)(n.code,{children:"setNeedsUpdate"})}),"\n",(0,i.jsx)(n.p,{children:"Flags a channel to need update. This could be a result of change in the input data or bin options."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"aggregator.setNeedsUpdate(0);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Arguments:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"channel"})," (number, optional) - mark the given channel as dirty. If not provided, all channels will be updated."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"update",children:(0,i.jsx)(n.code,{children:"update"})}),"\n",(0,i.jsx)(n.p,{children:"Called after all props are set and before results are accessed. The aggregator should allocate resources and redo aggregations if needed at this stage."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"aggregator.update();\n"})}),"\n",(0,i.jsx)(n.h4,{id:"predraw",children:(0,i.jsx)(n.code,{children:"preDraw"})}),"\n",(0,i.jsx)(n.p,{children:"Called before the result buffers are drawn to screen. Certain types of aggregations are dependent on render time context and this is alternative opportunity to update just-in-time."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"aggregator.preDraw();\n"})}),"\n",(0,i.jsx)(n.h4,{id:"getbin",children:(0,i.jsx)(n.code,{children:"getBin"})}),"\n",(0,i.jsx)(n.p,{children:"Get the information of a given bin."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const bin = aggregator.getBin(100);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Arguments:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"index"})," (number) - index of the bin to locate it in ",(0,i.jsx)(n.code,{children:"getBins()"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Returns:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"id"})," (number[]) - Unique bin ID."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"value"})," (number[]) - Aggregated values by channel."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"count"})," (number) - Number of data points in this bin."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pointIndices"})," (number[] | undefined) - Indices of data points in this bin if available. This field may not be populated when using GPU-based implementations."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"getbins",children:(0,i.jsx)(n.code,{children:"getBins"})}),"\n",(0,i.jsx)(n.p,{children:"Get an accessor to all bin IDs."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const binIdsAttribute = aggregator.getBins();\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/layer#dataattributes",children:"binary attribute"})," of the output bin IDs, or"]}),"\n",(0,i.jsxs)(n.li,{children:["null, if ",(0,i.jsx)(n.code,{children:"update"})," has never been called"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"getresult",children:(0,i.jsx)(n.code,{children:"getResult"})}),"\n",(0,i.jsx)(n.p,{children:"Get an accessor to the aggregated values of a given channel."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const resultAttribute = aggregator.getResult(0);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Arguments:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"channel"})," (number) - the channel to retrieve results from"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Returns:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/layer#dataattributes",children:"binary attribute"})," of the output values of the given channel, or"]}),"\n",(0,i.jsxs)(n.li,{children:["null, if ",(0,i.jsx)(n.code,{children:"update"})," has never been called"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"getresultdomain",children:(0,i.jsx)(n.code,{children:"getResultDomain"})}),"\n",(0,i.jsx)(n.p,{children:"Get the [min, max] of aggregated values of a given channel."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const [min, max] = aggregator.getResultDomain(0);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Arguments:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"channel"})," (number) - the channel to retrieve results from"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Returns the domain ([number, number]) of the aggregated values of the given channel."}),"\n",(0,i.jsx)(n.h4,{id:"destroy",children:(0,i.jsx)(n.code,{children:"destroy"})}),"\n",(0,i.jsx)(n.p,{children:"Dispose all allocated resources."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"aggregator.destroy();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"members",children:"Members"}),"\n",(0,i.jsxs)(n.p,{children:["An implementation of ",(0,i.jsx)(n.code,{children:"Aggregator"})," should expose the following members:"]}),"\n",(0,i.jsxs)(n.h4,{id:"bincount",children:[(0,i.jsx)(n.code,{children:"binCount"})," (number)"]}),"\n",(0,i.jsx)(n.p,{children:"The number of bins in the aggregated result."}),"\n",(0,i.jsx)(n.h2,{id:"source",children:"Source"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/visgl/deck.gl/tree/9.2-release/modules/aggregation-layers/src/common/aggregator/aggregator.ts",children:"modules/aggregation-layers/src/common/aggregator/aggregator.ts"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var s=r(96540);const i={},t=s.createContext(i);function l(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);