"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5835],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(a),m=r,h=d["".concat(l,".").concat(m)]||d[m]||g[m]||o;return a?n.createElement(h,i(i({ref:t},c),{},{components:a})):n.createElement(h,i({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},23814:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(87462),r=(a(67294),a(3905));const o={},i="Composite Layers",s={unversionedId:"developer-guide/custom-layers/composite-layers",id:"developer-guide/custom-layers/composite-layers",title:"Composite Layers",description:'A composite layer is a special kind of layer that creates other layers. It enables the creation of new layers by careful composition of existing layers (a primary example being the GeoJsonLayer). In addition, it is often convenient to change the interface and behavior of an existing layer using a composite "adaptor" layer instead of modifying the layer itself (the sample S2Layer is a simple adaptor on top of the PolygonLayer).',source:"@site/../docs/developer-guide/custom-layers/composite-layers.md",sourceDirName:"developer-guide/custom-layers",slug:"/developer-guide/custom-layers/composite-layers",permalink:"/docs/developer-guide/custom-layers/composite-layers",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/custom-layers/composite-layers.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Picking",permalink:"/docs/developer-guide/custom-layers/picking"},next:{title:"Subclassed Layers",permalink:"/docs/developer-guide/custom-layers/subclassed-layers"}},l={},p=[{value:"Use Cases",id:"use-cases",level:2},{value:"Adaptor Layers",id:"adaptor-layers",level:3},{value:"Collection Layers",id:"collection-layers",level:3},{value:"Implementing A Composite Layer",id:"implementing-a-composite-layer",level:2},{value:"Defining Composite Layer Properties",id:"defining-composite-layer-properties",level:3},{value:"Rendering Sublayers",id:"rendering-sublayers",level:3},{value:"Mapping Properties",id:"mapping-properties",level:3},{value:"Forwarding Properties",id:"forwarding-properties",level:3},{value:"Picking",id:"picking",level:3},{value:"Transforming Data",id:"transforming-data",level:3}],c={toc:p},d="wrapper";function g(e){let{components:t,...a}=e;return(0,r.kt)(d,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"composite-layers"},"Composite Layers"),(0,r.kt)("p",null,"A composite layer is a special kind of layer that creates other layers. It enables the creation of new layers by careful composition of existing layers (a primary example being the ",(0,r.kt)("inlineCode",{parentName:"p"},"GeoJsonLayer"),'). In addition, it is often convenient to change the interface and behavior of an existing layer using a composite "adaptor" layer instead of modifying the layer itself (the sample ',(0,r.kt)("inlineCode",{parentName:"p"},"S2Layer")," is a simple adaptor on top of the ",(0,r.kt)("inlineCode",{parentName:"p"},"PolygonLayer"),")."),(0,r.kt)("h2",{id:"use-cases"},"Use Cases"),(0,r.kt)("h3",{id:"adaptor-layers"},"Adaptor Layers"),(0,r.kt)("p",null,"Sometimes an existing layer renders the right thing, but it would be desirable that it accepts another data format, had another interface (different accessors), or performed aggregation on its data."),(0,r.kt)("p",null,"Examples could be:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"LASPointCloudLayer")," that accepts ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," as an URL pointing to a ",(0,r.kt)("a",{parentName:"li",href:"https://www.asprs.org/committee-general/laser-las-file-format-exchange-activities.html"},"LAS"),"\nfile, and convert it to the format that ",(0,r.kt)("inlineCode",{parentName:"li"},"PointCloudLayer")," consumes."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"TopoJSONLayer")," that is like the ",(0,r.kt)("inlineCode",{parentName:"li"},"GeoJsonLayer"),", but accepts ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/topojson/topojson"},"TopoJSON")," provided to the ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," prop."),(0,r.kt)("li",{parentName:"ul"},"Adding aggregation to an existing layer. By default, deck.gl layers render one graphical element for each element in the ",(0,r.kt)("inlineCode",{parentName:"li"},"data"),' prop. But in some cases, e.g. heatmaps, the data needs to be aggregated (or "binned") into cells before rendering. An adaptor in the form of a composite layer is one way to add this functionality.')),(0,r.kt)("p",null,"The deck.gl layers ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/layers/text-layer"},"TextLayer"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/aggregation-layers/hexagon-layer"},"HexagonLayer"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/aggregation-layers/cpu-grid-layer"},"CPUGridLayer"),' and few others are written as composite "adapter" layers.'),(0,r.kt)("h3",{id:"collection-layers"},"Collection Layers"),(0,r.kt)("p",null,"Often a more complex visualization is composited from a number of layers that use a common set of props. For example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"NodeLayer")," that renders a text string inside a circle at each anchor position, by combining the ",(0,r.kt)("inlineCode",{parentName:"li"},"ScatterplotLayer")," and the ",(0,r.kt)("inlineCode",{parentName:"li"},"TextLayer"),"."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"MapLayer")," that takes a custom map data format, breaks it down to sets of geometries by type, and render them with the ",(0,r.kt)("inlineCode",{parentName:"li"},"PathLayer"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"SolidPolygonLayer"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"TextLayer")," respectively.")),(0,r.kt)("p",null,"Creating a collection layer have the following advantages:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Collect the complex code that handles a specific data format or visual configuration into one class. This helps to create a cleaner, more abstract interface for the users of this layer, and control the complexity of the component that renders the ",(0,r.kt)("inlineCode",{parentName:"li"},"Deck")," instance."),(0,r.kt)("li",{parentName:"ul"},"Improve memory usage by sharing the same objects/buffers cross layers. Instead of each sublayer loading and storing their own copy of the raw data, the composite layer will manage the data source and pass it down to several layers.")),(0,r.kt)("p",null,"The deck.gl layers ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/layers/geojson-layer"},"GeoJsonLayer")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/layers/polygon-layer"},"PolygonLayer"),' are written as composite "collection" layers.'),(0,r.kt)("h2",{id:"implementing-a-composite-layer"},"Implementing A Composite Layer"),(0,r.kt)("p",null,"Consider the following example: we need a layer that is like the ",(0,r.kt)("inlineCode",{parentName:"p"},"IconLayer"),", but renders a text label alongside each icon."),(0,r.kt)("p",null,"A composite layer can be created by extending the ",(0,r.kt)("inlineCode",{parentName:"p"},"CompositeLayer")," class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {CompositeLayer, IconLayer, TextLayer} from 'deck.gl';\n\nclass LabeledIconLayer extends CompositeLayer {\n  // TODO\n}\nLabeledIconLayer.layerName = 'LabeledIconLayer';\n")),(0,r.kt)("h3",{id:"defining-composite-layer-properties"},"Defining Composite Layer Properties"),(0,r.kt)("p",null,"We will need to define the layer-specific properties of the new layer. In this example, the new layer's interface is a combination of that of the ",(0,r.kt)("inlineCode",{parentName:"p"},"IconLayer")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"TextLayer"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"LabeledIconLayer.defaultProps = {\n  // Shared accessors\n  getPosition: {type: 'accessor', value: x => x.position},\n  // Icon properties\n  iconAtlas: null,\n  iconMapping: {type: 'object', value: {}, async: true},\n  // Icon accessors\n  getIcon: {type: 'accessor', value: x => x.icon},\n  getIconSize: {type: 'accessor', value: 20},\n  getIconColor: {type: 'accessor', value: [0, 0, 0, 255]},\n  // Text properties\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontWeight: DEFAULT_FONT_WEIGHT,\n  // Text accessors\n  getText: {type: 'accessor', value: x => x.text},\n  getTextSize: {type: 'accessor', value: 12}\n  getTextColor: {type: 'accessor', value: [0, 0, 0, 255]}\n}\n")),(0,r.kt)("h3",{id:"rendering-sublayers"},"Rendering Sublayers"),(0,r.kt)("p",null,"A composite layer should implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"renderLayers()"),' method and return an array of layers ("sublayers").'),(0,r.kt)("p",null,"In this example, the idea is to draw an ",(0,r.kt)("inlineCode",{parentName:"p"},"IconLayer")," and a ",(0,r.kt)("inlineCode",{parentName:"p"},"TextLayer"),", which share the same source data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class LabeledIconLayer extends CompositeLayer {\n  renderLayers() {\n    return [\n      // the icons\n      new IconLayer({\n        data: this.props.data,\n        // TODO\n      }),\n      // the labels\n      new TextLayer({\n        data: this.props.data,\n        // TODO\n      })\n    ];\n  }\n}\n")),(0,r.kt)("h3",{id:"mapping-properties"},"Mapping Properties"),(0,r.kt)("p",null,"Because the composite layer doesn't draw directly to the canvas, it controls the rendering result by setting props of its sublayers."),(0,r.kt)("p",null,"Since the sublayers do not understand our custom layer's prop names, we will need to map the props of the ",(0,r.kt)("inlineCode",{parentName:"p"},"LabeledIconLayer")," to the appropriate props of each sublayer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class LabeledIconLayer extends CompositeLayer {\n  renderLayers() {\n    return [\n      // the icons\n      new IconLayer({\n        id: `${this.props.id}-icon`,\n        data: this.props.data,\n\n        iconAtlas: this.props.iconAtlas,\n        iconMapping: this.props.iconMapping,\n\n        getPosition: this.props.getPosition,\n        getIcon: this.props.getIcon,\n        getSize: this.props.getIconSize,\n        getColor: this.props.getIconColor\n      }),\n      // the labels\n      new TextLayer({\n        id: `${this.props.id}-label`,\n        data: this.props.data,\n\n        fontFamily: this.props.fontFamily,\n        fontWeight: this.props.fontWeight,\n\n        getPosition: this.props.getPosition,\n        getText: this.props.getText,\n        getSize: this.props.getTextSize\n        getColor: this.props.getTextColor\n      })\n    ];\n  }\n}\n")),(0,r.kt)("p",null,"Something that needs special attention is that all layer ids must be unique, no matter whether they are nested inside other layers. This means the sublayer ids must be generated dynamically based on the id of their parent, otherwise when there are multiple instances of ",(0,r.kt)("inlineCode",{parentName:"p"},"LabeledIconLayer"),"s their sublayer ids will collide."),(0,r.kt)("p",null,"Finally, to make ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer#updatetriggers"},"updateTriggers")," work when accessors need to be recalculated, we need to remap the user's ",(0,r.kt)("inlineCode",{parentName:"p"},"updateTriggers")," from the parent layer's prop names to the sublayers' prop names."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class LabeledIconLayer extends CompositeLayer {\n  renderLayers() {\n    return [\n      // the icons\n      new IconLayer({\n        ...\n        updateTriggers: {\n          getPosition: this.props.updateTriggers.getPosition,\n          getIcon: this.props.updateTriggers.getIcon,\n          getSize: this.props.updateTriggers.getIconSize,\n          getColor: this.props.updateTriggers.getIconColor\n        }\n      }),\n      // the labels\n      new TextLayer({\n        ...\n        updateTriggers: {\n          getPosition: this.props.updateTriggers.getPosition,\n          getText: this.props.updateTriggers.getText,\n          getSize: this.props.updateTriggers.getTextSize,\n          getColor: this.props.updateTriggers.getTextColor\n        }\n      })\n    ];\n  }\n}\n")),(0,r.kt)("h3",{id:"forwarding-properties"},"Forwarding Properties"),(0,r.kt)("p",null,"There are a number of base ",(0,r.kt)("inlineCode",{parentName:"p"},"Layer")," class props that are usually expected to propagate down to all sublayers, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"pickable"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"visible"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"coordinateSystem")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"opacity"),". It is desirable to just forward many of these props directly to the sublayers."),(0,r.kt)("p",null,"There is a method ",(0,r.kt)("inlineCode",{parentName:"p"},"compositeLayer.getSubLayerProps")," that handles a lot of these common compliance chore that were mentioned above. When calling it with a list of prop values that we care about, the list gets wrapped/populated with additional props that will help the sublayers align with deck.gl norms."),(0,r.kt)("p",null,"The complete code looks like follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class LabeledIconLayer extends CompositeLayer {\n  renderLayers() {\n    return [\n      // the icons\n      new IconLayer(this.getSubLayerProps({\n        // `getSubLayerProps` will concat the parent layer id with this id\n        id: 'icon',\n        data: this.props.data,\n\n        iconAtlas: this.props.iconAtlas,\n        iconMapping: this.props.iconMapping,\n\n        getPosition: this.props.getPosition,\n        getIcon: this.props.getIcon,\n        getSize: this.props.getIconSize,\n        getColor: this.props.getIconColor,\n\n        updateTriggers: {\n          getPosition: this.props.updateTriggers.getPosition,\n          getIcon: this.props.updateTriggers.getIcon,\n          getSize: this.props.updateTriggers.getIconSize,\n          getColor: this.props.updateTriggers.getIconColor\n        }\n      })),\n      // the labels\n      new TextLayer(this.getSubLayerProps({\n        // `getSubLayerProps` will concat the parent layer id with this id\n        id: 'id',\n        data: this.props.data,\n\n        fontFamily: this.props.fontFamily,\n        fontWeight: this.props.fontWeight,\n\n        getPosition: this.props.getPosition,\n        getText: this.props.getText,\n        getSize: this.props.getTextSize\n        getColor: this.props.getTextColor,\n\n        updateTriggers: {\n          getPosition: this.props.updateTriggers.getPosition,\n          getText: this.props.updateTriggers.getText,\n          getSize: this.props.updateTriggers.getTextSize,\n          getColor: this.props.updateTriggers.getTextColor\n        }\n      }))\n    ];\n  }\n}\n")),(0,r.kt)("h3",{id:"picking"},"Picking"),(0,r.kt)("p",null,"By default, the composite layer passes the picking info from its sublayers as-is to the callbacks. However, when we implement an adaptor layer that performs data conversion or aggregation, the data that the sublayer sees may not be the same data that the user passed in."),(0,r.kt)("p",null,"In this case, The composite layer may intercept the event info and modify it by implementing the ",(0,r.kt)("inlineCode",{parentName:"p"},"getPickingInfo()")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class AwesomeCompositeLayer extends CompositeLayer {\n\n  ...\n\n  getPickingInfo({info, sourceLayer}) {\n    // override info.object\n    return info;\n  }\n\n}\n")),(0,r.kt)("p",null,"For more details, read about ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/custom-layers/picking"},"how picking works"),"."),(0,r.kt)("h3",{id:"transforming-data"},"Transforming Data"),(0,r.kt)("p",null,"Because deck.gl's primitive layers expect input to be a flat iteratorable data structure, some composite layers need to transform user data into a different format before passing to sublayers. This transformation may consist converting a tree to an array, filtering, sorting, etc. For example, the ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/layers/geojson-layer"},"GeoJsonLayer")," splits features by type and passes each to ",(0,r.kt)("inlineCode",{parentName:"p"},"ScatterplotLayer"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"PathLayer")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"SolidPolygonLayer")," respectively. The ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/layers/text-layer"},"TextLayer")," breaks each text string down to multiple characters and render them with a variation of ",(0,r.kt)("inlineCode",{parentName:"p"},"IconLayer"),"."),(0,r.kt)("p",null,"From the user's perspective, when they specify accessors such as ",(0,r.kt)("inlineCode",{parentName:"p"},"getColor"),", or callbacks such as ",(0,r.kt)("inlineCode",{parentName:"p"},"onHover"),", the functions should always interface with the original data that they give the top-level layer, instead of its internal implementations. For the sublayer to reference back to the original data, we can add a reference onto every transformed datum by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"getSubLayerRow"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class MyCompositeLayer extends CompositeLayer {\n  updateState({props, changeFlags}) {\n    if (changeFlags.dataChanged) {\n      // data to pass to the sublayer\n      const subLayerData = [];\n      /*\n       * input data format:\n         [\n           {position: [-122.45, 37.78], timestamps: [0, 1, 4, 7, 8]},\n           {position: [-122.43, 38.01], timestamps: [2, 4]},\n           ...\n         ]\n       * data format to pass to sublayer:\n         [\n           {timestamp: 0},\n           {timestamp: 1},\n           {timestamp: 4},\n           {timestamp: 7},\n           ...\n         ]\n       */\n      props.data.forEach((object, index) => {\n        for (const timestamp of object.timestamps) {\n          // `getSubLayerRow` decorates each data row for the sub layer with a reference to the original object and index\n          subLayerData.push(this.getSubLayerRow({\n            timestamp\n          }, object, index));\n        }\n      });\n\n      this.setState({subLayerData});\n    }\n  }\n}\n")),(0,r.kt)("p",null,"When the sublayer receives data decorated by ",(0,r.kt)("inlineCode",{parentName:"p"},"getSubLayerRow"),", its accessors need to know how to read the data to access the original objects. In the above example, ",(0,r.kt)("inlineCode",{parentName:"p"},"getPosition: d => d.position")," would fail if called with ",(0,r.kt)("inlineCode",{parentName:"p"},"{timestamp: 0}"),", while the user expects it to be called with ",(0,r.kt)("inlineCode",{parentName:"p"},"{position: [-122.45, 37.78], timestamps: [0, 1, 4, 7, 8]}"),". This can be solved by wrapping the user-provided accessor with ",(0,r.kt)("inlineCode",{parentName:"p"},"getSubLayerAccessor"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"  renderLayers() {\n    const {subLayerData} = this.state;\n    const {getPosition, getRadius, getFillColor, getLineColor, getLineWidth, updateTriggers} = this.props;\n\n    return new ScatterplotLayer(props, this.getSubLayerProps({\n      id: 'scatterplot',\n      updateTriggers,\n\n      data: this.state.subLayerData,\n      getPosition: this.getSubLayerAccessor(getPosition),\n      getRadius: this.getSubLayerAccessor(getRadius),\n      getFillColor: this.getSubLayerAccessor(getFillColor),\n      getLineColor: this.getSubLayerAccessor(getLineColor),\n      getLineWidth: this.getSubLayerAccessor(getLineWidth)\n    }));\n  }\n")),(0,r.kt)("p",null,"The default implementations of lifecycle methods such as ",(0,r.kt)("inlineCode",{parentName:"p"},"getPickingInfo")," also understand how to retrieve the original objects from the sublayer data if they are created using ",(0,r.kt)("inlineCode",{parentName:"p"},"getSubLayerRow"),"."))}g.isMDXComponent=!0}}]);