"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[4244],{3905:(e,t,o)=>{o.d(t,{Zo:()=>s,kt:()=>f});var n=o(67294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function i(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function p(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?i(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function a(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)o=i[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)o=i[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),o=t;return e&&(o="function"==typeof e?e(t):p(p({},t),e)),o},s=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,s=a(e,["components","mdxType","originalType","parentName"]),d=l(o),m=r,f=d["".concat(c,".").concat(m)]||d[m]||u[m]||i;return o?n.createElement(f,p(p({ref:t},s),{},{components:o})):n.createElement(f,p({ref:t},s))}));function f(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=o.length,p=new Array(i);p[0]=m;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a[d]="string"==typeof e?e:r,p[1]=a;for(var l=2;l<i;l++)p[l]=o[l];return n.createElement.apply(null,p)}return n.createElement.apply(null,o)}m.displayName="MDXCreateElement"},17500:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>p,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var n=o(87462),r=(o(67294),o(3905));const i={},p="project64 (Shader Module)",a={unversionedId:"api-reference/core/project64",id:"api-reference/core/project64",title:"project64 (Shader Module)",description:"The project64 shader module is an extension of the project shader module that does projection using 64 bit floating point. It provides an increase in precision, at the cost of performance. Note that starting with deck.gl v6.1, the improved default 32 bit projection mode provides sufficient precision for most use cases.",source:"@site/../docs/api-reference/core/project64.md",sourceDirName:"api-reference/core",slug:"/api-reference/core/project64",permalink:"/docs/api-reference/core/project64",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/api-reference/core/project64.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"project32 (Shader Module)",permalink:"/docs/api-reference/core/project32"},next:{title:"Viewport",permalink:"/docs/api-reference/core/viewport"}},c={},l=[{value:"getUniforms",id:"getuniforms",level:2},{value:"GLSL Uniforms",id:"glsl-uniforms",level:2},{value:"GLSL Functions",id:"glsl-functions",level:2},{value:"project_position_to_clipspace",id:"project_position_to_clipspace",level:3},{value:"project_position_fp64",id:"project_position_fp64",level:3},{value:"project_common_position_to_clipspace_fp64",id:"project_common_position_to_clipspace_fp64",level:3},{value:"Remarks",id:"remarks",level:2}],s={toc:l},d="wrapper";function u(e){let{components:t,...o}=e;return(0,r.kt)(d,(0,n.Z)({},s,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"project64-shader-module"},"project64 (Shader Module)"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"project64")," shader module is an extension of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/project"},"project")," shader module that does projection using 64 bit floating point. It provides an increase in precision, at the cost of performance. Note that starting with deck.gl v6.1, the improved default 32 bit projection mode provides sufficient precision for most use cases."),(0,r.kt)("h2",{id:"getuniforms"},"getUniforms"),(0,r.kt)("p",null,"The uniforms needed by ",(0,r.kt)("inlineCode",{parentName:"p"},"project64")," are extracted from the ",(0,r.kt)("inlineCode",{parentName:"p"},"project")," module uniforms ",(0,r.kt)("inlineCode",{parentName:"p"},"project_uViewProjectionMatrix")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"project_uScale"),"."),(0,r.kt)("h2",{id:"glsl-uniforms"},"GLSL Uniforms"),(0,r.kt)("p",null,"Uniforms are considered private to each shader module. They may change in between patch releases. Always use documented functions instead of accessing module uniforms directly."),(0,r.kt)("p",null,"The uniforms of the ",(0,r.kt)("inlineCode",{parentName:"p"},"project64")," shader module are prefixed with ",(0,r.kt)("inlineCode",{parentName:"p"},"project64_")," in their names."),(0,r.kt)("h2",{id:"glsl-functions"},"GLSL Functions"),(0,r.kt)("h3",{id:"project_position_to_clipspace"},"project_position_to_clipspace"),(0,r.kt)("p",null,"64 bit implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"project_position_to_clipspace")," interface."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-glsl"},"vec4 project_position_to_clipspace(vec3 position, vec3 position64Low, vec3 offset)\nvec4 project_position_to_clipspace(vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition)\n")),(0,r.kt)("p",null,"Parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"position")," - vertex position in the layer's coordinate system."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"position64Low")," - low part of the vertex position, calculated as ",(0,r.kt)("inlineCode",{parentName:"li"},"aLow = a - Math.fround(a)"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"offset")," - offset from the coordinate, in common space"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"commonPosition")," - projected position in the common space")),(0,r.kt)("p",null,"Returns:\nProjected position in the clipspace."),(0,r.kt)("h3",{id:"project_position_fp64"},"project_position_fp64"),(0,r.kt)("p",null,"64 bit counterpart of the ",(0,r.kt)("inlineCode",{parentName:"p"},"project")," modules ",(0,r.kt)("inlineCode",{parentName:"p"},"project_position")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-glsl"},"void project_position_fp64(vec4 position_fp64, out vec2 out_val[2])\nvoid project_position_fp64(vec2 position, vec2 position64Low, out vec2 out_val[2])\n")),(0,r.kt)("h3",{id:"project_common_position_to_clipspace_fp64"},"project_common_position_to_clipspace_fp64"),(0,r.kt)("p",null,"64 bit counterpart of the ",(0,r.kt)("inlineCode",{parentName:"p"},"project")," modules ",(0,r.kt)("inlineCode",{parentName:"p"},"project_common_position_to_clipspace")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-glsl"},"vec4 project_to_clipspace_fp64(vec2 vertex_pos_modelspace[4])\n")),(0,r.kt)("h2",{id:"remarks"},"Remarks"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"project64")," depends on luma.gl's ",(0,r.kt)("inlineCode",{parentName:"li"},"fp64")," module which is a big and complex shader module, which means that ",(0,r.kt)("inlineCode",{parentName:"li"},"project64")," is a big dependency for your shader.")))}u.isMDXComponent=!0}}]);