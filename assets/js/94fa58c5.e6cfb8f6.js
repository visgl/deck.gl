"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[6704],{99:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>d,default:()=>g,frontMatter:()=>c,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"api-reference/layers/icon-layer","title":"IconLayer","description":"The IconLayer renders raster icons at given coordinates.","source":"@site/../docs/api-reference/layers/icon-layer.md","sourceDirName":"api-reference/layers","slug":"/api-reference/layers/icon-layer","permalink":"/docs/api-reference/layers/icon-layer","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/deck.gl/tree/master/website/../docs/api-reference/layers/icon-layer.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"HexagonLayer","permalink":"/docs/api-reference/aggregation-layers/hexagon-layer"},"next":{"title":"LineLayer","permalink":"/docs/api-reference/layers/line-layer"}}');var s=n(74848),o=n(28453),r=n(23249),a=n(11470),l=n(19365);const c={},d="IconLayer",h={},p=[{value:"Example: pre-packed iconAtlas",id:"example-pre-packed-iconatlas",level:2},{value:"Example: auto packing iconAtlas",id:"example-auto-packing-iconatlas",level:2},{value:"Installation",id:"installation",level:2},{value:"Properties",id:"properties",level:2},{value:"<code>iconAtlas</code> (string | Texture | Image | ImageData | HTMLCanvasElement | HTMLVideoElement | ImageBitmap | Promise | object, optional)",id:"iconatlas",level:4},{value:"<code>iconMapping</code> (object | string, optional)",id:"iconmapping",level:4},{value:"<code>sizeScale</code> (number, optional) transition-enabled",id:"sizescale",level:4},{value:"<code>sizeBasis</code> (string, optional)",id:"sizebasis",level:4},{value:"<code>sizeUnits</code> (string, optional)",id:"sizeunits",level:4},{value:"<code>sizeMinPixels</code> (number, optional) transition-enabled",id:"sizeminpixels",level:4},{value:"<code>sizeMaxPixels</code> (number, optional) transition-enabled",id:"sizemaxpixels",level:4},{value:"<code>billboard</code> (boolean, optional)",id:"billboard",level:4},{value:"<code>alphaCutoff</code> (number, optional)",id:"alphacutoff",level:4},{value:"<code>loadOptions</code> (object, optional)",id:"loadoptions",level:4},{value:"<code>textureParameters</code> (object)",id:"textureparameters",level:4},{value:"Data Accessors",id:"data-accessors",level:3},{value:"<code>getIcon</code> (Accessor&lt;string&gt;, optional)",id:"geticon",level:4},{value:"<code>getPosition</code> (Accessor&lt;Position&gt;, optional) transition-enabled",id:"getposition",level:4},{value:"<code>getSize</code> (Accessor&lt;number&gt;, optional) transition-enabled",id:"getsize",level:4},{value:"<code>getColor</code> (Accessor&lt;Color&gt;, optional) transition-enabled",id:"getcolor",level:4},{value:"<code>getAngle</code> (Accessor&lt;number&gt;, optional) transition-enabled",id:"getangle",level:4},{value:"<code>getPixelOffset</code> (Accessor&lt;number[2]&gt;, optional) transition-enabled",id:"getpixeloffset",level:4},{value:"Callbacks",id:"callbacks",level:3},{value:"<code>onIconError</code> (Function)",id:"oniconerror",level:4},{value:"Use binary attributes",id:"use-binary-attributes",level:2},{value:"Source",id:"source",level:2}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"iconlayer",children:"IconLayer"})}),"\n","\n",(0,s.jsx)(r.C5,{}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"IconLayer"})," renders raster icons at given coordinates."]}),"\n",(0,s.jsxs)(t.p,{children:["There are two approaches to load icons. You can pre-generated a sprite image (",(0,s.jsx)(t.code,{children:"iconAtlas"}),"), which packs all your icons\ninto one layout, and a JSON descriptor (",(0,s.jsx)(t.code,{children:"iconMapping"}),"), which describes the position and size of each icon in the ",(0,s.jsx)(t.code,{children:"iconAtlas"}),".\nYou can create sprite images with tools such as ",(0,s.jsx)(t.a,{href:"https://www.codeandweb.com/texturepacker",children:"TexturePacker"}),". This is the\nmost efficient way to load icons."]}),"\n",(0,s.jsxs)(t.p,{children:["It is also possible to ask ",(0,s.jsx)(t.code,{children:"IconLayer"})," to generate ",(0,s.jsx)(t.code,{children:"iconAtlas"})," dynamically. This is slower but might be useful in certain\nuse cases."]}),"\n",(0,s.jsx)(t.h2,{id:"example-pre-packed-iconatlas",children:"Example: pre-packed iconAtlas"}),"\n","\n",(0,s.jsxs)(a.A,{groupId:"language",children:[(0,s.jsx)(l.A,{value:"js",label:"JavaScript",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import {Deck} from '@deck.gl/core';\nimport {IconLayer} from '@deck.gl/layers';\n\nconst layer = new IconLayer({\n  id: 'IconLayer',\n  data: 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/bart-stations.json',\n  getColor: d => [Math.sqrt(d.exits), 140, 0],\n  getIcon: d => 'marker',\n  getPosition: d => d.coordinates,\n  getSize: 40,\n  iconAtlas: 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/icon-atlas.png',\n  iconMapping: 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/icon-atlas.json',\n  pickable: true\n});\n\nnew Deck({\n  initialViewState: {\n    longitude: -122.4,\n    latitude: 37.74,\n    zoom: 11\n  },\n  controller: true,\n  getTooltip: ({object}) => object && object.name,\n  layers: [layer]\n});\n"})})}),(0,s.jsx)(l.A,{value:"ts",label:"TypeScript",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import {Deck, PickingInfo} from '@deck.gl/core';\nimport {IconLayer} from '@deck.gl/layers';\n\ntype BartStation = {\n  name: string;\n  entries: number;\n  exits: number;\n  coordinates: [longitude: number, latitude: number];\n};\n\nconst layer = new IconLayer<BartStation>({\n  id: 'IconLayer',\n  data: 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/bart-stations.json',\n  getColor: (d: BartStation) => [Math.sqrt(d.exits), 140, 0],\n  getIcon: (d: BartStation) => 'marker',\n  getPosition: (d: BartStation) => d.coordinates,\n  getSize: 40,\n  iconAtlas: 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/icon-atlas.png',\n  iconMapping: 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/icon-atlas.json',\n  pickable: true\n});\n\nnew Deck({\n  initialViewState: {\n    longitude: -122.4,\n    latitude: 37.74,\n    zoom: 11\n  },\n  controller: true,\n  getTooltip: ({object}: PickingInfo<BartStation>) => object && object.name,\n  layers: [layer]\n});\n"})})}),(0,s.jsx)(l.A,{value:"react",label:"React",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"import React from 'react';\nimport {DeckGL} from '@deck.gl/react';\nimport {IconLayer} from '@deck.gl/layers';\nimport type {PickingInfo} from '@deck.gl/core';\n\ntype BartStation = {\n  name: string;\n  entries: number;\n  exits: number;\n  coordinates: [longitude: number, latitude: number];\n};\n\nfunction App() {\n  const layer = new IconLayer<BartStation>({\n    id: 'IconLayer',\n    data: 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/bart-stations.json',\n    getColor: (d: BartStation) => [Math.sqrt(d.exits), 140, 0],\n    getIcon: (d: BartStation) => 'marker',\n    getPosition: (d: BartStation) => d.coordinates,\n    getSize: 40,\n    iconAtlas: 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/icon-atlas.png',\n    iconMapping: 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/icon-atlas.json',\n    pickable: true\n  });\n\n  return <DeckGL\n    initialViewState={{\n      longitude: -122.4,\n      latitude: 37.74,\n      zoom: 11\n    }}\n    controller\n    getTooltip={({object}: PickingInfo<BartStation>) => object && object.name}\n    layers={[layer]}\n  />;\n}\n"})})})]}),"\n",(0,s.jsx)(t.h2,{id:"example-auto-packing-iconatlas",children:"Example: auto packing iconAtlas"}),"\n",(0,s.jsxs)(t.p,{children:["In some use cases, it is not possible to know the icons that will be used. Instead, each icon needs to be fetched from\na programmatically generated URL at runtime. For example, if you want to visualize avatars of github contributors for\na project on a map, it is not convenient for you to generate the ",(0,s.jsx)(t.code,{children:"iconAtlas"})," with all the contributors' avatars.\nIn this case, you can follow this example. Auto packing icons is less efficient than pre-packed."]}),"\n",(0,s.jsxs)(a.A,{groupId:"language",children:[(0,s.jsx)(l.A,{value:"js",label:"JavaScript",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import {Deck} from '@deck.gl/core';\nimport {IconLayer} from '@deck.gl/layers';\nimport {Octokit} from '@octokit/rest';\nconst octokit = new Octokit();\n\nconst layer = new IconLayer<User>({\n  id: 'IconLayer',\n  data: octokit.repos.getContributors({owner: 'visgl', repo: 'deck.gl'}),\n  dataTransform: result => result.data,\n  getIcon: d => ({\n    url: d.avatar_url,\n    width: 128,\n    height: 128\n  }),\n  getPosition: (d, {index}) => [index * 100, Math.sqrt(d.contributions) * 10, 0],\n  getSize: 40,\n  pickable: true\n});\n\nnew Deck({\n  views: new OrthographicView(),\n  initialViewState: {\n    target: [0, 0, 0],\n    zoom: 0\n  },\n  controller: true,\n  getTooltip: ({object}) => object && `${object.login}`,\n  layers: [layer]\n});\n"})})}),(0,s.jsx)(l.A,{value:"ts",label:"TypeScript",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import {Deck, OrthographicView, PickingInfo} from '@deck.gl/core';\nimport {IconLayer} from '@deck.gl/layers';\nimport {Octokit} from '@octokit/rest';\nconst octokit = new Octokit();\n\n// https://docs.github.com/en/rest/repos/repos?apiVersion=2022-11-28#list-repository-contributors\ntype User = {\n  id: number;\n  login: string;\n  avatar_url: string;\n  contributions: number;\n};\n\nconst layer = new IconLayer<User>({\n  id: 'IconLayer',\n  data: octokit.repos.getContributors({owner: 'visgl', repo: 'deck.gl'}),\n  dataTransform: result => result.data,\n  getIcon: (d: User) => ({\n    url: d.avatar_url,\n    width: 128,\n    height: 128\n  }),\n  getPosition: (d: User, {index}) => [index * 100, Math.sqrt(d.contributions) * 10, 0],\n  getSize: 40,\n  pickable: true\n});\n\nnew Deck({\n  views: new OrthographicView(),\n  initialViewState: {\n    target: [0, 0, 0],\n    zoom: 0\n  },\n  controller: true,\n  getTooltip: ({object}: PickingInfo<User>) => object && `${object.login}`,\n  layers: [layer]\n});\n"})})}),(0,s.jsx)(l.A,{value:"react",label:"React",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"import React from 'react';\nimport {DeckGL} from '@deck.gl/react';\nimport {IconLayer} from '@deck.gl/layers';\nimport type {PickingInfo} from '@deck.gl/core';\nimport {Octokit} from '@octokit/rest';\nconst octokit = new Octokit();\n\n// https://docs.github.com/en/rest/repos/repos?apiVersion=2022-11-28#list-repository-contributors\ntype User = {\n  id: number;\n  login: string;\n  avatar_url: string;\n  contributions: number;\n};\n\nfunction App() {\n  const layer = new IconLayer<User>({\n    id: 'IconLayer',\n    data: octokit.repos.getContributors({owner: 'visgl', repo: 'deck.gl'}),\n    dataTransform: result => result.data,\n    getIcon: (d: User) => ({\n      url: d.avatar_url,\n      width: 128,\n      height: 128\n    }),\n    getPosition: (d: User, {index}) => [index * 100, Math.sqrt(d.contributions) * 10, 0],\n    getSize: 40,\n    pickable: true\n  });\n\n  return <DeckGL\n    initialViewState={{\n      longitude: -122.4,\n      latitude: 37.74,\n      zoom: 11\n    }}\n    controller\n    getTooltip={({object}: PickingInfo<User>) => object && `${object.login}`}\n    layers={[layer]}\n  />;\n}\n"})})})]}),"\n",(0,s.jsx)(t.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(t.p,{children:"To install the dependencies from NPM:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"npm install deck.gl\n# or\nnpm install @deck.gl/core @deck.gl/layers\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import {IconLayer} from '@deck.gl/layers';\nimport type {IconLayerProps} from '@deck.gl/layers';\n\nnew IconLayer<DataT>(...props: IconLayerProps<DataT>[]);\n"})}),"\n",(0,s.jsx)(t.p,{children:"To use pre-bundled scripts:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<script src="https://unpkg.com/deck.gl@^9.0.0/dist.min.js"><\/script>\n\x3c!-- or --\x3e\n<script src="https://unpkg.com/@deck.gl/core@^9.0.0/dist.min.js"><\/script>\n<script src="https://unpkg.com/@deck.gl/layers@^9.0.0/dist.min.js"><\/script>\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"new deck.IconLayer({});\n"})}),"\n",(0,s.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,s.jsxs)(t.p,{children:["Inherits from all ",(0,s.jsx)(t.a,{href:"/docs/api-reference/core/layer",children:"Base Layer"})," properties."]}),"\n",(0,s.jsxs)(t.h4,{id:"iconatlas",children:[(0,s.jsx)(t.code,{children:"iconAtlas"})," (string | Texture | Image | ImageData | HTMLCanvasElement | HTMLVideoElement | ImageBitmap | Promise | object, optional)"]}),"\n",(0,s.jsx)(t.p,{children:"A pre-packed image that contains all icons."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["If a string is supplied, it is interpreted as a URL or a ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs",children:"Data URL"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["One of the following, or a Promise that resolves to one of the following:","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["One of the valid ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D",children:"pixel sources for WebGL2 texture"})]}),"\n",(0,s.jsxs)(t.li,{children:["A luma.gl ",(0,s.jsx)(t.a,{href:"https://luma.gl/docs/api-reference/core/resources/texture/",children:"Texture"})," instance"]}),"\n",(0,s.jsxs)(t.li,{children:["A plain object that can be passed to the ",(0,s.jsx)(t.code,{children:"Texture"})," constructor, e.g. ",(0,s.jsx)(t.code,{children:"{width: <number>, height: <number>, data: <Uint8Array>}"}),". Note that whenever this object shallowly changes, a new texture will be created."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The image data will be converted to a ",(0,s.jsx)(t.a,{href:"https://luma.gl/docs/api-reference/core/resources/texture",children:"Texture"})," object. See ",(0,s.jsx)(t.code,{children:"textureParameters"})," prop for advanced customization."]}),"\n",(0,s.jsx)(t.p,{children:"If you go with pre-packed strategy, this prop is required."}),"\n",(0,s.jsx)(t.p,{children:"If you choose to use auto packing, this prop should be left empty."}),"\n",(0,s.jsxs)(t.h4,{id:"iconmapping",children:[(0,s.jsx)(t.code,{children:"iconMapping"})," (object | string, optional)"]}),"\n",(0,s.jsx)(t.p,{children:"Icon names mapped to icon definitions, or a URL to load such mapping from a JSON file. Each icon is defined with the following values:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"x"})," (number, required): x position of icon on the atlas image"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"y"})," (number, required): y position of icon on the atlas image"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"width"})," (number, required): width of icon on the atlas image"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"height"})," (number, required): height of icon on the atlas image"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"anchorX"})," (number, optional): horizontal position of icon anchor. Default: half width."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"anchorY"})," (number, optional): vertical position of icon anchor. Default: half height."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"mask"})," (boolean, optional): whether icon is treated as a transparency mask.\nIf ",(0,s.jsx)(t.code,{children:"true"}),", user defined color is applied.\nIf ",(0,s.jsx)(t.code,{children:"false"}),", pixel color from the image is applied. User still can specify the opacity through getColor.\nDefault: ",(0,s.jsx)(t.code,{children:"false"})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"If you go with pre-packed strategy, this prop is required."}),"\n",(0,s.jsx)(t.p,{children:"If you choose to use auto packing, this prop should be left empty."}),"\n",(0,s.jsxs)(t.h4,{id:"sizescale",children:[(0,s.jsx)(t.code,{children:"sizeScale"})," (number, optional) ",(0,s.jsx)(t.img,{src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"1"})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Icon size multiplier."}),"\n",(0,s.jsxs)(t.h4,{id:"sizebasis",children:[(0,s.jsx)(t.code,{children:"sizeBasis"})," (string, optional)"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Default: 'height'"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Determines which dimension the size controls when scaling the icon. Valid values:"}),"\n",(0,s.jsx)(t.p,{children:"'height': The icon size controls the height of the icon (default)."}),"\n",(0,s.jsx)(t.p,{children:"'width': The icon size controls the width of the icon."}),"\n",(0,s.jsx)(t.p,{children:"This affects how the icon is scaled to maintain its aspect ratio based on the chosen size basis."}),"\n",(0,s.jsxs)(t.h4,{id:"sizeunits",children:[(0,s.jsx)(t.code,{children:"sizeUnits"})," (string, optional)"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"pixels"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The units of the size, one of ",(0,s.jsx)(t.code,{children:"'meters'"}),", ",(0,s.jsx)(t.code,{children:"'common'"}),", and ",(0,s.jsx)(t.code,{children:"'pixels'"}),". See ",(0,s.jsx)(t.a,{href:"/docs/developer-guide/coordinate-systems#supported-units",children:"unit system"}),"."]}),"\n",(0,s.jsxs)(t.h4,{id:"sizeminpixels",children:[(0,s.jsx)(t.code,{children:"sizeMinPixels"})," (number, optional) ",(0,s.jsx)(t.img,{src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"0"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The minimum size in pixels. When using non-pixel ",(0,s.jsx)(t.code,{children:"sizeUnits"}),", this prop can be used to prevent the icon from getting too small when zoomed out."]}),"\n",(0,s.jsxs)(t.h4,{id:"sizemaxpixels",children:[(0,s.jsx)(t.code,{children:"sizeMaxPixels"})," (number, optional) ",(0,s.jsx)(t.img,{src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"Number.MAX_SAFE_INTEGER"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The maximum size in pixels. When using non-pixel ",(0,s.jsx)(t.code,{children:"sizeUnits"}),", this prop can be used to prevent the icon from getting too big when zoomed in."]}),"\n",(0,s.jsxs)(t.h4,{id:"billboard",children:[(0,s.jsx)(t.code,{children:"billboard"})," (boolean, optional)"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"true"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["If ",(0,s.jsx)(t.code,{children:"true"}),", the icon always faces camera. Otherwise the icon faces up (z)."]}),"\n",(0,s.jsxs)(t.h4,{id:"alphacutoff",children:[(0,s.jsx)(t.code,{children:"alphaCutoff"})," (number, optional)"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"0.05"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:['Discard pixels whose opacity is below this threshold. A discarded pixel would create a "hole" in the icon that is not considered part of the object. This is useful for customizing picking behavior, e.g. setting ',(0,s.jsx)(t.code,{children:"alphaCutoff: 0, autoHighlight"})," will highlight an object whenever the cursor moves into its bounding box, instead of over the visible pixels."]}),"\n",(0,s.jsxs)(t.h4,{id:"loadoptions",children:[(0,s.jsx)(t.code,{children:"loadOptions"})," (object, optional)"]}),"\n",(0,s.jsxs)(t.p,{children:["On top of the ",(0,s.jsx)(t.a,{href:"/docs/api-reference/core/layer#loadoptions",children:"default options"}),", also accepts options for the following loaders:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://loaders.gl/modules/images/docs/api-reference/image-loader",children:"ImageLoader"})," if the ",(0,s.jsx)(t.code,{children:"iconAtlas"})," prop is an URL, or if ",(0,s.jsx)(t.code,{children:"getIcon"})," returns URLs for auto-packing"]}),"\n"]}),"\n",(0,s.jsxs)(t.h4,{id:"textureparameters",children:[(0,s.jsx)(t.code,{children:"textureParameters"})," (object)"]}),"\n",(0,s.jsxs)(t.p,{children:["Customize the ",(0,s.jsx)(t.a,{href:"https://luma.gl/docs/api-reference/core/resources/sampler#samplerprops",children:"texture parameters"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If not specified, the layer uses the following defaults to create a linearly smoothed texture from ",(0,s.jsx)(t.code,{children:"iconAtlas"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"{\n  minFilter: 'linear',\n  magFilter: 'linear',\n  mipmapFilter: 'linear',\n  addressModeU: 'clamp-to-edge',\n  addressModeV: 'clamp-to-edge'\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"data-accessors",children:"Data Accessors"}),"\n",(0,s.jsxs)(t.h4,{id:"geticon",children:[(0,s.jsx)(t.code,{children:"getIcon"})," (",(0,s.jsx)(t.a,{href:"/docs/developer-guide/using-layers#accessors",children:"Accessor<string>"}),", optional)"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"d => d.icon"})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Method called to retrieve the icon name of each object, returns string or object."}),"\n",(0,s.jsxs)(t.p,{children:["If you go with pre-packed strategy, then ",(0,s.jsx)(t.code,{children:"getIcon"})," should return a string representing name of the icon,\nused to retrieve icon definition from given ",(0,s.jsx)(t.code,{children:"iconMapping"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If you choose to use auto packing, then ",(0,s.jsx)(t.code,{children:"getIcon"})," should return an object which contains\nthe following properties."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"url"})," (string, required): url to fetch the icon"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"height"})," (number, required): max height of icon"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"width"})," (number, required): max width of icon"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"id"}),": (string, optional): unique identifier of the icon, fall back to ",(0,s.jsx)(t.code,{children:"url"})," if not specified"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"anchorX"}),", ",(0,s.jsx)(t.code,{children:"anchorY"}),", ",(0,s.jsx)(t.code,{children:"mask"})," are the same as mentioned in ",(0,s.jsx)(t.code,{children:"iconMapping"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"IconLayer"})," uses ",(0,s.jsx)(t.code,{children:"id"})," (fallback to ",(0,s.jsx)(t.code,{children:"url"}),") to dedupe icons. For icons with the same id, even if their sizes differ, ",(0,s.jsx)(t.code,{children:"IconLayer"})," will only define one icon according to the first occurrence and ignore the rest of them. Vice versa, for icons with different ids, even if ",(0,s.jsx)(t.code,{children:"url"}),"s are the same, the image will be fetched again to create a new definition with different size, anchor, etc."]}),"\n",(0,s.jsxs)(t.p,{children:["The image loaded from ",(0,s.jsx)(t.code,{children:"url"})," is always resized to fit the box defined by ",(0,s.jsx)(t.code,{children:"[width, height]"})," while preserving its aspect ratio."]}),"\n",(0,s.jsxs)(t.h4,{id:"getposition",children:[(0,s.jsx)(t.code,{children:"getPosition"})," (",(0,s.jsx)(t.a,{href:"/docs/developer-guide/using-layers#accessors",children:"Accessor<Position>"}),", optional) ",(0,s.jsx)(t.img,{src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"d => d.position"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Method called to retrieve the position of each object, returns ",(0,s.jsx)(t.code,{children:"[lng, lat, z]"}),"."]}),"\n",(0,s.jsxs)(t.h4,{id:"getsize",children:[(0,s.jsx)(t.code,{children:"getSize"})," (",(0,s.jsx)(t.a,{href:"/docs/developer-guide/using-layers#accessors",children:"Accessor<number>"}),", optional) ",(0,s.jsx)(t.img,{src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"1"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The size of each object, in units specified by ",(0,s.jsx)(t.code,{children:"sizeUnits"})," (default pixels). By default the size controls the height of the object, this can be changed with the sizeBasis property."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"If a number is provided, it is used as the size for all objects."}),"\n",(0,s.jsx)(t.li,{children:"If a function is provided, it is called on each object to retrieve its size."}),"\n"]}),"\n",(0,s.jsxs)(t.h4,{id:"getcolor",children:[(0,s.jsx)(t.code,{children:"getColor"})," (",(0,s.jsx)(t.a,{href:"/docs/developer-guide/using-layers#accessors",children:"Accessor<Color>"}),", optional) ",(0,s.jsx)(t.img,{src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"[0, 0, 0, 255]"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The rgba color is in the format of ",(0,s.jsx)(t.code,{children:"[r, g, b, [a]]"}),". Each channel is a number between 0-255 and ",(0,s.jsx)(t.code,{children:"a"})," is 255 if not supplied."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"If an array is provided, it is used as the color for all objects."}),"\n",(0,s.jsx)(t.li,{children:"If a function is provided, it is called on each object to retrieve its color."}),"\n",(0,s.jsxs)(t.li,{children:["If ",(0,s.jsx)(t.code,{children:"mask"})," = false, only the alpha component will be used to control the opacity of the icon."]}),"\n"]}),"\n",(0,s.jsxs)(t.h4,{id:"getangle",children:[(0,s.jsx)(t.code,{children:"getAngle"})," (",(0,s.jsx)(t.a,{href:"/docs/developer-guide/using-layers#accessors",children:"Accessor<number>"}),", optional) ",(0,s.jsx)(t.img,{src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"0"})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The rotating angle  of each object, in degrees."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"If a number is provided, it is used as the angle for all objects."}),"\n",(0,s.jsx)(t.li,{children:"If a function is provided, it is called on each object to retrieve its angle."}),"\n"]}),"\n",(0,s.jsxs)(t.h4,{id:"getpixeloffset",children:[(0,s.jsx)(t.code,{children:"getPixelOffset"})," (",(0,s.jsx)(t.a,{href:"/docs/developer-guide/using-layers#accessors",children:"Accessor<number[2]>"}),", optional) ",(0,s.jsx)(t.img,{src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"[0, 0]"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Screen space offset relative to the ",(0,s.jsx)(t.code,{children:"coordinates"})," in pixel unit."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"If an array is provided, it is used as the offset for all objects."}),"\n",(0,s.jsx)(t.li,{children:"If a function is provided, it is called on each object to retrieve its offset."}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"callbacks",children:"Callbacks"}),"\n",(0,s.jsxs)(t.h4,{id:"oniconerror",children:[(0,s.jsx)(t.code,{children:"onIconError"})," (Function)"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Default: ",(0,s.jsx)(t.code,{children:"null"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Only used when using auto-packing. If the attempt to fetch an icon returned by ",(0,s.jsx)(t.code,{children:"getIcon"})," fails, this callback is called with the following arguments:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"event"})," (object)","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"url"})," (string) - the URL that was trying to fetch"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"loadOptions"})," (object) - the load options used for the fetch"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"source"})," (object) - the original data object that requested this icon"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"sourceIndex"})," (object) - the index of the original data object that requested this icon"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"error"})," (Error)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"use-binary-attributes",children:"Use binary attributes"}),"\n",(0,s.jsxs)(t.p,{children:["This section is about the special requirements when ",(0,s.jsx)(t.a,{href:"/docs/developer-guide/performance#supply-attributes-directly",children:"supplying attributes directly"})," to an ",(0,s.jsx)(t.code,{children:"IconLayer"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If ",(0,s.jsx)(t.code,{children:"data.attributes.getIcon"})," is supplied, since its value can only be a typed array, ",(0,s.jsx)(t.code,{children:"iconMapping"})," can only use integers as keys."]}),"\n",(0,s.jsx)(t.h2,{id:"source",children:"Source"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://github.com/visgl/deck.gl/tree/9.2-release/modules/layers/src/icon-layer",children:"modules/layers/src/icon-layer"})})]})}function g(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},11175:(e,t,n)=>{n.d(t,{Ut:()=>s,Vi:()=>i,lP:()=>o});const i={LIGHT:"https://deck.gl/mapstyle/deck-light.json",LIGHT_LABEL:"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json",DARK:"https://deck.gl/mapstyle/deck-dark.json",BLANK:{version:8,sources:{},layers:[]}},s="https://raw.githubusercontent.com/visgl/deck.gl-data/master/website",o="https://github.com/visgl/deck.gl/tree/9.2-release"},89323:(e,t,n)=>{n.d(t,{i:()=>c});const i=["dataComparator","fetch"],s=["autoHighlight","coordinateOrigin","coordinateSystem","highlightColor","modelMatrix","opacity","pickable","visible","wrapLongitude"],o={loaders:[],coordinateSystem:"COORDINATE_SYSTEM.LNGLAT",renderSubLayers:"props => new GeoJsonLayer(props)",characterSet:'" !\\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"'};function r(e,t){if(!e.includes("\n")||0===t)return e;const n=e.split("\n");if(t>0){const e="".padStart(t," ");return n.map(((t,n)=>n>0?e+t:t)).join("\n")}return n.map(((e,n)=>n>0?e.slice(-t):e)).join("\n")}function a(e){return null==e?"null":"string"==typeof e?"'"+e+"'":"function"==typeof e?e.toString():Array.isArray(e)?"["+e.map(a).join(", ")+"]":e===Number.MAX_SAFE_INTEGER?"Number.MAX_SAFE_INTEGER":r(JSON.stringify(e,null,2),2)}function l(e,t){const n=[],l={};t=function(e){const t=e.split("\n");t.pop();const n={};let i,s=1/0;for(const o of t){const e=o.match(/^(\s*)(\w+):\s*(.*)/);e&&e[1].length<=s?(s=e[1].length,i=e[2],n[i]=e[3]):i&&(n[i]+="\n"+o)}for(i in n)n[i]=r(n[i].replace(/,\s*$/,""),2-s);return n}(t);let c=e.constructor,d=!1;const h=e.props[Symbol.for("asyncPropOriginal")],p=e.props[Symbol.for("asyncPropResolved")];function u(e,t,s,o){if(!l[e]&&!i.includes(e)){const i=(s?"// ":"")+e+": "+t+",";void 0===o?n.push(i):n.splice(o,0,i),l[e]=!0}}let g=1;for(u("id",a(e.id)),t.data&&u("data",t.data,!1,g++);c.layerName;){if(c.hasOwnProperty("defaultProps")){n.push("","/* props "+(d?"inherited from":"from")+" "+c.layerName+" class */","");const i=Object.keys(c.defaultProps).sort();for(const n of i){const i=c.defaultProps[n],r=!(n in h)&&!(n in p)&&!Object.hasOwnProperty.call(e.props,n);let l,d=!1;n in t?l=t[n]:(d=i&&i.deprecatedFor,d=d||n.startsWith("_"),d=d||i&&"accessor"===i.type&&"function"==typeof i.value,d=d||"Layer"===c.layerName&&!s.includes(n),l=h[n]||e.props[n],l="function"==typeof l?null:n in o?o[n]:a(l)),d||u(n,l,r)}}c=Object.getPrototypeOf(c),d=!0}for(const i in t)i in l||u(i,t[i],!1,g++);return n.join("\n  ")}function c(e,t){const{Layer:n,isExperimental:i,getTooltip:s,props:o,mapStyle:a=!0,dependencies:c=[],imports:d,initialViewState:h}=e,p=i?"_"+n.layerName:n.layerName,u=["DeckGL",p],g=[];if(d)for(const r in d)r[0]>="a"||(r.endsWith("Loader")?g.push(r):u.push(r));const f=r(JSON.stringify(h,null,2).replace(/"/g,""),2),m="const {"+u.join(", ")+"} = deck;\n"+(g.length?"const {"+g.join(", ")+"} = loaders;\n":"")+"\nconst layer = new "+p+"({\n  "+l(t,o)+"\n});\n\nnew DeckGL({\n  "+(a?"mapStyle: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',":"")+"\n  initialViewState: "+f+",\n  controller: true,\n  "+(s?"getTooltip: "+s+",":"")+"\n  layers: [layer]\n});\n  ";!function(e){let{dependencies:t=[],title:n,source:i}=e;const s={js_external:t.concat(["https://unpkg.com/deck.gl@latest/dist.min.js"]).join(";"),title:n,parent:48721472,tags:["webgl","data visualization"],editors:"001",css:"\n  body {\n    margin: 0;\n    width: 100vw;\n    height: 100vh;\n    overflow: hidden;\n  }\n  \n  .deck-tooltip {\n    font-size: 0.8em;\n    font-family: Helvetica, Arial, sans-serif;\n  }\n  ",js:"/*\n* "+window.location.href+"\n*/\n"+i},o=document.createElement("form");o.action="https://codepen.io/pen/define/",o.method="POST",o.style.display="none",document.body.appendChild(o);const r=document.createElement("input");r.type="text",r.name="data",r.value=JSON.stringify(s),o.appendChild(r),window.open("","deck-example-codepen"),o.target="deck-example-codepen",o.submit(),o.remove()}({dependencies:c.concat(["https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.js"]),title:"deck.gl "+n.layerName,source:m})}},4548:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{j:()=>makeLayerDemo});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(96540),_deck_gl_react__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(96864),react_map_gl_maplibre__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(29533),styled_components__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(16065),_docusaurus_theme_common__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(95293),_constants_defaults__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(11175),_codepen_automation__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(89323),react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(74848);const INITIAL_VIEW_STATE={longitude:-122.4,latitude:37.74,zoom:11,maxZoom:20,pitch:30,bearing:0},TOOLTIP_STYLE={padding:"4px",background:"rgba(0, 0, 0, 0.8)",color:"#fff",maxWidth:"300px",fontSize:"10px",zIndex:9},DemoPlaceholder=styled_components__WEBPACK_IMPORTED_MODULE_5__.Ay.div.withConfig({displayName:"demo-base__DemoPlaceholder",componentId:"sc-bhdrci-0"})(["height:50vh;min-height:200px;position:relative;margin-bottom:24px;@media screen and (max-width:768px){height:60vh;}"]),DemoContainer=styled_components__WEBPACK_IMPORTED_MODULE_5__.Ay.div.withConfig({displayName:"demo-base__DemoContainer",componentId:"sc-bhdrci-1"})(["height:50vh;min-height:200px;position:absolute;width:100%;left:0;top:0;overflow:hidden;@media screen and (max-width:768px){height:60vh;}"]),DemoSourceLink=styled_components__WEBPACK_IMPORTED_MODULE_5__.Ay.div.withConfig({displayName:"demo-base__DemoSourceLink",componentId:"sc-bhdrci-2"})(["position:absolute;top:0;right:0;padding:8px;background:var(--ifm-background-surface-color);margin:12px;box-shadow:0 2px 4px rgba(0,0,0,0.3);cursor:pointer;font-weight:bold;font-size:12px;&:hover{color:var(--ifm-color-primary);}svg{width:20px;vertical-align:middle;margin-right:4px;}"]);function evalObject(source,globals,output){return eval("(function evalObject(globals){\n    Object.assign(globalThis, globals);\n    "+(output?source+"\n      return {"+output.join(",")+"};":"return "+source+";")+"\n  })")(globals)}function makeLayerDemo(config){const{Layer:Layer,getTooltip:getTooltip,props:props,mapStyle:mapStyle=!0,initialViewState:initialViewState=INITIAL_VIEW_STATE,imports:imports}=config;config.initialViewState=initialViewState;const _getTooltip=getTooltip&&eval(getTooltip),styledGetTooltip=e=>{const t=_getTooltip&&_getTooltip(e);return t&&{text:t,style:TOOLTIP_STYLE}},layerProps=evalObject(props,imports);function Demo(){const{colorMode:e}=(0,_docusaurus_theme_common__WEBPACK_IMPORTED_MODULE_6__.G)(),t=new Layer(layerProps),n="dark"===e?_constants_defaults__WEBPACK_IMPORTED_MODULE_2__.Vi.DARK:_constants_defaults__WEBPACK_IMPORTED_MODULE_2__.Vi.LIGHT;return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(DemoPlaceholder,{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(DemoContainer,{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_deck_gl_react__WEBPACK_IMPORTED_MODULE_7__.A,{pickingRadius:5,initialViewState:initialViewState,getTooltip:styledGetTooltip,controller:!0,layers:[t],children:mapStyle&&(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_map_gl_maplibre__WEBPACK_IMPORTED_MODULE_1__.T5,{reuseMaps:!0,mapStyle:n})})}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(DemoSourceLink,{onClick:()=>(0,_codepen_automation__WEBPACK_IMPORTED_MODULE_3__.i)(config,t),children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path",{d:"M0 0h24v24H0V0z",fill:"none"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path",{fill:"currentcolor",d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"})]}),"Edit on Codepen"]})]})}return react__WEBPACK_IMPORTED_MODULE_0__.memo(Demo)}},23249:(e,t,n)=>{n.d(t,{C5:()=>S,EW:()=>b,Hc:()=>C,Mx:()=>x,T7:()=>L,Wm:()=>E,bY:()=>w,gX:()=>A,lX:()=>_,m2:()=>j,qi:()=>T,tI:()=>P,yA:()=>M});var i=n(8961),s=n(3346),o=n(48956),r=n(34651),a=n(84962),l=n(5397),c=n(78243),d=n(60192),h=n(21410),p=n(23010),u=n(10800),g=n(39738),f=n(80458),m=n(83667),v=n(4548),y=n(11175);const _=(0,v.j)({Layer:s.A,getTooltip:"({object}) => object && `${object.from.name} to ${object.to.name}`",props:"{\n    data: '"+y.Ut+"/bart-segments.json',\n    pickable: true,\n    getWidth: 12,\n    getSourcePosition: d => d.from.coordinates,\n    getTargetPosition: d => d.to.coordinates,\n    getSourceColor: d => [Math.sqrt(d.inbound), 140, 0],\n    getTargetColor: d => [Math.sqrt(d.outbound), 140, 0]\n  }"}),x=(0,v.j)({Layer:o.A,getTooltip:"({bitmap}) => bitmap && `${bitmap.pixel}`",props:"{\n    bounds: [-122.519, 37.7045, -122.355, 37.829],\n    image: '"+y.Ut+"/sf-districts.png',\n    pickable: true\n  }"}),w=(0,v.j)({Layer:r.A,getTooltip:"({object}) => object && `height: ${object.value * 5000}m`",props:"{\n    data: '"+y.Ut+"/hexagons.json',\n    diskResolution: 12,\n    radius: 250,\n    extruded: true,\n    pickable: true,\n    elevationScale: 5000,\n    getPosition: d => d.centroid,\n    getFillColor: d => [48, 128, d.value * 255, 255],\n    getLineColor: [0, 0, 0],\n    getLineWidth: 20,\n    getElevation: d => d.value\n  }"}),b=(0,v.j)({Layer:a.A,getTooltip:"({object}) => object && (object.properties.name || object.properties.station)",props:"{\n    data: '"+y.Ut+"/bart.geo.json',\n    pickable: true,\n    stroked: false,\n    filled: true,\n    extruded: true,\n    lineWidthMinPixels: 2,\n    pointType: 'circle+text',\n    pointRadiusUnits: 'pixels',\n    getText: f => f.properties.name,\n    getTextSize: 12,\n    getFillColor: [160, 160, 180, 200],\n    getLineColor: f => {\n      const hex = f.properties.color;\n      // convert to RGB\n      return hex ? hex.match(/[0-9a-f]{2}/g).map(x => parseInt(x, 16)) : [0, 0, 0];\n    },\n    getPointRadius: 4,\n    getLineWidth: 20,\n    getElevation: 30\n  }"}),P=(0,v.j)({Layer:l.A,getTooltip:"({object}) => object && `height: ${object.value * 5000}m`",props:"{\n    data: '"+y.Ut+"/hexagons.json',\n    pickable: true,\n    extruded: true,\n    cellSize: 200,\n    elevationScale: 5000,\n    getPosition: d => d.centroid,\n    getFillColor: d => [48, 128, d.value * 255, 255],\n    getElevation: d => d.value\n  }"}),S=(0,v.j)({Layer:c.A,getTooltip:"({object}) => object && `${object.name}\n${object.address}`",props:"{\n    data: '"+y.Ut+"/bart-stations.json',\n    pickable: true,\n    iconAtlas: '"+y.Ut+"/icon-atlas.png',\n    iconMapping: '"+y.Ut+"/icon-atlas.json',\n    getPosition: d => d.coordinates,\n    getIcon: d => 'marker',\n    getSize: 40,\n    getColor: d => [Math.sqrt(d.exits), 140, 0]\n  }"}),C=(0,v.j)({Layer:d.A,getTooltip:"({object}) => object && `${object.from.name} to ${object.to.name}`",props:"{\n    data: '"+y.Ut+"/bart-segments.json',\n    pickable: true,\n    getWidth: 12,\n    getSourcePosition: d => d.from.coordinates,\n    getTargetPosition: d => d.to.coordinates,\n    getColor: d => [Math.sqrt(d.inbound + d.outbound), 140, 0]\n  }"}),j=(0,v.j)({Layer:h.A,getTooltip:"({object}) => object && object.name",props:"{\n    data: '"+y.Ut+"/bart-lines.json',\n    parameters: {\n      depthMask: false\n    },\n    pickable: true,\n    widthMinPixels: 2,\n    getPath: d => d.path,\n    getColor: d => {\n      const hex = d.color;\n      // convert to RGB\n      return hex.match(/[0-9a-f]{2}/g).map(x => parseInt(x, 16));\n    },\n    getWidth: 100\n  }"}),A=(0,v.j)({Layer:p.A,getTooltip:"({object}) => object && object.position.join(', ')",imports:{COORDINATE_SYSTEM:i.rf},props:"{\n    data: '"+y.Ut+"/pointcloud.json',\n    pickable: true,\n    coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n    coordinateOrigin: [-122.4, 37.74],\n    pointSize: 2,\n    getPosition: d => d.position,\n    getNormal: d => d.normal,\n    getColor: d => d.color\n  }"}),L=(0,v.j)({Layer:u.A,getTooltip:"({object}) => object && `${object.zipcode}\nPopulation: ${object.population}`",props:"{\n    data: '"+y.Ut+"/sf-zipcodes.json',\n    pickable: true,\n\n    lineWidthMinPixels: 1,\n    getPolygon: d => d.contour,\n    getElevation: d => d.population / d.area / 10,\n    getFillColor: d => [d.population / d.area / 60, 140, 0],\n    getLineColor: [255, 255, 255],\n    getLineWidth: 20\n  }"}),M=(0,v.j)({Layer:g.A,getTooltip:"({object}) => object && `${object.zipcode}\nPopulation: ${object.population}`",props:"{\n    data: '"+y.Ut+"/sf-zipcodes.json',\n    pickable: true,\n    filled: true,\n    extruded: true,\n    wireframe: true,\n    getPolygon: d => d.contour,\n    getElevation: d => d.population / d.area / 10,\n    getFillColor: d => [d.population / d.area / 60, 140, 0],\n    getLineColor: [80, 80, 80]\n  }"}),T=(0,v.j)({Layer:f.A,getTooltip:"({object}) => object && `${object.name}\n${object.address}`",props:"{\n    data: '"+y.Ut+"/bart-stations.json',\n    pickable: true,\n    opacity: 0.8,\n    stroked: true,\n    radiusScale: 6,\n    radiusMinPixels: 1,\n    radiusMaxPixels: 100,\n    lineWidthMinPixels: 1,\n    getPosition: d => d.coordinates,\n    getRadius: d => Math.sqrt(d.exits),\n    getFillColor: [255, 140, 0],\n    getLineColor: [0, 0, 0]\n  }"}),E=(0,v.j)({Layer:m.A,getTooltip:"({object}) => object && `${object.name}\n${object.address}`",props:"{\n    data: '"+y.Ut+"/bart-stations.json',\n    pickable: true,\n    getPosition: d => d.coordinates,\n    getText: d => d.name,\n    getColor: [255, 128, 0],\n    getSize: 16,\n    getAngle: 0,\n    getTextAnchor: 'middle',\n    getAlignmentBaseline: 'center'\n  }"})},27962:(e,t,n)=>{n.d(t,{A:()=>x});var i=n(50948);const s=()=>{},o=2,r=3,a=e=>e,l=1;class c{constructor(e){this._onTransitionUpdate=e=>{const{time:t,settings:{interpolator:n,startProps:i,endProps:s,duration:o,easing:r}}=e,a=r(t/o),l=n.interpolateProps(i,s,a);this.propsInTransition=this.getControllerState(Object.assign({},this.props,l)).getViewportProps(),this.onViewStateChange({viewState:this.propsInTransition,oldViewState:this.props})},this.getControllerState=e.getControllerState,this.propsInTransition=null,this.transition=new i.A(e.timeline),this.onViewStateChange=e.onViewStateChange||s,this.onStateChange=e.onStateChange||s}finalize(){this.transition.cancel()}getViewportInTransition(){return this.propsInTransition}processViewStateChange(e){let t=!1;const n=this.props;if(this.props=e,!n||this._shouldIgnoreViewportChange(n,e))return!1;if(this._isTransitionEnabled(e)){let i=n;if(this.transition.inProgress){const{interruption:e,endProps:t}=this.transition.settings;i=Object.assign({},n,e===o?t:this.propsInTransition||n)}this._triggerTransition(i,e),t=!0}else this.transition.cancel();return t}updateTransition(){this.transition.update()}_isTransitionEnabled(e){const{transitionDuration:t,transitionInterpolator:n}=e;return(t>0||"auto"===t)&&Boolean(n)}_isUpdateDueToCurrentTransition(e){return!(!this.transition.inProgress||!this.propsInTransition)&&this.transition.settings.interpolator.arePropsEqual(e,this.propsInTransition)}_shouldIgnoreViewportChange(e,t){if(this.transition.inProgress){return this.transition.settings.interruption===r||this._isUpdateDueToCurrentTransition(t)}return!this._isTransitionEnabled(t)||t.transitionInterpolator.arePropsEqual(e,t)}_triggerTransition(e,t){const n=this.getControllerState(e),i=this.getControllerState(t).shortestPathFrom(n),s=t.transitionInterpolator,o=s.getDuration?s.getDuration(e,t):t.transitionDuration;if(0===o)return;const r=s.initializeProps(e,i);this.propsInTransition={};const c={duration:o,easing:t.transitionEasing||a,interpolator:s,interruption:t.transitionInterruption||l,startProps:r.start,endProps:r.end,onStart:t.onTransitionStart,onUpdate:this._onTransitionUpdate,onInterrupt:this._onTransitionEnd(t.onTransitionInterrupt),onEnd:this._onTransitionEnd(t.onTransitionEnd)};this.transition.start(c),this.onStateChange({inTransition:!0}),this.updateTransition()}_onTransitionEnd(e){return t=>{this.propsInTransition=null,this.onStateChange({inTransition:!1,isZooming:!1,isPanning:!1,isRotating:!1}),null==e||e(t)}}}var d=n(58662);const h={transitionDuration:0},p=e=>1-(1-e)*(1-e),u=["wheel"],g=["panstart","panmove","panend"],f=["pinchstart","pinchmove","pinchend"],m=["multipanstart","multipanmove","multipanend"],v=["dblclick"],y=["keydown"],_={};class x{constructor(e){this.state={},this._events={},this._interactionState={isDragging:!1},this._customEvents=[],this._eventStartBlocked=null,this._panMove=!1,this.invertPan=!1,this.dragMode="rotate",this.inertia=0,this.scrollZoom=!0,this.dragPan=!0,this.dragRotate=!0,this.doubleClickZoom=!0,this.touchZoom=!0,this.touchRotate=!1,this.keyboard=!0,this.transitionManager=new c(Object.assign({},e,{getControllerState:e=>new this.ControllerState(e),onViewStateChange:this._onTransition.bind(this),onStateChange:this._setInteractionState.bind(this)})),this.handleEvent=this.handleEvent.bind(this),this.eventManager=e.eventManager,this.onViewStateChange=e.onViewStateChange||(()=>{}),this.onStateChange=e.onStateChange||(()=>{}),this.makeViewport=e.makeViewport}set events(e){this.toggleEvents(this._customEvents,!1),this.toggleEvents(e,!0),this._customEvents=e,this.props&&this.setProps(this.props)}finalize(){for(const t in this._events){var e;if(this._events[t])null==(e=this.eventManager)||e.off(t,this.handleEvent)}this.transitionManager.finalize()}handleEvent(e){this._controllerState=void 0;const t=this._eventStartBlocked;switch(e.type){case"panstart":return!t&&this._onPanStart(e);case"panmove":return this._onPan(e);case"panend":return this._onPanEnd(e);case"pinchstart":return!t&&this._onPinchStart(e);case"pinchmove":return this._onPinch(e);case"pinchend":return this._onPinchEnd(e);case"multipanstart":return!t&&this._onMultiPanStart(e);case"multipanmove":return this._onMultiPan(e);case"multipanend":return this._onMultiPanEnd(e);case"dblclick":return this._onDoubleClick(e);case"wheel":return this._onWheel(e);case"keydown":return this._onKeyDown(e);default:return!1}}get controllerState(){return this._controllerState=this._controllerState||new this.ControllerState(Object.assign({makeViewport:this.makeViewport},this.props,this.state)),this._controllerState}getCenter(e){const{x:t,y:n}=this.props,{offsetCenter:i}=e;return[i.x-t,i.y-n]}isPointInBounds(e,t){const{width:n,height:i}=this.props;if(t&&t.handled)return!1;const s=e[0]>=0&&e[0]<=n&&e[1]>=0&&e[1]<=i;return s&&t&&t.stopPropagation(),s}isFunctionKeyPressed(e){const{srcEvent:t}=e;return Boolean(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)}isDragging(){return this._interactionState.isDragging||!1}blockEvents(e){const t=setTimeout((()=>{this._eventStartBlocked===t&&(this._eventStartBlocked=null)}),e);this._eventStartBlocked=t}setProps(e){e.dragMode&&(this.dragMode=e.dragMode),this.props=e,"transitionInterpolator"in e||(e.transitionInterpolator=this._getTransitionProps().transitionInterpolator),this.transitionManager.processViewStateChange(e);const{inertia:t}=e;this.inertia=Number.isFinite(t)?t:!0===t?300:0;const{scrollZoom:n=!0,dragPan:i=!0,dragRotate:s=!0,doubleClickZoom:o=!0,touchZoom:r=!0,touchRotate:a=!1,keyboard:l=!0}=e,c=Boolean(this.onViewStateChange);this.toggleEvents(u,c&&n),this.toggleEvents(g,c),this.toggleEvents(f,c&&(r||a)),this.toggleEvents(m,c&&a),this.toggleEvents(v,c&&o),this.toggleEvents(y,c&&l),this.scrollZoom=n,this.dragPan=i,this.dragRotate=s,this.doubleClickZoom=o,this.touchZoom=r,this.touchRotate=a,this.keyboard=l}updateTransition(){this.transitionManager.updateTransition()}toggleEvents(e,t){this.eventManager&&e.forEach((e=>{this._events[e]!==t&&(this._events[e]=t,t?this.eventManager.on(e,this.handleEvent):this.eventManager.off(e,this.handleEvent))}))}updateViewport(e,t,n){void 0===t&&(t=null),void 0===n&&(n={});const i=Object.assign({},e.getViewportProps(),t),s=this.controllerState!==e;if(this.state=e.getState(),this._setInteractionState(n),s){const e=this.controllerState&&this.controllerState.getViewportProps();this.onViewStateChange&&this.onViewStateChange({viewState:i,interactionState:this._interactionState,oldViewState:e,viewId:this.props.id})}}_onTransition(e){this.onViewStateChange(Object.assign({},e,{interactionState:this._interactionState,viewId:this.props.id}))}_setInteractionState(e){Object.assign(this._interactionState,e),this.onStateChange(this._interactionState)}_onPanStart(e){const t=this.getCenter(e);if(!this.isPointInBounds(t,e))return!1;let n=this.isFunctionKeyPressed(e)||e.rightButton||!1;(this.invertPan||"pan"===this.dragMode)&&(n=!n);const i=this.controllerState[n?"panStart":"rotateStart"]({pos:t});return this._panMove=n,this.updateViewport(i,h,{isDragging:!0}),!0}_onPan(e){return!!this.isDragging()&&(this._panMove?this._onPanMove(e):this._onPanRotate(e))}_onPanEnd(e){return!!this.isDragging()&&(this._panMove?this._onPanMoveEnd(e):this._onPanRotateEnd(e))}_onPanMove(e){if(!this.dragPan)return!1;const t=this.getCenter(e),n=this.controllerState.pan({pos:t});return this.updateViewport(n,h,{isDragging:!0,isPanning:!0}),!0}_onPanMoveEnd(e){const{inertia:t}=this;if(this.dragPan&&t&&e.velocity){const n=this.getCenter(e),i=[n[0]+e.velocityX*t/2,n[1]+e.velocityY*t/2],s=this.controllerState.pan({pos:i}).panEnd();this.updateViewport(s,Object.assign({},this._getTransitionProps(),{transitionDuration:t,transitionEasing:p}),{isDragging:!1,isPanning:!0})}else{const e=this.controllerState.panEnd();this.updateViewport(e,null,{isDragging:!1,isPanning:!1})}return!0}_onPanRotate(e){if(!this.dragRotate)return!1;const t=this.getCenter(e),n=this.controllerState.rotate({pos:t});return this.updateViewport(n,h,{isDragging:!0,isRotating:!0}),!0}_onPanRotateEnd(e){const{inertia:t}=this;if(this.dragRotate&&t&&e.velocity){const n=this.getCenter(e),i=[n[0]+e.velocityX*t/2,n[1]+e.velocityY*t/2],s=this.controllerState.rotate({pos:i}).rotateEnd();this.updateViewport(s,Object.assign({},this._getTransitionProps(),{transitionDuration:t,transitionEasing:p}),{isDragging:!1,isRotating:!0})}else{const e=this.controllerState.rotateEnd();this.updateViewport(e,null,{isDragging:!1,isRotating:!1})}return!0}_onWheel(e){if(!this.scrollZoom)return!1;const t=this.getCenter(e);if(!this.isPointInBounds(t,e))return!1;e.srcEvent.preventDefault();const{speed:n=.01,smooth:i=!1}=!0===this.scrollZoom?{}:this.scrollZoom,{delta:s}=e;let o=2/(1+Math.exp(-Math.abs(s*n)));s<0&&0!==o&&(o=1/o);const r=i?Object.assign({},this._getTransitionProps({around:t}),{transitionDuration:250}):h,a=this.controllerState.zoom({pos:t,scale:o});return this.updateViewport(a,r,{isZooming:!0,isPanning:!0}),!0}_onMultiPanStart(e){const t=this.getCenter(e);if(!this.isPointInBounds(t,e))return!1;const n=this.controllerState.rotateStart({pos:t});return this.updateViewport(n,h,{isDragging:!0}),!0}_onMultiPan(e){if(!this.touchRotate)return!1;if(!this.isDragging())return!1;const t=this.getCenter(e);t[0]-=e.deltaX;const n=this.controllerState.rotate({pos:t});return this.updateViewport(n,h,{isDragging:!0,isRotating:!0}),!0}_onMultiPanEnd(e){if(!this.isDragging())return!1;const{inertia:t}=this;if(this.touchRotate&&t&&e.velocityY){const n=this.getCenter(e),i=[n[0],n[1]+=e.velocityY*t/2],s=this.controllerState.rotate({pos:i});this.updateViewport(s,Object.assign({},this._getTransitionProps(),{transitionDuration:t,transitionEasing:p}),{isDragging:!1,isRotating:!0}),this.blockEvents(t)}else{const e=this.controllerState.rotateEnd();this.updateViewport(e,null,{isDragging:!1,isRotating:!1})}return!0}_onPinchStart(e){const t=this.getCenter(e);if(!this.isPointInBounds(t,e))return!1;const n=this.controllerState.zoomStart({pos:t}).rotateStart({pos:t});return _._startPinchRotation=e.rotation,_._lastPinchEvent=e,this.updateViewport(n,h,{isDragging:!0}),!0}_onPinch(e){if(!this.touchZoom&&!this.touchRotate)return!1;if(!this.isDragging())return!1;let t=this.controllerState;if(this.touchZoom){const{scale:n}=e,i=this.getCenter(e);t=t.zoom({pos:i,scale:n})}if(this.touchRotate){const{rotation:n}=e;t=t.rotate({deltaAngleX:_._startPinchRotation-n})}return this.updateViewport(t,h,{isDragging:!0,isPanning:this.touchZoom,isZooming:this.touchZoom,isRotating:this.touchRotate}),_._lastPinchEvent=e,!0}_onPinchEnd(e){if(!this.isDragging())return!1;const{inertia:t}=this,{_lastPinchEvent:n}=_;if(this.touchZoom&&t&&n&&e.scale!==n.scale){const i=this.getCenter(e);let s=this.controllerState.rotateEnd();const o=Math.log2(e.scale),r=(o-Math.log2(n.scale))/(e.deltaTime-n.deltaTime),a=Math.pow(2,o+r*t/2);s=s.zoom({pos:i,scale:a}).zoomEnd(),this.updateViewport(s,Object.assign({},this._getTransitionProps({around:i}),{transitionDuration:t,transitionEasing:p}),{isDragging:!1,isPanning:this.touchZoom,isZooming:this.touchZoom,isRotating:!1}),this.blockEvents(t)}else{const e=this.controllerState.zoomEnd().rotateEnd();this.updateViewport(e,null,{isDragging:!1,isPanning:!1,isZooming:!1,isRotating:!1})}return _._startPinchRotation=null,_._lastPinchEvent=null,!0}_onDoubleClick(e){if(!this.doubleClickZoom)return!1;const t=this.getCenter(e);if(!this.isPointInBounds(t,e))return!1;const n=this.isFunctionKeyPressed(e),i=this.controllerState.zoom({pos:t,scale:n?.5:2});return this.updateViewport(i,this._getTransitionProps({around:t}),{isZooming:!0,isPanning:!0}),this.blockEvents(100),!0}_onKeyDown(e){if(!this.keyboard)return!1;const t=this.isFunctionKeyPressed(e),{zoomSpeed:n,moveSpeed:i,rotateSpeedX:s,rotateSpeedY:o}=!0===this.keyboard?{}:this.keyboard,{controllerState:r}=this;let a;const l={};switch(e.srcEvent.code){case"Minus":a=t?r.zoomOut(n).zoomOut(n):r.zoomOut(n),l.isZooming=!0;break;case"Equal":a=t?r.zoomIn(n).zoomIn(n):r.zoomIn(n),l.isZooming=!0;break;case"ArrowLeft":t?(a=r.rotateLeft(s),l.isRotating=!0):(a=r.moveLeft(i),l.isPanning=!0);break;case"ArrowRight":t?(a=r.rotateRight(s),l.isRotating=!0):(a=r.moveRight(i),l.isPanning=!0);break;case"ArrowUp":t?(a=r.rotateUp(o),l.isRotating=!0):(a=r.moveUp(i),l.isPanning=!0);break;case"ArrowDown":t?(a=r.rotateDown(o),l.isRotating=!0):(a=r.moveDown(i),l.isPanning=!0);break;default:return!1}return this.updateViewport(a,this._getTransitionProps(),l),!0}_getTransitionProps(e){const{transition:t}=this;return t&&t.transitionInterpolator?e?Object.assign({},t,{transitionInterpolator:new d.A(Object.assign({},e,t.transitionInterpolator.opts,{makeViewport:this.controllerState.makeViewport}))}):t:h}}},67797:(e,t,n)=>{n.d(t,{A:()=>d,y:()=>c});var i=n(54901),s=n(27962),o=n(43221),r=n(73279),a=n(95238),l=n(58662);class c extends o.A{constructor(e){const{width:t,height:n,latitude:i,longitude:s,zoom:o,bearing:r=0,pitch:l=0,altitude:c=1.5,position:d=[0,0,0],maxZoom:h=20,minZoom:p=0,maxPitch:u=60,minPitch:g=0,startPanLngLat:f,startZoomLngLat:m,startRotatePos:v,startBearing:y,startPitch:_,startZoom:x,normalize:w=!0}=e;(0,a.A)(Number.isFinite(s)),(0,a.A)(Number.isFinite(i)),(0,a.A)(Number.isFinite(o)),super({width:t,height:n,latitude:i,longitude:s,zoom:o,bearing:r,pitch:l,altitude:c,maxZoom:h,minZoom:p,maxPitch:u,minPitch:g,normalize:w,position:d},{startPanLngLat:f,startZoomLngLat:m,startRotatePos:v,startBearing:y,startPitch:_,startZoom:x}),this.makeViewport=e.makeViewport}panStart(e){let{pos:t}=e;return this._getUpdatedState({startPanLngLat:this._unproject(t)})}pan(e){let{pos:t,startPos:n}=e;const i=this.getState().startPanLngLat||this._unproject(n);if(!i)return this;const s=this.makeViewport(this.getViewportProps()).panByPosition(i,t);return this._getUpdatedState(s)}panEnd(){return this._getUpdatedState({startPanLngLat:null})}rotateStart(e){let{pos:t}=e;return this._getUpdatedState({startRotatePos:t,startBearing:this.getViewportProps().bearing,startPitch:this.getViewportProps().pitch})}rotate(e){let{pos:t,deltaAngleX:n=0,deltaAngleY:i=0}=e;const{startRotatePos:s,startBearing:o,startPitch:r}=this.getState();if(!s||void 0===o||void 0===r)return this;let a;return a=t?this._getNewRotation(t,s,r,o):{bearing:o+n,pitch:r+i},this._getUpdatedState(a)}rotateEnd(){return this._getUpdatedState({startBearing:null,startPitch:null})}zoomStart(e){let{pos:t}=e;return this._getUpdatedState({startZoomLngLat:this._unproject(t),startZoom:this.getViewportProps().zoom})}zoom(e){let{pos:t,startPos:n,scale:s}=e,{startZoom:o,startZoomLngLat:r}=this.getState();if(r||(o=this.getViewportProps().zoom,r=this._unproject(n)||this._unproject(t)),!r)return this;const{maxZoom:a,minZoom:l}=this.getViewportProps();let c=o+Math.log2(s);c=(0,i.qE)(c,l,a);const d=this.makeViewport(Object.assign({},this.getViewportProps(),{zoom:c}));return this._getUpdatedState(Object.assign({zoom:c},d.panByPosition(r,t)))}zoomEnd(){return this._getUpdatedState({startZoomLngLat:null,startZoom:null})}zoomIn(e){return void 0===e&&(e=2),this._zoomFromCenter(e)}zoomOut(e){return void 0===e&&(e=2),this._zoomFromCenter(1/e)}moveLeft(e){return void 0===e&&(e=100),this._panFromCenter([e,0])}moveRight(e){return void 0===e&&(e=100),this._panFromCenter([-e,0])}moveUp(e){return void 0===e&&(e=100),this._panFromCenter([0,e])}moveDown(e){return void 0===e&&(e=100),this._panFromCenter([0,-e])}rotateLeft(e){return void 0===e&&(e=15),this._getUpdatedState({bearing:this.getViewportProps().bearing-e})}rotateRight(e){return void 0===e&&(e=15),this._getUpdatedState({bearing:this.getViewportProps().bearing+e})}rotateUp(e){return void 0===e&&(e=10),this._getUpdatedState({pitch:this.getViewportProps().pitch+e})}rotateDown(e){return void 0===e&&(e=10),this._getUpdatedState({pitch:this.getViewportProps().pitch-e})}shortestPathFrom(e){const t=e.getViewportProps(),n=Object.assign({},this.getViewportProps()),{bearing:i,longitude:s}=n;return Math.abs(i-t.bearing)>180&&(n.bearing=i<0?i+360:i-360),Math.abs(s-t.longitude)>180&&(n.longitude=s<0?s+360:s-360),n}applyConstraints(e){const{maxZoom:t,minZoom:n,zoom:s}=e;e.zoom=(0,i.qE)(s,n,t);const{maxPitch:o,minPitch:a,pitch:l}=e;e.pitch=(0,i.qE)(l,a,o);const{normalize:c=!0}=e;return c&&Object.assign(e,(0,r.CK)(e)),e}_zoomFromCenter(e){const{width:t,height:n}=this.getViewportProps();return this.zoom({pos:[t/2,n/2],scale:e})}_panFromCenter(e){const{width:t,height:n}=this.getViewportProps();return this.pan({startPos:[t/2,n/2],pos:[t/2+e[0],n/2+e[1]]})}_getUpdatedState(e){return new this.constructor(Object.assign({makeViewport:this.makeViewport},this.getViewportProps(),this.getState(),e))}_unproject(e){const t=this.makeViewport(this.getViewportProps());return e&&t.unproject(e)}_getNewRotation(e,t,n,s){const o=e[0]-t[0],r=e[1]-t[1],a=e[1],l=t[1],{width:c,height:d}=this.getViewportProps(),h=o/c;let p=0;r>0?Math.abs(d-l)>5&&(p=r/(l-d)*1.2):r<0&&l>5&&(p=1-a/l),p=(0,i.qE)(p,-1,1);const{minPitch:u,maxPitch:g}=this.getViewportProps();let f=n;return p>0?f=n+p*(g-n):p<0&&(f=n-p*(u-n)),{pitch:f,bearing:s+180*h}}}class d extends s.A{constructor(){super(...arguments),this.ControllerState=c,this.transition={transitionDuration:300,transitionInterpolator:new l.A({transitionProps:{compare:["longitude","latitude","zoom","bearing","pitch","position"],required:["longitude","latitude","zoom"]}})},this.dragMode="pan"}setProps(e){e.position=e.position||[0,0,0];const t=this.props;super.setProps(e);(!t||t.height!==e.height)&&this.updateViewport(new this.ControllerState(Object.assign({makeViewport:this.makeViewport},e,this.state)))}}},43221:(e,t,n)=>{n.d(t,{A:()=>i});class i{constructor(e,t){this._viewportProps=this.applyConstraints(e),this._state=t}getViewportProps(){return this._viewportProps}getState(){return this._state}}},95656:(e,t,n)=>{n.d(t,{A:()=>r,k:()=>o});var i=n(18120);let s={};function o(e){s=e}function r(e,t,n,o){i.A.level>0&&s[e]&&s[e].call(null,t,n,o)}},58035:(e,t,n)=>{n.d(t,{$:()=>r});const i=[255,255,255],s=1;let o=0;class r{constructor(e){void 0===e&&(e={}),this.type="ambient";const{color:t=i}=e,{intensity:n=s}=e;this.id=e.id||"ambient-"+o++,this.color=t,this.intensity=n}}},55207:(e,t,n)=>{n.d(t,{Z:()=>l});var i=n(87597);const s=[255,255,255],o=1,r=[0,0,-1];let a=0;class l{constructor(e){void 0===e&&(e={}),this.type="directional";const{color:t=s}=e,{intensity:n=o}=e,{direction:l=r}=e,{_shadow:c=!1}=e;this.id=e.id||"directional-"+a++,this.color=t,this.intensity=n,this.type="directional",this.direction=new i.P(l).normalize().toArray(),this.shadow=c}getProjectedLight(e){return this}}},55443:(e,t,n)=>{n.d(t,{A:()=>S});var i=n(58035),s=n(55207),o=n(31886),r=n(87597),a=n(44584);class l extends a.A{constructor(e,t){super(e,t);const n=e.createTexture({format:"rgba8unorm",width:1,height:1,sampler:{minFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}}),i=e.createTexture({format:"depth16unorm",width:1,height:1});this.fbo=e.createFramebuffer({id:"shadowmap",width:1,height:1,colorAttachments:[n],depthStencilAttachment:i})}delete(){this.fbo&&(this.fbo.destroy(),this.fbo=null)}getShadowMap(){return this.fbo.colorAttachments[0].texture}render(e){const t=this.fbo,n=this.device.canvasContext.cssToDeviceRatio(),i=e.viewports[0],s=i.width*n,o=i.height*n;s===t.width&&o===t.height||t.resize({width:s,height:o}),super.render(Object.assign({},e,{clearColor:[1,1,1,1],target:t,pass:"shadow"}))}getLayerParameters(e,t,n){return Object.assign({},e.props.parameters,{blend:!1,depthWriteEnabled:!0,depthCompare:"less-equal"})}shouldDrawLayer(e){return!1!==e.props.shadowEnabled}getShaderModuleProps(e,t,n){return{shadow:{project:n.project,drawToShadowMap:!0}}}}var c=n(8961),d=n(40281),h=n(63190),p=n(73279);const u="\nuniform shadowUniforms {\n  bool drawShadowMap;\n  bool useShadowMap;\n  vec4 color;\n  highp int lightId;\n  float lightCount;\n  mat4 viewProjectionMatrix0;\n  mat4 viewProjectionMatrix1;\n  vec4 projectCenter0;\n  vec4 projectCenter1;\n} shadow;\n",g="\n"+u+"\n\nconst int max_lights = 2;\n\nout vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  mat4 viewProjectionMatrices[max_lights];\n  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;\n  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;\n  vec4 projectCenters[max_lights];\n  projectCenters[0] = shadow.projectCenter0;\n  projectCenters[1] = shadow.projectCenter1;\n\n  if (shadow.drawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);\n  }\n  if (shadow.useShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow.lightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n\n",f="\n"+u+"\n\nconst int max_lights = 2;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\n\nin vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow.drawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow.useShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow.lightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow.color.a / shadow.lightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n\n",m=(0,h.A)((function(e){let{viewport:t,center:n}=e;return new o.k(t.viewProjectionMatrix).invert().transform(n)})),v=(0,h.A)((function(e){let{viewport:t,shadowMatrices:n}=e;const i=[],s=t.pixelUnprojectionMatrix,a=t.isGeospatial?void 0:1,l=[[0,0,a],[t.width,0,a],[0,t.height,a],[t.width,t.height,a],[0,0,-1],[t.width,0,-1],[0,t.height,-1],[t.width,t.height,-1]].map((e=>function(e,t){const[n,i,s]=e,o=(0,p.xJ)([n,i,s],t);if(Number.isFinite(s))return o;return[o[0],o[1],0]}(e,s)));for(const c of n){const e=c.clone().translate(new r.P(t.center).negate()),n=l.map((t=>e.transform(t))),s=(new o.k).ortho({left:Math.min(...n.map((e=>e[0]))),right:Math.max(...n.map((e=>e[0]))),bottom:Math.min(...n.map((e=>e[1]))),top:Math.max(...n.map((e=>e[1]))),near:Math.min(...n.map((e=>-e[2]))),far:Math.max(...n.map((e=>-e[2])))});i.push(s.multiplyRight(c))}return i})),y=[0,0,0,1],_=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0];const x={name:"shadow",dependencies:[d.A],vs:g,fs:f,inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    position = shadow_setVertexPosition(geometry.position);\n    ","fs:DECKGL_FILTER_COLOR":"\n    color = shadow_filterShadowColor(color);\n    "},getUniforms:function(e){const{shadowEnabled:t=!0,project:n}=e;if(!(t&&n&&e.shadowMatrices&&e.shadowMatrices.length))return{drawShadowMap:!1,useShadowMap:!1,shadow_uShadowMap0:e.dummyShadowMap,shadow_uShadowMap1:e.dummyShadowMap};const i=d.A.getUniforms(n),s=m({viewport:n.viewport,center:i.center}),o=[],a=v({shadowMatrices:e.shadowMatrices,viewport:n.viewport}).slice();for(let d=0;d<e.shadowMatrices.length;d++){const e=a[d],t=e.clone().translate(new r.P(n.viewport.center).negate());i.coordinateSystem===c.rf.LNGLAT&&i.projectionMode===c.Kx.WEB_MERCATOR?(a[d]=t,o[d]=s):(a[d]=e.clone().multiplyRight(_),o[d]=t.transform(s))}const l={drawShadowMap:Boolean(e.drawToShadowMap),useShadowMap:!!e.shadowMaps&&e.shadowMaps.length>0,color:e.shadowColor||y,lightId:e.shadowLightId||0,lightCount:e.shadowMatrices.length,shadow_uShadowMap0:e.dummyShadowMap,shadow_uShadowMap1:e.dummyShadowMap};for(let r=0;r<a.length;r++)l["viewProjectionMatrix"+r]=a[r],l["projectCenter"+r]=o[r];for(let r=0;r<2;r++)l["shadow_uShadowMap"+r]=e.shadowMaps&&e.shadowMaps[r]||e.dummyShadowMap;return l},uniformTypes:{drawShadowMap:"f32",useShadowMap:"f32",color:"vec4<f32>",lightId:"i32",lightCount:"f32",viewProjectionMatrix0:"mat4x4<f32>",viewProjectionMatrix1:"mat4x4<f32>",projectCenter0:"vec4<f32>",projectCenter1:"vec4<f32>"}},w={color:[255,255,255],intensity:1},b=[{color:[255,255,255],intensity:1,direction:[-1,3,-1]},{color:[255,255,255],intensity:.9,direction:[1,-8,-2.5]}],P=[0,0,0,200/255];class S{constructor(e){void 0===e&&(e={}),this.id="lighting-effect",this.shadowColor=P,this.shadow=!1,this.directionalLights=[],this.pointLights=[],this.shadowPasses=[],this.dummyShadowMap=null,this.setProps(e)}setup(e){this.context=e;const{device:t,deck:n}=e;this.shadow&&!this.dummyShadowMap&&(this._createShadowPasses(t),n._addDefaultShaderModule(x),this.dummyShadowMap=t.createTexture({width:1,height:1}))}setProps(e){this.ambientLight=void 0,this.directionalLights=[],this.pointLights=[];for(const t in e){const n=e[t];switch(n.type){case"ambient":this.ambientLight=n;break;case"directional":this.directionalLights.push(n);break;case"point":this.pointLights.push(n)}}this._applyDefaultLights(),this.shadow=this.directionalLights.some((e=>e.shadow)),this.context&&this.setup(this.context),this.props=e}preRender(e){let{layers:t,layerFilter:n,viewports:i,onViewportActive:s,views:o}=e;if(this.shadow){this.shadowMatrices=this._calculateMatrices();for(let e=0;e<this.shadowPasses.length;e++){this.shadowPasses[e].render({layers:t,layerFilter:n,viewports:i,onViewportActive:s,views:o,shaderModuleProps:{shadow:{shadowLightId:e,dummyShadowMap:this.dummyShadowMap,shadowMatrices:this.shadowMatrices}}})}}}getShaderModuleProps(e,t){const n=this.shadow?{project:t.project,shadowMaps:this.shadowPasses.map((e=>e.getShadowMap())),dummyShadowMap:this.dummyShadowMap,shadowColor:this.shadowColor,shadowMatrices:this.shadowMatrices}:{},i={enabled:!0,ambientLight:this.ambientLight,directionalLights:this.directionalLights.map((t=>t.getProjectedLight({layer:e}))),pointLights:this.pointLights.map((t=>t.getProjectedLight({layer:e})))},s=e.props.material;return{shadow:n,lighting:i,phongMaterial:s,gouraudMaterial:s}}cleanup(e){for(const t of this.shadowPasses)t.delete();this.shadowPasses.length=0,this.dummyShadowMap&&(this.dummyShadowMap.destroy(),this.dummyShadowMap=null,e.deck._removeDefaultShaderModule(x))}_calculateMatrices(){const e=[];for(const t of this.directionalLights){const n=(new o.k).lookAt({eye:new r.P(t.direction).negate()});e.push(n)}return e}_createShadowPasses(e){for(let t=0;t<this.directionalLights.length;t++){const n=new l(e);this.shadowPasses[t]=n}}_applyDefaultLights(){const{ambientLight:e,pointLights:t,directionalLights:n}=this;e||0!==t.length||0!==n.length||(this.ambientLight=new i.$(w),this.directionalLights.push(new s.Z(b[0]),new s.Z(b[1])))}}},1570:(e,t,n)=>{n.d(t,{A:()=>B});var i=n(26839),s=n(72246);const o=s.h1;function r(e,t,n){const i="webgpu"===n&&"uint8"===t.type?"unorm8":t.type;return{attribute:e,format:t.size>1?i+"x"+t.size:t.type,byteOffset:t.offset||0}}function a(e){return e.stride||e.size*e.bytesPerElement}var l=n(81052),c=n(87350),d=n(18120);function h(e,t){t.offset&&d.A.removed("shaderAttribute.offset","vertexOffset, elementOffset")();const n=a(e),i=(void 0!==t.vertexOffset?t.vertexOffset:e.vertexOffset||0)*n+(t.elementOffset||0)*e.bytesPerElement+(e.offset||0);return Object.assign({},t,{offset:i,stride:n})}class p{constructor(e,t,n){this._buffer=null,this.device=e,this.id=t.id||"",this.size=t.size||1;const i=t.logicalType||t.type,o="float64"===i;let r,{defaultValue:a}=t;a=Number.isFinite(a)?[a]:a||new Array(this.size).fill(0),r=o?"float32":!i&&t.isIndexed?"uint32":i||"float32";let l=function(e){switch(e){case"float64":return Float64Array;case"uint8":case"unorm8":return Uint8ClampedArray;default:return(0,s.Ak)(e)}}(i||r);this.doublePrecision=o,o&&!1===t.fp64&&(l=Float32Array),this.value=null,this.settings=Object.assign({},t,{defaultType:l,defaultValue:a,logicalType:i,type:r,normalized:r.includes("norm"),size:this.size,bytesPerElement:l.BYTES_PER_ELEMENT}),this.state=Object.assign({},n,{externalBuffer:null,bufferAccessor:this.settings,allocatedValue:null,numInstances:0,bounds:null,constant:!1})}get isConstant(){return this.state.constant}get buffer(){return this._buffer}get byteOffset(){const e=this.getAccessor();return e.vertexOffset?e.vertexOffset*a(e):0}get numInstances(){return this.state.numInstances}set numInstances(e){this.state.numInstances=e}delete(){this._buffer&&(this._buffer.delete(),this._buffer=null),l.A.release(this.state.allocatedValue)}getBuffer(){return this.state.constant?null:this.state.externalBuffer||this._buffer}getValue(e,t){void 0===e&&(e=this.id),void 0===t&&(t=null);const n={};if(this.state.constant){const i=this.value;if(t){const s=h(this.getAccessor(),t),o=s.offset/i.BYTES_PER_ELEMENT,r=s.size||this.size;n[e]=i.subarray(o,o+r)}else n[e]=i}else n[e]=this.getBuffer();return this.doublePrecision&&(this.value instanceof Float64Array?n[e+"64Low"]=n[e]:n[e+"64Low"]=new Float32Array(this.size)),n}_getBufferLayout(e,t){void 0===e&&(e=this.id),void 0===t&&(t=null);const n=this.getAccessor(),i=[],s={name:this.id,byteStride:a(n),attributes:i};if(this.doublePrecision){const s=function(e,t){const n=h(e,t);return{high:n,low:Object.assign({},n,{offset:n.offset+4*e.size})}}(n,t||{});i.push(r(e,Object.assign({},n,s.high),this.device.type),r(e+"64Low",Object.assign({},n,s.low),this.device.type))}else if(t){const s=h(n,t);i.push(r(e,Object.assign({},n,s),this.device.type))}else i.push(r(e,n,this.device.type));return s}setAccessor(e){this.state.bufferAccessor=e}getAccessor(){return this.state.bufferAccessor}getBounds(){if(this.state.bounds)return this.state.bounds;let e=null;if(this.state.constant&&this.value){const t=Array.from(this.value);e=[t,t]}else{const{value:t,numInstances:n,size:i}=this,s=n*i;if(t&&s&&t.length>=s){const n=new Array(i).fill(1/0),o=new Array(i).fill(-1/0);for(let e=0;e<s;)for(let s=0;s<i;s++){const i=t[e++];i<n[s]&&(n[s]=i),i>o[s]&&(o[s]=i)}e=[n,o]}}return this.state.bounds=e,e}setData(e){const{state:t}=this;let n;n=ArrayBuffer.isView(e)?{value:e}:e instanceof i.h?{buffer:e}:e;const s=Object.assign({},this.settings,n);if(ArrayBuffer.isView(n.value)){if(!n.type){if(this.doublePrecision&&n.value instanceof Float64Array)s.type="float32";else{const e=o(n.value);s.type=s.normalized?e.replace("int","norm"):e}}s.bytesPerElement=n.value.BYTES_PER_ELEMENT,s.stride=a(s)}if(t.bounds=null,n.constant){let e=n.value;e=this._normalizeValue(e,[],0),this.settings.normalized&&(e=this.normalizeConstant(e));if(!(!t.constant||!this._areValuesEqual(e,this.value)))return!1;t.externalBuffer=null,t.constant=!0,this.value=ArrayBuffer.isView(e)?e:new Float32Array(e)}else if(n.buffer){const e=n.buffer;t.externalBuffer=e,t.constant=!1,this.value=n.value||null}else if(n.value){this._checkExternalBuffer(n);let e=n.value;t.externalBuffer=null,t.constant=!1,this.value=e;let{buffer:i}=this;const o=a(s),r=(s.vertexOffset||0)*o;if(this.doublePrecision&&e instanceof Float64Array&&(e=(0,c.cT)(e,s)),this.settings.isIndexed){const t=this.settings.defaultType;e.constructor!==t&&(e=new t(e))}const l=e.byteLength+r+2*o;(!i||i.byteLength<l)&&(i=this._createBuffer(l)),i.write(e,r)}return this.setAccessor(s),!0}updateSubBuffer(e){void 0===e&&(e={}),this.state.bounds=null;const t=this.value,{startOffset:n=0,endOffset:i}=e;this.buffer.write(this.doublePrecision&&t instanceof Float64Array?(0,c.cT)(t,{size:this.size,startIndex:n,endIndex:i}):t.subarray(n,i),n*t.BYTES_PER_ELEMENT+this.byteOffset)}allocate(e,t){void 0===t&&(t=!1);const{state:n}=this,i=n.allocatedValue,s=l.A.allocate(i,e+1,{size:this.size,type:this.settings.defaultType,copy:t});this.value=s;const{byteOffset:o}=this;let{buffer:r}=this;return(!r||r.byteLength<s.byteLength+o)&&(r=this._createBuffer(s.byteLength+o),t&&i&&r.write(i instanceof Float64Array?(0,c.cT)(i,this):i,o)),n.allocatedValue=s,n.constant=!1,n.externalBuffer=null,this.setAccessor(this.settings),!0}_checkExternalBuffer(e){const{value:t}=e;if(!ArrayBuffer.isView(t))throw new Error("Attribute "+this.id+" value is not TypedArray");const n=this.settings.defaultType;let i=!1;if(this.doublePrecision&&(i=t.BYTES_PER_ELEMENT<4),i)throw new Error("Attribute "+this.id+" does not support "+t.constructor.name);t instanceof n||!this.settings.normalized||"normalized"in e||d.A.warn("Attribute "+this.id+" is normalized")()}normalizeConstant(e){switch(this.settings.type){case"snorm8":return new Float32Array(e).map((e=>(e+128)/255*2-1));case"snorm16":return new Float32Array(e).map((e=>(e+32768)/65535*2-1));case"unorm8":return new Float32Array(e).map((e=>e/255));case"unorm16":return new Float32Array(e).map((e=>e/65535));default:return e}}_normalizeValue(e,t,n){const{defaultValue:i,size:s}=this.settings;if(Number.isFinite(e))return t[n]=e,t;if(!e){let e=s;for(;--e>=0;)t[n+e]=i[e];return t}switch(s){case 4:t[n+3]=Number.isFinite(e[3])?e[3]:i[3];case 3:t[n+2]=Number.isFinite(e[2])?e[2]:i[2];case 2:t[n+1]=Number.isFinite(e[1])?e[1]:i[1];case 1:t[n+0]=Number.isFinite(e[0])?e[0]:i[0];break;default:let o=s;for(;--o>=0;)t[n+o]=Number.isFinite(e[o])?e[o]:i[o]}return t}_areValuesEqual(e,t){if(!e||!t)return!1;const{size:n}=this;for(let i=0;i<n;i++)if(e[i]!==t[i])return!1;return!0}_createBuffer(e){var t;this._buffer&&this._buffer.destroy();const{isIndexed:n,type:s}=this.settings;return this._buffer=this.device.createBuffer(Object.assign({},null==(t=this._buffer)?void 0:t.props,{id:this.id,usage:(n?i.h.INDEX:i.h.VERTEX)|i.h.COPY_DST,indexType:n?s:void 0,byteLength:e})),this._buffer}}var u=n(95238),g=n(33698),f=n(13696);const m=[],v=[[0,1/0]];var y=n(39976);class _ extends p{constructor(e,t){super(e,t,{startIndices:null,lastExternalBuffer:null,binaryValue:null,binaryAccessor:null,needsUpdate:!0,needsRedraw:!1,layoutChanged:!1,updateRanges:v}),this.constant=!1,this.settings.update=t.update||(t.accessor?this._autoUpdater:void 0),Object.seal(this.settings),Object.seal(this.state),this._validateAttributeUpdaters()}get startIndices(){return this.state.startIndices}set startIndices(e){this.state.startIndices=e}needsUpdate(){return this.state.needsUpdate}needsRedraw(e){let{clearChangedFlags:t=!1}=void 0===e?{}:e;const n=this.state.needsRedraw;return this.state.needsRedraw=n&&!t,n}layoutChanged(){return this.state.layoutChanged}setAccessor(e){var t,n,i;(t=this.state).layoutChanged||(t.layoutChanged=(n=e,i=this.getAccessor(),!(n.type===i.type&&n.size===i.size&&a(n)===a(i)&&(n.offset||0)===(i.offset||0)))),super.setAccessor(e)}getUpdateTriggers(){const{accessor:e}=this.settings;return[this.id].concat("function"!=typeof e&&e||[])}supportsTransition(){return Boolean(this.settings.transition)}getTransitionSetting(e){if(!e||!this.supportsTransition())return null;const{accessor:t}=this.settings,n=this.settings.transition,i=Array.isArray(t)?e[t.find((t=>e[t]))]:e[t];return(0,y.K)(i,n)}setNeedsUpdate(e,t){if(void 0===e&&(e=this.id),this.state.needsUpdate=this.state.needsUpdate||e,this.setNeedsRedraw(e),t){const{startRow:e=0,endRow:n=1/0}=t;this.state.updateRanges=function(e,t){if(e===v)return e;if(t[0]<0&&(t[0]=0),t[0]>=t[1])return e;const n=[],i=e.length;let s=0;for(let o=0;o<i;o++){const i=e[o];i[1]<t[0]?(n.push(i),s=o+1):i[0]>t[1]?n.push(i):t=[Math.min(i[0],t[0]),Math.max(i[1],t[1])]}return n.splice(s,0,t),n}(this.state.updateRanges,[e,n])}else this.state.updateRanges=v}clearNeedsUpdate(){this.state.needsUpdate=!1,this.state.updateRanges=m}setNeedsRedraw(e){void 0===e&&(e=this.id),this.state.needsRedraw=this.state.needsRedraw||e}allocate(e){const{state:t,settings:n}=this;return!n.noAlloc&&(!!n.update&&(super.allocate(e,t.updateRanges!==v),!0))}updateBuffer(e){let{numInstances:t,data:n,props:i,context:s}=e;if(!this.needsUpdate())return!1;const{state:{updateRanges:o},settings:{update:r,noAlloc:a}}=this;let l=!0;if(r){for(const[e,a]of o)r.call(s,this,{data:n,startRow:e,endRow:a,props:i,numInstances:t});if(this.value)if(this.constant||!this.buffer||this.buffer.byteLength<this.value.byteLength+this.byteOffset)this.setData({value:this.value,constant:this.constant}),this.constant=!1;else for(const[e,n]of o){const i=Number.isFinite(e)?this.getVertexOffset(e):0,s=Number.isFinite(n)?this.getVertexOffset(n):a||!Number.isFinite(t)?this.value.length:t*this.size;super.updateSubBuffer({startOffset:i,endOffset:s})}else;this._checkAttributeArray()}else l=!1;return this.clearNeedsUpdate(),this.setNeedsRedraw(),l}setConstantValue(e,t){const n="webgpu"===this.device.type;if(n||void 0===t||"function"==typeof t){if(n&&"function"!=typeof t){const e=this._normalizeValue(t,[],0);this._areValuesEqual(e,this.value)||this.setNeedsUpdate("WebGPU constant updated")}return!1}const i=this.settings.transform&&e?this.settings.transform.call(e,t):t;return this.setData({constant:!0,value:i})&&this.setNeedsRedraw(),this.clearNeedsUpdate(),!0}setExternalBuffer(e){const{state:t}=this;return e?(this.clearNeedsUpdate(),t.lastExternalBuffer===e||(t.lastExternalBuffer=e,this.setNeedsRedraw(),this.setData(e)),!0):(t.lastExternalBuffer=null,!1)}setBinaryValue(e,t){void 0===t&&(t=null);const{state:n,settings:i}=this;if(!e)return n.binaryValue=null,n.binaryAccessor=null,!1;if(i.noAlloc)return!1;if(n.binaryValue===e)return this.clearNeedsUpdate(),!0;n.binaryValue=e,this.setNeedsRedraw();if(i.transform||t!==this.startIndices){ArrayBuffer.isView(e)&&(e={value:e});const s=e;(0,u.A)(ArrayBuffer.isView(s.value),"invalid "+i.accessor);const o=Boolean(s.size)&&s.size!==this.size;return n.binaryAccessor=(0,g.I)(s.value,{size:s.size||this.size,stride:s.stride,offset:s.offset,startIndices:t,nested:o}),!1}return this.clearNeedsUpdate(),this.setData(e),!0}getVertexOffset(e){const{startIndices:t}=this;return(t?e<t.length?t[e]:this.numInstances:e)*this.size}getValue(){const e=this.settings.shaderAttributes,t=super.getValue();if(!e)return t;for(const n in e)Object.assign(t,super.getValue(n,e[n]));return t}getBufferLayout(e){this.state.layoutChanged=!1;const t=this.settings.shaderAttributes,n=super._getBufferLayout(),{stepMode:i}=this.settings;if(n.stepMode="dynamic"===i?e?e.isInstanced?"instance":"vertex":"instance":null!=i?i:"vertex",!t)return n;for(const s in t){const e=super._getBufferLayout(s,t[s]);n.attributes.push(...e.attributes)}return n}_autoUpdater(e,t){let{data:n,startRow:i,endRow:s,props:o,numInstances:r}=t;if(e.constant&&"webgpu"!==this.context.device.type)return;const{settings:a,state:l,value:c,size:d,startIndices:h}=e,{accessor:p,transform:m}=a;let v=l.binaryAccessor||("function"==typeof p?p:o[p]);"function"!=typeof v&&"string"==typeof p&&(v=()=>o[p]),(0,u.A)("function"==typeof v,'accessor "'+p+'" is not a function');let y=e.getVertexOffset(i);const{iterable:_,objectInfo:x}=(0,g.X)(n,i,s);for(const u of _){x.index++;let t=v(u,x);if(m&&(t=m.call(this,t)),h){const n=(x.index<h.length-1?h[x.index+1]:r)-h[x.index];if(t&&Array.isArray(t[0])){let n=y;for(const i of t)e._normalizeValue(i,c,n),n+=d}else t&&t.length>d?c.set(t,y):(e._normalizeValue(t,x.target,0),(0,f.R)({target:c,source:x.target,start:y,count:n}));y+=n*d}else e._normalizeValue(t,c,y),y+=d}}_validateAttributeUpdaters(){const{settings:e}=this;if(!(e.noAlloc||"function"==typeof e.update))throw new Error("Attribute "+this.id+" missing update or accessor")}_checkAttributeArray(){const{value:e}=this,t=Math.min(4,this.size);if(e&&e.length>=t){let n=!0;switch(t){case 4:n=n&&Number.isFinite(e[3]);case 3:n=n&&Number.isFinite(e[2]);case 2:n=n&&Number.isFinite(e[1]);case 1:n=n&&Number.isFinite(e[0]);break;default:n=!1}if(!n)throw new Error("Illegal attribute generated for "+this.id)}}}var x=n(63190),w=n(95656),b=n(68475),P=n(22454);function S(e){const{source:t,target:n,start:i=0,size:s,getData:o}=e,r=e.end||n.length,a=t.length,l=r-i;if(a>l)return void n.set(t.subarray(0,l),i);if(n.set(t,i),!o)return;let c=a;for(;c<l;){const e=o(c,t);for(let t=0;t<s;t++)n[i+c]=e[t]||0,c++}}function C(e){switch(e){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";default:throw new Error('No defined attribute type for size "'+e+'"')}}function j(e){switch(e){case 1:return"float32";case 2:return"float32x2";case 3:return"float32x3";case 4:return"float32x4";default:throw new Error("invalid type size")}}function A(e){e.push(e.shift())}function L(e){let{device:t,source:n,target:i}=e;var s;(!i||i.byteLength<n.byteLength)&&(null==(s=i)||s.destroy(),i=t.createBuffer({byteLength:n.byteLength,usage:n.usage}));return i}function M(e){let{device:t,buffer:n,attribute:i,fromLength:s,toLength:o,fromStartIndices:r,getData:a=e=>e}=e;const l=i.doublePrecision&&i.value instanceof Float64Array?2:1,c=i.size*l,d=i.byteOffset,h=i.settings.bytesPerElement<4?d/i.settings.bytesPerElement*4:d,p=i.startIndices,u=r&&p,g=i.isConstant;if(!u&&n&&s>=o)return n;const f=i.value instanceof Float64Array?Float32Array:i.value.constructor,m=g?i.value:new f(i.getBuffer().readSyncWebGL(d,o*f.BYTES_PER_ELEMENT).buffer);if(i.settings.normalized&&!g){const e=a;a=(t,n)=>i.normalizeConstant(e(t,n))}const v=g?(e,t)=>a(m,t):(e,t)=>a(m.subarray(e+d,e+d+c),t),y=n?new Float32Array(n.readSyncWebGL(h,4*s).buffer):new Float32Array(0),_=new Float32Array(o);var x;(function(e){let{source:t,target:n,size:i,getData:s,sourceStartIndices:o,targetStartIndices:r}=e;if(!o||!r)return S({source:t,target:n,size:i,getData:s}),n;let a=0,l=0;const c=s&&((e,t)=>s(e+l,t)),d=Math.min(o.length,r.length);for(let h=1;h<d;h++){const e=o[h]*i,s=r[h]*i;S({source:t.subarray(a,e),target:n,start:l,end:s,size:i,getData:c}),a=e,l=s}l<n.length&&S({source:[],target:n,start:l,size:i,getData:c})}({source:y,target:_,sourceStartIndices:r,targetStartIndices:p,size:c,getData:v}),!n||n.byteLength<_.byteLength+h)&&(null==(x=n)||x.destroy(),n=t.createBuffer({byteLength:_.byteLength+h,usage:35050}));return n.write(_,h),n}var T=n(50948);class E{constructor(e){let{device:t,attribute:n,timeline:i}=e;this.buffers=[],this.currentLength=0,this.device=t,this.transition=new T.A(i),this.attribute=n,this.attributeInTransition=function(e){const{device:t,settings:n,value:i}=e,s=new _(t,n);return s.setData({value:i instanceof Float64Array?new Float64Array(0):new Float32Array(0),normalized:n.normalized}),s}(n),this.currentStartIndices=n.startIndices}get inProgress(){return this.transition.inProgress}start(e,t,n){void 0===n&&(n=1/0),this.settings=e,this.currentStartIndices=this.attribute.startIndices,this.currentLength=function(e,t){const{doublePrecision:n,settings:i,value:s,size:o}=e,r=n&&s instanceof Float64Array?2:1;let a=0;const{shaderAttributes:l}=e.settings;if(l)for(const d of Object.values(l)){var c;a=Math.max(a,null!=(c=d.vertexOffset)?c:0)}return(i.noAlloc?s.length:(t+a)*o)*r}(this.attribute,t),this.transition.start(Object.assign({},e,{duration:n}))}update(){const e=this.transition.update();return e&&this.onUpdate(),e}setBuffer(e){this.attributeInTransition.setData({buffer:e,normalized:this.attribute.settings.normalized,value:this.attributeInTransition.value})}cancel(){this.transition.cancel()}delete(){this.cancel();for(const e of this.buffers)e.destroy();this.buffers.length=0}}const O={name:"interpolation",vs:"uniform interpolationUniforms {\n  float time;\n} interpolation;\n",uniformTypes:{time:"f32"}},I="#version 300 es\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nin ATTRIBUTE_TYPE aFrom;\nin ATTRIBUTE_TYPE aTo;\nout ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, interpolation.time);\n  gl_Position = vec4(0.0);\n}\n",R="#version 300 es\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nin ATTRIBUTE_TYPE aFrom;\nin ATTRIBUTE_TYPE aFrom64Low;\nin ATTRIBUTE_TYPE aTo;\nin ATTRIBUTE_TYPE aTo64Low;\nout ATTRIBUTE_TYPE vCurrent;\nout ATTRIBUTE_TYPE vCurrent64Low;\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid main(void) {\n  for (int i=0; i<ATTRIBUTE_SIZE; i++) {\n    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);\n    vCurrent[i] = value.x;\n    vCurrent64Low[i] = value.y;\n  }\n  gl_Position = vec4(0.0);\n}\n";function k(e){return e.doublePrecision&&e.value instanceof Float64Array}const z={name:"spring",vs:"uniform springUniforms {\n  float damping;\n  float stiffness;\n} spring;\n",uniformTypes:{damping:"f32",stiffness:"f32"}},D="#version 300 es\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nin ATTRIBUTE_TYPE aPrev;\nin ATTRIBUTE_TYPE aCur;\nin ATTRIBUTE_TYPE aTo;\nout ATTRIBUTE_TYPE vNext;\nout float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE force = delta * spring.stiffness;\n  ATTRIBUTE_TYPE resistance = velocity * spring.damping;\n  return force - resistance + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",F="#version 300 es\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nin float vIsTransitioningFlag;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  fragColor = vec4(1.0);\n}";const U={interpolation:class extends E{constructor(e){let{device:t,attribute:n,timeline:i}=e;super({device:t,attribute:n,timeline:i}),this.type="interpolation",this.transform=function(e,t){const n=t.size,i=C(n),s=j(n),o=t.getBufferLayout();if(k(t))return new b.p(e,{vs:R,bufferLayout:[{name:"aFrom",byteStride:8*n,attributes:[{attribute:"aFrom",format:s,byteOffset:0},{attribute:"aFrom64Low",format:s,byteOffset:4*n}]},{name:"aTo",byteStride:8*n,attributes:[{attribute:"aTo",format:s,byteOffset:0},{attribute:"aTo64Low",format:s,byteOffset:4*n}]}],modules:[P.dI,O],defines:{ATTRIBUTE_TYPE:i,ATTRIBUTE_SIZE:n},moduleSettings:{},varyings:["vCurrent","vCurrent64Low"],bufferMode:35980,disableWarnings:!0});return new b.p(e,{vs:I,bufferLayout:[{name:"aFrom",format:s},{name:"aTo",format:o.attributes[0].format}],modules:[O],defines:{ATTRIBUTE_TYPE:i},varyings:["vCurrent"],disableWarnings:!0})}(t,n)}start(e,t){const n=this.currentLength,i=this.currentStartIndices;if(super.start(e,t,e.duration),e.duration<=0)return void this.transition.cancel();const{buffers:s,attribute:o}=this;A(s),s[0]=M({device:this.device,buffer:s[0],attribute:o,fromLength:n,toLength:this.currentLength,fromStartIndices:i,getData:e.enter}),s[1]=L({device:this.device,source:s[0],target:s[1]}),this.setBuffer(s[1]);const{transform:r}=this,a=r.model;let l=Math.floor(this.currentLength/o.size);k(o)&&(l/=2),a.setVertexCount(l),o.isConstant?(a.setAttributes({aFrom:s[0]}),a.setConstantAttributes({aTo:o.value})):a.setAttributes({aFrom:s[0],aTo:o.getBuffer()}),r.transformFeedback.setBuffers({vCurrent:s[1]})}onUpdate(){const{duration:e,easing:t}=this.settings,{time:n}=this.transition;let i=n/e;t&&(i=t(i));const{model:s}=this.transform,o={time:i};s.shaderInputs.setProps({interpolation:o}),this.transform.run({discard:!0})}delete(){super.delete(),this.transform.destroy()}},spring:class extends E{constructor(e){let{device:t,attribute:n,timeline:i}=e;super({device:t,attribute:n,timeline:i}),this.type="spring",this.texture=function(e){return e.createTexture({data:new Uint8Array(4),format:"rgba8unorm",width:1,height:1})}(t),this.framebuffer=function(e,t){return e.createFramebuffer({id:"spring-transition-is-transitioning-framebuffer",width:1,height:1,colorAttachments:[t]})}(t,this.texture),this.transform=function(e,t){const n=C(t.size),i=j(t.size);return new b.p(e,{vs:D,fs:F,bufferLayout:[{name:"aPrev",format:i},{name:"aCur",format:i},{name:"aTo",format:t.getBufferLayout().attributes[0].format}],varyings:["vNext"],modules:[z],defines:{ATTRIBUTE_TYPE:n},parameters:{depthCompare:"always",blendColorOperation:"max",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaOperation:"max",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"}})}(t,n)}start(e,t){const n=this.currentLength,i=this.currentStartIndices;super.start(e,t);const{buffers:s,attribute:o}=this;for(let a=0;a<2;a++)s[a]=M({device:this.device,buffer:s[a],attribute:o,fromLength:n,toLength:this.currentLength,fromStartIndices:i,getData:e.enter});s[2]=L({device:this.device,source:s[0],target:s[2]}),this.setBuffer(s[1]);const{model:r}=this.transform;r.setVertexCount(Math.floor(this.currentLength/o.size)),o.isConstant?r.setConstantAttributes({aTo:o.value}):r.setAttributes({aTo:o.getBuffer()})}onUpdate(){const{buffers:e,transform:t,framebuffer:n,transition:i}=this,s=this.settings;t.model.setAttributes({aPrev:e[0],aCur:e[1]}),t.transformFeedback.setBuffers({vNext:e[2]});const o={stiffness:s.stiffness,damping:s.damping};t.model.shaderInputs.setProps({spring:o}),t.run({framebuffer:n,discard:!1,parameters:{viewport:[0,0,1,1]},clearColor:[0,0,0,0]}),A(e),this.setBuffer(e[1]);this.device.readPixelsToArrayWebGL(n)[0]>0||i.end()}delete(){super.delete(),this.transform.destroy(),this.texture.destroy(),this.framebuffer.destroy()}}};class V{constructor(e,t){let{id:n,timeline:i}=t;if(!e)throw new Error("AttributeTransitionManager is constructed without device");this.id=n,this.device=e,this.timeline=i,this.transitions={},this.needsRedraw=!1,this.numInstances=1}finalize(){for(const e in this.transitions)this._removeTransition(e)}update(e){let{attributes:t,transitions:n,numInstances:i}=e;this.numInstances=i||1;for(const s in t){const e=t[s],i=e.getTransitionSetting(n);i&&this._updateAttribute(s,e,i)}for(const s in this.transitions){const e=t[s];e&&e.getTransitionSetting(n)||this._removeTransition(s)}}hasAttribute(e){const t=this.transitions[e];return t&&t.inProgress}getAttributes(){const e={};for(const t in this.transitions){const n=this.transitions[t];n.inProgress&&(e[t]=n.attributeInTransition)}return e}run(){if(0===this.numInstances)return!1;for(const t in this.transitions){this.transitions[t].update()&&(this.needsRedraw=!0)}const e=this.needsRedraw;return this.needsRedraw=!1,e}_removeTransition(e){this.transitions[e].delete(),delete this.transitions[e]}_updateAttribute(e,t,n){const i=this.transitions[e];let s=!i||i.type!==n.type;if(s){i&&this._removeTransition(e);const o=U[n.type];o?this.transitions[e]=new o({attribute:t,timeline:this.timeline,device:this.device}):(d.A.error("unsupported transition type '"+n.type+"'")(),s=!1)}(s||t.needsRedraw())&&(this.needsRedraw=!0,this.transitions[e].start(n,this.numInstances))}}const N="attributeManager.invalidate";class B{constructor(e,t){let{id:n="attribute-manager",stats:i,timeline:s}=void 0===t?{}:t;this.mergeBoundsMemoized=(0,x.A)(c._Z),this.id=n,this.device=e,this.attributes={},this.updateTriggers={},this.needsRedraw=!0,this.userData={},this.stats=i,this.attributeTransitionManager=new V(e,{id:n+"-transitions",timeline:s}),Object.seal(this)}finalize(){for(const e in this.attributes)this.attributes[e].delete();this.attributeTransitionManager.finalize()}getNeedsRedraw(e){void 0===e&&(e={clearRedrawFlags:!1});const t=this.needsRedraw;return this.needsRedraw=this.needsRedraw&&!e.clearRedrawFlags,t&&this.id}setNeedsRedraw(){this.needsRedraw=!0}add(e){this._add(e)}addInstanced(e){this._add(e,{stepMode:"instance"})}remove(e){for(const t of e)void 0!==this.attributes[t]&&(this.attributes[t].delete(),delete this.attributes[t])}invalidate(e,t){const n=this._invalidateTrigger(e,t);(0,w.A)(N,this,e,n)}invalidateAll(e){for(const t in this.attributes)this.attributes[t].setNeedsUpdate(t,e);(0,w.A)(N,this,"all")}update(e){let{data:t,numInstances:n,startIndices:i=null,transitions:s,props:o={},buffers:r={},context:a={}}=e,l=!1;(0,w.A)("attributeManager.updateStart",this),this.stats&&this.stats.get("Update Attributes").timeStart();for(const c in this.attributes){const e=this.attributes[c],s=e.settings.accessor;e.startIndices=i,e.numInstances=n,o[c]&&d.A.removed("props."+c,"data.attributes."+c)(),e.setExternalBuffer(r[c])||e.setBinaryValue("string"==typeof s?r[s]:void 0,t.startIndices)||"string"==typeof s&&!r[s]&&e.setConstantValue(a,o[s])||e.needsUpdate()&&(l=!0,this._updateAttribute({attribute:e,numInstances:n,data:t,props:o,context:a})),this.needsRedraw=this.needsRedraw||e.needsRedraw()}l&&(0,w.A)("attributeManager.updateEnd",this,n),this.stats&&this.stats.get("Update Attributes").timeEnd(),this.attributeTransitionManager.update({attributes:this.attributes,numInstances:n,transitions:s})}updateTransition(){const{attributeTransitionManager:e}=this,t=e.run();return this.needsRedraw=this.needsRedraw||t,t}getAttributes(){return Object.assign({},this.attributes,this.attributeTransitionManager.getAttributes())}getBounds(e){const t=e.map((e=>{var t;return null==(t=this.attributes[e])?void 0:t.getBounds()}));return this.mergeBoundsMemoized(t)}getChangedAttributes(e){void 0===e&&(e={clearChangedFlags:!1});const{attributes:t,attributeTransitionManager:n}=this,i=Object.assign({},n.getAttributes());for(const s in t){const o=t[s];o.needsRedraw(e)&&!n.hasAttribute(s)&&(i[s]=o)}return i}getBufferLayouts(e){return Object.values(this.getAttributes()).map((t=>t.getBufferLayout(e)))}_add(e,t){for(const n in e){const i=e[n],s=Object.assign({},i,{id:n,size:(i.isIndexed?1:i.size)||1},t);this.attributes[n]=new _(this.device,s)}this._mapUpdateTriggersToAttributes()}_mapUpdateTriggersToAttributes(){const e={};for(const t in this.attributes){this.attributes[t].getUpdateTriggers().forEach((n=>{e[n]||(e[n]=[]),e[n].push(t)}))}this.updateTriggers=e}_invalidateTrigger(e,t){const{attributes:n,updateTriggers:i}=this,s=i[e];return s&&s.forEach((e=>{const i=n[e];i&&i.setNeedsUpdate(i.id,t)})),s}_updateAttribute(e){const{attribute:t,numInstances:n}=e;if((0,w.A)("attribute.updateStart",t),t.constant)return void t.setConstantValue(e.context,t.value);t.allocate(n)&&(0,w.A)("attribute.allocate",t,n);t.updateBuffer(e)&&(this.needsRedraw=!0,(0,w.A)("attribute.updateEnd",t,n))}}},39976:(e,t,n)=>{n.d(t,{K:()=>s});const i={interpolation:{duration:0,easing:e=>e},spring:{stiffness:.05,damping:.5}};function s(e,t){if(!e)return null;Number.isFinite(e)&&(e={type:"interpolation",duration:e});const n=e.type||"interpolation";return Object.assign({},i[n],t,e,{type:n})}},33847:(e,t,n)=>{n.d(t,{A:()=>l});var i=n(3002),s=n(95656),o=n(13696),r=n(95958);class a extends i.A{get isComposite(){return!0}get isDrawable(){return!1}get isLoaded(){return super.isLoaded&&this.getSubLayers().every((e=>e.isLoaded))}getSubLayers(){return this.internalState&&this.internalState.subLayers||[]}initializeState(e){}setState(e){super.setState(e),this.setNeedsUpdate()}getPickingInfo(e){let{info:t}=e;const{object:n}=t;return n&&n.__source&&n.__source.parent&&n.__source.parent.id===this.id?(t.object=n.__source.object,t.index=n.__source.index,t):t}filterSubLayer(e){return!0}shouldRenderSubLayer(e,t){return t&&t.length}getSubLayerClass(e,t){const{_subLayerProps:n}=this.props;return n&&n[e]&&n[e].type||t}getSubLayerRow(e,t,n){return e.__source={parent:this,object:t,index:n},e}getSubLayerAccessor(e){if("function"==typeof e){const t={index:-1,data:this.props.data,target:[]};return(n,i)=>n&&n.__source?(t.index=n.__source.index,e(n.__source.object,t)):e(n,i)}return e}getSubLayerProps(e){var t;void 0===e&&(e={});const{opacity:n,pickable:i,visible:s,parameters:o,getPolygonOffset:a,highlightedObjectIndex:l,autoHighlight:c,highlightColor:d,coordinateSystem:h,coordinateOrigin:p,wrapLongitude:u,positionFormat:g,modelMatrix:f,extensions:m,fetch:v,operation:y,_subLayerProps:_}=this.props,x={id:"",updateTriggers:{},opacity:n,pickable:i,visible:s,parameters:o,getPolygonOffset:a,highlightedObjectIndex:l,autoHighlight:c,highlightColor:d,coordinateSystem:h,coordinateOrigin:p,wrapLongitude:u,positionFormat:g,modelMatrix:f,extensions:m,fetch:v,operation:y},w=_&&e.id&&_[e.id],b=w&&w.updateTriggers,P=e.id||"sublayer";if(w){const t=this.props[r.fW],n=e.type?e.type._propTypes:{};for(const e in w){const i=n[e]||t[e];i&&"accessor"===i.type&&(w[e]=this.getSubLayerAccessor(w[e]))}}Object.assign(x,e,w),x.id=this.props.id+"-"+P,x.updateTriggers=Object.assign({all:null==(t=this.props.updateTriggers)?void 0:t.all},e.updateTriggers,b);for(const r of m){const e=r.getSubLayerProps.call(this,r);e&&Object.assign(x,e,{updateTriggers:Object.assign(x.updateTriggers,e.updateTriggers)})}return x}_updateAutoHighlight(e){for(const t of this.getSubLayers())t.updateAutoHighlight(e)}_getAttributeManager(){return null}_postUpdate(e,t){let n=this.internalState.subLayers;const i=!n||this.needsUpdate();if(i){const e=this.renderLayers();n=(0,o.B)(e,Boolean),this.internalState.subLayers=n}(0,s.A)("compositeLayer.renderLayers",this,i,n);for(const s of n)s.parent=this}}a.layerName="CompositeLayer";const l=a},8961:(e,t,n)=>{n.d(t,{Kx:()=>r,We:()=>c,p5:()=>a,rf:()=>o,tg:()=>l});var i=n(18120),s=n(7853);const o={DEFAULT:-1,LNGLAT:1,METER_OFFSETS:2,LNGLAT_OFFSETS:3,CARTESIAN:0};Object.defineProperty(o,"IDENTITY",{get:()=>(i.A.deprecated("COORDINATE_SYSTEM.IDENTITY","COORDINATE_SYSTEM.CARTESIAN")(),0)});const r={WEB_MERCATOR:1,GLOBE:2,WEB_MERCATOR_AUTO_OFFSET:4,IDENTITY:0},a={common:0,meters:1,pixels:2},l={click:"onClick",dblclick:"onClick",panstart:"onDragStart",panmove:"onDrag",panend:"onDragEnd"},c={multipan:[s.uq,{threshold:10,direction:s.e8.Vertical,pointers:2}],pinch:[s.h1,{},null,["multipan"]],pan:[s.uq,{threshold:1},["pinch"],["multipan"]],dblclick:[s.Cx,{event:"dblclick",taps:2}],click:[s.Cx,{event:"click"},null,["dblclick"]]}},36378:(e,t,n)=>{n.d(t,{A:()=>oe});var i=n(3726),s=n(3189);const o=[n(64458).A],r=["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)","vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)","vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)","fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"],a=[];function l(e){const t=s._.getDefaultShaderAssembler();for(const i of o)t.addDefaultModule(i);t._hookFunctions.length=0;const n="glsl"===e?r:a;for(const i of n)t.addShaderHook(i);return t}const c="uniform layerUniforms {\n  uniform float opacity;\n} layer;\n",d={name:"layer",vs:c,fs:c,getUniforms:e=>({opacity:Math.pow(e.opacity,1/2.2)}),uniformTypes:{opacity:"f32"}};var h=n(95958),p=n(18120),u=n(95656),g=n(13696),f=n(97983),m=n(327);class v{constructor(e,t,n){this._loadCount=0,this._subscribers=new Set,this.id=e,this.context=n,this.setData(t)}subscribe(e){this._subscribers.add(e)}unsubscribe(e){this._subscribers.delete(e)}inUse(){return this._subscribers.size>0}delete(){}getData(){return this.isLoaded?this._error?Promise.reject(this._error):this._content:this._loader.then((()=>this.getData()))}setData(e,t){if(e===this._data&&!t)return;this._data=e;const n=++this._loadCount;let i=e;"string"==typeof e&&(i=(0,m.H)(e)),i instanceof Promise?(this.isLoaded=!1,this._loader=i.then((e=>{this._loadCount===n&&(this.isLoaded=!0,this._error=void 0,this._content=e)})).catch((e=>{this._loadCount===n&&(this.isLoaded=!0,this._error=e||!0)}))):(this.isLoaded=!0,this._error=void 0,this._content=e);for(const s of this._subscribers)s.onChange(this.getData())}}class y{constructor(e){var t;this.protocol=e.protocol||"resource://",this._context={device:e.device,gl:null==(t=e.device)?void 0:t.gl,resourceManager:this},this._resources={},this._consumers={},this._pruneRequest=null}contains(e){return!!e.startsWith(this.protocol)||e in this._resources}add(e){let{resourceId:t,data:n,forceUpdate:i=!1,persistent:s=!0}=e,o=this._resources[t];o?o.setData(n,i):(o=new v(t,n,this._context),this._resources[t]=o),o.persistent=s}remove(e){const t=this._resources[e];t&&(t.delete(),delete this._resources[e])}unsubscribe(e){let{consumerId:t}=e;const n=this._consumers[t];if(n){for(const e in n){const t=n[e],i=this._resources[t.resourceId];i&&i.unsubscribe(t)}delete this._consumers[t],this.prune()}}subscribe(e){let{resourceId:t,onChange:n,consumerId:i,requestId:s="default"}=e;const{_resources:o,protocol:r}=this;t.startsWith(r)&&(t=t.replace(r,""),o[t]||this.add({resourceId:t,data:null,persistent:!1}));const a=o[t];if(this._track(i,s,a,n),a)return a.getData()}prune(){this._pruneRequest||(this._pruneRequest=setTimeout((()=>this._prune()),0))}finalize(){for(const e in this._resources)this._resources[e].delete()}_track(e,t,n,i){const s=this._consumers,o=s[e]=s[e]||{};let r=o[t];const a=r&&r.resourceId&&this._resources[r.resourceId];a&&(a.unsubscribe(r),this.prune()),n&&(r?(r.onChange=i,r.resourceId=n.id):r={onChange:i,resourceId:n.id},o[t]=r,n.subscribe(r))}_prune(){this._pruneRequest=null;for(const e of Object.keys(this._resources)){const t=this._resources[e];t.persistent||t.inUse()||(t.delete(),delete this._resources[e])}}}var _=n(43976);class x{constructor(e,t){var n;this._lastRenderedLayers=[],this._needsRedraw=!1,this._needsUpdate=!1,this._nextLayers=null,this._debug=!1,this._defaultShaderModulesChanged=!1,this.activateViewport=e=>{(0,u.A)("layerManager.activateViewport",this,e),e&&(this.context.viewport=e)};const{deck:s,stats:o,viewport:r,timeline:a}=t||{};this.layers=[],this.resourceManager=new y({device:e,protocol:"deck://"}),this.context={mousePosition:null,userData:{},layerManager:this,device:e,gl:null==e?void 0:e.gl,deck:s,shaderAssembler:l((null==e||null==(n=e.info)?void 0:n.shadingLanguage)||"glsl"),defaultShaderModules:[d],renderPass:void 0,stats:o||new f.A({id:"deck.gl"}),viewport:r||new _.A({id:"DEFAULT-INITIAL-VIEWPORT"}),timeline:a||new i.K,resourceManager:this.resourceManager,onError:void 0},Object.seal(this)}finalize(){this.resourceManager.finalize();for(const e of this.layers)this._finalizeLayer(e)}needsRedraw(e){void 0===e&&(e={clearRedrawFlags:!1});let t=this._needsRedraw;e.clearRedrawFlags&&(this._needsRedraw=!1);for(const n of this.layers){const i=n.getNeedsRedraw(e);t=t||i}return t}needsUpdate(){return this._nextLayers&&this._nextLayers!==this._lastRenderedLayers?"layers changed":this._defaultShaderModulesChanged?"shader modules changed":this._needsUpdate}setNeedsRedraw(e){this._needsRedraw=this._needsRedraw||e}setNeedsUpdate(e){this._needsUpdate=this._needsUpdate||e}getLayers(e){let{layerIds:t}=void 0===e?{}:e;return t?this.layers.filter((e=>t.find((t=>0===e.id.indexOf(t))))):this.layers}setProps(e){"debug"in e&&(this._debug=e.debug),"userData"in e&&(this.context.userData=e.userData),"layers"in e&&(this._nextLayers=e.layers),"onError"in e&&(this.context.onError=e.onError)}setLayers(e,t){(0,u.A)("layerManager.setLayers",this,t,e),this._lastRenderedLayers=e;const n=(0,g.B)(e,Boolean);for(const i of n)i.context=this.context;this._updateLayers(this.layers,n)}updateLayers(){const e=this.needsUpdate();e&&(this.setNeedsRedraw("updating layers: "+e),this.setLayers(this._nextLayers||this._lastRenderedLayers,e)),this._nextLayers=null}addDefaultShaderModule(e){const{defaultShaderModules:t}=this.context;t.find((t=>t.name===e.name))||(t.push(e),this._defaultShaderModulesChanged=!0)}removeDefaultShaderModule(e){const{defaultShaderModules:t}=this.context,n=t.findIndex((t=>t.name===e.name));n>=0&&(t.splice(n,1),this._defaultShaderModulesChanged=!0)}_handleError(e,t,n){n.raiseError(t,e+" of "+n)}_updateLayers(e,t){const n={};for(const o of e)n[o.id]?p.A.warn("Multiple old layers with same id "+o.id)():n[o.id]=o;if(this._defaultShaderModulesChanged){for(const t of e)t.setNeedsUpdate(),t.setChangeFlags({extensionsChanged:!0});this._defaultShaderModulesChanged=!1}const i=[];this._updateSublayersRecursively(t,n,i),this._finalizeOldLayers(n);let s=!1;for(const o of i)if(o.hasUniformTransition()){s="Uniform transition in "+o;break}this._needsUpdate=s,this.layers=i}_updateSublayersRecursively(e,t,n){for(const s of e){s.context=this.context;const e=t[s.id];null===e&&p.A.warn("Multiple new layers with same id "+s.id)(),t[s.id]=null;let o=null;try{this._debug&&e!==s&&s.validateProps(),e?(this._transferLayerState(e,s),this._updateLayer(s)):this._initializeLayer(s),n.push(s),o=s.isComposite?s.getSubLayers():null}catch(i){this._handleError("matching",i,s)}o&&this._updateSublayersRecursively(o,t,n)}}_finalizeOldLayers(e){for(const t in e){const n=e[t];n&&this._finalizeLayer(n)}}_initializeLayer(e){try{e._initialize(),e.lifecycle=h.VD.INITIALIZED}catch(t){this._handleError("initialization",t,e)}}_transferLayerState(e,t){t._transferState(e),t.lifecycle=h.VD.MATCHED,t!==e&&(e.lifecycle=h.VD.AWAITING_GC)}_updateLayer(e){try{e._update()}catch(t){this._handleError("update",t,e)}}_finalizeLayer(e){this._needsRedraw=this._needsRedraw||"finalized "+e,e.lifecycle=h.VD.AWAITING_FINALIZATION;try{e._finalize(),e.lifecycle=h.VD.FINALIZED}catch(t){this._handleError("finalization",t,e)}}}var w=n(50111);class b{constructor(e){this.views=[],this.width=100,this.height=100,this.viewState={},this.controllers={},this.timeline=e.timeline,this._viewports=[],this._viewportMap={},this._isUpdating=!1,this._needsRedraw="First render",this._needsUpdate="Initialize",this._eventManager=e.eventManager,this._eventCallbacks={onViewStateChange:e.onViewStateChange,onInteractionStateChange:e.onInteractionStateChange},Object.seal(this),this.setProps(e)}finalize(){for(const e in this.controllers){const t=this.controllers[e];t&&t.finalize()}this.controllers={}}needsRedraw(e){void 0===e&&(e={clearRedrawFlags:!1});const t=this._needsRedraw;return e.clearRedrawFlags&&(this._needsRedraw=!1),t}setNeedsUpdate(e){this._needsUpdate=this._needsUpdate||e,this._needsRedraw=this._needsRedraw||e}updateViewStates(){for(const e in this.controllers){const t=this.controllers[e];t&&t.updateTransition()}}getViewports(e){return e?this._viewports.filter((t=>t.containsPixel(e))):this._viewports}getViews(){const e={};return this.views.forEach((t=>{e[t.id]=t})),e}getView(e){return this.views.find((t=>t.id===e))}getViewState(e){const t="string"==typeof e?this.getView(e):e,n=t&&this.viewState[t.getViewStateId()]||this.viewState;return t?t.filterViewState(n):n}getViewport(e){return this._viewportMap[e]}unproject(e,t){const n=this.getViewports(),i={x:e[0],y:e[1]};for(let s=n.length-1;s>=0;--s){const o=n[s];if(o.containsPixel(i)){const n=e.slice();return n[0]-=o.x,n[1]-=o.y,o.unproject(n,t)}}return null}setProps(e){e.views&&this._setViews(e.views),e.viewState&&this._setViewState(e.viewState),("width"in e||"height"in e)&&this._setSize(e.width,e.height),this._isUpdating||this._update()}_update(){this._isUpdating=!0,this._needsUpdate&&(this._needsUpdate=!1,this._rebuildViewports()),this._needsUpdate&&(this._needsUpdate=!1,this._rebuildViewports()),this._isUpdating=!1}_setSize(e,t){e===this.width&&t===this.height||(this.width=e,this.height=t,this.setNeedsUpdate("Size changed"))}_setViews(e){e=(0,g.B)(e,Boolean);this._diffViews(e,this.views)&&this.setNeedsUpdate("views changed"),this.views=e}_setViewState(e){if(e){!(0,w.b)(e,this.viewState,3)&&this.setNeedsUpdate("viewState changed"),this.viewState=e}else p.A.warn("missing `viewState` or `initialViewState`")()}_createController(e,t){return new(0,t.type)({timeline:this.timeline,eventManager:this._eventManager,onViewStateChange:this._eventCallbacks.onViewStateChange,onStateChange:this._eventCallbacks.onInteractionStateChange,makeViewport:t=>{var n;return null==(n=this.getView(e.id))?void 0:n.makeViewport({viewState:t,width:this.width,height:this.height})}})}_updateController(e,t,n,i){const s=e.controller;if(s&&n){const o=Object.assign({},t,s,{id:e.id,x:n.x,y:n.y,width:n.width,height:n.height});return i&&i.constructor===s.type||(i=this._createController(e,o)),i&&i.setProps(o),i}return null}_rebuildViewports(){const{views:e}=this,t=this.controllers;this._viewports=[],this.controllers={};let n=!1;for(let i=e.length;i--;){const s=e[i],o=this.getViewState(s),r=s.makeViewport({viewState:o,width:this.width,height:this.height});let a=t[s.id];const l=Boolean(s.controller);l&&!a&&(n=!0),!n&&l||!a||(a.finalize(),a=null),this.controllers[s.id]=this._updateController(s,o,r,a),r&&this._viewports.unshift(r)}for(const i in t){const e=t[i];e&&!this.controllers[i]&&e.finalize()}this._buildViewportMap()}_buildViewportMap(){this._viewportMap={},this._viewports.forEach((e=>{e.id&&(this._viewportMap[e.id]=this._viewportMap[e.id]||e)}))}_diffViews(e,t){return e.length!==t.length||e.some(((n,i)=>!e[i].equals(t[i])))}}var P=n(63201),S=n(55443);const C=new S.A;class j{constructor(e){this._resolvedEffects=[],this._defaultEffects=[],this.effects=[],this._context=e,this._needsRedraw="Initial render",this._setEffects([])}addDefaultEffect(e){const t=this._defaultEffects;if(!t.find((t=>t.id===e.id))){const n=t.findIndex((t=>{return n=e,(null!=(i=t.order)?i:1/0)-(null!=(s=n.order)?s:1/0)>0;var n,i,s}));n<0?t.push(e):t.splice(n,0,e),e.setup(this._context),this._setEffects(this.effects)}}setProps(e){"effects"in e&&((0,w.b)(e.effects,this.effects,1)||this._setEffects(e.effects))}needsRedraw(e){void 0===e&&(e={clearRedrawFlags:!1});const t=this._needsRedraw;return e.clearRedrawFlags&&(this._needsRedraw=!1),t}getEffects(){return this._resolvedEffects}_setEffects(e){const t={};for(const i of this.effects)t[i.id]=i;const n=[];for(const i of e){const e=t[i.id];let s=i;e&&e!==i?e.setProps?(e.setProps(i.props),s=e):e.cleanup(this._context):e||i.setup(this._context),n.push(s),delete t[i.id]}for(const i in t)t[i].cleanup(this._context);this.effects=n,this._resolvedEffects=n.concat(this._defaultEffects),e.some((e=>e instanceof S.A))||this._resolvedEffects.push(C),this._needsRedraw="effects changed"}finalize(){for(const e of this._resolvedEffects)e.cleanup(this._context);this.effects.length=0,this._resolvedEffects.length=0,this._defaultEffects.length=0}}var A=n(44584);class L extends A.A{shouldDrawLayer(e){const{operation:t}=e.props;return t.includes("draw")||t.includes("terrain")}}var M=n(78218);class T{constructor(e){this.device=e,this.layerFilter=null,this.drawPickingColors=!1,this.drawLayersPass=new L(e),this.pickLayersPass=new M.A(e),this.renderCount=0,this._needsRedraw="Initial render",this.renderBuffers=[],this.lastPostProcessEffect=null}setProps(e){this.layerFilter!==e.layerFilter&&(this.layerFilter=e.layerFilter,this._needsRedraw="layerFilter changed"),this.drawPickingColors!==e.drawPickingColors&&(this.drawPickingColors=e.drawPickingColors,this._needsRedraw="drawPickingColors changed")}renderLayers(e){if(!e.viewports.length)return;const t=this.drawPickingColors?this.pickLayersPass:this.drawLayersPass,n=Object.assign({layerFilter:this.layerFilter,isPicking:this.drawPickingColors},e);n.effects&&this._preRender(n.effects,n);const i=this.lastPostProcessEffect?this.renderBuffers[0]:n.target;this.lastPostProcessEffect&&(n.clearColor=[0,0,0,0],n.clearCanvas=!0);const s=t.render(Object.assign({},n,{target:i}));n.effects&&(this.lastPostProcessEffect&&(n.clearCanvas=void 0===e.clearCanvas||e.clearCanvas),this._postRender(n.effects,n)),this.renderCount++,(0,u.A)("deckRenderer.renderLayers",this,s,e)}needsRedraw(e){void 0===e&&(e={clearRedrawFlags:!1});const t=this._needsRedraw;return e.clearRedrawFlags&&(this._needsRedraw=!1),t}finalize(){const{renderBuffers:e}=this;for(const t of e)t.delete();e.length=0}_preRender(e,t){this.lastPostProcessEffect=null,t.preRenderStats=t.preRenderStats||{};for(const n of e)t.preRenderStats[n.id]=n.preRender(t),n.postRender&&(this.lastPostProcessEffect=n.id);this.lastPostProcessEffect&&this._resizeRenderBuffers()}_resizeRenderBuffers(){const{renderBuffers:e}=this,t=this.device.canvasContext.getDrawingBufferSize(),[n,i]=t;0===e.length&&[0,1].map((t=>{const s=this.device.createTexture({sampler:{minFilter:"linear",magFilter:"linear"},width:n,height:i});e.push(this.device.createFramebuffer({id:"deck-renderbuffer-"+t,colorAttachments:[s]}))}));for(const s of e)s.resize(t)}_postRender(e,t){const{renderBuffers:n}=this,i=Object.assign({},t,{inputBuffer:n[0],swapBuffer:n[1]});for(const s of e)if(s.postRender){i.target=s.id===this.lastPostProcessEffect?t.target:void 0;const e=s.postRender(i);i.inputBuffer=e,i.swapBuffer=e===n[0]?n[1]:n[0]}}}const E={pickedColor:null,pickedObjectIndex:-1};function O(e){let{pickedColors:t,decodePickingColor:n,deviceX:i,deviceY:s,deviceRadius:o,deviceRect:r}=e;const{x:a,y:l,width:c,height:d}=r;let h=o*o,u=-1,g=0;for(let p=0;p<d;p++){const e=p+l-s,n=e*e;if(n>h)g+=4*c;else for(let s=0;s<c;s++){if(t[g+3]-1>=0){const e=s+a-i,t=e*e+n;t<=h&&(h=t,u=g)}g+=4}}if(u>=0){const e=t.slice(u,u+4),i=n(e);if(i){const t=Math.floor(u/4/c),n=u/4-t*c;return Object.assign({},i,{pickedColor:e,pickedX:a+n,pickedY:l+t})}p.A.error("Picked non-existent layer. Is picking buffer corrupt?")()}return E}function I(e){let{pickedColors:t,decodePickingColor:n}=e;const i=new Map;if(t)for(let s=0;s<t.length;s+=4){if(t[s+3]-1>=0){const e=t.slice(s,s+4),o=e.join(",");if(!i.has(o)){const t=n(e);t?i.set(o,Object.assign({},t,{color:e})):p.A.error("Picked non-existent layer. Is picking buffer corrupt?")()}}}return Array.from(i.values())}function R(e){let t,{pickInfo:n,viewports:i,pixelRatio:s,x:o,y:r,z:a}=e,l=i[0];if(i.length>1&&(l=function(e,t){for(let n=e.length-1;n>=0;n--){const i=e[n];if(i.containsPixel(t))return i}return e[0]}((null==n?void 0:n.pickedViewports)||i,{x:o,y:r})),l){const e=[o-l.x,r-l.y];void 0!==a&&(e[2]=a),t=l.unproject(e)}return{color:null,layer:null,viewport:l,index:-1,picked:!1,x:o,y:r,pixel:[o,r],coordinate:t,devicePixel:n&&"pickedX"in n?[n.pickedX,n.pickedY]:void 0,pixelRatio:s}}function k(e){const{pickInfo:t,lastPickedInfo:n,mode:i,layers:s}=e,{pickedColor:o,pickedLayer:r,pickedObjectIndex:a}=t,l=r?[r]:[];if("hover"===i){const e=n.index,t=n.layerId,i=r?r.props.id:null;if(i!==t||a!==e){if(i!==t){const e=s.find((e=>e.props.id===t));e&&l.unshift(e)}n.layerId=i,n.index=a,n.info=null}}const c=R(e),d=new Map;return d.set(null,c),l.forEach((e=>{let t=Object.assign({},c);e===r&&(t.color=o,t.index=a,t.picked=!0),t=z({layer:e,info:t,mode:i});const s=t.layer;e===r&&"hover"===i&&(n.info=t),d.set(s.id,t),"hover"===i&&s.updateAutoHighlight(t)})),d}function z(e){let{layer:t,info:n,mode:i}=e;for(;t&&n;){const e=n.layer||null;n.sourceLayer=e,n.layer=t,n=t.getPickingInfo({info:n,mode:i,sourceLayer:e}),t=t.parent}return n}class D{constructor(e){this._pickable=!0,this.device=e,this.pickLayersPass=new M.A(e),this.lastPickedInfo={index:-1,layerId:null,info:null}}setProps(e){"layerFilter"in e&&(this.layerFilter=e.layerFilter),"_pickable"in e&&(this._pickable=e._pickable)}finalize(){this.pickingFBO&&this.pickingFBO.destroy(),this.depthFBO&&this.depthFBO.destroy()}pickObjectAsync(e){return this._pickClosestObjectAsync(e)}pickObjectsAsync(e){return this._pickVisibleObjectsAsync(e)}pickObject(e){return this._pickClosestObject(e)}pickObjects(e){return this._pickVisibleObjects(e)}getLastPickedObject(e,t){let{x:n,y:i,layers:s,viewports:o}=e;void 0===t&&(t=this.lastPickedInfo.info);const r=t&&t.layer&&t.layer.id,a=t&&t.viewport&&t.viewport.id,l=r?s.find((e=>e.id===r)):null,c=a&&o.find((e=>e.id===a))||o[0],d=c&&c.unproject([n-c.x,i-c.y]),h={x:n,y:i,viewport:c,coordinate:d,layer:l};return Object.assign({},t,h)}_resizeBuffer(){var e,t;if(!this.pickingFBO&&(this.pickingFBO=this.device.createFramebuffer({colorAttachments:["rgba8unorm"],depthStencilAttachment:"depth16unorm"}),this.device.isTextureFormatRenderable("rgba32float"))){const e=this.device.createFramebuffer({colorAttachments:["rgba32float"],depthStencilAttachment:"depth16unorm"});this.depthFBO=e}const{canvas:n}=this.device.getDefaultCanvasContext();null==(e=this.pickingFBO)||e.resize({width:n.width,height:n.height}),null==(t=this.depthFBO)||t.resize({width:n.width,height:n.height})}_getPickable(e){if(!1===this._pickable)return null;const t=e.filter((e=>this.pickLayersPass.shouldDrawLayer(e)&&!e.isComposite));return t.length?t:null}async _pickClosestObjectAsync(e){let{layers:t,views:n,viewports:i,x:s,y:o,radius:r=0,depth:a=1,mode:l="query",unproject3D:c,onViewportActive:d,effects:h}=e;const p=this.device.canvasContext.cssToDeviceRatio(),u=this._getPickable(t);if(!u||0===i.length)return{result:[],emptyInfo:R({viewports:i,x:s,y:o,pixelRatio:p})};this._resizeBuffer();const g=this.device.canvasContext.cssToDevicePixels([s,o],!0),f=[g.x+Math.floor(g.width/2),g.y+Math.floor(g.height/2)],m=Math.round(r*p),{width:v,height:y}=this.pickingFBO,_=this._getPickingRect({deviceX:f[0],deviceY:f[1],deviceRadius:m,deviceWidth:v,deviceHeight:y}),x={x:s-r,y:o-r,width:2*r+1,height:2*r+1};let w;const b=[],P=new Set;for(let S=0;S<a;S++){let e,t;if(_){const t=this._drawAndSample({layers:u,views:n,viewports:i,onViewportActive:d,deviceRect:_,cullRect:x,effects:h,pass:"picking:"+l});e=O(Object.assign({},t,{deviceX:f[0],deviceY:f[1],deviceRadius:m,deviceRect:_}))}else e={pickedColor:null,pickedObjectIndex:-1};if(e.pickedLayer&&c&&this.depthFBO){const{pickedColors:s}=this._drawAndSample({layers:[e.pickedLayer],views:n,viewports:i,onViewportActive:d,deviceRect:{x:e.pickedX,y:e.pickedY,width:1,height:1},cullRect:x,effects:h,pass:"picking:"+l+":z"},!0);s[3]&&(t=s[0])}e.pickedLayer&&S+1<a&&(P.add(e.pickedLayer),e.pickedLayer.disablePickingIndex(e.pickedObjectIndex)),w=k({pickInfo:e,lastPickedInfo:this.lastPickedInfo,mode:l,layers:u,viewports:i,x:s,y:o,z:t,pixelRatio:p});for(const n of w.values())n.layer&&b.push(n);if(!e.pickedColor)break}for(const S of P)S.restorePickingColors();return{result:b,emptyInfo:w.get(null)}}_pickClosestObject(e){let{layers:t,views:n,viewports:i,x:s,y:o,radius:r=0,depth:a=1,mode:l="query",unproject3D:c,onViewportActive:d,effects:h}=e;const p=this.device.canvasContext.cssToDeviceRatio(),u=this._getPickable(t);if(!u||0===i.length)return{result:[],emptyInfo:R({viewports:i,x:s,y:o,pixelRatio:p})};this._resizeBuffer();const g=this.device.canvasContext.cssToDevicePixels([s,o],!0),f=[g.x+Math.floor(g.width/2),g.y+Math.floor(g.height/2)],m=Math.round(r*p),{width:v,height:y}=this.pickingFBO,_=this._getPickingRect({deviceX:f[0],deviceY:f[1],deviceRadius:m,deviceWidth:v,deviceHeight:y}),x={x:s-r,y:o-r,width:2*r+1,height:2*r+1};let w;const b=[],P=new Set;for(let S=0;S<a;S++){let e,t;if(_){const t=this._drawAndSample({layers:u,views:n,viewports:i,onViewportActive:d,deviceRect:_,cullRect:x,effects:h,pass:"picking:"+l});e=O(Object.assign({},t,{deviceX:f[0],deviceY:f[1],deviceRadius:m,deviceRect:_}))}else e={pickedColor:null,pickedObjectIndex:-1};if(e.pickedLayer&&c&&this.depthFBO){const{pickedColors:s}=this._drawAndSample({layers:[e.pickedLayer],views:n,viewports:i,onViewportActive:d,deviceRect:{x:e.pickedX,y:e.pickedY,width:1,height:1},cullRect:x,effects:h,pass:"picking:"+l+":z"},!0);s[3]&&(t=s[0])}e.pickedLayer&&S+1<a&&(P.add(e.pickedLayer),e.pickedLayer.disablePickingIndex(e.pickedObjectIndex)),w=k({pickInfo:e,lastPickedInfo:this.lastPickedInfo,mode:l,layers:u,viewports:i,x:s,y:o,z:t,pixelRatio:p});for(const n of w.values())n.layer&&b.push(n);if(!e.pickedColor)break}for(const S of P)S.restorePickingColors();return{result:b,emptyInfo:w.get(null)}}async _pickVisibleObjectsAsync(e){let{layers:t,views:n,viewports:i,x:s,y:o,width:r=1,height:a=1,mode:l="query",maxObjects:c=null,onViewportActive:d,effects:h}=e;const p=this._getPickable(t);if(!p||0===i.length)return[];this._resizeBuffer();const u=this.device.canvasContext.cssToDeviceRatio(),g=this.device.canvasContext.cssToDevicePixels([s,o],!0),f=g.x,m=g.y+g.height,v=this.device.canvasContext.cssToDevicePixels([s+r,o+a],!0),y=v.x+v.width,_=v.y,x={x:f,y:_,width:y-f,height:m-_},w=I(this._drawAndSample({layers:p,views:n,viewports:i,onViewportActive:d,deviceRect:x,cullRect:{x:s,y:o,width:r,height:a},effects:h,pass:"picking:"+l})),b=new Map,P=[],S=Number.isFinite(c);for(let j=0;j<w.length;j++){var C;if(S&&P.length>=c)break;const e=w[j];let t={color:e.pickedColor,layer:null,index:e.pickedObjectIndex,picked:!0,x:s,y:o,pixelRatio:u};t=z({layer:e.pickedLayer,info:t,mode:l});const n=t.layer.id;b.has(n)||b.set(n,new Set);const i=b.get(n),r=null!=(C=t.object)?C:t.index;i.has(r)||(i.add(r),P.push(t))}return P}_pickVisibleObjects(e){let{layers:t,views:n,viewports:i,x:s,y:o,width:r=1,height:a=1,mode:l="query",maxObjects:c=null,onViewportActive:d,effects:h}=e;const p=this._getPickable(t);if(!p||0===i.length)return[];this._resizeBuffer();const u=this.device.canvasContext.cssToDeviceRatio(),g=this.device.canvasContext.cssToDevicePixels([s,o],!0),f=g.x,m=g.y+g.height,v=this.device.canvasContext.cssToDevicePixels([s+r,o+a],!0),y=v.x+v.width,_=v.y,x={x:f,y:_,width:y-f,height:m-_},w=I(this._drawAndSample({layers:p,views:n,viewports:i,onViewportActive:d,deviceRect:x,cullRect:{x:s,y:o,width:r,height:a},effects:h,pass:"picking:"+l})),b=new Map,P=[],S=Number.isFinite(c);for(let j=0;j<w.length;j++){var C;if(S&&P.length>=c)break;const e=w[j];let t={color:e.pickedColor,layer:null,index:e.pickedObjectIndex,picked:!0,x:s,y:o,pixelRatio:u};t=z({layer:e.pickedLayer,info:t,mode:l});const n=t.layer.id;b.has(n)||b.set(n,new Set);const i=b.get(n),r=null!=(C=t.object)?C:t.index;i.has(r)||(i.add(r),P.push(t))}return P}async _drawAndSampleAsync(e,t){let{layers:n,views:i,viewports:s,onViewportActive:o,deviceRect:r,cullRect:a,effects:l,pass:c}=e;void 0===t&&(t=!1);const d=t?this.depthFBO:this.pickingFBO,h={layers:n,layerFilter:this.layerFilter,views:i,viewports:s,onViewportActive:o,pickingFBO:d,deviceRect:r,cullRect:a,effects:l,pass:c,pickZ:t,preRenderStats:{},isPicking:!0};for(const y of l)y.useInPicking&&(h.preRenderStats[y.id]=y.preRender(h));const{decodePickingColor:p}=this.pickLayersPass.render(h),{x:u,y:g,width:f,height:m}=r,v=new(t?Float32Array:Uint8Array)(f*m*4);return this.device.readPixelsToArrayWebGL(d,{sourceX:u,sourceY:g,sourceWidth:f,sourceHeight:m,target:v}),{pickedColors:v,decodePickingColor:p}}_drawAndSample(e,t){let{layers:n,views:i,viewports:s,onViewportActive:o,deviceRect:r,cullRect:a,effects:l,pass:c}=e;void 0===t&&(t=!1);const d=t?this.depthFBO:this.pickingFBO,h={layers:n,layerFilter:this.layerFilter,views:i,viewports:s,onViewportActive:o,pickingFBO:d,deviceRect:r,cullRect:a,effects:l,pass:c,pickZ:t,preRenderStats:{},isPicking:!0};for(const y of l)y.useInPicking&&(h.preRenderStats[y.id]=y.preRender(h));const{decodePickingColor:p}=this.pickLayersPass.render(h),{x:u,y:g,width:f,height:m}=r,v=new(t?Float32Array:Uint8Array)(f*m*4);return this.device.readPixelsToArrayWebGL(d,{sourceX:u,sourceY:g,sourceWidth:f,sourceHeight:m,target:v}),{pickedColors:v,decodePickingColor:p}}_getPickingRect(e){let{deviceX:t,deviceY:n,deviceRadius:i,deviceWidth:s,deviceHeight:o}=e;const r=Math.max(0,t-i),a=Math.max(0,n-i),l=Math.min(s,t+i+1)-r,c=Math.min(o,n+i+1)-a;return l<=0||c<=0?null:{x:r,y:a,width:l,height:c}}}var F=n(8961);const U={"top-left":{top:0,left:0},"top-right":{top:0,right:0},"bottom-left":{bottom:0,left:0},"bottom-right":{bottom:0,right:0},fill:{top:0,left:0,bottom:0,right:0}},V="top-left",N="__root";class B{constructor(e){let{deck:t,parentElement:n}=e;this.defaultWidgets=[],this.widgets=[],this.resolvedWidgets=[],this.containers={},this.lastViewports={},this.deck=t,null==n||n.classList.add("deck-widget-container"),this.parentElement=n}getWidgets(){return this.resolvedWidgets}setProps(e){if(e.widgets&&!(0,w.b)(e.widgets,this.widgets,1)){const t=e.widgets.filter(Boolean);this._setWidgets(t)}}finalize(){for(const e of this.getWidgets())this._removeWidget(e);this.defaultWidgets.length=0,this.resolvedWidgets.length=0;for(const e in this.containers)this.containers[e].remove()}addDefault(e){this.defaultWidgets.find((t=>t.id===e.id))||(this._addWidget(e),this.defaultWidgets.push(e),this._setWidgets(this.widgets))}onRedraw(e){let{viewports:t,layers:n}=e;const i=t.reduce(((e,t)=>(e[t.id]=t,e)),{});for(const s of this.getWidgets()){const{viewId:e}=s;if(e){const t=i[e];t&&(s.onViewportChange&&s.onViewportChange(t),null==s.onRedraw||s.onRedraw({viewports:[t],layers:n}))}else{if(s.onViewportChange)for(const e of t)s.onViewportChange(e);null==s.onRedraw||s.onRedraw({viewports:t,layers:n})}}this.lastViewports=i,this._updateContainers()}onHover(e,t){for(const i of this.getWidgets()){var n;const{viewId:s}=i;s&&s!==(null==(n=e.viewport)?void 0:n.id)||null==i.onHover||i.onHover(e,t)}}onEvent(e,t){const n=F.tg[t.type];if(n)for(const o of this.getWidgets()){var i;const{viewId:r}=o;var s;if(!r||r===(null==(i=e.viewport)?void 0:i.id))null==(s=o[n])||s.call(o,e,t)}}_setWidgets(e){const t={};for(const n of this.resolvedWidgets)t[n.id]=n;this.resolvedWidgets.length=0;for(const n of this.defaultWidgets)t[n.id]=null,this.resolvedWidgets.push(n);for(let n of e){const e=t[n.id];e?e.viewId!==n.viewId||e.placement!==n.placement?(this._removeWidget(e),this._addWidget(n)):n!==e&&(e.setProps(n.props),n=e):this._addWidget(n),t[n.id]=null,this.resolvedWidgets.push(n)}for(const n in t){const e=t[n];e&&this._removeWidget(e)}this.widgets=e}_addWidget(e){const{viewId:t=null,placement:n=V}=e;e.widgetManager=this,e.deck=this.deck,e.rootElement=e.onCreateRootElement(),e.rootElement&&this._getContainer(t,n).append(e.rootElement),null==e.onAdd||e.onAdd({deck:this.deck,viewId:t}),e.updateHTML()}_removeWidget(e){null==e.onRemove||e.onRemove(),e.rootElement&&e.rootElement.remove(),e.rootElement=void 0,e.deck=void 0,e.widgetManager=void 0}_getContainer(e,t){const n=e||N;let i=this.containers[n];var s;i||(i=document.createElement("div"),i.style.pointerEvents="none",i.style.position="absolute",i.style.overflow="hidden",null==(s=this.parentElement)||s.append(i),this.containers[n]=i);let o=i.querySelector("."+t);return o||(o=globalThis.document.createElement("div"),o.className=t,o.style.position="absolute",o.style.zIndex="2",Object.assign(o.style,U[t]),i.append(o)),o}_updateContainers(){const e=this.deck.width,t=this.deck.height;for(const n in this.containers){const i=this.lastViewports[n]||null,s=n===N||i,o=this.containers[n];s?(o.style.display="block",o.style.left=(i?i.x:0)+"px",o.style.top=(i?i.y:0)+"px",o.style.width=(i?i.width:e)+"px",o.style.height=(i?i.height:t)+"px"):o.style.display="none"}}}var W=n(16770);const G={zIndex:"1",position:"absolute",pointerEvents:"none",color:"#a0a7b4",backgroundColor:"#29323c",padding:"10px",top:"0",left:"0",display:"none"};class H extends W.x{constructor(e){void 0===e&&(e={}),super(e),this.id="default-tooltip",this.placement="fill",this.className="deck-tooltip",this.isVisible=!1,this.setProps(e)}onCreateRootElement(){const e=document.createElement("div");return e.className=this.className,Object.assign(e.style,G),e}onRenderHTML(e){}onViewportChange(e){var t;this.isVisible&&e.id===(null==(t=this.lastViewport)?void 0:t.id)&&e!==this.lastViewport&&this.setTooltip(null)}onHover(e){const{deck:t}=this,n=t&&t.props.getTooltip;if(!n)return;const i=n(e);this.lastViewport=e.viewport,this.setTooltip(i,e.x,e.y)}setTooltip(e,t,n){const i=this.rootElement;if(i){if("string"==typeof e)i.innerText=e;else{if(!e)return this.isVisible=!1,void(i.style.display="none");e.text&&(i.innerText=e.text),e.html&&(i.innerHTML=e.html),e.className&&(i.className=e.className)}this.isVisible=!0,i.style.display="block",i.style.transform="translate("+t+"px, "+n+"px)",e&&"object"==typeof e&&"style"in e&&Object.assign(i.style,e.style)}}}H.defaultProps=Object.assign({},W.x.defaultProps);var K=n(81052),q=n(5223),Z=n(8045);const Y={dataType:null,batchType:null,id:"JSON",name:"JSON",module:"",version:"",options:{},extensions:["json","geojson"],mimeTypes:["application/json","application/geo+json"],testText:function(e){const t=e[0],n=e[e.length-1];return"{"===t&&"}"===n||"["===t&&"]"===n},parseTextSync:JSON.parse};const J=function(){const e="9.2.0",t=globalThis.deck&&globalThis.deck.VERSION;if(t&&t!==e)throw new Error("deck.gl - multiple versions detected: "+t+" vs "+e);return t||(p.A.log(1,"deck.gl "+e)(),globalThis.deck=Object.assign({},globalThis.deck,{VERSION:e,version:e,log:p.A,_registerLoggers:u.k}),(0,q.mk)([Y,[Z.$,{imagebitmap:{premultiplyAlpha:"none"}}]])),e}();var X=n(95850),$=n(16370),Q=n(59658),ee=n(7853),te=n(95238);function ne(){}const ie={id:"",width:"100%",height:"100%",style:null,viewState:null,initialViewState:null,pickingRadius:0,layerFilter:null,parameters:{},parent:null,device:null,deviceProps:{},gl:null,canvas:null,layers:[],effects:[],views:null,controller:null,useDevicePixels:!0,touchAction:"none",eventRecognizerOptions:{},_framebuffer:null,_animate:!1,_pickable:!0,_typedArrayManagerProps:{},_customRender:null,widgets:[],onDeviceInitialized:ne,onWebGLInitialized:ne,onResize:ne,onViewStateChange:ne,onInteractionStateChange:ne,onBeforeRender:ne,onAfterRender:ne,onLoad:ne,onError:e=>p.A.error(e.message,e.cause)(),onHover:null,onClick:null,onDragStart:null,onDrag:null,onDragEnd:null,_onMetrics:null,getCursor:e=>{let{isDragging:t}=e;return t?"grabbing":"grab"},getTooltip:null,debug:!1,drawPickingColors:!1};class se{constructor(e){this.width=0,this.height=0,this.userData={},this.device=null,this.canvas=null,this.viewManager=null,this.layerManager=null,this.effectManager=null,this.deckRenderer=null,this.deckPicker=null,this.eventManager=null,this.widgetManager=null,this.tooltip=null,this.animationLoop=null,this.cursorState={isHovering:!1,isDragging:!1},this.stats=new f.A({id:"deck.gl"}),this.metrics={fps:0,setPropsTime:0,updateAttributesTime:0,framesRedrawn:0,pickTime:0,pickCount:0,gpuTime:0,gpuTimePerFrame:0,cpuTime:0,cpuTimePerFrame:0,bufferMemory:0,textureMemory:0,renderbufferMemory:0,gpuMemory:0},this._metricsCounter=0,this._needsRedraw="Initial render",this._pickRequest={mode:"hover",x:-1,y:-1,radius:0,event:null},this._lastPointerDownInfo=null,this._onPointerMove=e=>{const{_pickRequest:t}=this;if("pointerleave"===e.type)t.x=-1,t.y=-1,t.radius=0;else{if(e.leftButton||e.rightButton)return;{const n=e.offsetCenter;if(!n)return;t.x=n.x,t.y=n.y,t.radius=this.props.pickingRadius}}this.layerManager&&(this.layerManager.context.mousePosition={x:t.x,y:t.y}),t.event=e},this._onEvent=e=>{const t=F.tg[e.type],n=e.offsetCenter;if(!t||!n||!this.layerManager)return;const i=this.layerManager.getLayers(),s=this.deckPicker.getLastPickedObject({x:n.x,y:n.y,layers:i,viewports:this.getViewports(n)},this._lastPointerDownInfo),{layer:o}=s,r=o&&(o[t]||o.props[t]),a=this.props[t];let l=!1;r&&(l=r.call(o,s,e)),l||(null==a||a(s,e),this.widgetManager.onEvent(s,e))},this._onPointerDown=e=>{var t;if("webgpu"===(null==(t=this.device)?void 0:t.type))return;const n=e.offsetCenter,i=this._pick("pickObject","pickObject Time",{x:n.x,y:n.y,radius:this.props.pickingRadius});this._lastPointerDownInfo=i.result[0]||i.emptyInfo},this.props=Object.assign({},ie,e),(e=this.props).viewState&&e.initialViewState&&p.A.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(),this.viewState=this.props.initialViewState,e.device&&(this.device=e.device);let t=this.device;!t&&e.gl&&(e.gl instanceof WebGLRenderingContext&&p.A.error("WebGL1 context not supported.")(),t=$.l.attach(e.gl,this.props.deviceProps)),t||(t=this._createDevice(e)),this.animationLoop=this._createAnimationLoop(t,e),this.setProps(e),e._typedArrayManagerProps&&K.A.setOptions(e._typedArrayManagerProps),this.animationLoop.start()}finalize(){var e,t,n,i,s,o,r,a,l,c;(null==(e=this.animationLoop)||e.stop(),null==(t=this.animationLoop)||t.destroy(),this.animationLoop=null,this._lastPointerDownInfo=null,null==(n=this.layerManager)||n.finalize(),this.layerManager=null,null==(i=this.viewManager)||i.finalize(),this.viewManager=null,null==(s=this.effectManager)||s.finalize(),this.effectManager=null,null==(o=this.deckRenderer)||o.finalize(),this.deckRenderer=null,null==(r=this.deckPicker)||r.finalize(),this.deckPicker=null,null==(a=this.eventManager)||a.destroy(),this.eventManager=null,null==(l=this.widgetManager)||l.finalize(),this.widgetManager=null,this.props.canvas||this.props.device||this.props.gl||!this.canvas)||(null==(c=this.canvas.parentElement)||c.removeChild(this.canvas),this.canvas=null)}setProps(e){var t,n,i;this.stats.get("setProps Time").timeStart(),"onLayerHover"in e&&p.A.removed("onLayerHover","onHover")(),"onLayerClick"in e&&p.A.removed("onLayerClick","onClick")(),e.initialViewState&&!(0,w.b)(this.props.initialViewState,e.initialViewState,3)&&(this.viewState=e.initialViewState),Object.assign(this.props,e),this._setCanvasSize(this.props);const s=Object.create(this.props);if(Object.assign(s,{views:this._getViews(),width:this.width,height:this.height,viewState:this._getViewState()}),e.device&&e.device.id!==(null==(t=this.device)?void 0:t.id)){var o,r,a,l;if(null==(o=this.animationLoop)||o.stop(),this.canvas!==(null==(r=e.device.canvasContext)?void 0:r.canvas))null==(a=this.canvas)||a.remove(),null==(l=this.eventManager)||l.destroy(),this.canvas=null;p.A.log("recreating animation loop for new device! id="+e.device.id)(),this.animationLoop=this._createAnimationLoop(e.device,e),this.animationLoop.start()}if(null==(n=this.animationLoop)||n.setProps(s),void 0!==e.useDevicePixels&&(null==(i=this.device)||null==(i=i.canvasContext)?void 0:i.canvas)instanceof HTMLCanvasElement){this.device.canvasContext.props.useDevicePixels=e.useDevicePixels;const t=this.device.canvasContext.canvas,n={target:t,contentBoxSize:[{inlineSize:t.clientWidth,blockSize:t.clientHeight}],devicePixelContentBoxSize:[{inlineSize:t.clientWidth,blockSize:t.clientHeight}],borderBoxSize:[{inlineSize:t.clientWidth,blockSize:t.clientHeight}]};this.device.canvasContext._handleResize([n])}this.layerManager&&(this.viewManager.setProps(s),this.layerManager.activateViewport(this.getViewports()[0]),this.layerManager.setProps(s),this.effectManager.setProps(s),this.deckRenderer.setProps(s),this.deckPicker.setProps(s),this.widgetManager.setProps(s)),this.stats.get("setProps Time").timeEnd()}needsRedraw(e){if(void 0===e&&(e={clearRedrawFlags:!1}),!this.layerManager)return!1;if(this.props._animate)return"Deck._animate";let t=this._needsRedraw;e.clearRedrawFlags&&(this._needsRedraw=!1);const n=this.viewManager.needsRedraw(e),i=this.layerManager.needsRedraw(e),s=this.effectManager.needsRedraw(e),o=this.deckRenderer.needsRedraw(e);return t=t||n||i||s||o,t}redraw(e){if(!this.layerManager)return;let t=this.needsRedraw({clearRedrawFlags:!0});t=e||t,t&&(this.stats.get("Redraw Count").incrementCount(),this.props._customRender?this.props._customRender(t):this._drawLayers(t))}get isInitialized(){return null!==this.viewManager}getViews(){return(0,te.A)(this.viewManager),this.viewManager.views}getViewports(e){return(0,te.A)(this.viewManager),this.viewManager.getViewports(e)}getCanvas(){return this.canvas}pickObject(e){const t=this._pick("pickObject","pickObject Time",e).result;return t.length?t[0]:null}pickMultipleObjects(e){return e.depth=e.depth||10,this._pick("pickObject","pickMultipleObjects Time",e).result}pickObjects(e){return this._pick("pickObjects","pickObjects Time",e)}_addResources(e,t){void 0===t&&(t=!1);for(const n in e)this.layerManager.resourceManager.add({resourceId:n,data:e[n],forceUpdate:t})}_removeResources(e){for(const t of e)this.layerManager.resourceManager.remove(t)}_addDefaultEffect(e){this.effectManager.addDefaultEffect(e)}_addDefaultShaderModule(e){this.layerManager.addDefaultShaderModule(e)}_removeDefaultShaderModule(e){var t;null==(t=this.layerManager)||t.removeDefaultShaderModule(e)}_pick(e,t,n){(0,te.A)(this.deckPicker);const{stats:i}=this;i.get("Pick Count").incrementCount(),i.get(t).timeStart();const s=this.deckPicker[e](Object.assign({layers:this.layerManager.getLayers(n),views:this.viewManager.getViews(),viewports:this.getViewports(n),onViewportActive:this.layerManager.activateViewport,effects:this.effectManager.getEffects()},n));return i.get(t).timeEnd(),s}_createCanvas(e){let t=e.canvas;if("string"==typeof t&&(t=document.getElementById(t),(0,te.A)(t)),!t){t=document.createElement("canvas"),t.id=e.id||"deckgl-overlay",e.width&&"number"==typeof e.width&&(t.width=e.width),e.height&&"number"==typeof e.height&&(t.height=e.height);(e.parent||document.body).appendChild(t)}return Object.assign(t.style,e.style),t}_setCanvasSize(e){if(!this.canvas)return;const{width:t,height:n}=e;if(t||0===t){const e=Number.isFinite(t)?t+"px":t;this.canvas.style.width=e}if(n||0===n){var i;const t=Number.isFinite(n)?n+"px":n;this.canvas.style.position=(null==(i=e.style)?void 0:i.position)||"absolute",this.canvas.style.height=t}}_updateCanvasSize(){var e,t;const{canvas:n}=this;if(!n)return;const i=null!=(e=n.clientWidth)?e:n.width,s=null!=(t=n.clientHeight)?t:n.height;var o,r;i===this.width&&s===this.height||(this.width=i,this.height=s,null==(o=this.viewManager)||o.setProps({width:i,height:s}),null==(r=this.layerManager)||r.activateViewport(this.getViewports()[0]),this.props.onResize({width:i,height:s}))}_createAnimationLoop(e,t){const{gl:n,onError:i}=t;return new Q.F({device:e,autoResizeDrawingBuffer:!n,autoResizeViewport:!1,onInitialize:e=>this._setDevice(e.device),onRender:this._onRenderFrame.bind(this),onError:i})}_createDevice(e){var t,n;const i=null==(t=this.props.deviceProps)?void 0:t.createCanvasContext,s="object"==typeof i?i:void 0,o=Object.assign({adapters:[]},e.deviceProps);o.adapters.includes($.l)||o.adapters.push($.l);const r={alphaMode:"webgpu"===(null==(n=this.props.deviceProps)?void 0:n.type)?"premultiplied":void 0};return X.a.createDevice(Object.assign({_reuseDevices:!0,type:"webgl"},o,{createCanvasContext:Object.assign({},r,s,{canvas:this._createCanvas(e),useDevicePixels:this.props.useDevicePixels,autoResize:!0})}))}_getViewState(){return this.props.viewState||this.viewState}_getViews(){const{views:e}=this.props,t=Array.isArray(e)?e:e?[e]:[new P.A({id:"default-view"})];return t.length&&this.props.controller&&(t[0].props.controller=this.props.controller),t}_onContextLost(){const{onError:e}=this.props;this.animationLoop&&e&&e(new Error("WebGL context is lost"))}_pickAndCallback(){var e;if("webgpu"===(null==(e=this.device)?void 0:e.type))return;const{_pickRequest:t}=this;if(t.event){const{result:e,emptyInfo:o}=this._pick("pickObject","pickObject Time",t);this.cursorState.isHovering=e.length>0;let r=o,a=!1;for(const i of e){var n;r=i,a=(null==(n=i.layer)?void 0:n.onHover(i,t.event))||a}var i,s;if(!a)null==(i=(s=this.props).onHover)||i.call(s,r,t.event),this.widgetManager.onHover(r,t.event);t.event=null}}_updateCursor(){const e=this.props.parent||this.canvas;e&&(e.style.cursor=this.props.getCursor(this.cursorState))}_setDevice(e){var t,n;if(this.device=e,!this.animationLoop)return;this.canvas||(this.canvas=null==(n=this.device.canvasContext)?void 0:n.canvas,!this.canvas.isConnected&&this.props.parent&&this.props.parent.insertBefore(this.canvas,this.props.parent.firstChild));"webgl"===this.device.type&&this.device.setParametersWebGL({blend:!0,blendFunc:[770,771,1,771],polygonOffsetFill:!0,depthTest:!0,depthFunc:515}),this.props.onDeviceInitialized(this.device),"webgl"===this.device.type&&this.props.onWebGLInitialized(this.device.gl);const s=new i.K;s.play(),this.animationLoop.attachTimeline(s),this.eventManager=new ee.EU(this.props.parent||this.canvas,{touchAction:this.props.touchAction,recognizers:Object.keys(F.We).map((e=>{var t;const[n,i,s,o]=F.We[e],r=null==(t=this.props.eventRecognizerOptions)?void 0:t[e];return{recognizer:new n(Object.assign({},i,r,{event:e})),recognizeWith:s,requestFailure:o}})),events:{pointerdown:this._onPointerDown,pointermove:this._onPointerMove,pointerleave:this._onPointerMove}});for(const i in F.tg)this.eventManager.on(i,this._onEvent);this.viewManager=new b({timeline:s,eventManager:this.eventManager,onViewStateChange:this._onViewStateChange.bind(this),onInteractionStateChange:this._onInteractionStateChange.bind(this),views:this._getViews(),viewState:this._getViewState(),width:this.width,height:this.height});const o=this.viewManager.getViewports()[0];this.layerManager=new x(this.device,{deck:this,stats:this.stats,viewport:o,timeline:s}),this.effectManager=new j({deck:this,device:this.device}),this.deckRenderer=new T(this.device),this.deckPicker=new D(this.device),this.widgetManager=new B({deck:this,parentElement:null==(t=this.canvas)?void 0:t.parentElement}),this.widgetManager.addDefault(new H),this.setProps(this.props),this._updateCanvasSize(),this.props.onLoad()}_drawLayers(e,t){var n;const{device:i,gl:s}=this.layerManager.context;this.props.onBeforeRender({device:i,gl:s});const o=Object.assign({target:this.props._framebuffer,layers:this.layerManager.getLayers(),viewports:this.viewManager.getViewports(),onViewportActive:this.layerManager.activateViewport,views:this.viewManager.getViews(),pass:"screen",effects:this.effectManager.getEffects()},t);null==(n=this.deckRenderer)||n.renderLayers(o),"screen"===o.pass&&this.widgetManager.onRedraw({viewports:o.viewports,layers:o.layers}),this.props.onAfterRender({device:i,gl:s})}_onRenderFrame(){var e;this._getFrameStats(),this._metricsCounter++%60==0&&(this._getMetrics(),this.stats.reset(),p.A.table(4,this.metrics)(),this.props._onMetrics&&this.props._onMetrics(this.metrics)),this._updateCanvasSize(),this._updateCursor(),this.layerManager.updateLayers(),"webgpu"!==(null==(e=this.device)?void 0:e.type)&&this._pickAndCallback(),this.redraw(),this.viewManager&&this.viewManager.updateViewStates()}_onViewStateChange(e){const t=this.props.onViewStateChange(e)||e.viewState;this.viewState&&(this.viewState=Object.assign({},this.viewState,{[e.viewId]:t}),this.props.viewState||this.viewManager&&this.viewManager.setProps({viewState:this.viewState}))}_onInteractionStateChange(e){this.cursorState.isDragging=e.isDragging||!1,this.props.onInteractionStateChange(e)}_getFrameStats(){const{stats:e}=this;e.get("frameRate").timeEnd(),e.get("frameRate").timeStart();const t=this.animationLoop.stats;e.get("GPU Time").addTime(t.get("GPU Time").lastTiming),e.get("CPU Time").addTime(t.get("CPU Time").lastTiming)}_getMetrics(){const{metrics:e,stats:t}=this;e.fps=t.get("frameRate").getHz(),e.setPropsTime=t.get("setProps Time").time,e.updateAttributesTime=t.get("Update Attributes").time,e.framesRedrawn=t.get("Redraw Count").count,e.pickTime=t.get("pickObject Time").time+t.get("pickMultipleObjects Time").time+t.get("pickObjects Time").time,e.pickCount=t.get("Pick Count").count,e.gpuTime=t.get("GPU Time").time,e.cpuTime=t.get("CPU Time").time,e.gpuTimePerFrame=t.get("GPU Time").getAverageTime(),e.cpuTimePerFrame=t.get("CPU Time").getAverageTime();const n=X.a.stats.get("Memory Usage");e.bufferMemory=n.get("Buffer Memory").count,e.textureMemory=n.get("Texture Memory").count,e.renderbufferMemory=n.get("Renderbuffer Memory").count,e.gpuMemory=n.get("GPU Memory").count}}se.defaultProps=ie,se.VERSION=J;const oe=se},3002:(e,t,n)=>{n.d(t,{A:()=>ie});var i=n(26839),s=n(99871),o=n(8961),r=n(1570),a=n(39976),l=n(54901),c=n(50948);class d extends c.A{get value(){return this._value}_onUpdate(){const{time:e,settings:{fromValue:t,toValue:n,duration:i,easing:s}}=this,o=s(e/i);this._value=(0,l.Cc)(t,n,o)}}const h=1e-5;function p(e,t,n,i,s){const o=t-e;return(n-t)*s+-o*i+o+t}function u(e,t){if(Array.isArray(e)){let n=0;for(let i=0;i<e.length;i++){const s=e[i]-t[i];n+=s*s}return Math.sqrt(n)}return Math.abs(e-t)}class g extends c.A{get value(){return this._currValue}_onUpdate(){const{fromValue:e,toValue:t,damping:n,stiffness:i}=this.settings,{_prevValue:s=e,_currValue:o=e}=this;let r=function(e,t,n,i,s){if(Array.isArray(n)){const o=[];for(let r=0;r<n.length;r++)o[r]=p(e[r],t[r],n[r],i,s);return o}return p(e,t,n,i,s)}(s,o,t,n,i);const a=u(r,t),l=u(r,o);a<h&&l<h&&(r=t,this.end()),this._prevValue=o,this._currValue=r}}var f=n(18120);const m={interpolation:d,spring:g};class v{constructor(e){this.transitions=new Map,this.timeline=e}get active(){return this.transitions.size>0}add(e,t,n,i){const{transitions:s}=this;if(s.has(e)){const n=s.get(e),{value:i=n.settings.fromValue}=n;t=i,this.remove(e)}if(!(i=(0,a.K)(i)))return;const o=m[i.type];if(!o)return void f.A.error("unsupported transition type '"+i.type+"'")();const r=new o(this.timeline);r.start(Object.assign({},i,{fromValue:t,toValue:n})),s.set(e,r)}remove(e){const{transitions:t}=this;t.has(e)&&(t.get(e).cancel(),t.delete(e))}update(){const e={};for(const[t,n]of this.transitions)n.update(),e[t]=n.value,n.inProgress||this.remove(t);return e}clear(){for(const e of this.transitions.keys())this.remove(e)}}var y=n(9649),_=n(95958);function x(e){if(null===(t=e)||"object"!=typeof t)throw new Error("count(): argument not an object");var t;if("function"==typeof e.count)return e.count();if(Number.isFinite(e.size))return e.size;if(Number.isFinite(e.length))return e.length;if(function(e){return null!==e&&"object"==typeof e&&e.constructor===Object}(e))return Object.keys(e).length;throw new Error("count(): argument not a container")}var w=n(95656),b=n(95238),P=n(63190);function S(e,t){if(!t)return e;const n=Object.assign({},e,t);if("defines"in t&&(n.defines=Object.assign({},e.defines,t.defines)),"modules"in t&&(n.modules=(e.modules||[]).concat(t.modules),t.modules.some((e=>"project64"===e.name)))){const e=n.modules.findIndex((e=>"project32"===e.name));e>=0&&n.modules.splice(e,1)}if("inject"in t)if(e.inject){const i=Object.assign({},e.inject);for(const e in t.inject)i[e]=(i[e]||"")+t.inject[e];n.inject=i}else n.inject=t.inject;return n}var C=n(5600),j=n(81052),A=n(33698),L=n(80698);const M={minFilter:"linear",mipmapFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"},T={};var E=n(50111);const O={boolean:{validate:(e,t)=>!0,equal:(e,t,n)=>Boolean(e)===Boolean(t)},number:{validate:(e,t)=>Number.isFinite(e)&&(!("max"in t)||e<=t.max)&&(!("min"in t)||e>=t.min)},color:{validate:(e,t)=>t.optional&&!e||k(e)&&(3===e.length||4===e.length),equal:(e,t,n)=>(0,E.b)(e,t,1)},accessor:{validate(e,t){const n=z(e);return"function"===n||n===z(t.value)},equal:(e,t,n)=>"function"==typeof t||(0,E.b)(e,t,1)},array:{validate:(e,t)=>t.optional&&!e||k(e),equal(e,t,n){const{compare:i}=n,s=Number.isInteger(i)?i:i?1:0;return i?(0,E.b)(e,t,s):e===t}},object:{equal(e,t,n){if(n.ignore)return!0;const{compare:i}=n,s=Number.isInteger(i)?i:i?1:0;return i?(0,E.b)(e,t,s):e===t}},function:{validate:(e,t)=>t.optional&&!e||"function"==typeof e,equal:(e,t,n)=>!n.compare&&!1!==n.ignore||e===t},data:{transform:(e,t,n)=>{if(!e)return e;const{dataTransform:i}=n.props;return i?i(e):"string"==typeof e.shape&&e.shape.endsWith("-table")&&Array.isArray(e.data)?e.data:e}},image:{transform:(e,t,n)=>{const i=n.context;return i&&i.device?function(e,t,n,i){if(n instanceof L.g)return n;n.constructor&&"Object"!==n.constructor.name&&(n={data:n});let s=null;n.compressed&&(s={minFilter:"linear",mipmapFilter:n.data.length>1?"nearest":"linear"});const{width:o,height:r}=n.data,a=t.createTexture(Object.assign({},n,{sampler:Object.assign({},M,s,i),mipLevels:t.getMipLevelCount(o,r)}));return a.generateMipmapsWebGL(),T[a.id]=e,a}(n.id,i.device,e,Object.assign({},t.parameters,n.props.textureParameters)):null},release:(e,t,n)=>{var i,s;i=n.id,(s=e)&&s instanceof L.g&&T[s.id]===i&&(s.delete(),delete T[s.id])}}};function I(e,t){switch(z(t)){case"object":return R(e,t);case"array":return R(e,{type:"array",value:t,compare:!1});case"boolean":return R(e,{type:"boolean",value:t});case"number":return R(e,{type:"number",value:t});case"function":return R(e,{type:"function",value:t,compare:!0});default:return{name:e,type:"unknown",value:t}}}function R(e,t){return"type"in t?Object.assign({name:e},O[t.type],t):"value"in t?Object.assign({name:e,type:z(t.value)},t):{name:e,type:"object",value:t}}function k(e){return Array.isArray(e)||ArrayBuffer.isView(e)}function z(e){return k(e)?"array":null===e?"null":typeof e}const D="_mergedDefaultProps";function F(e,t){if(!(e instanceof G.constructor))return{};let n=D;if(t)for(const s of t){const e=s.constructor;e&&(n+=":"+(e.extensionName||e.name))}const i=N(e,n);return i||(e[n]=function(e,t){const n=e.prototype;if(!n)return null;const i=Object.getPrototypeOf(e),s=F(i),o=N(e,"defaultProps")||{},r=function(e){const t={},n={},i={};for(const[s,o]of Object.entries(e)){const e=null==o?void 0:o.deprecatedFor;if(e)i[s]=Array.isArray(e)?e:[e];else{const e=I(s,o);t[s]=e,n[s]=e.value}}return{propTypes:t,defaultProps:n,deprecatedProps:i}}(o),a=Object.assign(Object.create(null),s,r.defaultProps),l=Object.assign(Object.create(null),null==s?void 0:s[_.fW],r.propTypes),c=Object.assign(Object.create(null),null==s?void 0:s[_.uH],r.deprecatedProps);for(const d of t){const e=F(d.constructor);e&&(Object.assign(a,e),Object.assign(l,e[_.fW]),Object.assign(c,e[_.uH]))}(function(e,t){const n=function(e){const t=e.componentName;t||f.A.warn(e.name+".componentName not specified")();return t||e.name}(t);Object.defineProperties(e,{id:{writable:!0,value:n}})})(a,e),function(e,t){const n={},i={};for(const s in t){const e=t[s],{name:o,value:r}=e;e.async&&(n[o]=r,i[o]=U(o))}e[_.jA]=n,e[_.YN]={},Object.defineProperties(e,i)}(a,l),function(e,t){for(const n in t)Object.defineProperty(e,n,{enumerable:!1,set(e){const i=this.id+": "+n;for(const s of t[n])V(this,s)||(this[s]=e);f.A.deprecated(i,t[n].join("/"))()}})}(a,c),a[_.fW]=l,a[_.uH]=c,0!==t.length||V(e,"_propTypes")||(e._propTypes=l);return a}(e,t||[]))}function U(e){return{enumerable:!0,set(t){"string"==typeof t||t instanceof Promise||(0,A.Td)(t)?this[_.YN][e]=t:this[_.vf][e]=t},get(){if(this[_.vf]){if(e in this[_.vf]){return this[_.vf][e]||this[_.jA][e]}if(e in this[_.YN]){const t=this[_.r3]&&this[_.r3].internalState;if(t&&t.hasAsyncProp(e))return t.getAsyncProp(e)||this[_.jA][e]}}return this[_.jA][e]}}}function V(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function N(e,t){return V(e,t)&&e[t]}let B=0;class W{constructor(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this.props=function(e,t){let n;for(let o=t.length-1;o>=0;o--){const e=t[o];"extensions"in e&&(n=e.extensions)}const i=F(e.constructor,n),s=Object.create(i);s[_.r3]=e,s[_.YN]={},s[_.vf]={};for(let o=0;o<t.length;++o){const e=t[o];for(const t in e)s[t]=e[t]}return Object.freeze(s),s}(this,t),this.id=this.props.id,this.count=B++}clone(e){const{props:t}=this,n={};for(const i in t[_.jA])i in t[_.vf]?n[i]=t[_.vf][i]:i in t[_.YN]&&(n[i]=t[_.YN][i]);return new this.constructor(Object.assign({},t,n,e))}}W.componentName="Component",W.defaultProps={};const G=W;var H=n(19495);const K=Object.freeze({});class q{constructor(e){this.component=e,this.asyncProps={},this.onAsyncPropUpdated=()=>{},this.oldProps=null,this.oldAsyncProps=null}finalize(){for(const e in this.asyncProps){const t=this.asyncProps[e];t&&t.type&&t.type.release&&t.type.release(t.resolvedValue,t.type,this.component)}this.asyncProps={},this.component=null,this.resetOldProps()}getOldProps(){return this.oldAsyncProps||this.oldProps||K}resetOldProps(){this.oldAsyncProps=null,this.oldProps=this.component?this.component.props:null}hasAsyncProp(e){return e in this.asyncProps}getAsyncProp(e){const t=this.asyncProps[e];return t&&t.resolvedValue}isAsyncPropLoading(e){if(e){const t=this.asyncProps[e];return Boolean(t&&t.pendingLoadCount>0&&t.pendingLoadCount!==t.resolvedLoadCount)}for(const t in this.asyncProps)if(this.isAsyncPropLoading(t))return!0;return!1}reloadAsyncProp(e,t){this._watchPromise(e,Promise.resolve(t))}setAsyncProps(e){this.component=e[_.r3]||this.component;const t=e[_.vf]||{},n=e[_.YN]||e,i=e[_.jA]||{};for(const s in t){const e=t[s];this._createAsyncPropData(s,i[s]),this._updateAsyncProp(s,e),t[s]=this.getAsyncProp(s)}for(const s in n){const e=n[s];this._createAsyncPropData(s,i[s]),this._updateAsyncProp(s,e)}}_fetch(e,t){return null}_onResolve(e,t){}_onError(e,t){}_updateAsyncProp(e,t){this._didAsyncInputValueChange(e,t)&&("string"==typeof t&&(t=this._fetch(e,t)),t instanceof Promise?this._watchPromise(e,t):(0,A.Td)(t)?this._resolveAsyncIterable(e,t):this._setPropValue(e,t))}_freezeAsyncOldProps(){if(!this.oldAsyncProps&&this.oldProps){this.oldAsyncProps=Object.create(this.oldProps);for(const e in this.asyncProps)Object.defineProperty(this.oldAsyncProps,e,{enumerable:!0,value:this.oldProps[e]})}}_didAsyncInputValueChange(e,t){const n=this.asyncProps[e];return t!==n.resolvedValue&&t!==n.lastValue&&(n.lastValue=t,!0)}_setPropValue(e,t){this._freezeAsyncOldProps();const n=this.asyncProps[e];n&&(t=this._postProcessValue(n,t),n.resolvedValue=t,n.pendingLoadCount++,n.resolvedLoadCount=n.pendingLoadCount)}_setAsyncPropValue(e,t,n){const i=this.asyncProps[e];i&&n>=i.resolvedLoadCount&&void 0!==t&&(this._freezeAsyncOldProps(),i.resolvedValue=t,i.resolvedLoadCount=n,this.onAsyncPropUpdated(e,t))}_watchPromise(e,t){const n=this.asyncProps[e];if(n){n.pendingLoadCount++;const i=n.pendingLoadCount;t.then((t=>{this.component&&(t=this._postProcessValue(n,t),this._setAsyncPropValue(e,t,i),this._onResolve(e,t))})).catch((t=>{this._onError(e,t)}))}}async _resolveAsyncIterable(e,t){if("data"!==e)return void this._setPropValue(e,t);const n=this.asyncProps[e];if(!n)return;n.pendingLoadCount++;const i=n.pendingLoadCount;let s=[],o=0;var r,a=!1,l=!1;try{for(var c,d=(0,H.A)(t);a=!(c=await d.next()).done;a=!1){const t=c.value;{if(!this.component)return;const{dataTransform:n}=this.component.props;s=n?n(t,s):s.concat(t),Object.defineProperty(s,"__diff",{enumerable:!1,value:[{startRow:o,endRow:s.length}]}),o=s.length,this._setAsyncPropValue(e,s,i)}}}catch(h){l=!0,r=h}finally{try{a&&null!=d.return&&await d.return()}finally{if(l)throw r}}this._onResolve(e,s)}_postProcessValue(e,t){const n=e.type;return n&&this.component&&(n.release&&n.release(e.resolvedValue,n,this.component),n.transform)?n.transform(t,n,this.component):t}_createAsyncPropData(e,t){if(!this.asyncProps[e]){const n=this.component&&this.component.props[_.fW];this.asyncProps[e]={type:n&&n[e],lastValue:null,resolvedValue:t,pendingLoadCount:0,resolvedLoadCount:0}}}}class Z extends q{constructor(e){let{attributeManager:t,layer:n}=e;super(n),this.attributeManager=t,this.needsRedraw=!0,this.needsUpdate=!0,this.subLayers=null,this.usesPickingColorCache=!1}get layer(){return this.component}_fetch(e,t){const n=this.layer,i=null==n?void 0:n.props.fetch;return i?i(t,{propName:e,layer:n}):super._fetch(e,t)}_onResolve(e,t){const n=this.layer;if(n){const i=n.props.onDataLoad;"data"===e&&i&&i(t,{propName:e,layer:n})}}_onError(e,t){const n=this.layer;n&&n.raiseError(t,"loading "+e+" of "+this.layer)}}var Y=n(73279),J=n(327);const X=2**24-1,$=Object.freeze([]),Q=(0,P.A)((e=>{let{oldViewport:t,viewport:n}=e;return t.equals(n)}));let ee=new Uint8ClampedArray(0);const te={data:{type:"data",value:$,async:!0},dataComparator:{type:"function",value:null,optional:!0},_dataDiff:{type:"function",value:e=>e&&e.__diff,optional:!0},dataTransform:{type:"function",value:null,optional:!0},onDataLoad:{type:"function",value:null,optional:!0},onError:{type:"function",value:null,optional:!0},fetch:{type:"function",value:(e,t)=>{let{propName:n,layer:i,loaders:s,loadOptions:o,signal:r}=t;const{resourceManager:a}=i.context;var l;(o=o||i.getLoadOptions(),s=s||i.props.loaders,r)&&(o=Object.assign({},o,{fetch:Object.assign({},null==(l=o)?void 0:l.fetch,{signal:r})}));let c=a.contains(e);return c||o||(a.add({resourceId:e,data:(0,J.H)(e,s),persistent:!1}),c=!0),c?a.subscribe({resourceId:e,onChange:e=>{var t;return null==(t=i.internalState)?void 0:t.reloadAsyncProp(n,e)},consumerId:i.id,requestId:n}):(0,J.H)(e,s,o)}},updateTriggers:{},visible:!0,pickable:!1,opacity:{type:"number",min:0,max:1,value:1},operation:"draw",onHover:{type:"function",value:null,optional:!0},onClick:{type:"function",value:null,optional:!0},onDragStart:{type:"function",value:null,optional:!0},onDrag:{type:"function",value:null,optional:!0},onDragEnd:{type:"function",value:null,optional:!0},coordinateSystem:o.rf.DEFAULT,coordinateOrigin:{type:"array",value:[0,0,0],compare:!0},modelMatrix:{type:"array",value:null,compare:!0,optional:!0},wrapLongitude:!1,positionFormat:"XYZ",colorFormat:"RGBA",parameters:{type:"object",value:{},optional:!0,compare:2},loadOptions:{type:"object",value:null,optional:!0,ignore:!0},transitions:null,extensions:[],loaders:{type:"array",value:[],optional:!0,ignore:!0},getPolygonOffset:{type:"function",value:e=>{let{layerIndex:t}=e;return[0,100*-t]}},highlightedObjectIndex:null,autoHighlight:!1,highlightColor:{type:"accessor",value:[0,0,128,128]}};class ne extends G{constructor(){super(...arguments),this.internalState=null,this.lifecycle=_.VD.NO_STATE,this.parent=null}static get componentName(){return Object.prototype.hasOwnProperty.call(this,"layerName")?this.layerName:""}get root(){let e=this;for(;e.parent;)e=e.parent;return e}toString(){return(this.constructor.layerName||this.constructor.name)+"({id: '"+this.props.id+"'})"}project(e){(0,b.A)(this.internalState);const t=this.internalState.viewport||this.context.viewport,n=(0,C.w)(e,{viewport:t,modelMatrix:this.props.modelMatrix,coordinateOrigin:this.props.coordinateOrigin,coordinateSystem:this.props.coordinateSystem}),[i,s,o]=(0,Y.VJ)(n,t.pixelProjectionMatrix);return 2===e.length?[i,s]:[i,s,o]}unproject(e){(0,b.A)(this.internalState);return(this.internalState.viewport||this.context.viewport).unproject(e)}projectPosition(e,t){(0,b.A)(this.internalState);const n=this.internalState.viewport||this.context.viewport;return(0,C.R)(e,Object.assign({viewport:n,modelMatrix:this.props.modelMatrix,coordinateOrigin:this.props.coordinateOrigin,coordinateSystem:this.props.coordinateSystem},t))}get isComposite(){return!1}get isDrawable(){return!0}setState(e){this.setChangeFlags({stateChanged:!0}),Object.assign(this.state,e),this.setNeedsRedraw()}setNeedsRedraw(){this.internalState&&(this.internalState.needsRedraw=!0)}setNeedsUpdate(){this.internalState&&(this.context.layerManager.setNeedsUpdate(String(this)),this.internalState.needsUpdate=!0)}get isLoaded(){return!!this.internalState&&!this.internalState.isAsyncPropLoading()}get wrapLongitude(){return this.props.wrapLongitude}isPickable(){return this.props.pickable&&this.props.visible}getModels(){const e=this.state;return e&&(e.models||e.model&&[e.model])||[]}setShaderModuleProps(){for(const e of this.getModels())e.shaderInputs.setProps(...arguments)}getAttributeManager(){return this.internalState&&this.internalState.attributeManager}getCurrentLayer(){return this.internalState&&this.internalState.layer}getLoadOptions(){return this.props.loadOptions}use64bitPositions(){const{coordinateSystem:e}=this.props;return e===o.rf.DEFAULT||e===o.rf.LNGLAT||e===o.rf.CARTESIAN}onHover(e,t){return this.props.onHover&&this.props.onHover(e,t)||!1}onClick(e,t){return this.props.onClick&&this.props.onClick(e,t)||!1}nullPickingColor(){return[0,0,0]}encodePickingColor(e,t){return void 0===t&&(t=[]),t[0]=e+1&255,t[1]=e+1>>8&255,t[2]=e+1>>8>>8&255,t}decodePickingColor(e){(0,b.A)(e instanceof Uint8Array);const[t,n,i]=e;return t+256*n+65536*i-1}getNumInstances(){return Number.isFinite(this.props.numInstances)?this.props.numInstances:this.state&&void 0!==this.state.numInstances?this.state.numInstances:x(this.props.data)}getStartIndices(){return this.props.startIndices?this.props.startIndices:this.state&&this.state.startIndices?this.state.startIndices:null}getBounds(){var e;return null==(e=this.getAttributeManager())?void 0:e.getBounds(["positions","instancePositions"])}getShaders(e){e=S(e,{disableWarnings:!0,modules:this.context.defaultShaderModules});for(const t of this.props.extensions)e=S(e,t.getShaders.call(this,t));return e}shouldUpdateState(e){return e.changeFlags.propsOrDataChanged}updateState(e){const t=this.getAttributeManager(),{dataChanged:n}=e.changeFlags;if(n&&t)if(Array.isArray(n))for(const i of n)t.invalidateAll(i);else t.invalidateAll();if(t){const{props:n}=e,i=this.internalState.hasPickingBuffer,s=Number.isInteger(n.highlightedObjectIndex)||n.pickable||n.extensions.some((e=>e.getNeedsPickingBuffer.call(this,e)));if(i!==s){this.internalState.hasPickingBuffer=s;const{pickingColors:e,instancePickingColors:n}=t.attributes,i=e||n;i&&(s&&i.constant&&(i.constant=!1,t.invalidate(i.id)),i.value||s||(i.constant=!0,i.value=[0,0,0]))}}}finalizeState(e){for(const n of this.getModels())n.destroy();const t=this.getAttributeManager();t&&t.finalize(),this.context&&this.context.resourceManager.unsubscribe({consumerId:this.id}),this.internalState&&(this.internalState.uniformTransitions.clear(),this.internalState.finalize())}draw(e){for(const t of this.getModels())t.draw(e.renderPass)}getPickingInfo(e){let{info:t,mode:n,sourceLayer:i}=e;const{index:s}=t;return s>=0&&Array.isArray(this.props.data)&&(t.object=this.props.data[s]),t}raiseError(e,t){var n,i,s;(t&&(e=new Error(t+": "+e.message,{cause:e})),null!=(n=(i=this.props).onError)&&n.call(i,e))||(null==(s=this.context)||null==s.onError||s.onError(e,this))}getNeedsRedraw(e){return void 0===e&&(e={clearRedrawFlags:!1}),this._getNeedsRedraw(e)}needsUpdate(){return!!this.internalState&&(this.internalState.needsUpdate||this.hasUniformTransition()||this.shouldUpdateState(this._getUpdateParams()))}hasUniformTransition(){var e;return(null==(e=this.internalState)?void 0:e.uniformTransitions.active)||!1}activateViewport(e){if(!this.internalState)return;const t=this.internalState.viewport;this.internalState.viewport=e,t&&Q({oldViewport:t,viewport:e})||(this.setChangeFlags({viewportChanged:!0}),this.isComposite?this.needsUpdate()&&this.setNeedsUpdate():this._update())}invalidateAttribute(e){void 0===e&&(e="all");const t=this.getAttributeManager();t&&("all"===e?t.invalidateAll():t.invalidate(e))}updateAttributes(e){let t=!1;for(const n in e)e[n].layoutChanged()&&(t=!0);for(const n of this.getModels())this._setModelAttributes(n,e,t)}_updateAttributes(){const e=this.getAttributeManager();if(!e)return;const t=this.props,n=this.getNumInstances(),i=this.getStartIndices();e.update({data:t.data,numInstances:n,startIndices:i,props:t,transitions:t.transitions,buffers:t.data.attributes,context:this});const s=e.getChangedAttributes({clearChangedFlags:!0});this.updateAttributes(s)}_updateAttributeTransition(){const e=this.getAttributeManager();e&&e.updateTransition()}_updateUniformTransition(){const{uniformTransitions:e}=this.internalState;if(e.active){const t=e.update(),n=Object.create(this.props);for(const e in t)Object.defineProperty(n,e,{value:t[e]});return n}return this.props}calculateInstancePickingColors(e,t){let{numInstances:n}=t;if(e.constant)return;const i=Math.floor(ee.length/4);if(this.internalState.usesPickingColorCache=!0,i<n){n>X&&f.A.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(),ee=j.A.allocate(ee,n,{size:4,copy:!0,maxCount:Math.max(n,X)});const e=Math.floor(ee.length/4),t=[0,0,0];for(let n=i;n<e;n++)this.encodePickingColor(n,t),ee[4*n+0]=t[0],ee[4*n+1]=t[1],ee[4*n+2]=t[2],ee[4*n+3]=0}e.value=ee.subarray(0,4*n)}_setModelAttributes(e,t,n){var s;if(void 0===n&&(n=!1),!Object.keys(t).length)return;if(n){const n=this.getAttributeManager();e.setBufferLayout(n.getBufferLayouts(e)),t=n.getAttributes()}const o=(null==(s=e.userData)?void 0:s.excludeAttributes)||{},r={},a={};for(const l in t){if(o[l])continue;const n=t[l].getValue();for(const s in n){const o=n[s];o instanceof i.h?t[l].settings.isIndexed?e.setIndexBuffer(o):r[s]=o:o&&(a[s]=o)}}e.setAttributes(r),e.setConstantAttributes(a)}disablePickingIndex(e){const t=this.props.data;if(!("attributes"in t))return void this._disablePickingIndex(e);const{pickingColors:n,instancePickingColors:i}=this.getAttributeManager().attributes,s=n||i,o=s&&t.attributes&&t.attributes[s.id];if(o&&o.value){const n=o.value,i=this.encodePickingColor(e);for(let e=0;e<t.length;e++){const t=s.getVertexOffset(e);n[t]===i[0]&&n[t+1]===i[1]&&n[t+2]===i[2]&&this._disablePickingIndex(e)}}else this._disablePickingIndex(e)}_disablePickingIndex(e){const{pickingColors:t,instancePickingColors:n}=this.getAttributeManager().attributes,i=t||n;if(!i)return;const s=i.getVertexOffset(e),o=i.getVertexOffset(e+1);i.buffer.write(new Uint8Array(o-s),s)}restorePickingColors(){const{pickingColors:e,instancePickingColors:t}=this.getAttributeManager().attributes,n=e||t;n&&(this.internalState.usesPickingColorCache&&n.value.buffer!==ee.buffer&&(n.value=ee.subarray(0,n.value.length)),n.updateSubBuffer({startOffset:0}))}_initialize(){(0,b.A)(!this.internalState),(0,b.A)(Number.isFinite(this.props.coordinateSystem)),(0,w.A)("layer.initialize",this);const e=this._getAttributeManager();e&&e.addInstanced({instancePickingColors:{type:"uint8",size:4,noAlloc:!0,update:this.calculateInstancePickingColors}}),this.internalState=new Z({attributeManager:e,layer:this}),this._clearChangeFlags(),this.state={},Object.defineProperty(this.state,"attributeManager",{get:()=>(f.A.deprecated("layer.state.attributeManager","layer.getAttributeManager()")(),e)}),this.internalState.uniformTransitions=new v(this.context.timeline),this.internalState.onAsyncPropUpdated=this._onAsyncPropUpdated.bind(this),this.internalState.setAsyncProps(this.props),this.initializeState(this.context);for(const t of this.props.extensions)t.initializeState.call(this,this.context,t);this.setChangeFlags({dataChanged:"init",propsChanged:"init",viewportChanged:!0,extensionsChanged:!0}),this._update()}_transferState(e){(0,w.A)("layer.matched",this,this===e);const{state:t,internalState:n}=e;this!==e&&(this.internalState=n,this.state=t,this.internalState.setAsyncProps(this.props),this._diffProps(this.props,this.internalState.getOldProps()))}_update(){const e=this.needsUpdate();if((0,w.A)("layer.update",this,e),!e)return;const t=this.props,n=this.context,i=this.internalState,s=n.viewport,o=this._updateUniformTransition();i.propsInTransition=o,n.viewport=i.viewport||s,this.props=o;try{const e=this._getUpdateParams(),t=this.getModels();if(n.device)this.updateState(e);else try{this.updateState(e)}catch(r){}for(const n of this.props.extensions)n.updateState.call(this,e,n);this.setNeedsRedraw(),this._updateAttributes();const i=this.getModels()[0]!==t[0];this._postUpdate(e,i)}finally{n.viewport=s,this.props=t,this._clearChangeFlags(),i.needsUpdate=!1,i.resetOldProps()}}_finalize(){(0,w.A)("layer.finalize",this),this.finalizeState(this.context);for(const e of this.props.extensions)e.finalizeState.call(this,this.context,e)}_drawLayer(e){let{renderPass:t,shaderModuleProps:n=null,uniforms:i={},parameters:o={}}=e;this._updateAttributeTransition();const r=this.props,a=this.context;this.props=this.internalState.propsInTransition||r;try{n&&this.setShaderModuleProps(n);const{getPolygonOffset:e}=this.props,r=e&&e(i)||[0,0];a.device instanceof s.WebGLDevice&&a.device.setParametersWebGL({polygonOffset:r});for(const t of this.getModels())"webgpu"===t.device.type?t.setParameters(Object.assign({},t.parameters,o)):t.setParameters(o);if(a.device instanceof s.WebGLDevice)a.device.withParametersWebGL(o,(()=>{const e={renderPass:t,shaderModuleProps:n,uniforms:i,parameters:o,context:a};for(const t of this.props.extensions)t.draw.call(this,e,t);this.draw(e)}));else{const e={renderPass:t,shaderModuleProps:n,uniforms:i,parameters:o,context:a};for(const t of this.props.extensions)t.draw.call(this,e,t);this.draw(e)}}finally{this.props=r}}getChangeFlags(){var e;return null==(e=this.internalState)?void 0:e.changeFlags}setChangeFlags(e){if(!this.internalState)return;const{changeFlags:t}=this.internalState;for(const i in e)if(e[i]){let n=!1;if("dataChanged"===i){const s=e[i],o=t[i];s&&Array.isArray(o)&&(t.dataChanged=Array.isArray(s)?o.concat(s):s,n=!0)}t[i]||(t[i]=e[i],n=!0),n&&(0,w.A)("layer.changeFlag",this,i,e)}const n=Boolean(t.dataChanged||t.updateTriggersChanged||t.propsChanged||t.extensionsChanged);t.propsOrDataChanged=n,t.somethingChanged=n||t.viewportChanged||t.stateChanged}_clearChangeFlags(){this.internalState.changeFlags={dataChanged:!1,propsChanged:!1,updateTriggersChanged:!1,viewportChanged:!1,stateChanged:!1,extensionsChanged:!1,propsOrDataChanged:!1,somethingChanged:!1}}_diffProps(e,t){const n=(0,y.mg)(e,t);if(n.updateTriggersChanged)for(const s in n.updateTriggersChanged)n.updateTriggersChanged[s]&&this.invalidateAttribute(s);if(n.transitionsChanged)for(const s in n.transitionsChanged){var i;this.internalState.uniformTransitions.add(s,t[s],e[s],null==(i=e.transitions)?void 0:i[s])}return this.setChangeFlags(n)}validateProps(){(0,y.zo)(this.props)}updateAutoHighlight(e){this.props.autoHighlight&&!Number.isInteger(this.props.highlightedObjectIndex)&&this._updateAutoHighlight(e)}_updateAutoHighlight(e){const t={highlightedObjectColor:e.picked?e.color:null},{highlightColor:n}=this.props;e.picked&&"function"==typeof n&&(t.highlightColor=n(e)),this.setShaderModuleProps({picking:t}),this.setNeedsRedraw()}_getAttributeManager(){const e=this.context;return new r.A(e.device,{id:this.props.id,stats:e.stats,timeline:e.timeline})}_postUpdate(e,t){const{props:n,oldProps:i}=e,s=this.state.model;null!=s&&s.isInstanced&&s.setInstanceCount(this.getNumInstances());const{autoHighlight:o,highlightedObjectIndex:r,highlightColor:a}=n;if(t||i.autoHighlight!==o||i.highlightedObjectIndex!==r||i.highlightColor!==a){const e={};Array.isArray(a)&&(e.highlightColor=a),(t||i.autoHighlight!==o||r!==i.highlightedObjectIndex)&&(e.highlightedObjectColor=Number.isFinite(r)&&r>=0?this.encodePickingColor(r):null),this.setShaderModuleProps({picking:e})}}_getUpdateParams(){return{props:this.props,oldProps:this.internalState.getOldProps(),context:this.context,changeFlags:this.internalState.changeFlags}}_getNeedsRedraw(e){if(!this.internalState)return!1;let t=!1;t=t||this.internalState.needsRedraw&&this.id;const n=this.getAttributeManager(),i=!!n&&n.getNeedsRedraw(e);if(t=t||i,t)for(const s of this.props.extensions)s.onNeedsRedraw.call(this,s);return this.internalState.needsRedraw=this.internalState.needsRedraw&&!e.clearRedrawFlags,t}_onAsyncPropUpdated(){this._diffProps(this.props,this.internalState.getOldProps()),this.setNeedsUpdate()}}ne.defaultProps=te,ne.layerName="Layer";const ie=ne},16770:(e,t,n)=>{n.d(t,{x:()=>o});var i=n(50111),s=n(91013);class o{constructor(e){this.viewId=null,this.props=Object.assign({},this.constructor.defaultProps,e),this.id=this.props.id}setProps(e){const t=this.props,n=this.rootElement;n&&t.className!==e.className&&(t.className&&n.classList.remove(t.className),e.className&&n.classList.add(e.className)),n&&!(0,i.b)(t.style,e.style,1)&&((0,s.h)(n,t.style),(0,s.Z)(n,e.style)),Object.assign(this.props,e),this.updateHTML()}updateHTML(){this.rootElement&&this.onRenderHTML(this.rootElement)}onCreateRootElement(){const e=["deck-widget",this.className,this.props.className],t=document.createElement("div");return e.filter((e=>"string"==typeof e&&e.length>0)).forEach((e=>t.classList.add(e))),(0,s.Z)(t,this.props.style),t}onAdd(e){}onRemove(){}onViewportChange(e){}onRedraw(e){}onHover(e,t){}onClick(e,t){}onDrag(e,t){}onDragStart(e,t){}onDragEnd(e,t){}}o.defaultProps={id:"widget",style:{},className:""}},95958:(e,t,n)=>{n.d(t,{VD:()=>i,YN:()=>l,fW:()=>o,jA:()=>a,r3:()=>s,uH:()=>r,vf:()=>c});const i={NO_STATE:"Awaiting state",MATCHED:"Matched. State transferred from previous layer",INITIALIZED:"Initialized",AWAITING_GC:"Discarded. Awaiting garbage collection",AWAITING_FINALIZATION:"No longer matched. Awaiting garbage collection",FINALIZED:"Finalized! Awaiting garbage collection"},s=Symbol.for("component"),o=Symbol.for("propTypes"),r=Symbol.for("deprecatedProps"),a=Symbol.for("asyncPropDefaults"),l=Symbol.for("asyncPropOriginal"),c=Symbol.for("asyncPropResolved")},9649:(e,t,n)=>{n.d(t,{Me:()=>a,mg:()=>o,zo:()=>s});var i=n(95958);function s(e){const t=e[i.fW];for(const n in t){const i=t[n],{validate:s}=i;if(s&&!s(e[n],i))throw new Error("Invalid prop "+n+": "+e[n])}}function o(e,t){const n=a({newProps:e,oldProps:t,propTypes:e[i.fW],ignoreProps:{data:null,updateTriggers:null,extensions:null,transitions:null}}),s=function(e,t){if(null===t)return"oldProps is null, initial diff";let n=!1;const{dataComparator:i,_dataDiff:s}=e;i?i(e.data,t.data)||(n="Data comparator detected a change"):e.data!==t.data&&(n="A new data container was supplied");n&&s&&(n=s(e.data,t.data)||n);return n}(e,t);let o=!1;return s||(o=function(e,t){if(null===t)return{all:!0};if("all"in e.updateTriggers){if(d(e,t,"all"))return{all:!0}}const n={};let i=!1;for(const s in e.updateTriggers)if("all"!==s){d(e,t,s)&&(n[s]=!0,i=!0)}return!!i&&n}(e,t)),{dataChanged:s,propsChanged:n,updateTriggersChanged:o,extensionsChanged:c(e,t),transitionsChanged:r(e,t)}}function r(e,t){if(!e.transitions)return!1;const n={},s=e[i.fW];let o=!1;for(const i in e.transitions){const r=s[i],a=r&&r.type;("number"===a||"color"===a||"array"===a)&&l(e[i],t[i],r)&&(n[i]=!0,o=!0)}return!!o&&n}function a(e){let{newProps:t,oldProps:n,ignoreProps:i={},propTypes:s={},triggerName:o="props"}=e;if(n===t)return!1;if("object"!=typeof t||null===t)return o+" changed shallowly";if("object"!=typeof n||null===n)return o+" changed shallowly";for(const r of Object.keys(t))if(!(r in i)){if(!(r in n))return o+"."+r+" added";const e=l(t[r],n[r],s[r]);if(e)return o+"."+r+" "+e}for(const r of Object.keys(n))if(!(r in i)){if(!(r in t))return o+"."+r+" dropped";if(!Object.hasOwnProperty.call(t,r)){const e=l(t[r],n[r],s[r]);if(e)return o+"."+r+" "+e}}return!1}function l(e,t,n){let i=n&&n.equal;return i&&!i(e,t,n)?"changed deeply":i||(i=e&&t&&e.equals,!i||i.call(e,t))?i||t===e?null:"changed shallowly":"changed deeply"}function c(e,t){if(null===t)return!0;const n=t.extensions,{extensions:i}=e;if(i===n)return!1;if(!n||!i)return!0;if(i.length!==n.length)return!0;for(let s=0;s<i.length;s++)if(!i[s].equals(n[s]))return!0;return!1}function d(e,t,n){let i=e.updateTriggers[n];i=null==i?{}:i;let s=t.updateTriggers[n];s=null==s?{}:s;return a({oldProps:s,newProps:i,triggerName:n})}},44584:(e,t,n)=>{n.d(t,{A:()=>s});var i=n(39883);class s extends i.A{constructor(){super(...arguments),this._lastRenderIndex=-1}render(e){var t,n,i;const[s,o]=this.device.canvasContext.getDrawingBufferSize(),r=null==(t=e.clearCanvas)||t,a=null!=(n=e.clearColor)?n:!!r&&[0,0,0,0],l=!!r&&1,c=!!r&&0,d=null!=(i=e.colorMask)?i:15,h={viewport:[0,0,s,o]};e.colorMask&&(h.colorMask=d),e.scissorRect&&(h.scissorRect=e.scissorRect);const p=this.device.beginRenderPass({framebuffer:e.target,parameters:h,clearColor:a,clearDepth:l,clearStencil:c});try{return this._drawLayers(p,e)}finally{p.end(),this.device.submit()}}_drawLayers(e,t){const{target:n,shaderModuleProps:i,viewports:s,views:o,onViewportActive:r,clearStack:a=!0}=t;t.pass=t.pass||"unknown",a&&(this._lastRenderIndex=-1);const l=[];for(const c of s){const s=o&&o[c.id];null==r||r(c);const a=this._getDrawLayerParams(c,t),d=c.subViewports||[c];for(const o of d){const r=this._drawLayersInViewport(e,{target:n,shaderModuleProps:i,viewport:o,view:s,pass:t.pass,layers:t.layers},a);l.push(r)}}return l}_getDrawLayerParams(e,t,n){let{layers:i,pass:s,isPicking:r=!1,layerFilter:a,cullRect:l,effects:c,shaderModuleProps:d}=t;void 0===n&&(n=!1);const h=[],p=o(this._lastRenderIndex+1),u={layer:i[0],viewport:e,isPicking:r,renderPass:s,cullRect:l},g={};for(let o=0;o<i.length;o++){const t=i[o],r=this._shouldDrawLayer(t,u,a,g),l={shouldDrawLayer:r};var f;if(r&&!n)l.shouldDrawLayer=!0,l.layerRenderIndex=p(t,r),l.shaderModuleProps=this._getShaderModuleProps(t,c,s,d),l.layerParameters=Object.assign({},null==(f=t.context.deck)?void 0:f.props.parameters,this.getLayerParameters(t,o,e));h[o]=l}return h}_drawLayersInViewport(e,t,n){let{layers:i,shaderModuleProps:s,pass:o,target:r,viewport:a,view:l}=t;const c=function(e,t){var n,i;let{shaderModuleProps:s,target:o,viewport:r}=t;const a=null!=(n=null==s||null==(i=s.project)?void 0:i.devicePixelRatio)?n:e.canvasContext.cssToDeviceRatio(),[,l]=e.canvasContext.getDrawingBufferSize(),c=o?o.height:l,d=r;return[d.x*a,c-(d.y+d.height)*a,d.width*a,d.height*a]}(this.device,{shaderModuleProps:s,target:r,viewport:a});if(l){const{clear:e,clearColor:t,clearDepth:n,clearStencil:i}=l.props;if(e){let e=[0,0,0,0],s=1,o=0;Array.isArray(t)?e=[...t.slice(0,3),t[3]||255].map((e=>e/255)):!1===t&&(e=!1),void 0!==n&&(s=n),void 0!==i&&(o=i);this.device.beginRenderPass({framebuffer:r,parameters:{viewport:c,scissorRect:c},clearColor:e,clearDepth:s,clearStencil:o}).end()}}const d={totalCount:i.length,visibleCount:0,compositeCount:0,pickableCount:0};e.setParameters({viewport:c});for(let p=0;p<i.length;p++){const t=i[p],s=n[p],{shouldDrawLayer:r}=s;if(r&&t.props.pickable&&d.pickableCount++,t.isComposite&&d.compositeCount++,t.isDrawable&&s.shouldDrawLayer){const{layerRenderIndex:n,shaderModuleProps:i,layerParameters:r}=s;d.visibleCount++,this._lastRenderIndex=Math.max(this._lastRenderIndex,n),i.project&&(i.project.viewport=a),t.context.renderPass=e;try{t._drawLayer({renderPass:e,shaderModuleProps:i,uniforms:{layerIndex:n},parameters:r})}catch(h){t.raiseError(h,"drawing "+t+" to "+o)}}}return d}shouldDrawLayer(e){return!0}getShaderModuleProps(e,t,n){return null}getLayerParameters(e,t,n){return e.props.parameters}_shouldDrawLayer(e,t,n,i){if(!(e.props.visible&&this.shouldDrawLayer(e)))return!1;t.layer=e;let s=e.parent;for(;s;){if(!s.props.visible||!s.filterSubLayer(t))return!1;t.layer=s,s=s.parent}if(n){const e=t.layer.id;if(e in i||(i[e]=n(t)),!i[e])return!1}return e.activateViewport(t.viewport),!0}_getShaderModuleProps(e,t,n,i){var s;const o=this.device.canvasContext.cssToDeviceRatio(),a=(null==(s=e.internalState)?void 0:s.propsInTransition)||e.props,l={layer:a,picking:{isActive:!1},project:{viewport:e.context.viewport,devicePixelRatio:o,modelMatrix:a.modelMatrix,coordinateSystem:a.coordinateSystem,coordinateOrigin:a.coordinateOrigin,autoWrapLongitude:e.wrapLongitude}};if(t)for(const c of t)r(l,null==c.getShaderModuleProps?void 0:c.getShaderModuleProps(e,l));return r(l,this.getShaderModuleProps(e,t,l),i)}}function o(e,t){void 0===e&&(e=0),void 0===t&&(t={});const n={},i=(s,r)=>{const a=s.props._offset,l=s.id,c=s.parent&&s.parent.id;let d;if(c&&!(c in t)&&i(s.parent,!1),c in n){const e=n[c]=n[c]||o(t[c],t);d=e(s,r),n[l]=e}else Number.isFinite(a)?(d=a+(t[c]||0),n[l]=null):d=e;return r&&d>=e&&(e=d+1),t[l]=d,d};return i}function r(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];for(const s of n)if(s)for(const t in s)e[t]?Object.assign(e[t],s[t]):e[t]=s[t];return e}},39883:(e,t,n)=>{n.d(t,{A:()=>i});class i{constructor(e,t){void 0===t&&(t={id:"pass"});const{id:n}=t;this.id=n,this.device=e,this.props=Object.assign({},t)}setProps(e){Object.assign(this.props,e)}render(e){}cleanup(){}}},78218:(e,t,n)=>{n.d(t,{A:()=>r});var i=n(44584),s=n(18120);const o={blendColorOperation:"add",blendColorSrcFactor:"one",blendColorDstFactor:"zero",blendAlphaOperation:"add",blendAlphaSrcFactor:"constant",blendAlphaDstFactor:"zero"};class r extends i.A{constructor(){super(...arguments),this._colorEncoderState=null}render(e){return"pickingFBO"in e?this._drawPickingBuffer(e):super.render(e)}_drawPickingBuffer(e){let{layers:t,layerFilter:n,views:i,viewports:s,onViewportActive:o,pickingFBO:r,deviceRect:{x:l,y:c,width:d,height:h},cullRect:p,effects:u,pass:g="picking",pickZ:f,shaderModuleProps:m}=e;this.pickZ=f;const v=this._resetColorEncoder(f),y=[l,c,d,h],_=super.render({target:r,layers:t,layerFilter:n,views:i,viewports:s,onViewportActive:o,cullRect:p,effects:null==u?void 0:u.filter((e=>e.useInPicking)),pass:g,isPicking:!0,shaderModuleProps:m,clearColor:[0,0,0,0],colorMask:15,scissorRect:y});this._colorEncoderState=null;return{decodePickingColor:v&&a.bind(null,v),stats:_}}shouldDrawLayer(e){const{pickable:t,operation:n}=e.props;return t&&n.includes("draw")||n.includes("terrain")||n.includes("mask")}getShaderModuleProps(e,t,n){return{picking:{isActive:1,isAttribute:this.pickZ},lighting:{enabled:!1}}}getLayerParameters(e,t,n){const i=Object.assign({},e.props.parameters),{pickable:r,operation:a}=e.props;return!this._colorEncoderState||a.includes("terrain")?i.blend=!1:r&&a.includes("draw")&&(Object.assign(i,o),i.blend=!0,i.blendColor=function(e,t,n){const{byLayer:i,byAlpha:o}=e;let r,a=i.get(t);a?(a.viewports.push(n),r=a.a):(r=i.size+1,r<=255?(a={a:r,layer:t,viewports:[n]},i.set(t,a),o[r]=a):(s.A.warn("Too many pickable layers, only picking the first 255")(),r=0));return[0,0,0,r/255]}(this._colorEncoderState,e,n)),i}_resetColorEncoder(e){return this._colorEncoderState=e?null:{byLayer:new Map,byAlpha:[]},this._colorEncoderState}}function a(e,t){const n=e.byAlpha[t[3]];return n&&{pickedLayer:n.layer,pickedViewports:n.viewports,pickedObjectIndex:n.layer.decodePickingColor(t)}}},27972:(e,t,n)=>{n.d(t,{A:()=>i});const i={name:"color",dependencies:[],source:"\n\nstruct ColorUniforms {\n  opacity: f32,\n};\n\nvar<private> color: ColorUniforms = ColorUniforms(1.0);\n// TODO (kaapp) avoiding binding index collisions to handle layer opacity \n// requires some thought.\n// @group(0) @binding(0) var<uniform> color: ColorUniforms;\n\n@must_use\nfn deckgl_premultiplied_alpha(fragColor: vec4<f32>) -> vec4<f32> {\n    return vec4(fragColor.rgb * fragColor.a, fragColor.a); \n};\n",getUniforms:e=>({}),uniformTypes:{opacity:"f32"}}},64458:(e,t,n)=>{n.d(t,{A:()=>s});const i="#define SMOOTH_EDGE_RADIUS 0.5",s={name:"geometry",source:"const SMOOTH_EDGE_RADIUS: f32 = 0.5;\n\nstruct VertexGeometry {\n  position: vec4<f32>,\n  worldPosition: vec3<f32>,\n  worldPositionAlt: vec3<f32>,\n  normal: vec3<f32>,\n  uv: vec2<f32>,\n  pickingColor: vec3<f32>,\n};\n\nvar<private> geometry_: VertexGeometry = VertexGeometry(\n  vec4<f32>(0.0, 0.0, 1.0, 0.0),\n  vec3<f32>(0.0, 0.0, 0.0),\n  vec3<f32>(0.0, 0.0, 0.0),\n  vec3<f32>(0.0, 0.0, 0.0),\n  vec2<f32>(0.0, 0.0),\n  vec3<f32>(0.0, 0.0, 0.0)\n);\n\nstruct FragmentGeometry {\n  uv: vec2<f32>,\n};\n\nvar<private> fragmentGeometry: FragmentGeometry;\n\nfn smoothedge(edge: f32, x: f32) -> f32 {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n",vs:i+"\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n",fs:i+"\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n"}},28756:(e,t,n)=>{n.d(t,{A:()=>s});var i=n(49042);const s=Object.assign({},i.q,{defaultUniforms:Object.assign({},i.q.defaultUniforms,{useFloatColors:!1}),inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ","vs:DECKGL_FILTER_COLOR":"\n  picking_setPickingColor(geometry.pickingColor);\n  ","fs:DECKGL_FILTER_COLOR":{order:99,injection:"\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "}}})},5600:(e,t,n)=>{n.d(t,{R:()=>p,w:()=>h});var i=n(8961),s=n(28593),o=n(59073),r=n(39426),a=n(82859),l=n(73279);const c=[0,0,0];function d(e,t,n){void 0===n&&(n=!1);const i=t.projectPosition(e);if(n&&t instanceof o.A){const[n,s,o=0]=e,r=t.getDistanceScales([n,s]);i[2]=o*r.unitsPerMeter[2]}return i}function h(e,t){let{viewport:n,modelMatrix:s,coordinateSystem:o,coordinateOrigin:a,offsetMode:c}=t,[h,p,u=0]=e;switch(s&&([h,p,u]=r.Z0([],[h,p,u,1],s)),o){case i.rf.LNGLAT:return d([h,p,u],n,c);case i.rf.LNGLAT_OFFSETS:return d([h+a[0],p+a[1],u+(a[2]||0)],n,c);case i.rf.METER_OFFSETS:return d((0,l.dT)(a,[h,p,u]),n,c);case i.rf.CARTESIAN:default:return n.isGeospatial?[h+a[0],p+a[1],u+a[2]]:n.projectPosition([h,p,u])}}function p(e,t){const{viewport:n,coordinateSystem:o,coordinateOrigin:r,modelMatrix:l,fromCoordinateSystem:d,fromCoordinateOrigin:p}=function(e){const{viewport:t,modelMatrix:n,coordinateOrigin:s}=e;let{coordinateSystem:o,fromCoordinateSystem:r,fromCoordinateOrigin:a}=e;return o===i.rf.DEFAULT&&(o=t.isGeospatial?i.rf.LNGLAT:i.rf.CARTESIAN),void 0===r&&(r=o),void 0===a&&(a=s),{viewport:t,coordinateSystem:o,coordinateOrigin:s,modelMatrix:n,fromCoordinateSystem:r,fromCoordinateOrigin:a}}(t),{autoOffset:u=!0}=t,{geospatialOrigin:g=c,shaderCoordinateOrigin:f=c,offsetMode:m=!1}=u?(0,s.o)(n,o,r):{},v=h(e,{viewport:n,modelMatrix:l,coordinateSystem:d,coordinateOrigin:p,offsetMode:m});if(m){const e=n.projectPosition(g||f);a.jb(v,v,e)}return v}},40281:(e,t,n)=>{n.d(t,{A:()=>d});var i=n(34938),s=n(64458),o=n(28593),r=n(8961);const a=Object.keys(r.rf).map((e=>"const COORDINATE_SYSTEM_"+e+": i32 = "+r.rf[e]+";")).join("")+"\n"+Object.keys(r.Kx).map((e=>"const PROJECTION_MODE_"+e+": i32 = "+r.Kx[e]+";")).join("")+"\n"+Object.keys(r.p5).map((e=>"const UNIT_"+e.toUpperCase()+": i32 = "+r.p5[e]+";")).join("")+'\n\nconst TILE_SIZE: f32 = 512.0;\nconst PI: f32 = 3.1415926536;\nconst WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);\nconst ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);\nconst EARTH_RADIUS: f32 = 6370972.0; // meters\nconst GLOBE_RADIUS: f32 = 256.0;\n\n// -----------------------------------------------------------------------------\n// Uniform block (converted from GLSL uniform block)\n// -----------------------------------------------------------------------------\nstruct ProjectUniforms {\n  wrapLongitude: i32,\n  coordinateSystem: i32,\n  commonUnitsPerMeter: vec3<f32>,\n  projectionMode: i32,\n  scale: f32,\n  commonUnitsPerWorldUnit: vec3<f32>,\n  commonUnitsPerWorldUnit2: vec3<f32>,\n  center: vec4<f32>,\n  modelMatrix: mat4x4<f32>,\n  viewProjectionMatrix: mat4x4<f32>,\n  viewportSize: vec2<f32>,\n  devicePixelRatio: f32,\n  focalDistance: f32,\n  cameraPosition: vec3<f32>,\n  coordinateOrigin: vec3<f32>,\n  commonOrigin: vec3<f32>,\n  pseudoMeters: i32,\n};\n\n@group(0) @binding(0)\nvar<uniform> project: ProjectUniforms;\n\n// -----------------------------------------------------------------------------\n// Geometry data\n// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,\n// you might supply this via vertex attributes or a uniform. Here we define a\n// uniform struct for demonstration.)\n// -----------------------------------------------------------------------------\n\n// Structure to carry additional geometry data used by deck.gl filters.\nstruct Geometry {\n  worldPosition: vec3<f32>,\n  worldPositionAlt: vec3<f32>,\n  position: vec4<f32>,\n  normal: vec3<f32>,\n  uv: vec2<f32>,\n  pickingColor: vec3<f32>,\n};\n\n// @group(0) @binding(1)\nvar<private> geometry: Geometry;\n'+'\n\n// -----------------------------------------------------------------------------\n// Functions\n// -----------------------------------------------------------------------------\n\n// Returns an adjustment factor for commonUnitsPerMeter\nfn _project_size_at_latitude(lat: f32) -> f32 {\n  let y = clamp(lat, -89.9, 89.9);\n  return 1.0 / cos(radians(y));\n}\n\n// Overloaded version: scales a value in meters at a given latitude.\nfn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {\n  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);\n}\n\n// Computes a non-linear scale factor based on geometry.\n// (Note: This function relies on "geometry" being provided.)\nfn project_size() -> f32 {\n  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n      project.pseudoMeters == 0) {\n    if (geometry.position.w == 0.0) {\n      return _project_size_at_latitude(geometry.worldPosition.y);\n    }\n    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    let y2 = y * y;\n    let y4 = y2 * y2;\n    let y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n\n// Overloads to scale offsets (meters to world units)\nfn project_size_float(meters: f32) -> f32 {\n  return meters * project.commonUnitsPerMeter.z * project_size();\n}\n\nfn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {\n  return meters * project.commonUnitsPerMeter.xy * project_size();\n}\n\nfn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {\n  return meters * project.commonUnitsPerMeter * project_size();\n}\n\nfn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);\n}\n\n// Returns a rotation matrix aligning the z\u2011axis with the given up vector.\nfn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {\n  let uz = normalize(up);\n  let ux = select(\n    vec3<f32>(1.0, 0.0, 0.0),\n    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),\n    abs(uz.z) == 1.0\n  );\n  let uy = cross(uz, ux);\n  return mat3x3<f32>(ux, uy, uz);\n}\n\n// Since WGSL does not support "out" parameters, we return a struct.\nstruct RotationResult {\n  needsRotation: bool,\n  transform: mat3x3<f32>,\n};\n\nfn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {\n  if (project.projectionMode == PROJECTION_MODE_GLOBE) {\n    return RotationResult(true, project_get_orientation_matrix(commonPosition));\n  } else {\n    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed\n  };\n}\n\n// Projects a normal vector from the current coordinate system to world space.\nfn project_normal(vector: vec3<f32>) -> vec3<f32> {\n  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);\n  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);\n  let rotResult = project_needs_rotation(geometry.position.xyz);\n  if (rotResult.needsRotation) {\n    n = rotResult.transform * n;\n  }\n  return n;\n}\n\n// Applies a scale offset based on y-offset (dy)\nfn project_offset_(offset: vec4<f32>) -> vec4<f32> {\n  let dy: f32 = offset.y;\n  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;\n  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\n\n// Projects lng/lat coordinates to a unit tile [0,1]\nfn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {\n  var x = lnglat.x;\n  if (project.wrapLongitude != 0) {\n    x = ((x + 180.0) % 360.0) - 180.0;\n  }\n  let y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2<f32>(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// Projects lng/lat/z coordinates for a globe projection.\nfn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {\n  let lambda = radians(lnglatz.x);\n  let phi = radians(lnglatz.y);\n  let cosPhi = cos(phi);\n  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n  return vec3<f32>(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\n\n// Projects positions (with an optional 64-bit low part) from the input\n// coordinate system to the common space.\nfn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {\n  var position_world = project.modelMatrix * position;\n\n  // Work around for a Mac+NVIDIA bug:\n  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4<f32>(\n        project_mercator_(position_world.xy),\n        _project_size_at_latitude_m(position_world.z, position_world.y),\n        position_world.w\n      );\n    }\n    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);\n    }\n  }\n  if (project.projectionMode == PROJECTION_MODE_GLOBE) {\n    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4<f32>(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {\n        return vec4<f32>(\n          project_mercator_(position_world.xy) - project.commonOrigin.xy,\n          project_size_float(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||\n      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);\n  }\n\n  return project_offset_(position_world) +\n         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));\n}\n\n// Overloaded versions for different input types.\nfn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {\n  return project_position_vec4_f64(position, ZERO_64_LOW);\n}\n\nfn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {\n  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nfn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {\n  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nfn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {\n  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\n// Transforms a common space position to clip space.\nfn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {\n  return viewProjectionMatrix * position + center;\n}\n\n// Uses the project viewProjectionMatrix and center.\nfn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {\n  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);\n}\n\n// Returns a clip space offset corresponding to a given number of screen pixels.\nfn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {\n  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;\n  return offset * project.focalDistance;\n}\n\nfn project_meter_size_to_pixel(meters: f32) -> f32 {\n  return project_size_float(meters) * project.scale;\n}\n\nfn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {\n  if (unit == UNIT_METERS) {\n    return project_meter_size_to_pixel(size);\n  } else if (unit == UNIT_COMMON) {\n    return size * project.scale;\n  }\n  // UNIT_PIXELS: no scaling applied.\n  return size;\n}\n\nfn project_pixel_size_float(pixels: f32) -> f32 {\n  return pixels / project.scale;\n}\n\nfn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {\n  return pixels / project.scale;\n}\n',l=Object.keys(r.rf).map((e=>"const int COORDINATE_SYSTEM_"+e+" = "+r.rf[e]+";")).join("")+"\n"+Object.keys(r.Kx).map((e=>"const int PROJECTION_MODE_"+e+" = "+r.Kx[e]+";")).join("")+"\n"+Object.keys(r.p5).map((e=>"const int UNIT_"+e.toUpperCase()+" = "+r.p5[e]+";")).join("")+"\nuniform projectUniforms {\nbool wrapLongitude;\nint coordinateSystem;\nvec3 commonUnitsPerMeter;\nint projectionMode;\nfloat scale;\nvec3 commonUnitsPerWorldUnit;\nvec3 commonUnitsPerWorldUnit2;\nvec4 center;\nmat4 modelMatrix;\nmat4 viewProjectionMatrix;\nvec2 viewportSize;\nfloat devicePixelRatio;\nfloat focalDistance;\nvec3 cameraPosition;\nvec3 coordinateOrigin;\nvec3 commonOrigin;\nbool pseudoMeters;\n} project;\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size_at_latitude(float lat) {\nfloat y = clamp(lat, -89.9, 89.9);\nreturn 1.0 / cos(radians(y));\n}\nfloat project_size() {\nif (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&\nproject.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\nproject.pseudoMeters == false) {\nif (geometry.position.w == 0.0) {\nreturn project_size_at_latitude(geometry.worldPosition.y);\n}\nfloat y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\nfloat y2 = y * y;\nfloat y4 = y2 * y2;\nfloat y6 = y4 * y2;\nreturn 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n}\nreturn 1.0;\n}\nfloat project_size_at_latitude(float meters, float lat) {\nreturn meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);\n}\nfloat project_size(float meters) {\nreturn meters * project.commonUnitsPerMeter.z * project_size();\n}\nvec2 project_size(vec2 meters) {\nreturn meters * project.commonUnitsPerMeter.xy * project_size();\n}\nvec3 project_size(vec3 meters) {\nreturn meters * project.commonUnitsPerMeter * project_size();\n}\nvec4 project_size(vec4 meters) {\nreturn vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\nvec3 uz = normalize(up);\nvec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\nvec3 uy = cross(uz, ux);\nreturn mat3(ux, uy, uz);\n}\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\nif (project.projectionMode == PROJECTION_MODE_GLOBE) {\ntransform = project_get_orientation_matrix(commonPosition);\nreturn true;\n}\nreturn false;\n}\nvec3 project_normal(vec3 vector) {\nvec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);\nvec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);\nmat3 rotation;\nif (project_needs_rotation(geometry.position.xyz, rotation)) {\nn = rotation * n;\n}\nreturn n;\n}\nvec4 project_offset_(vec4 offset) {\nfloat dy = offset.y;\nvec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;\nreturn vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\nfloat x = lnglat.x;\nif (project.wrapLongitude) {\nx = mod(x + 180., 360.0) - 180.;\n}\nfloat y = clamp(lnglat.y, -89.9, 89.9);\nreturn vec2(\nradians(x) + PI,\nPI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n) * WORLD_SCALE;\n}\nvec3 project_globe_(vec3 lnglatz) {\nfloat lambda = radians(lnglatz.x);\nfloat phi = radians(lnglatz.y);\nfloat cosPhi = cos(phi);\nfloat D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\nreturn vec3(\nsin(lambda) * cosPhi,\n-cos(lambda) * cosPhi,\nsin(phi)\n) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\nvec4 position_world = project.modelMatrix * position;\nif (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {\nif (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\nreturn vec4(\nproject_mercator_(position_world.xy),\nproject_size_at_latitude(position_world.z, position_world.y),\nposition_world.w\n);\n}\nif (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\nposition_world.xyz += project.coordinateOrigin;\n}\n}\nif (project.projectionMode == PROJECTION_MODE_GLOBE) {\nif (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\nreturn vec4(\nproject_globe_(position_world.xyz),\nposition_world.w\n);\n}\n}\nif (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\nif (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\nif (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {\nreturn vec4(\nproject_mercator_(position_world.xy) - project.commonOrigin.xy,\nproject_size(position_world.z),\nposition_world.w\n);\n}\n}\n}\nif (project.projectionMode == PROJECTION_MODE_IDENTITY ||\n(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\nproject.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\nposition_world.xyz -= project.coordinateOrigin;\n}\nreturn project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));\n}\nvec4 project_position(vec4 position) {\nreturn project_position(position, ZERO_64_LOW);\n}\nvec3 project_position(vec3 position, vec3 position64Low) {\nvec4 projected_position = project_position(vec4(position, 1.0), position64Low);\nreturn projected_position.xyz;\n}\nvec3 project_position(vec3 position) {\nvec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\nreturn projected_position.xyz;\n}\nvec2 project_position(vec2 position) {\nvec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\nreturn projected_position.xy;\n}\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\nreturn viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\nreturn project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\nvec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;\nreturn offset * project.focalDistance;\n}\nfloat project_size_to_pixel(float meters) {\nreturn project_size(meters) * project.scale;\n}\nfloat project_size_to_pixel(float size, int unit) {\nif (unit == UNIT_METERS) return project_size_to_pixel(size);\nif (unit == UNIT_COMMON) return size * project.scale;\nreturn size;\n}\nfloat project_pixel_size(float pixels) {\nreturn pixels / project.scale;\n}\nvec2 project_pixel_size(vec2 pixels) {\nreturn pixels / project.scale;\n}\n",c={};const d={name:"project",dependencies:[i.i,s.A],source:a,vs:l,getUniforms:function(e){return void 0===e&&(e=c),"viewport"in e?(0,o.a)(e):{}},uniformTypes:{wrapLongitude:"f32",coordinateSystem:"i32",commonUnitsPerMeter:"vec3<f32>",projectionMode:"i32",scale:"f32",commonUnitsPerWorldUnit:"vec3<f32>",commonUnitsPerWorldUnit2:"vec3<f32>",center:"vec4<f32>",modelMatrix:"mat4x4<f32>",viewProjectionMatrix:"mat4x4<f32>",viewportSize:"vec2<f32>",devicePixelRatio:"f32",focalDistance:"f32",cameraPosition:"vec3<f32>",coordinateOrigin:"vec3<f32>",commonOrigin:"vec3<f32>",pseudoMeters:"f32"}}},28593:(e,t,n)=>{n.d(t,{a:()=>g,o:()=>u});var i=n(39426),s=n(90218),o=n(8961),r=n(63190);const a=[0,0,0,0],l=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0],c=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],d=[0,0,0],h=[0,0,0],p=(0,r.A)((function(e){let{viewport:t,devicePixelRatio:n,coordinateSystem:r,coordinateOrigin:h}=e;const{projectionCenter:p,viewProjectionMatrix:g,originCommon:f,cameraPosCommon:m,shaderCoordinateOrigin:v,geospatialOrigin:y}=function(e,t,n){const{viewMatrixUncentered:o,projectionMatrix:r}=e;let{viewMatrix:c,viewProjectionMatrix:d}=e,h=a,p=a,g=e.cameraPosition;const{geospatialOrigin:f,shaderCoordinateOrigin:m,offsetMode:v}=u(e,t,n);v&&(p=e.projectPosition(f||m),g=[g[0]-p[0],g[1]-p[1],g[2]-p[2]],p[3]=1,h=i.Z0([],p,d),c=o||c,d=s.lw([],r,c),d=s.lw([],d,l));return{viewMatrix:c,viewProjectionMatrix:d,projectionCenter:h,originCommon:p,cameraPosCommon:g,shaderCoordinateOrigin:m,geospatialOrigin:f}}(t,r,h),_=t.getDistanceScales(),x=[t.width*n,t.height*n],w=i.Z0([],[0,0,-t.focalDistance,1],t.projectionMatrix)[3]||1,b={coordinateSystem:r,projectionMode:t.projectionMode,coordinateOrigin:v,commonOrigin:f.slice(0,3),center:p,pseudoMeters:Boolean(t._pseudoMeters),viewportSize:x,devicePixelRatio:n,focalDistance:w,commonUnitsPerMeter:_.unitsPerMeter,commonUnitsPerWorldUnit:_.unitsPerMeter,commonUnitsPerWorldUnit2:d,scale:t.scale,wrapLongitude:!1,viewProjectionMatrix:g,modelMatrix:c,cameraPosition:m};if(y){const e=t.getDistanceScales(y);switch(r){case o.rf.METER_OFFSETS:b.commonUnitsPerWorldUnit=e.unitsPerMeter,b.commonUnitsPerWorldUnit2=e.unitsPerMeter2;break;case o.rf.LNGLAT:case o.rf.LNGLAT_OFFSETS:t._pseudoMeters||(b.commonUnitsPerMeter=e.unitsPerMeter),b.commonUnitsPerWorldUnit=e.unitsPerDegree,b.commonUnitsPerWorldUnit2=e.unitsPerDegree2;break;case o.rf.CARTESIAN:b.commonUnitsPerWorldUnit=[1,1,e.unitsPerMeter[2]],b.commonUnitsPerWorldUnit2=[0,0,e.unitsPerMeter2[2]]}}return b}));function u(e,t,n){void 0===n&&(n=h),n.length<3&&(n=[n[0],n[1],0]);let i,s=n,r=!0;switch(i=t===o.rf.LNGLAT_OFFSETS||t===o.rf.METER_OFFSETS?n:e.isGeospatial?[Math.fround(e.longitude),Math.fround(e.latitude),0]:null,e.projectionMode){case o.Kx.WEB_MERCATOR:t!==o.rf.LNGLAT&&t!==o.rf.CARTESIAN||(i=[0,0,0],r=!1);break;case o.Kx.WEB_MERCATOR_AUTO_OFFSET:t===o.rf.LNGLAT?s=i:t===o.rf.CARTESIAN&&(s=[Math.fround(e.center[0]),Math.fround(e.center[1]),0],i=e.unprojectPosition(s),s[0]-=n[0],s[1]-=n[1],s[2]-=n[2]);break;case o.Kx.IDENTITY:s=e.position.map(Math.fround),s[2]=s[2]||0;break;case o.Kx.GLOBE:r=!1,i=null;break;default:r=!1}return{geospatialOrigin:i,shaderCoordinateOrigin:s,offsetMode:r}}function g(e){let{viewport:t,devicePixelRatio:n=1,modelMatrix:i=null,coordinateSystem:s=o.rf.DEFAULT,coordinateOrigin:r=h,autoWrapLongitude:a=!1}=e;s===o.rf.DEFAULT&&(s=t.isGeospatial?o.rf.LNGLAT:o.rf.CARTESIAN);const l=p({viewport:t,devicePixelRatio:n,coordinateSystem:s,coordinateOrigin:r});return l.wrapLongitude=a,l.modelMatrix=i||c,l}},30428:(e,t,n)=>{n.d(t,{A:()=>i});const i={name:"project32",dependencies:[n(40281).A],source:"// Define a structure to hold both the clip-space position and the common position.\nstruct ProjectResult {\n  clipPosition: vec4<f32>,\n  commonPosition: vec4<f32>,\n};\n\n// This function mimics the GLSL version with the 'out' parameter by returning both values.\nfn project_position_to_clipspace_and_commonspace(\n    position: vec3<f32>,\n    position64Low: vec3<f32>,\n    offset: vec3<f32>\n) -> ProjectResult {\n  // Compute the projected position.\n  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);\n\n  // Start with the provided offset.\n  var finalOffset: vec3<f32> = offset;\n\n  // Get whether a rotation is needed and the rotation matrix.\n  let rotationResult = project_needs_rotation(projectedPosition);\n\n  // If rotation is needed, update the offset.\n  if (rotationResult.needsRotation) {\n    finalOffset = rotationResult.transform * offset;\n  }\n\n  // Compute the common position.\n  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);\n\n  // Convert to clip-space.\n  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);\n\n  return ProjectResult(clipPosition, commonPosition);\n}\n\n// A convenience overload that returns only the clip-space position.\nfn project_position_to_clipspace(\n    position: vec3<f32>,\n    position64Low: vec3<f32>,\n    offset: vec3<f32>\n) -> vec4<f32> {\n  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;\n}\n",vs:"vec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n"}},58662:(e,t,n)=>{n.d(t,{A:()=>a});var i=n(51020),s=n(54901);const o=["longitude","latitude","zoom","bearing","pitch"],r=["longitude","latitude","zoom"];class a extends i.A{constructor(e){void 0===e&&(e={});const t=Array.isArray(e)?e:e.transitionProps,n=Array.isArray(e)?{}:e;n.transitionProps=Array.isArray(t)?{compare:t,required:t}:t||{compare:o,required:r},super(n.transitionProps),this.opts=n}initializeProps(e,t){const n=super.initializeProps(e,t),{makeViewport:i,around:s}=this.opts;if(i&&s){const o=i(e),r=i(t),a=o.unproject(s);n.start.around=s,Object.assign(n.end,{around:r.project(a),aroundPosition:a,width:t.width,height:t.height})}return n}interpolateProps(e,t,n){const i={};for(const o of this._propsToExtract)i[o]=(0,s.Cc)(e[o]||0,t[o]||0,n);if(t.aroundPosition&&this.opts.makeViewport){const o=this.opts.makeViewport(Object.assign({},t,i));Object.assign(i,o.panByPosition(t.aroundPosition,(0,s.Cc)(e.around,t.around,n)))}return i}}},51020:(e,t,n)=>{n.d(t,{A:()=>o});var i=n(54901),s=n(95238);class o{constructor(e){const{compare:t,extract:n,required:i}=e;this._propsToCompare=t,this._propsToExtract=n||t,this._requiredProps=i}arePropsEqual(e,t){for(const n of this._propsToCompare)if(!(n in e)||!(n in t)||!(0,i.aI)(e[n],t[n]))return!1;return!0}initializeProps(e,t){const n={},i={};for(const s of this._propsToExtract)(s in e||s in t)&&(n[s]=e[s],i[s]=t[s]);return this._checkRequiredProps(n),this._checkRequiredProps(i),{start:n,end:i}}getDuration(e,t){return t.transitionDuration}_checkRequiredProps(e){this._requiredProps&&this._requiredProps.forEach((t=>{const n=e[t];(0,s.A)(Number.isFinite(n)||Array.isArray(n),t+" is required for transition")}))}}},50948:(e,t,n)=>{n.d(t,{A:()=>i});class i{constructor(e){this._inProgress=!1,this._handle=null,this.time=0,this.settings={duration:0},this._timeline=e}get inProgress(){return this._inProgress}start(e){var t,n;this.cancel(),this.settings=e,this._inProgress=!0,null==(t=(n=this.settings).onStart)||t.call(n,this)}end(){var e,t;this._inProgress&&(this._timeline.removeChannel(this._handle),this._handle=null,this._inProgress=!1,null==(e=(t=this.settings).onEnd)||e.call(t,this))}cancel(){var e,t;this._inProgress&&(null==(e=(t=this.settings).onInterrupt)||e.call(t,this),this._timeline.removeChannel(this._handle),this._handle=null,this._inProgress=!1)}update(){var e,t;if(!this._inProgress)return!1;if(null===this._handle){const{_timeline:e,settings:t}=this;this._handle=e.addChannel({delay:e.getTime(),duration:t.duration})}return this.time=this._timeline.getTime(this._handle),this._onUpdate(),null==(e=(t=this.settings).onUpdate)||e.call(t,this),this._timeline.isFinished(this._handle)&&this.end(),!0}_onUpdate(){}}},91013:(e,t,n)=>{function i(e,t){t&&Object.entries(t).map((t=>{let[n,i]=t;n.startsWith("--")?e.style.setProperty(n,i):e.style[n]=i}))}function s(e,t){t&&Object.keys(t).map((t=>{t.startsWith("--")?e.style.removeProperty(t):e.style[t]=""}))}n.d(t,{Z:()=>i,h:()=>s})},95238:(e,t,n)=>{function i(e,t){if(!e)throw new Error(t||"deck.gl: assertion failed.")}n.d(t,{A:()=>i})},50111:(e,t,n)=>{function i(e,t,n){if(e===t)return!0;if(!n||!e||!t)return!1;if(Array.isArray(e)){if(!Array.isArray(t)||e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(!i(e[s],t[s],n-1))return!1;return!0}if(Array.isArray(t))return!1;if("object"==typeof e&&"object"==typeof t){const s=Object.keys(e),o=Object.keys(t);if(s.length!==o.length)return!1;for(const r of s){if(!t.hasOwnProperty(r))return!1;if(!i(e[r],t[r],n-1))return!1}return!0}return!1}n.d(t,{b:()=>i})},13696:(e,t,n)=>{function i(e,t){return void 0===t&&(t=()=>!0),Array.isArray(e)?s(e,t,[]):t(e)?[e]:[]}function s(e,t,n){let i=-1;for(;++i<e.length;){const o=e[i];Array.isArray(o)?s(o,t,n):t(o)&&n.push(o)}return n}function o(e){let{target:t,source:n,start:i=0,count:s=1}=e;const o=n.length,r=s*o;let a=0;for(let l=i;a<o;a++)t[l++]=n[a];for(;a<r;)a<r-a?(t.copyWithin(i+a,i,i+a),a*=2):(t.copyWithin(i+a,i,i+r-a),a=r);return t}n.d(t,{B:()=>i,R:()=>o})},33698:(e,t,n)=>{n.d(t,{I:()=>a,Td:()=>r,X:()=>o});const i=[],s=[];function o(e,t,n){void 0===t&&(t=0),void 0===n&&(n=1/0);let o=i;const r={index:-1,data:e,target:[]};return e?"function"==typeof e[Symbol.iterator]?o=e:e.length>0&&(s.length=e.length,o=s):o=i,(t>0||Number.isFinite(n))&&(o=(Array.isArray(o)?o:Array.from(o)).slice(t,n),r.index=t-1),{iterable:o,objectInfo:r}}function r(e){return e&&e[Symbol.asyncIterator]}function a(e,t){const{size:n,stride:i,offset:s,startIndices:o,nested:r}=t,a=e.BYTES_PER_ELEMENT,l=i?i/a:n,c=s?s/a:0,d=Math.floor((e.length-c)/l);return(t,i)=>{let{index:s,target:a}=i;if(!o){const t=s*l+c;for(let i=0;i<n;i++)a[i]=e[t+i];return a}const h=o[s],p=o[s+1]||d;let u;if(r){u=new Array(p-h);for(let t=h;t<p;t++){const i=t*l+c;a=new Array(n);for(let t=0;t<n;t++)a[t]=e[i+t];u[t-h]=a}}else if(l===n)u=e.subarray(h*n+c,p*n+c);else{u=new e.constructor((p-h)*n);let t=0;for(let i=h;i<p;i++){const s=i*l+c;for(let i=0;i<n;i++)u[t++]=e[s+i]}}return u}}},18120:(e,t,n)=>{n.d(t,{A:()=>i});const i=new(n(85335).t)({id:"deck"})},87350:(e,t,n)=>{n.d(t,{$M:()=>o,Vl:()=>a,_Z:()=>u,cT:()=>p,on:()=>l,zi:()=>r});var i=n(81052),s=n(87597);function o(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}function r(e,t){const n=e%t;return n<0?t+n:n}function a(e){return[e[12],e[13],e[14]]}function l(e){return{left:d(e[3]+e[0],e[7]+e[4],e[11]+e[8],e[15]+e[12]),right:d(e[3]-e[0],e[7]-e[4],e[11]-e[8],e[15]-e[12]),bottom:d(e[3]+e[1],e[7]+e[5],e[11]+e[9],e[15]+e[13]),top:d(e[3]-e[1],e[7]-e[5],e[11]-e[9],e[15]-e[13]),near:d(e[3]+e[2],e[7]+e[6],e[11]+e[10],e[15]+e[14]),far:d(e[3]-e[2],e[7]-e[6],e[11]-e[10],e[15]-e[14])}}const c=new s.P;function d(e,t,n,i){c.set(e,t,n);const o=c.len();return{distance:i/o,normal:new s.P(-e/o,-t/o,-n/o)}}let h;function p(e,t){const{size:n=1,startIndex:s=0}=t,o=void 0!==t.endIndex?t.endIndex:e.length,r=(o-s)/n;h=i.A.allocate(h,r,{type:Float32Array,size:2*n});let a=s,l=0;for(;a<o;){for(let t=0;t<n;t++){const i=e[a++];h[l+t]=i,h[l+t+n]=(c=i)-Math.fround(c)}l+=2*n}var c;return h.subarray(0,r*n*2)}function u(e){let t=null,n=!1;for(const i of e)i&&(t?(n||(t=[[t[0][0],t[0][1]],[t[1][0],t[1][1]]],n=!0),t[0][0]=Math.min(t[0][0],i[0][0]),t[0][1]=Math.min(t[0][1],i[0][1]),t[1][0]=Math.max(t[1][0],i[1][0]),t[1][1]=Math.max(t[1][1],i[1][1])):t=i);return t}},63190:(e,t,n)=>{function i(e,t){if(e===t)return!0;if(Array.isArray(e)){const n=e.length;if(!t||t.length!==n)return!1;for(let i=0;i<n;i++)if(e[i]!==t[i])return!1;return!0}return!1}function s(e){let t,n={};return s=>{for(const o in s)if(!i(s[o],n[o])){t=e(s),n=s;break}return t}}n.d(t,{A:()=>s})},50364:(e,t,n)=>{n.d(t,{A:()=>a});var i=n(33698),s=n(81052),o=n(95238),r=n(26839);class a{constructor(e){this.indexStarts=[0],this.vertexStarts=[0],this.vertexCount=0,this.instanceCount=0;const{attributes:t={}}=e;this.typedArrayManager=s.A,this.attributes={},this._attributeDefs=t,this.opts=e,this.updateGeometry(e)}updateGeometry(e){Object.assign(this.opts,e);const{data:t,buffers:n={},getGeometry:i,geometryBuffer:s,positionFormat:r,dataChanged:a,normalize:l=!0}=this.opts;if(this.data=t,this.getGeometry=i,this.positionSize=s&&s.size||("XY"===r?2:3),this.buffers=n,this.normalize=l,s&&((0,o.A)(t.startIndices),this.getGeometry=this.getGeometryFromBuffer(s),l||(n.vertexPositions=s)),this.geometryBuffer=n.vertexPositions,Array.isArray(a))for(const o of a)this._rebuildGeometry(o);else this._rebuildGeometry()}updatePartialGeometry(e){let{startRow:t,endRow:n}=e;this._rebuildGeometry({startRow:t,endRow:n})}getGeometryFromBuffer(e){const t=e.value||e;return ArrayBuffer.isView(t)?(0,i.I)(t,{size:this.positionSize,offset:e.offset,stride:e.stride,startIndices:this.data.startIndices}):null}_allocate(e,t){const{attributes:n,buffers:i,_attributeDefs:s,typedArrayManager:o}=this;for(const r in s)if(r in i)o.release(n[r]),n[r]=null;else{const i=s[r];i.copy=t,n[r]=o.allocate(n[r],e,i)}}_forEachGeometry(e,t,n){const{data:s,getGeometry:o}=this,{iterable:r,objectInfo:a}=(0,i.X)(s,t,n);for(const i of r){a.index++;e(o?o(i,a):null,a.index)}}_rebuildGeometry(e){if(!this.data)return;let{indexStarts:t,vertexStarts:n,instanceCount:i}=this;const{data:s,geometryBuffer:o}=this,{startRow:a=0,endRow:l=1/0}=e||{},c={};if(e||(t=[0],n=[0]),this.normalize||!o)this._forEachGeometry(((e,t)=>{const i=e&&this.normalizeGeometry(e);c[t]=i,n[t+1]=n[t]+(i?this.getGeometrySize(i):0)}),a,l),i=n[n.length-1];else if(n=s.startIndices,i=n[s.length]||0,ArrayBuffer.isView(o))i=i||o.length/this.positionSize;else if(o instanceof r.h){const e=4*this.positionSize;i=i||o.byteLength/e}else if(o.buffer){const e=o.stride||4*this.positionSize;i=i||o.buffer.byteLength/e}else if(o.value){const e=o.value,t=o.stride/e.BYTES_PER_ELEMENT||this.positionSize;i=i||e.length/t}this._allocate(i,Boolean(e)),this.indexStarts=t,this.vertexStarts=n,this.instanceCount=i;const d={};this._forEachGeometry(((e,s)=>{const o=c[s]||e;d.vertexStart=n[s],d.indexStart=t[s];const r=s<n.length-1?n[s+1]:i;d.geometrySize=r-n[s],d.geometryIndex=s,this.updateGeometryAttributes(o,d)}),a,l),this.vertexCount=t[t.length-1]}}},81052:(e,t,n)=>{n.d(t,{A:()=>i});const i=new class{constructor(e){void 0===e&&(e={}),this._pool=[],this.opts={overAlloc:2,poolSize:100},this.setOptions(e)}setOptions(e){Object.assign(this.opts,e)}allocate(e,t,n){let{size:i=1,type:s,padding:o=0,copy:r=!1,initialize:a=!1,maxCount:l}=n;const c=s||e&&e.constructor||Float32Array,d=t*i+o;if(ArrayBuffer.isView(e)){if(d<=e.length)return e;if(d*e.BYTES_PER_ELEMENT<=e.buffer.byteLength)return new c(e.buffer,0,d)}let h=1/0;l&&(h=l*i+o);const p=this._allocate(c,d,a,h);return e&&r?p.set(e):a||p.fill(0,0,4),this._release(e),p}release(e){this._release(e)}_allocate(e,t,n,i){let s=Math.max(Math.ceil(t*this.opts.overAlloc),1);s>i&&(s=i);const o=this._pool,r=e.BYTES_PER_ELEMENT*s,a=o.findIndex((e=>e.byteLength>=r));if(a>=0){const t=new e(o.splice(a,1)[0],0,s);return n&&t.fill(0),t}return new e(s)}_release(e){if(!ArrayBuffer.isView(e))return;const t=this._pool,{buffer:n}=e,{byteLength:i}=n,s=t.findIndex((e=>e.byteLength>=i));s<0?t.push(n):(s>0||t.length<this.opts.poolSize)&&t.splice(s,0,n),t.length>this.opts.poolSize&&t.shift()}}},43976:(e,t,n)=>{n.d(t,{A:()=>m});var i=n(18120),s=n(87350),o=n(31886),r=n(54901),a=n(87597),l=n(90218),c=n(73279),d=n(8961);const h=Math.PI/180,p=(0,s.$M)(),u=[0,0,0],g={unitsPerMeter:[1,1,1],metersPerUnit:[1,1,1]};class f{constructor(e){void 0===e&&(e={}),this._frustumPlanes={},this.id=e.id||this.constructor.displayName||"viewport",this.x=e.x||0,this.y=e.y||0,this.width=e.width||1,this.height=e.height||1,this.zoom=e.zoom||0,this.padding=e.padding,this.distanceScales=e.distanceScales||g,this.focalDistance=e.focalDistance||1,this.position=e.position||u,this.modelMatrix=e.modelMatrix||null;const{longitude:t,latitude:n}=e;this.isGeospatial=Number.isFinite(n)&&Number.isFinite(t),this._initProps(e),this._initMatrices(e),this.equals=this.equals.bind(this),this.project=this.project.bind(this),this.unproject=this.unproject.bind(this),this.projectPosition=this.projectPosition.bind(this),this.unprojectPosition=this.unprojectPosition.bind(this),this.projectFlat=this.projectFlat.bind(this),this.unprojectFlat=this.unprojectFlat.bind(this)}get subViewports(){return null}get metersPerPixel(){return this.distanceScales.metersPerUnit[2]/this.scale}get projectionMode(){return this.isGeospatial?this.zoom<12?d.Kx.WEB_MERCATOR:d.Kx.WEB_MERCATOR_AUTO_OFFSET:d.Kx.IDENTITY}equals(e){return e instanceof f&&(this===e||e.width===this.width&&e.height===this.height&&e.scale===this.scale&&(0,r.aI)(e.projectionMatrix,this.projectionMatrix)&&(0,r.aI)(e.viewMatrix,this.viewMatrix))}project(e,t){let{topLeft:n=!0}=void 0===t?{}:t;const i=this.projectPosition(e),s=(0,c.VJ)(i,this.pixelProjectionMatrix),[o,r]=s,a=n?r:this.height-r;return 2===e.length?[o,a]:[o,a,s[2]]}unproject(e,t){let{topLeft:n=!0,targetZ:i}=void 0===t?{}:t;const[s,o,r]=e,a=n?o:this.height-o,l=i&&i*this.distanceScales.unitsPerMeter[2],d=(0,c.xJ)([s,a,r],this.pixelUnprojectionMatrix,l),[h,p,u]=this.unprojectPosition(d);return Number.isFinite(r)?[h,p,u]:Number.isFinite(i)?[h,p,i]:[h,p]}projectPosition(e){const[t,n]=this.projectFlat(e);return[t,n,(e[2]||0)*this.distanceScales.unitsPerMeter[2]]}unprojectPosition(e){const[t,n]=this.unprojectFlat(e);return[t,n,(e[2]||0)*this.distanceScales.metersPerUnit[2]]}projectFlat(e){if(this.isGeospatial){const t=(0,c.Gw)(e);return t[1]=(0,r.qE)(t[1],-318,830),t}return e}unprojectFlat(e){return this.isGeospatial?(0,c.iV)(e):e}getBounds(e){void 0===e&&(e={});const t={targetZ:e.z||0},n=this.unproject([0,0],t),i=this.unproject([this.width,0],t),s=this.unproject([0,this.height],t),o=this.unproject([this.width,this.height],t);return[Math.min(n[0],i[0],s[0],o[0]),Math.min(n[1],i[1],s[1],o[1]),Math.max(n[0],i[0],s[0],o[0]),Math.max(n[1],i[1],s[1],o[1])]}getDistanceScales(e){return e&&this.isGeospatial?(0,c.nI)({longitude:e[0],latitude:e[1],highPrecision:!0}):this.distanceScales}containsPixel(e){let{x:t,y:n,width:i=1,height:s=1}=e;return t<this.x+this.width&&this.x<t+i&&n<this.y+this.height&&this.y<n+s}getFrustumPlanes(){return this._frustumPlanes.near||Object.assign(this._frustumPlanes,(0,s.on)(this.viewProjectionMatrix)),this._frustumPlanes}panByPosition(e,t){return null}_initProps(e){const t=e.longitude,n=e.latitude;this.isGeospatial&&(Number.isFinite(e.zoom)||(this.zoom=(0,c.fO)({latitude:n})+Math.log2(this.focalDistance)),this.distanceScales=e.distanceScales||(0,c.nI)({latitude:n,longitude:t}));const i=Math.pow(2,this.zoom);this.scale=i;const{position:s,modelMatrix:r}=e;let l=u;if(s&&(l=r?new o.k(r).transformAsVector(s,[]):s),this.isGeospatial){const e=this.projectPosition([t,n,0]);this.center=new a.P(l).scale(this.distanceScales.unitsPerMeter).add(e)}else this.center=this.projectPosition(l)}_initMatrices(e){const{viewMatrix:t=p,projectionMatrix:n=null,orthographic:c=!1,fovyRadians:d,fovy:u=75,near:g=.1,far:f=1e3,padding:m=null,focalDistance:v=1}=e;this.viewMatrixUncentered=t,this.viewMatrix=(new o.k).multiplyRight(t).translate(new a.P(this.center).negate()),this.projectionMatrix=n||function(e){let{width:t,height:n,orthographic:i,fovyRadians:s,focalDistance:a,padding:l,near:c,far:d}=e;const h=t/n,p=i?(new o.k).orthographic({fovy:s,aspect:h,focalDistance:a,near:c,far:d}):(new o.k).perspective({fovy:s,aspect:h,near:c,far:d});if(l){const{left:e=0,right:i=0,top:s=0,bottom:o=0}=l,a=(0,r.qE)((e+t-i)/2,0,t)-t/2,c=(0,r.qE)((s+n-o)/2,0,n)-n/2;p[8]-=2*a/t,p[9]+=2*c/n}return p}({width:this.width,height:this.height,orthographic:c,fovyRadians:d||u*h,focalDistance:v,padding:m,near:g,far:f});const y=(0,s.$M)();l.lw(y,y,this.projectionMatrix),l.lw(y,y,this.viewMatrix),this.viewProjectionMatrix=y,this.viewMatrixInverse=l.B8([],this.viewMatrix)||this.viewMatrix,this.cameraPosition=(0,s.Vl)(this.viewMatrixInverse);const _=(0,s.$M)(),x=(0,s.$M)();l.hs(_,_,[this.width/2,-this.height/2,1]),l.Tl(_,_,[1,-1,0]),l.lw(x,_,this.viewProjectionMatrix),this.pixelProjectionMatrix=x,this.pixelUnprojectionMatrix=l.B8((0,s.$M)(),this.pixelProjectionMatrix),this.pixelUnprojectionMatrix||i.A.warn("Pixel project matrix not invertible")()}}f.displayName="Viewport";const m=f},59073:(e,t,n)=>{n.d(t,{A:()=>c});var i=n(43976),s=n(73279),o=n(54901),r=n(31886),a=n(83588);class l extends i.A{constructor(e){void 0===e&&(e={});const{latitude:t=0,longitude:n=0,zoom:i=0,pitch:a=0,bearing:l=0,nearZMultiplier:c=.1,farZMultiplier:d=1.01,nearZ:h,farZ:p,orthographic:u=!1,projectionMatrix:g,repeat:f=!1,worldOffset:m=0,position:v,padding:y,legacyMeterSizes:_=!1}=e;let{width:x,height:w,altitude:b=1.5}=e;const P=Math.pow(2,i);let S;x=x||1,w=w||1;let C=null;if(g)b=g[5]/2,S=(0,s.Os)(b);else{let n;if(e.fovy?(S=e.fovy,b=(0,s.wZ)(S)):S=(0,s.Os)(b),y){const{top:e=0,bottom:t=0}=y;n=[0,(0,o.qE)((e+w-t)/2,0,w)-w/2]}C=(0,s.om)({width:x,height:w,scale:P,center:v&&[0,0,v[2]*(0,s.mY)(t)],offset:n,pitch:a,fovy:S,nearZMultiplier:c,farZMultiplier:d}),Number.isFinite(h)&&(C.near=h),Number.isFinite(p)&&(C.far=p)}let j=(0,s.rY)({height:w,pitch:a,bearing:l,scale:P,altitude:b});if(m){j=(new r.k).translate([512*m,0,0]).multiplyLeft(j)}super(Object.assign({},e,{width:x,height:w,viewMatrix:j,longitude:n,latitude:t,zoom:i},C,{fovy:S,focalDistance:b})),this.latitude=t,this.longitude=n,this.zoom=i,this.pitch=a,this.bearing=l,this.altitude=b,this.fovy=S,this.orthographic=u,this._subViewports=f?[]:null,this._pseudoMeters=_,Object.freeze(this)}get subViewports(){if(this._subViewports&&!this._subViewports.length){const e=this.getBounds(),t=Math.floor((e[0]+180)/360),n=Math.ceil((e[2]-180)/360);for(let i=t;i<=n;i++){const e=i?new l(Object.assign({},this,{worldOffset:i})):this;this._subViewports.push(e)}}return this._subViewports}projectPosition(e){if(this._pseudoMeters)return super.projectPosition(e);const[t,n]=this.projectFlat(e);return[t,n,(e[2]||0)*(0,s.mY)(e[1])]}unprojectPosition(e){if(this._pseudoMeters)return super.unprojectPosition(e);const[t,n]=this.unprojectFlat(e);return[t,n,(e[2]||0)/(0,s.mY)(n)]}addMetersToLngLat(e,t){return(0,s.dT)(e,t)}panByPosition(e,t){const n=(0,s.xJ)(t,this.pixelUnprojectionMatrix),i=this.projectFlat(e),o=a.WQ([],i,a.ze([],n)),r=a.WQ([],this.center,o),[l,c]=this.unprojectFlat(r);return{longitude:l,latitude:c}}getBounds(e){void 0===e&&(e={});const t=(0,s.gW)(this,e.z||0);return[Math.min(t[0][0],t[1][0],t[2][0],t[3][0]),Math.min(t[0][1],t[1][1],t[2][1],t[3][1]),Math.max(t[0][0],t[1][0],t[2][0],t[3][0]),Math.max(t[0][1],t[1][1],t[2][1],t[3][1])]}fitBounds(e,t){void 0===t&&(t={});const{width:n,height:i}=this,{longitude:o,latitude:r,zoom:a}=(0,s.Fe)(Object.assign({width:n,height:i,bounds:e},t));return new l({width:n,height:i,longitude:o,latitude:r,zoom:a})}}l.displayName="WebMercatorViewport";const c=l},63201:(e,t,n)=>{n.d(t,{A:()=>a});var i=n(49398),s=n(59073),o=n(67797);class r extends i.A{constructor(e){void 0===e&&(e={}),super(e)}getViewportType(){return s.A}get ControllerType(){return o.A}}r.displayName="MapView";const a=r},49398:(e,t,n)=>{n.d(t,{A:()=>a});const i=/([0-9]+\.?[0-9]*)(%|px)/;function s(e){switch(typeof e){case"number":return{position:e,relative:!1};case"string":const t=i.exec(e);if(t&&t.length>=3){const e="%"===t[2],n=parseFloat(t[1]);return{position:e?n/100:n,relative:e}}default:throw new Error("Could not parse position string "+e)}}function o(e,t){return e.relative?Math.round(e.position*t):e.position}var r=n(50111);class a{constructor(e){const{id:t,x:n=0,y:i=0,width:o="100%",height:r="100%",padding:a=null}=e;this.id=t||this.constructor.displayName||"view",this.props=Object.assign({},e,{id:this.id}),this._x=s(n),this._y=s(i),this._width=s(o),this._height=s(r),this._padding=a&&{left:s(a.left||0),right:s(a.right||0),top:s(a.top||0),bottom:s(a.bottom||0)},this.equals=this.equals.bind(this),Object.seal(this)}equals(e){return this===e||this.constructor===e.constructor&&(0,r.b)(this.props,e.props,2)}clone(e){return new(0,this.constructor)(Object.assign({},this.props,e))}makeViewport(e){let{width:t,height:n,viewState:i}=e;i=this.filterViewState(i);const s=this.getDimensions({width:t,height:n});if(!s.height||!s.width)return null;return new(this.getViewportType(i))(Object.assign({},i,this.props,s))}getViewStateId(){const{viewState:e}=this.props;return"string"==typeof e?e:(null==e?void 0:e.id)||this.id}filterViewState(e){if(this.props.viewState&&"object"==typeof this.props.viewState){if(!this.props.viewState.id)return this.props.viewState;const t=Object.assign({},e);for(const e in this.props.viewState)"id"!==e&&(t[e]=this.props.viewState[e]);return t}return e}getDimensions(e){let{width:t,height:n}=e;const i={x:o(this._x,t),y:o(this._y,n),width:o(this._width,t),height:o(this._height,n)};return this._padding&&(i.padding={left:o(this._padding.left,t),top:o(this._padding.top,n),right:o(this._padding.right,t),bottom:o(this._padding.bottom,n)}),i}get controller(){const e=this.props.controller;return e?!0===e?{type:this.ControllerType}:"function"==typeof e?{type:e}:Object.assign({type:this.ControllerType},e):null}}},3346:(e,t,n)=>{n.d(t,{A:()=>u});var i=n(3002),s=n(30428),o=n(28756),r=n(8961),a=n(8274);const l="uniform arcUniforms {\n  bool greatCircle;\n  bool useShortestPath;\n  float numSegments;\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  highp int widthUnits;\n} arc;\n",c={name:"arc",vs:l,fs:l,uniformTypes:{greatCircle:"f32",useShortestPath:"f32",numSegments:"f32",widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",widthUnits:"i32"}},d=[0,0,0,255],h={getSourcePosition:{type:"accessor",value:e=>e.sourcePosition},getTargetPosition:{type:"accessor",value:e=>e.targetPosition},getSourceColor:{type:"accessor",value:d},getTargetColor:{type:"accessor",value:d},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,numSegments:{type:"number",value:50,min:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class p extends i.A{getBounds(){var e;return null==(e=this.getAttributeManager())?void 0:e.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME arc-layer-vertex-shader\nin vec4 instanceSourceColors;\nin vec4 instanceTargetColors;\nin vec3 instanceSourcePositions;\nin vec3 instanceSourcePositions64Low;\nin vec3 instanceTargetPositions;\nin vec3 instanceTargetPositions64Low;\nin vec3 instancePickingColors;\nin float instanceWidths;\nin float instanceHeights;\nin float instanceTilts;\nout vec4 vColor;\nout vec2 uv;\nout float isValid;\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\nfloat deltaZ = targetZ - sourceZ;\nfloat dh = distance * instanceHeights;\nif (dh == 0.0) {\nreturn sourceZ + deltaZ * ratio;\n}\nfloat unitZ = deltaZ / dh;\nfloat p2 = unitZ * unitZ + 1.0;\nfloat dir = step(deltaZ, 0.0);\nfloat z0 = mix(sourceZ, targetZ, dir);\nfloat r = mix(ratio, 1.0 - ratio, dir);\nreturn sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\nvec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);\ndir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\nreturn dir_screenspace * offset_direction * width / 2.0;\n}\nfloat getSegmentRatio(float index) {\nreturn smoothstep(0.0, 1.0, index / (arc.numSegments - 1.0));\n}\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\nfloat distance = length(source.xy - target.xy);\nfloat z = paraboloid(distance, source.z, target.z, segmentRatio);\nfloat tiltAngle = radians(instanceTilts);\nvec2 tiltDirection = normalize(target.xy - source.xy);\nvec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\nreturn vec3(\nmix(source.xy, target.xy, segmentRatio) + tilt,\nz * cos(tiltAngle)\n);\n}\nfloat getAngularDist (vec2 source, vec2 target) {\nvec2 sourceRadians = radians(source);\nvec2 targetRadians = radians(target);\nvec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\nvec2 shd_sq = sin_half_delta * sin_half_delta;\nfloat a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\nreturn 2.0 * asin(sqrt(a));\n}\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\nvec2 lngLat;\nif(abs(angularDist - PI) < 0.001) {\nlngLat = (1.0 - t) * source.xy + t * target.xy;\n} else {\nfloat a = sin((1.0 - t) * angularDist);\nfloat b = sin(t * angularDist);\nvec3 p = source3D.yxz * a + target3D.yxz * b;\nlngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n}\nfloat z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\nreturn vec3(lngLat, z);\n}\nvoid main(void) {\ngeometry.worldPosition = instanceSourcePositions;\ngeometry.worldPositionAlt = instanceTargetPositions;\nfloat segmentIndex = float(gl_VertexID / 2);\nfloat segmentSide = mod(float(gl_VertexID), 2.) == 0. ? -1. : 1.;\nfloat segmentRatio = getSegmentRatio(segmentIndex);\nfloat prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\nfloat nextSegmentRatio = getSegmentRatio(min(arc.numSegments - 1.0, segmentIndex + 1.0));\nfloat indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\nisValid = 1.0;\nuv = vec2(segmentRatio, segmentSide);\ngeometry.uv = uv;\ngeometry.pickingColor = instancePickingColors;\nvec4 curr;\nvec4 next;\nvec3 source;\nvec3 target;\nif ((arc.greatCircle || project.projectionMode == PROJECTION_MODE_GLOBE) && project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\nsource = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\ntarget = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\nfloat angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\nvec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\nvec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\nvec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\nif (abs(currPos.x - prevPos.x) > 180.0) {\nindexDir = -1.0;\nisValid = 0.0;\n} else if (abs(currPos.x - nextPos.x) > 180.0) {\nindexDir = 1.0;\nisValid = 0.0;\n}\nnextPos = indexDir < 0.0 ? prevPos : nextPos;\nnextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\nif (isValid == 0.0) {\nnextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\nfloat t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\ncurrPos = mix(currPos, nextPos, t);\nsegmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n}\nvec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\nvec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\ncurr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\nnext = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n} else {\nvec3 source_world = instanceSourcePositions;\nvec3 target_world = instanceTargetPositions;\nif (arc.useShortestPath) {\nsource_world.x = mod(source_world.x + 180., 360.0) - 180.;\ntarget_world.x = mod(target_world.x + 180., 360.0) - 180.;\nfloat deltaLng = target_world.x - source_world.x;\nif (deltaLng > 180.) target_world.x -= 360.;\nif (deltaLng < -180.) source_world.x -= 360.;\n}\nsource = project_position(source_world, instanceSourcePositions64Low);\ntarget = project_position(target_world, instanceTargetPositions64Low);\nfloat antiMeridianX = 0.0;\nif (arc.useShortestPath) {\nif (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\nantiMeridianX = -(project.coordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n}\nfloat thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\nif (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\nisValid = 0.0;\nindexDir = sign(segmentRatio - thresholdRatio);\nsegmentRatio = thresholdRatio;\n}\n}\nnextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\nvec3 currPos = interpolateFlat(source, target, segmentRatio);\nvec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\nif (arc.useShortestPath) {\nif (nextPos.x < antiMeridianX) {\ncurrPos.x += TILE_SIZE;\nnextPos.x += TILE_SIZE;\n}\n}\ncurr = project_common_position_to_clipspace(vec4(currPos, 1.0));\nnext = project_common_position_to_clipspace(vec4(nextPos, 1.0));\ngeometry.position = vec4(currPos, 1.0);\n}\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceWidths * arc.widthScale, arc.widthUnits),\narc.widthMinPixels, arc.widthMaxPixels\n);\nvec3 offset = vec3(\ngetExtrusionOffset((next.xy - curr.xy) * indexDir, segmentSide, widthPixels),\n0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\nDECKGL_FILTER_GL_POSITION(curr, geometry);\ngl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\nvec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\nvColor = vec4(color.rgb, color.a * layer.opacity);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME arc-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 uv;\nin float isValid;\nout vec4 fragColor;\nvoid main(void) {\nif (isValid == 0.0) {\ndiscard;\n}\nfragColor = vColor;\ngeometry.uv = uv;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[s.A,o.A,c]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getSourceColor",defaultValue:d},instanceTargetColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getTargetColor",defaultValue:d},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(e){var t;(super.updateState(e),e.changeFlags.extensionsChanged)&&(null==(t=this.state.model)||t.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw(e){let{uniforms:t}=e;const{widthUnits:n,widthScale:i,widthMinPixels:s,widthMaxPixels:o,greatCircle:a,wrapLongitude:l,numSegments:c}=this.props,d={numSegments:c,widthUnits:r.p5[n],widthScale:i,widthMinPixels:s,widthMaxPixels:o,greatCircle:a,useShortestPath:l},h=this.state.model;h.shaderInputs.setProps({arc:d}),h.setVertexCount(2*c),h.draw(this.context.renderPass)}_getModel(){return new a.K(this.context.device,Object.assign({},this.getShaders(),{id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),topology:"triangle-strip",isInstanced:!0}))}}p.layerName="ArcLayer",p.defaultProps=h;const u=p},48956:(e,t,n)=>{n.d(t,{A:()=>y});var i=n(8961),s=n(3002),o=n(30428),r=n(28756),a=n(8274),l=n(73279),c=n(54901);const d=new Uint32Array([0,2,1,0,3,2]),h=new Float32Array([0,1,0,0,1,0,1,1]);function p(e,t){if(!t)return function(e){const t=new Float64Array(12);for(let n=0;n<e.length;n++)t[3*n+0]=e[n][0],t[3*n+1]=e[n][1],t[3*n+2]=e[n][2]||0;return{vertexCount:6,positions:t,indices:d,texCoords:h}}(e);const n=Math.max(Math.abs(e[0][0]-e[3][0]),Math.abs(e[1][0]-e[2][0])),i=Math.max(Math.abs(e[1][1]-e[0][1]),Math.abs(e[2][1]-e[3][1])),s=Math.ceil(n/t)+1,o=Math.ceil(i/t)+1,r=(s-1)*(o-1)*6,a=new Uint32Array(r),l=new Float32Array(s*o*2),c=new Float64Array(s*o*3);let p=0,g=0;for(let d=0;d<s;d++){const t=d/(s-1);for(let n=0;n<o;n++){const i=n/(o-1),s=u(e,t,i);c[3*p+0]=s[0],c[3*p+1]=s[1],c[3*p+2]=s[2]||0,l[2*p+0]=t,l[2*p+1]=1-i,d>0&&n>0&&(a[g++]=p-o,a[g++]=p-o-1,a[g++]=p-1,a[g++]=p-o,a[g++]=p-1,a[g++]=p),p++}}return{vertexCount:r,positions:c,indices:a,texCoords:l}}function u(e,t,n){return(0,c.Cc)((0,c.Cc)(e[0],e[1],n),(0,c.Cc)(e[3],e[2],n),t)}const g="uniform bitmapUniforms {\n  vec4 bounds;\n  float coordinateConversion;\n  float desaturate;\n  vec3 tintColor;\n  vec4 transparentColor;\n} bitmap;\n",f={name:"bitmap",vs:g,fs:g,uniformTypes:{bounds:"vec4<f32>",coordinateConversion:"f32",desaturate:"f32",tintColor:"vec3<f32>",transparentColor:"vec4<f32>"}},m={image:{type:"image",value:null,async:!0},bounds:{type:"array",value:[1,0,0,1],compare:!0},_imageCoordinateSystem:i.rf.DEFAULT,desaturate:{type:"number",min:0,max:1,value:0},transparentColor:{type:"color",value:[0,0,0,0]},tintColor:{type:"color",value:[255,255,255]},textureParameters:{type:"object",ignore:!0,value:null}};class v extends s.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nin vec2 texCoords;\nin vec3 positions;\nin vec3 positions64Low;\n\nout vec2 vTexCoord;\nout vec2 vTexPos;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  if (bitmap.coordinateConversion < -0.5) {\n    vTexPos = geometry.position.xy + project.commonOrigin.xy;\n  } else if (bitmap.coordinateConversion > 0.5) {\n    vTexPos = geometry.worldPosition.xy;\n  }\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nin vec2 vTexCoord;\nin vec2 vTexPos;\n\nout vec4 fragColor;\n\n/* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n// from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(\n    xy.x - PI,\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\n  ));\n}\n/* End projection utils */\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), bitmap.desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * bitmap.tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  if (bitmap.transparentColor.a == 0.0) {\n    return vec4(color, alpha);\n  }\n  float blendedAlpha = alpha + bitmap.transparentColor.a * (1.0 - alpha);\n  float highLightRatio = alpha / blendedAlpha;\n  vec3 blendedRGB = mix(bitmap.transparentColor.rgb, color, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bitmap.bounds[0]) / (bitmap.bounds[2] - bitmap.bounds[0]),\n    (pos.y - bitmap.bounds[3]) / (bitmap.bounds[1] - bitmap.bounds[3])\n  );\n}\n\n\nvec3 packUVsIntoRGB(vec2 uv) {\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\n  vec2 uv8bit = floor(uv * 256.);\n\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\n  // Scale and clamp to 0-1 range\n  vec2 uvFraction = fract(uv * 256.);\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\n\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\n\n  return vec3(uv8bit, fractions) / 255.;\n}\n\n\nvoid main(void) {\n  vec2 uv = vTexCoord;\n  if (bitmap.coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uv = getUV(lnglat);\n  } else if (bitmap.coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uv = getUV(commonPos);\n  }\n  vec4 bitmapColor = texture(bitmapTexture, uv);\n\n  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * layer.opacity);\n\n  geometry.uv = uv;\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n\n  if (bool(picking.isActive) && !bool(picking.isAttribute)) {\n    // Since instance information is not used, we can use picking color for pixel index\n    fragColor.rgb = packUVsIntoRGB(uv);\n  }\n}\n",modules:[o.A,r.A,f]})}initializeState(){const e=this.getAttributeManager();e.remove(["instancePickingColors"]);const t=!0;e.add({indices:{size:1,isIndexed:!0,update:e=>e.value=this.state.mesh.indices,noAlloc:t},positions:{size:3,type:"float64",fp64:this.use64bitPositions(),update:e=>e.value=this.state.mesh.positions,noAlloc:t},texCoords:{size:2,update:e=>e.value=this.state.mesh.texCoords,noAlloc:t}})}updateState(e){let{props:t,oldProps:n,changeFlags:i}=e;const s=this.getAttributeManager();var o;i.extensionsChanged&&(null==(o=this.state.model)||o.destroy(),this.state.model=this._getModel(),s.invalidateAll());if(t.bounds!==n.bounds){const e=this.state.mesh,t=this._createMesh();this.state.model.setVertexCount(t.vertexCount);for(const n in t)e&&e[n]!==t[n]&&s.invalidate(n);this.setState(Object.assign({mesh:t},this._getCoordinateUniforms()))}else t._imageCoordinateSystem!==n._imageCoordinateSystem&&this.setState(this._getCoordinateUniforms())}getPickingInfo(e){const{image:t}=this.props,n=e.info;if(!n.color||!t)return n.bitmap=null,n;const{width:i,height:s}=t;n.index=0;const o=function(e){const[t,n,i]=e;return[(t+(15&i)/16)/256,(n+(240&i)/256)/256]}(n.color);return n.bitmap={size:{width:i,height:s},uv:o,pixel:[Math.floor(o[0]*i),Math.floor(o[1]*s)]},n}disablePickingIndex(){this.setState({disablePicking:!0})}restorePickingColors(){this.setState({disablePicking:!1})}_updateAutoHighlight(e){super._updateAutoHighlight(Object.assign({},e,{color:this.encodePickingColor(0)}))}_createMesh(){const{bounds:e}=this.props;let t=e;return _(e)&&(t=[[e[0],e[1]],[e[0],e[3]],[e[2],e[3]],[e[2],e[1]]]),p(t,this.context.viewport.resolution)}_getModel(){return new a.K(this.context.device,Object.assign({},this.getShaders(),{id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),topology:"triangle-list",isInstanced:!1}))}draw(e){const{shaderModuleProps:t}=e,{model:n,coordinateConversion:i,bounds:s,disablePicking:o}=this.state,{image:r,desaturate:a,transparentColor:l,tintColor:c}=this.props;if((!t.picking.isActive||!o)&&r&&n){const e={bitmapTexture:r,bounds:s,coordinateConversion:i,desaturate:a,tintColor:c.slice(0,3).map((e=>e/255)),transparentColor:l.map((e=>e/255))};n.shaderInputs.setProps({bitmap:e}),n.draw(this.context.renderPass)}}_getCoordinateUniforms(){const{LNGLAT:e,CARTESIAN:t,DEFAULT:n}=i.rf;let{_imageCoordinateSystem:s}=this.props;if(s!==n){const{bounds:n}=this.props;if(!_(n))throw new Error("_imageCoordinateSystem only supports rectangular bounds");const i=this.context.viewport.resolution?e:t;if(s=s===e?e:t,s===e&&i===t)return{coordinateConversion:-1,bounds:n};if(s===t&&i===e){const e=(0,l.Gw)([n[0],n[1]]),t=(0,l.Gw)([n[2],n[3]]);return{coordinateConversion:1,bounds:[e[0],e[1],t[0],t[1]]}}}return{coordinateConversion:0,bounds:[0,0,0,0]}}}v.layerName="BitmapLayer",v.defaultProps=m;const y=v;function _(e){return Number.isFinite(e[0])}},34651:(e,t,n)=>{n.d(t,{A:()=>_});var i=n(3002),s=n(30428),o=n(28756),r=n(8961),a=n(31338),l=n(37072),c=n(8274),d=n(18120),h=n(25337),p=n(1746);class u extends h.V{constructor(e){const{indices:t,attributes:n}=function(e){const{radius:t,height:n=1,nradial:i=10}=e;let{vertices:s}=e;s&&(d.A.assert(s.length>=i),s=s.flatMap((e=>[e[0],e[1]])),(0,p.UD)(s,p.rJ.COUNTER_CLOCKWISE));const o=n>0,r=i+1,a=o?3*r+1:i,l=2*Math.PI/i,c=new Uint16Array(o?3*i*2:0),h=new Float32Array(3*a),u=new Float32Array(3*a);let g=0;if(o){for(let e=0;e<r;e++){const o=e*l,r=e%i,a=Math.sin(o),c=Math.cos(o);for(let e=0;e<2;e++)h[g+0]=s?s[2*r]:c*t,h[g+1]=s?s[2*r+1]:a*t,h[g+2]=(.5-e)*n,u[g+0]=s?s[2*r]:c,u[g+1]=s?s[2*r+1]:a,g+=3}h[g+0]=h[g-3],h[g+1]=h[g-2],h[g+2]=h[g-1],g+=3}for(let d=o?0:1;d<r;d++){const e=Math.floor(d/2)*Math.sign(.5-d%2),o=e*l,r=(e+i)%i,a=Math.sin(o),c=Math.cos(o);h[g+0]=s?s[2*r]:c*t,h[g+1]=s?s[2*r+1]:a*t,h[g+2]=n/2,u[g+2]=1,g+=3}if(o){let e=0;for(let t=0;t<i;t++)c[e++]=2*t+0,c[e++]=2*t+2,c[e++]=2*t+0,c[e++]=2*t+1,c[e++]=2*t+1,c[e++]=2*t+3}return{indices:c,attributes:{POSITION:{size:3,value:h},NORMAL:{size:3,value:u}}}}(e);super(Object.assign({},e,{indices:t,attributes:n}))}}const g="uniform columnUniforms {\n  float radius;\n  float angle;\n  vec2 offset;\n  bool extruded;\n  bool stroked;\n  bool isStroke;\n  float coverage;\n  float elevationScale;\n  float edgeDistance;\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  highp int radiusUnits;\n  highp int widthUnits;\n} column;\n",f={name:"column",vs:g,fs:g,uniformTypes:{radius:"f32",angle:"f32",offset:"vec2<f32>",extruded:"f32",stroked:"f32",isStroke:"f32",coverage:"f32",elevationScale:"f32",edgeDistance:"f32",widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",radiusUnits:"i32",widthUnits:"i32"}},m=[0,0,0,255],v={diskResolution:{type:"number",min:4,value:20},vertices:null,radius:{type:"number",min:0,value:1e3},angle:{type:"number",value:0},offset:{type:"array",value:[0,0]},coverage:{type:"number",min:0,max:1,value:1},elevationScale:{type:"number",min:0,value:1},radiusUnits:"meters",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,extruded:!0,wireframe:!1,filled:!0,stroked:!1,flatShading:!1,getPosition:{type:"accessor",value:e=>e.position},getFillColor:{type:"accessor",value:m},getLineColor:{type:"accessor",value:m},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0,getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class y extends i.A{getShaders(){const e={},{flatShading:t}=this.props;return t&&(e.FLAT_SHADING=1),super.getShaders({vs:"#version 300 es\n#define SHADER_NAME column-layer-vertex-shader\nin vec3 positions;\nin vec3 normals;\nin vec3 instancePositions;\nin float instanceElevations;\nin vec3 instancePositions64Low;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin float instanceStrokeWidths;\nin vec3 instancePickingColors;\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec3 cameraPosition;\nout vec4 position_commonspace;\n#endif\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\nvec4 color = column.isStroke ? instanceLineColors : instanceFillColors;\nmat2 rotationMatrix = mat2(cos(column.angle), sin(column.angle), -sin(column.angle), cos(column.angle));\nfloat elevation = 0.0;\nfloat strokeOffsetRatio = 1.0;\nif (column.extruded) {\nelevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;\n} else if (column.stroked) {\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceStrokeWidths * column.widthScale, column.widthUnits),\ncolumn.widthMinPixels, column.widthMaxPixels) / 2.0;\nfloat halfOffset = project_pixel_size(widthPixels) / project_size(column.edgeDistance * column.coverage * column.radius);\nif (column.isStroke) {\nstrokeOffsetRatio -= sign(positions.z) * halfOffset;\n} else {\nstrokeOffsetRatio -= halfOffset;\n}\n}\nfloat shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\nfloat dotRadius = column.radius * column.coverage * shouldRender;\ngeometry.pickingColor = instancePickingColors;\nvec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\nvec3 centroidPosition64Low = instancePositions64Low;\nvec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + column.offset) * dotRadius;\nif (column.radiusUnits == UNIT_METERS) {\noffset = project_size(offset);\n}\nvec3 pos = vec3(offset, 0.);\nDECKGL_FILTER_SIZE(pos, geometry);\ngl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\ngeometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nif (column.extruded && !column.isStroke) {\n#ifdef FLAT_SHADING\ncameraPosition = project.cameraPosition;\nposition_commonspace = geometry.position;\nvColor = vec4(color.rgb, color.a * layer.opacity);\n#else\nvec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\nvColor = vec4(lightColor, color.a * layer.opacity);\n#endif\n} else {\nvColor = vec4(color.rgb, color.a * layer.opacity);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME column-layer-fragment-shader\nprecision highp float;\nout vec4 fragColor;\nin vec4 vColor;\n#ifdef FLAT_SHADING\nin vec3 cameraPosition;\nin vec4 position_commonspace;\n#endif\nvoid main(void) {\nfragColor = vColor;\ngeometry.uv = vec2(0.);\n#ifdef FLAT_SHADING\nif (column.extruded && !column.isStroke && !bool(picking.isActive)) {\nvec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\nfragColor.rgb = lighting_getLightColor(vColor.rgb, cameraPosition, position_commonspace.xyz, normal);\n}\n#endif\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",defines:e,modules:[s.A,t?a.w:l.J,o.A,f]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceElevations:{size:1,transition:!0,accessor:"getElevation"},instanceFillColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getFillColor",defaultValue:m},instanceLineColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getLineColor",defaultValue:m},instanceStrokeWidths:{size:1,accessor:"getLineWidth",transition:!0}})}updateState(e){super.updateState(e);const{props:t,oldProps:n,changeFlags:i}=e,s=i.extensionsChanged||t.flatShading!==n.flatShading;var o;s&&(null==(o=this.state.models)||o.forEach((e=>e.destroy())),this.setState(this._getModels()),this.getAttributeManager().invalidateAll());const r=this.getNumInstances();this.state.fillModel.setInstanceCount(r),this.state.wireframeModel.setInstanceCount(r),(s||t.diskResolution!==n.diskResolution||t.vertices!==n.vertices||(t.extruded||t.stroked)!==(n.extruded||n.stroked))&&this._updateGeometry(t)}getGeometry(e,t,n){const i=new u({radius:1,height:n?2:0,vertices:t,nradial:e});let s=0;if(t)for(let o=0;o<e;o++){const n=t[o];s+=Math.sqrt(n[0]*n[0]+n[1]*n[1])/e}else s=1;return this.setState({edgeDistance:Math.cos(Math.PI/e)*s}),i}_getModels(){const e=this.getShaders(),t=this.getAttributeManager().getBufferLayouts(),n=new c.K(this.context.device,Object.assign({},e,{id:this.props.id+"-fill",bufferLayout:t,isInstanced:!0})),i=new c.K(this.context.device,Object.assign({},e,{id:this.props.id+"-wireframe",bufferLayout:t,isInstanced:!0}));return{fillModel:n,wireframeModel:i,models:[i,n]}}_updateGeometry(e){let{diskResolution:t,vertices:n,extruded:i,stroked:s}=e;const o=this.getGeometry(t,n,i||s);this.setState({fillVertexCount:o.attributes.POSITION.value.length/3});const r=this.state.fillModel,a=this.state.wireframeModel;r.setGeometry(o),r.setTopology("triangle-strip"),r.setIndexBuffer(null),a.setGeometry(o),a.setTopology("line-list")}draw(e){let{uniforms:t}=e;const{lineWidthUnits:n,lineWidthScale:i,lineWidthMinPixels:s,lineWidthMaxPixels:o,radiusUnits:a,elevationScale:l,extruded:c,filled:d,stroked:h,wireframe:p,offset:u,coverage:g,radius:f,angle:m}=this.props,v=this.state.fillModel,y=this.state.wireframeModel,{fillVertexCount:_,edgeDistance:x}=this.state,w={radius:f,angle:m/180*Math.PI,offset:u,extruded:c,stroked:h,coverage:g,elevationScale:l,edgeDistance:x,radiusUnits:r.p5[a],widthUnits:r.p5[n],widthScale:i,widthMinPixels:s,widthMaxPixels:o};c&&p&&(y.shaderInputs.setProps({column:Object.assign({},w,{isStroke:!0})}),y.draw(this.context.renderPass)),d&&(v.setVertexCount(_),v.shaderInputs.setProps({column:Object.assign({},w,{isStroke:!1})}),v.draw(this.context.renderPass)),!c&&h&&(v.setVertexCount(2*_/3),v.shaderInputs.setProps({column:Object.assign({},w,{isStroke:!0})}),v.draw(this.context.renderPass))}}y.layerName="ColumnLayer",y.defaultProps=v;const _=y},5397:(e,t,n)=>{n.d(t,{A:()=>a});var i=n(8961),s=n(8145),o=n(34651);class r extends o.A{_updateGeometry(){const e=new s.c9;this.state.fillModel.setGeometry(e)}draw(e){let{uniforms:t}=e;const{elevationScale:n,extruded:s,offset:o,coverage:r,cellSize:a,angle:l,radiusUnits:c}=this.props,d=this.state.fillModel,h={radius:a/2,radiusUnits:i.p5[c],angle:l,offset:o,extruded:s,stroked:!1,coverage:r,elevationScale:n,edgeDistance:1,isStroke:!1,widthUnits:0,widthScale:0,widthMinPixels:0,widthMaxPixels:0};d.shaderInputs.setProps({column:h}),d.draw(this.context.renderPass)}}r.layerName="GridCellLayer",r.defaultProps={cellSize:{type:"number",min:0,value:1e3},offset:{type:"array",value:[1,1]}};const a=r},84962:(e,t,n)=>{n.d(t,{A:()=>A});var i=n(98587),s=n(33847),o=n(33822);function r(e,t){if(!e)return null;const n="startIndices"in e?e.startIndices[t]:t,i=e.featureIds.value[n];return-1!==n?function(e,t,n){const i={properties:Object.assign({},e.properties[t])};for(const s in e.numericProps)i.properties[s]=e.numericProps[s].value[n];return i}(e,i,n):null}var a=n(78243),l=n(80458),c=n(83667),d=n(21410),h=n(39738);const p={circle:{type:l.A,props:{filled:"filled",stroked:"stroked",lineWidthMaxPixels:"lineWidthMaxPixels",lineWidthMinPixels:"lineWidthMinPixels",lineWidthScale:"lineWidthScale",lineWidthUnits:"lineWidthUnits",pointRadiusMaxPixels:"radiusMaxPixels",pointRadiusMinPixels:"radiusMinPixels",pointRadiusScale:"radiusScale",pointRadiusUnits:"radiusUnits",pointAntialiasing:"antialiasing",pointBillboard:"billboard",getFillColor:"getFillColor",getLineColor:"getLineColor",getLineWidth:"getLineWidth",getPointRadius:"getRadius"}},icon:{type:a.A,props:{iconAtlas:"iconAtlas",iconMapping:"iconMapping",iconSizeMaxPixels:"sizeMaxPixels",iconSizeMinPixels:"sizeMinPixels",iconSizeScale:"sizeScale",iconSizeUnits:"sizeUnits",iconAlphaCutoff:"alphaCutoff",iconBillboard:"billboard",getIcon:"getIcon",getIconAngle:"getAngle",getIconColor:"getColor",getIconPixelOffset:"getPixelOffset",getIconSize:"getSize"}},text:{type:c.A,props:{textSizeMaxPixels:"sizeMaxPixels",textSizeMinPixels:"sizeMinPixels",textSizeScale:"sizeScale",textSizeUnits:"sizeUnits",textBackground:"background",textBackgroundPadding:"backgroundPadding",textFontFamily:"fontFamily",textFontWeight:"fontWeight",textLineHeight:"lineHeight",textMaxWidth:"maxWidth",textOutlineColor:"outlineColor",textOutlineWidth:"outlineWidth",textWordBreak:"wordBreak",textCharacterSet:"characterSet",textBillboard:"billboard",textFontSettings:"fontSettings",getText:"getText",getTextAngle:"getAngle",getTextColor:"getColor",getTextPixelOffset:"getPixelOffset",getTextSize:"getSize",getTextAnchor:"getTextAnchor",getTextAlignmentBaseline:"getAlignmentBaseline",getTextBackgroundColor:"getBackgroundColor",getTextBorderColor:"getBorderColor",getTextBorderWidth:"getBorderWidth"}}},u={type:d.A,props:{lineWidthUnits:"widthUnits",lineWidthScale:"widthScale",lineWidthMinPixels:"widthMinPixels",lineWidthMaxPixels:"widthMaxPixels",lineJointRounded:"jointRounded",lineCapRounded:"capRounded",lineMiterLimit:"miterLimit",lineBillboard:"billboard",getLineColor:"getColor",getLineWidth:"getWidth"}},g={type:h.A,props:{extruded:"extruded",filled:"filled",wireframe:"wireframe",elevationScale:"elevationScale",material:"material",_full3d:"_full3d",getElevation:"getElevation",getFillColor:"getFillColor",getLineColor:"getLineColor"}};function f(e){let{type:t,props:n}=e;const i={};for(const s in n)i[s]=t.defaultProps[n[s]];return i}function m(e,t){const{transitions:n,updateTriggers:i}=e.props,s={updateTriggers:{},transitions:n&&{getPosition:n.geometry}};for(const o in t){const r=t[o];let a=e.props[o];o.startsWith("get")&&(a=e.getSubLayerAccessor(a),s.updateTriggers[r]=i[o],n&&(s.transitions[r]=n[o])),s[r]=a}return s}var v=n(18120);function y(e,t,n){void 0===n&&(n={});const i={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:s=0,endRow:o=e.length}=n;for(let r=s;r<o;r++){const n=e[r],{geometry:s}=n;if(s)if("GeometryCollection"===s.type){v.A.assert(Array.isArray(s.geometries),"GeoJSON does not have geometries array");const{geometries:e}=s;for(let s=0;s<e.length;s++){_(e[s],i,t,n,r)}}else _(s,i,t,n,r)}return i}function _(e,t,n,i,s){const{type:o,coordinates:r}=e,{pointFeatures:a,lineFeatures:l,polygonFeatures:c,polygonOutlineFeatures:d}=t;if(function(e,t){let n=x[e];v.A.assert(n,"Unknown GeoJSON type "+e);for(;t&&--n>0;)t=t[0];return t&&Number.isFinite(t[0])}(o,r))switch(o){case"Point":a.push(n({geometry:e},i,s));break;case"MultiPoint":r.forEach((e=>{a.push(n({geometry:{type:"Point",coordinates:e}},i,s))}));break;case"LineString":l.push(n({geometry:e},i,s));break;case"MultiLineString":r.forEach((e=>{l.push(n({geometry:{type:"LineString",coordinates:e}},i,s))}));break;case"Polygon":c.push(n({geometry:e},i,s)),r.forEach((e=>{d.push(n({geometry:{type:"LineString",coordinates:e}},i,s))}));break;case"MultiPolygon":r.forEach((e=>{c.push(n({geometry:{type:"Polygon",coordinates:e}},i,s)),e.forEach((e=>{d.push(n({geometry:{type:"LineString",coordinates:e}},i,s))}))}))}else v.A.warn(o+" coordinates are malformed")()}const x={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function w(e){return e.geometry.coordinates}function b(e,t){const n={points:{},lines:{},polygons:{},polygonsOutline:{}},{points:i,lines:s,polygons:o}=e,r=function(e,t){const n={points:null,lines:null,polygons:null};for(const i in n){const s=e[i].globalFeatureIds.value;n[i]=new Uint8ClampedArray(4*s.length);const o=[];for(let e=0;e<s.length;e++)t(s[e],o),n[i][4*e+0]=o[0],n[i][4*e+1]=o[1],n[i][4*e+2]=o[2],n[i][4*e+3]=255}return n}(e,t);n.points.data={length:i.positions.value.length/i.positions.size,attributes:Object.assign({},i.attributes,{getPosition:i.positions,instancePickingColors:{size:4,value:r.points}}),properties:i.properties,numericProps:i.numericProps,featureIds:i.featureIds},n.lines.data={length:s.pathIndices.value.length-1,startIndices:s.pathIndices.value,attributes:Object.assign({},s.attributes,{getPath:s.positions,instancePickingColors:{size:4,value:r.lines}}),properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},n.lines._pathType="open";const a=o.positions.value.length/o.positions.size,l=Array(a).fill(1);for(const c of o.primitivePolygonIndices.value)l[c-1]=0;return n.polygons.data={length:o.polygonIndices.value.length-1,startIndices:o.polygonIndices.value,attributes:Object.assign({},o.attributes,{getPolygon:o.positions,instanceVertexValid:{size:1,value:new Uint16Array(l)},pickingColors:{size:4,value:r.polygons}}),properties:o.properties,numericProps:o.numericProps,featureIds:o.featureIds},n.polygons._normalize=!1,o.triangles&&(n.polygons.data.attributes.indices=o.triangles.value),n.polygonsOutline.data={length:o.primitivePolygonIndices.value.length-1,startIndices:o.primitivePolygonIndices.value,attributes:Object.assign({},o.attributes,{getPath:o.positions,instancePickingColors:{size:4,value:r.polygons}}),properties:o.properties,numericProps:o.numericProps,featureIds:o.featureIds},n.polygonsOutline._pathType="open",n}const P=["instancePickingColors"],S=["points","linestrings","polygons"],C=Object.assign({},f(p.circle),f(p.icon),f(p.text),f(u),f(g),{stroked:!0,filled:!0,extruded:!1,wireframe:!1,_full3d:!1,iconAtlas:{type:"object",value:null},iconMapping:{type:"object",value:{}},getIcon:{type:"accessor",value:e=>e.properties.icon},getText:{type:"accessor",value:e=>e.properties.text},pointType:"circle",getRadius:{deprecatedFor:"getPointRadius"}});class j extends s.A{initializeState(){this.state={layerProps:{},features:{},featuresDiff:{}}}updateState(e){let{props:t,changeFlags:n}=e;if(!n.dataChanged)return;const{data:i}=this.props,s=i&&"points"in i&&"polygons"in i&&"lines"in i;this.setState({binary:s}),s?this._updateStateBinary({props:t,changeFlags:n}):this._updateStateJSON({props:t,changeFlags:n})}_updateStateBinary(e){let{props:t,changeFlags:n}=e;const i=b(t.data,this.encodePickingColor);this.setState({layerProps:i})}_updateStateJSON(e){let{props:t,changeFlags:n}=e;const i=function(e){if(Array.isArray(e))return e;switch(v.A.assert(e.type,"GeoJSON does not have type"),e.type){case"Feature":return[e];case"FeatureCollection":return v.A.assert(Array.isArray(e.features),"GeoJSON does not have features array"),e.features;default:return[{geometry:e}]}}(t.data),s=this.getSubLayerRow.bind(this);let r={};const a={};if(Array.isArray(n.dataChanged)){const e=this.state.features;for(const t in e)r[t]=e[t].slice(),a[t]=[];for(const t of n.dataChanged){const n=y(i,s,t);for(const i in e)a[i].push((0,o.J)({data:r[i],getIndex:e=>e.__source.index,dataRange:t,replace:n[i]}))}}else r=y(i,s);const l=function(e,t){const n={points:{},lines:{},polygons:{},polygonsOutline:{}},{pointFeatures:i,lineFeatures:s,polygonFeatures:o,polygonOutlineFeatures:r}=e;return n.points.data=i,n.points._dataDiff=t.pointFeatures&&(()=>t.pointFeatures),n.points.getPosition=w,n.lines.data=s,n.lines._dataDiff=t.lineFeatures&&(()=>t.lineFeatures),n.lines.getPath=w,n.polygons.data=o,n.polygons._dataDiff=t.polygonFeatures&&(()=>t.polygonFeatures),n.polygons.getPolygon=w,n.polygonsOutline.data=r,n.polygonsOutline._dataDiff=t.polygonOutlineFeatures&&(()=>t.polygonOutlineFeatures),n.polygonsOutline.getPath=w,n}(r,a);this.setState({features:r,featuresDiff:a,layerProps:l})}getPickingInfo(e){const t=super.getPickingInfo(e),{index:n,sourceLayer:i}=t;return t.featureType=S.find((e=>i.id.startsWith(this.id+"-"+e+"-"))),n>=0&&i.id.startsWith(this.id+"-points-text")&&this.state.binary&&(t.index=this.props.data.points.globalFeatureIds.value[n]),t}_updateAutoHighlight(e){const t=this.id+"-points-",n="points"===e.featureType;for(const i of this.getSubLayers())i.id.startsWith(t)===n&&i.updateAutoHighlight(e)}_renderPolygonLayer(){var e;const{extruded:t,wireframe:n}=this.props,{layerProps:i}=this.state,s="polygons-fill",o=this.shouldRenderSubLayer(s,null==(e=i.polygons)?void 0:e.data)&&this.getSubLayerClass(s,g.type);if(o){const e=m(this,g.props),r=t&&n;return r||delete e.getLineColor,e.updateTriggers.lineColors=r,new o(e,this.getSubLayerProps({id:s,updateTriggers:e.updateTriggers}),i.polygons)}return null}_renderLineLayers(){var e,t;const{extruded:n,stroked:i}=this.props,{layerProps:s}=this.state,o="polygons-stroke",r="linestrings",a=!n&&i&&this.shouldRenderSubLayer(o,null==(e=s.polygonsOutline)?void 0:e.data)&&this.getSubLayerClass(o,u.type),l=this.shouldRenderSubLayer(r,null==(t=s.lines)?void 0:t.data)&&this.getSubLayerClass(r,u.type);if(a||l){const e=m(this,u.props);return[a&&new a(e,this.getSubLayerProps({id:o,updateTriggers:e.updateTriggers}),s.polygonsOutline),l&&new l(e,this.getSubLayerProps({id:r,updateTriggers:e.updateTriggers}),s.lines)]}return null}_renderPointLayers(){const{pointType:e}=this.props,{layerProps:t,binary:n}=this.state;let{highlightedObjectIndex:s}=this.props;!n&&Number.isFinite(s)&&(s=t.points.data.findIndex((e=>e.__source.index===s)));const o=new Set(e.split("+")),r=[];for(const l of o){var a;const e="points-"+l,o=p[l],c=o&&this.shouldRenderSubLayer(e,null==(a=t.points)?void 0:a.data)&&this.getSubLayerClass(e,o.type);if(c){const a=m(this,o.props);let d=t.points;if("text"===l&&n){const e=d.data.attributes,t=(0,i.A)(e,P);d=Object.assign({},d,{data:Object.assign({},d.data,{attributes:t})})}r.push(new c(a,this.getSubLayerProps({id:e,updateTriggers:a.updateTriggers,highlightedObjectIndex:s}),d))}}return r}renderLayers(){const{extruded:e}=this.props,t=this._renderPolygonLayer();return[!e&&t,this._renderLineLayers(),this._renderPointLayers(),e&&t]}getSubLayerAccessor(e){const{binary:t}=this.state;return t&&"function"==typeof e?(t,n)=>{const{data:i,index:s}=n,o=r(i,s);return e(o,n)}:super.getSubLayerAccessor(e)}}j.layerName="GeoJsonLayer",j.defaultProps=C;const A=j},78243:(e,t,n)=>{n.d(t,{A:()=>S});var i=n(3002),s=n(30428),o=n(28756),r=n(8961),a=n(18120),l=n(8274),c=n(25337);const d="uniform iconUniforms {\n  float sizeScale;\n  vec2 iconsTextureDim;\n  float sizeBasis;\n  float sizeMinPixels;\n  float sizeMaxPixels;\n  bool billboard;\n  highp int sizeUnits;\n  float alphaCutoff;\n} icon;\n",h={name:"icon",vs:d,fs:d,uniformTypes:{sizeScale:"f32",iconsTextureDim:"vec2<f32>",sizeBasis:"f32",sizeMinPixels:"f32",sizeMaxPixels:"f32",billboard:"f32",sizeUnits:"i32",alphaCutoff:"f32"}};var p=n(327),u=n(33698);const g=()=>{},f={minFilter:"linear",mipmapFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"},m={x:0,y:0,width:0,height:0};function v(e,t,n,i){const s=Math.min(n/t.width,i/t.height),o=Math.floor(t.width*s),r=Math.floor(t.height*s);return 1===s?{image:t,width:o,height:r}:(e.canvas.height=r,e.canvas.width=o,e.clearRect(0,0,o,r),e.drawImage(t,0,0,t.width,t.height,0,0,o,r),{image:e.canvas,width:o,height:r})}function y(e){return e&&(e.id||e.url)}function _(e,t,n){for(let i=0;i<t.length;i++){const{icon:s,xOffset:o}=t[i];e[y(s)]=Object.assign({},s,{x:o,y:n})}}class x{constructor(e,t){let{onUpdate:n=g,onError:i=g}=t;this._loadOptions=null,this._texture=null,this._externalTexture=null,this._mapping={},this._samplerParameters=null,this._pendingCount=0,this._autoPacking=!1,this._xOffset=0,this._yOffset=0,this._rowHeight=0,this._buffer=4,this._canvasWidth=1024,this._canvasHeight=0,this._canvas=null,this.device=e,this.onUpdate=n,this.onError=i}finalize(){var e;null==(e=this._texture)||e.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(e){const t=this._autoPacking?y(e):e;return this._mapping[t]||m}setProps(e){let{loadOptions:t,autoPacking:n,iconAtlas:i,iconMapping:s,textureParameters:o}=e;var r;(t&&(this._loadOptions=t),void 0!==n&&(this._autoPacking=n),s&&(this._mapping=s),i)&&(null==(r=this._texture)||r.delete(),this._texture=null,this._externalTexture=i);o&&(this._samplerParameters=o)}get isLoaded(){return 0===this._pendingCount}packIcons(e,t){if(!this._autoPacking||"undefined"==typeof document)return;const n=Object.values(function(e,t,n){if(!e||!t)return null;n=n||{};const i={},{iterable:s,objectInfo:o}=(0,u.X)(e);for(const r of s){o.index++;const e=t(r,o),s=y(e);if(!e)throw new Error("Icon is missing.");if(!e.url)throw new Error("Icon url is missing.");i[s]||n[s]&&e.url===n[s].url||(i[s]=Object.assign({},e,{source:r,sourceIndex:o.index}))}return i}(e,t,this._mapping)||{});if(n.length>0){var i;const{mapping:e,xOffset:t,yOffset:s,rowHeight:o,canvasHeight:r}=function(e){let{icons:t,buffer:n,mapping:i={},xOffset:s=0,yOffset:o=0,rowHeight:r=0,canvasWidth:a}=e,l=[];for(let d=0;d<t.length;d++){const e=t[d];if(!i[y(e)]){const{height:t,width:c}=e;s+c+n>a&&(_(i,l,o),s=0,o=r+o+n,r=0,l=[]),l.push({icon:e,xOffset:s}),s=s+c+n,r=Math.max(r,t)}}return l.length>0&&_(i,l,o),{mapping:i,rowHeight:r,xOffset:s,yOffset:o,canvasWidth:a,canvasHeight:(c=r+o+n,Math.pow(2,Math.ceil(Math.log2(c))))};var c}({icons:n,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=o,this._mapping=e,this._xOffset=t,this._yOffset=s,this._canvasHeight=r,this._texture||(this._texture=this.device.createTexture({format:"rgba8unorm",data:null,width:this._canvasWidth,height:this._canvasHeight,sampler:this._samplerParameters||f,mipLevels:this.device.getMipLevelCount(this._canvasWidth,this._canvasHeight)})),this._texture.height!==this._canvasHeight&&(this._texture=function(e,t,n,i){const{width:s,height:o,device:r}=e,a=r.createTexture({format:"rgba8unorm",width:t,height:n,sampler:i,mipLevels:r.getMipLevelCount(t,n)}),l=r.createCommandEncoder();return l.copyTextureToTexture({sourceTexture:e,destinationTexture:a,width:s,height:o}),l.finish(),a.generateMipmapsWebGL(),e.destroy(),a}(this._texture,this._canvasWidth,this._canvasHeight,this._samplerParameters||f)),this.onUpdate(),this._canvas=this._canvas||document.createElement("canvas"),this._loadIcons(n),null==(i=this._texture)||i.generateMipmapsWebGL()}}_loadIcons(e){const t=this._canvas.getContext("2d",{willReadFrequently:!0});for(const n of e)this._pendingCount++,(0,p.H)(n.url,this._loadOptions).then((e=>{var i,s;const o=y(n),r=this._mapping[o],{x:a,y:l,width:c,height:d}=r,{image:h,width:p,height:u}=v(t,e,c,d);null==(i=this._texture)||i.copyExternalImage({image:h,x:a+(c-p)/2,y:l+(d-u)/2,width:p,height:u}),r.width=p,r.height=u,null==(s=this._texture)||s.generateMipmapsWebGL(),this.onUpdate()})).catch((e=>{this.onError({url:n.url,source:n.source,sourceIndex:n.sourceIndex,loadOptions:this._loadOptions,error:e})})).finally((()=>{this._pendingCount--}))}}const w=[0,0,0,255],b={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeBasis:"height",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:e=>e.position},getIcon:{type:"accessor",value:e=>e.icon},getColor:{type:"accessor",value:w},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,optional:!0},textureParameters:{type:"object",ignore:!0,value:null}};class P extends i.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME icon-layer-vertex-shader\nin vec2 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin float instanceSizes;\nin float instanceAngles;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec4 instanceIconFrames;\nin float instanceColorModes;\nin vec2 instanceOffsets;\nin vec2 instancePixelOffset;\nout float vColorMode;\nout vec4 vColor;\nout vec2 vTextureCoords;\nout vec2 uv;\nvec2 rotate_by_angle(vec2 vertex, float angle) {\nfloat angle_radian = angle * PI / 180.0;\nfloat cos_angle = cos(angle_radian);\nfloat sin_angle = sin(angle_radian);\nmat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\nreturn rotationMatrix * vertex;\n}\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\ngeometry.uv = positions;\ngeometry.pickingColor = instancePickingColors;\nuv = positions;\nvec2 iconSize = instanceIconFrames.zw;\nfloat sizePixels = clamp(\nproject_size_to_pixel(instanceSizes * icon.sizeScale, icon.sizeUnits),\nicon.sizeMinPixels, icon.sizeMaxPixels\n);\nfloat iconConstraint = icon.sizeBasis == 0.0 ? iconSize.x : iconSize.y;\nfloat instanceScale = iconConstraint == 0.0 ? 0.0 : sizePixels / iconConstraint;\nvec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\npixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\npixelOffset += instancePixelOffset;\npixelOffset.y *= -1.0;\nif (icon.billboard)  {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = vec3(pixelOffset, 0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\nDECKGL_FILTER_SIZE(offset_common, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvTextureCoords = mix(\ninstanceIconFrames.xy,\ninstanceIconFrames.xy + iconSize,\n(positions.xy + 1.0) / 2.0\n) / icon.iconsTextureDim;\nvColor = instanceColors;\nDECKGL_FILTER_COLOR(vColor, geometry);\nvColorMode = instanceColorModes;\n}\n",fs:"#version 300 es\n#define SHADER_NAME icon-layer-fragment-shader\nprecision highp float;\nuniform sampler2D iconsTexture;\nin float vColorMode;\nin vec4 vColor;\nin vec2 vTextureCoords;\nin vec2 uv;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = uv;\nvec4 texColor = texture(iconsTexture, vTextureCoords);\nvec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\nfloat a = texColor.a * layer.opacity * vColor.a;\nif (a < icon.alphaCutoff) {\ndiscard;\n}\nfragColor = vec4(color, a);\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[s.A,o.A,h]})}initializeState(){this.state={iconManager:new x(this.context.device,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})};this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:"uint8",accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:w},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(e){super.updateState(e);const{props:t,oldProps:n,changeFlags:i}=e,s=this.getAttributeManager(),{iconAtlas:o,iconMapping:r,data:a,getIcon:l,textureParameters:c}=t,{iconManager:d}=this.state;if("string"==typeof o)return;const h=o||this.internalState.isAsyncPropLoading("iconAtlas");var p;(d.setProps({loadOptions:t.loadOptions,autoPacking:!h,iconAtlas:o,iconMapping:h?r:null,textureParameters:c}),h?n.iconMapping!==t.iconMapping&&s.invalidate("getIcon"):(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getIcon))&&d.packIcons(a,l),i.extensionsChanged)&&(null==(p=this.state.model)||p.destroy(),this.state.model=this._getModel(),s.invalidateAll())}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(e){super.finalizeState(e),this.state.iconManager.finalize()}draw(e){let{uniforms:t}=e;const{sizeScale:n,sizeBasis:i,sizeMinPixels:s,sizeMaxPixels:o,sizeUnits:a,billboard:l,alphaCutoff:c}=this.props,{iconManager:d}=this.state,h=d.getTexture();if(h){const e=this.state.model,t={iconsTexture:h,iconsTextureDim:[h.width,h.height],sizeUnits:r.p5[a],sizeScale:n,sizeBasis:"height"===i?1:0,sizeMinPixels:s,sizeMaxPixels:o,billboard:l,alphaCutoff:c};e.shaderInputs.setProps({icon:t}),e.draw(this.context.renderPass)}}_getModel(){return new l.K(this.context.device,Object.assign({},this.getShaders(),{id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new c.V({topology:"triangle-strip",attributes:{positions:{size:2,value:new Float32Array([-1,-1,1,-1,-1,1,1,1])}}}),isInstanced:!0}))}_onUpdate(){this.setNeedsRedraw()}_onError(e){var t;const n=null==(t=this.getCurrentLayer())?void 0:t.props.onIconError;n?n(e):a.A.error(e.error.message)()}getInstanceOffset(e){const{width:t,height:n,anchorX:i=t/2,anchorY:s=n/2}=this.state.iconManager.getIconMapping(e);return[t/2-i,n/2-s]}getInstanceColorMode(e){return this.state.iconManager.getIconMapping(e).mask?1:0}getInstanceIconFrame(e){const{x:t,y:n,width:i,height:s}=this.state.iconManager.getIconMapping(e);return[t,n,i,s]}}P.defaultProps=b,P.layerName="IconLayer";const S=P},60192:(e,t,n)=>{n.d(t,{A:()=>g});var i=n(3002),s=n(30428),o=n(27972),r=n(28756),a=n(8961),l=n(8274),c=n(25337);const d="uniform lineUniforms {\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  float useShortestPath;\n  highp int widthUnits;\n} line;\n",h={name:"line",source:"struct LineUniforms {\n  widthScale: f32,\n  widthMinPixels: f32,\n  widthMaxPixels: f32,\n  useShortestPath: f32,\n  widthUnits: i32,\n};\n\n@group(0) @binding(1)\nvar<uniform> line: LineUniforms;\n",vs:d,fs:d,uniformTypes:{widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",useShortestPath:"f32",widthUnits:"i32"}},p={getSourcePosition:{type:"accessor",value:e=>e.sourcePosition},getTargetPosition:{type:"accessor",value:e=>e.targetPosition},getColor:{type:"accessor",value:[0,0,0,255]},getWidth:{type:"accessor",value:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class u extends i.A{getBounds(){var e;return null==(e=this.getAttributeManager())?void 0:e.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME line-layer-vertex-shader\nin vec3 positions;\nin vec3 instanceSourcePositions;\nin vec3 instanceTargetPositions;\nin vec3 instanceSourcePositions64Low;\nin vec3 instanceTargetPositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin float instanceWidths;\nout vec4 vColor;\nout vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\nvec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);\ndir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\nreturn dir_screenspace * offset_direction * width / 2.0;\n}\nvec3 splitLine(vec3 a, vec3 b, float x) {\nfloat t = (x - a.x) / (b.x - a.x);\nreturn vec3(x, mix(a.yz, b.yz, t));\n}\nvoid main(void) {\ngeometry.worldPosition = instanceSourcePositions;\ngeometry.worldPositionAlt = instanceTargetPositions;\nvec3 source_world = instanceSourcePositions;\nvec3 target_world = instanceTargetPositions;\nvec3 source_world_64low = instanceSourcePositions64Low;\nvec3 target_world_64low = instanceTargetPositions64Low;\nif (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {\nsource_world.x = mod(source_world.x + 180., 360.0) - 180.;\ntarget_world.x = mod(target_world.x + 180., 360.0) - 180.;\nfloat deltaLng = target_world.x - source_world.x;\nif (deltaLng * line.useShortestPath > 180.) {\nsource_world.x += 360. * line.useShortestPath;\nsource_world = splitLine(source_world, target_world, 180. * line.useShortestPath);\nsource_world_64low = vec3(0.0);\n} else if (deltaLng * line.useShortestPath < -180.) {\ntarget_world.x += 360. * line.useShortestPath;\ntarget_world = splitLine(source_world, target_world, 180. * line.useShortestPath);\ntarget_world_64low = vec3(0.0);\n} else if (line.useShortestPath < 0.) {\ngl_Position = vec4(0.);\nreturn;\n}\n}\nvec4 source_commonspace;\nvec4 target_commonspace;\nvec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\nvec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\nfloat segmentIndex = positions.x;\nvec4 p = mix(source, target, segmentIndex);\ngeometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\nuv = positions.xy;\ngeometry.uv = uv;\ngeometry.pickingColor = instancePickingColors;\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),\nline.widthMinPixels, line.widthMaxPixels\n);\nvec3 offset = vec3(\ngetExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\nDECKGL_FILTER_GL_POSITION(p, geometry);\ngl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\nvColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME line-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 uv;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = uv;\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",source:'// ---------- Helper Structures & Functions ----------\n\n// Placeholder filter functions.\nfn deckgl_filter_size(offset: vec3<f32>, geometry: Geometry) -> vec3<f32> {\n  return offset;\n}\nfn deckgl_filter_gl_position(p: vec4<f32>, geometry: Geometry) -> vec4<f32> {\n  return p;\n}\nfn deckgl_filter_color(color: vec4<f32>, geometry: Geometry) -> vec4<f32> {\n  return color;\n}\n\n// Compute an extrusion offset given a line direction (in clipspace),\n// an offset direction (-1 or 1), and a width in pixels.\n// Assumes a uniform "project" with a viewportSize field is available.\nfn getExtrusionOffset(line_clipspace: vec2<f32>, offset_direction: f32, width: f32) -> vec2<f32> {\n  // project.viewportSize should be provided as a uniform (not shown here)\n  let dir_screenspace = normalize(line_clipspace * project.viewportSize);\n  // Rotate by 90\xb0: (x,y) becomes (-y,x)\n  let rotated = vec2<f32>(-dir_screenspace.y, dir_screenspace.x);\n  return rotated * offset_direction * width / 2.0;\n}\n\n// Splits the line between two points at a given x coordinate.\n// Interpolates the y and z components.\nfn splitLine(a: vec3<f32>, b: vec3<f32>, x: f32) -> vec3<f32> {\n  let t: f32 = (x - a.x) / (b.x - a.x);\n  return vec3<f32>(x, a.yz + t * (b.yz - a.yz));\n}\n\n// ---------- Uniforms & Global Structures ----------\n\n// Uniforms for line, color, and project are assumed to be defined elsewhere.\n// For example:\n//\n// @group(0) @binding(0)\n// var<uniform> line: LineUniform;\n//\n// struct ColorUniform {\n//   opacity: f32,\n// };\n// @group(0) @binding(1)\n// var<uniform> color: ColorUniform;\n//\n// struct ProjectUniform {\n//   viewportSize: vec2<f32>,\n// };\n// @group(0) @binding(2)\n// var<uniform> project: ProjectUniform;\n\n\n\n// ---------- Vertex Output Structure ----------\n\nstruct Varyings {\n  @builtin(position) gl_Position: vec4<f32>,\n  @location(0) vColor: vec4<f32>,\n  @location(1) uv: vec2<f32>,\n};\n\n// ---------- Vertex Shader Entry Point ----------\n\n@vertex\nfn vertexMain(\n  @location(0) positions: vec3<f32>,\n  @location(1) instanceSourcePositions: vec3<f32>,\n  @location(2) instanceTargetPositions: vec3<f32>,\n  @location(3) instanceSourcePositions64Low: vec3<f32>,\n  @location(4) instanceTargetPositions64Low: vec3<f32>,\n  @location(5) instanceColors: vec4<f32>,\n  @location(6) instancePickingColors: vec3<f32>,\n  @location(7) instanceWidths: f32\n) -> Varyings {\n  var geometry: Geometry;\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  var source_world: vec3<f32> = instanceSourcePositions;\n  var target_world: vec3<f32> = instanceTargetPositions;\n  var source_world_64low: vec3<f32> = instanceSourcePositions64Low;\n  var target_world_64low: vec3<f32> = instanceTargetPositions64Low;\n\n  // Apply shortest-path adjustments if needed.\n  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {\n    source_world.x = (source_world.x + 180.0 % 360.0) - 180.0;\n    target_world.x = (target_world.x + 180.0 % 360.0) - 180.0;\n    let deltaLng: f32 = target_world.x - source_world.x;\n\n    if (deltaLng * line.useShortestPath > 180.0) {\n      source_world.x = source_world.x + 360.0 * line.useShortestPath;\n      source_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);\n      source_world_64low = vec3<f32>(0.0, 0.0, 0.0);\n    } else if (deltaLng * line.useShortestPath < -180.0) {\n      target_world.x = target_world.x + 360.0 * line.useShortestPath;\n      target_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);\n      target_world_64low = vec3<f32>(0.0, 0.0, 0.0);\n    } else if (line.useShortestPath < 0.0) {\n      var abortOut: Varyings;\n      abortOut.gl_Position = vec4<f32>(0.0);\n      abortOut.vColor = vec4<f32>(0.0);\n      abortOut.uv = vec2<f32>(0.0);\n      return abortOut;\n    }\n  }\n\n  // Project Pos and target positions to clip space.\n  let sourceResult = project_position_to_clipspace_and_commonspace(source_world, source_world_64low, vec3<f32>(0.0));\n  let targetResult = project_position_to_clipspace_and_commonspace(target_world, target_world_64low, vec3<f32>(0.0));\n  let sourcePos: vec4<f32> = sourceResult.clipPosition;\n  let targetPos: vec4<f32> = targetResult.clipPosition;\n  let source_commonspace: vec4<f32> = sourceResult.commonPosition;\n  let target_commonspace: vec4<f32> = targetResult.commonPosition;\n\n  // Interpolate along the line segment.\n  let segmentIndex: f32 = positions.x;\n  let p: vec4<f32> = sourcePos + segmentIndex * (targetPos - sourcePos);\n  geometry.position = source_commonspace + segmentIndex * (target_commonspace - source_commonspace);\n  let uv: vec2<f32> = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  // Determine width in pixels.\n  let widthPixels: f32 = clamp(\n    project_unit_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),\n    line.widthMinPixels, line.widthMaxPixels\n  );\n\n  // Compute extrusion offset.\n  let extrusion: vec2<f32> = getExtrusionOffset(targetPos.xy - sourcePos.xy, positions.y, widthPixels);\n  let offset: vec3<f32> = vec3<f32>(extrusion, 0.0);\n\n  // Apply deck.gl filter functions.\n  let filteredOffset = deckgl_filter_size(offset, geometry);\n  let filteredP = deckgl_filter_gl_position(p, geometry);\n\n  let clipOffset: vec2<f32> = project_pixel_size_to_clipspace(filteredOffset.xy);\n  let finalPosition: vec4<f32> = filteredP + vec4<f32>(clipOffset, 0.0, 0.0);\n\n  // Compute color.\n  var vColor: vec4<f32> = vec4<f32>(instanceColors.rgb, instanceColors.a * color.opacity);\n  // vColor = deckgl_filter_color(vColor, geometry);\n\n  var output: Varyings;\n  output.gl_Position = finalPosition;\n  output.vColor = vColor;\n  output.uv = uv;\n  return output;\n}\n\n@fragment\nfn fragmentMain(\n  @location(0) vColor: vec4<f32>,\n  @location(1) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n  // Create and initialize geometry with the provided uv.\n  var geometry: Geometry;\n  geometry.uv = uv;\n\n  // Start with the input color.\n  var fragColor: vec4<f32> = vColor;\n\n  // Apply the deck.gl filter to the color.\n  fragColor = deckgl_filter_color(fragColor, geometry);\n\n  // Apply premultiplied alpha as required by transparent canvas\n  fragColor = deckgl_premultiplied_alpha(fragColor);\n\n  return fragColor;\n}\n',modules:[s.A,o.A,r.A,h]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:[0,0,0,255]},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1}})}updateState(e){var t;(super.updateState(e),e.changeFlags.extensionsChanged)&&(null==(t=this.state.model)||t.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw(e){let{uniforms:t}=e;const{widthUnits:n,widthScale:i,widthMinPixels:s,widthMaxPixels:o,wrapLongitude:r}=this.props,l=this.state.model,c={widthUnits:a.p5[n],widthScale:i,widthMinPixels:s,widthMaxPixels:o,useShortestPath:r?1:0};l.shaderInputs.setProps({line:c}),l.draw(this.context.renderPass),r&&(l.shaderInputs.setProps({line:Object.assign({},c,{useShortestPath:-1})}),l.draw(this.context.renderPass))}_getModel(){const e="webgpu"===this.context.device.type?{depthWriteEnabled:!0,depthCompare:"less-equal"}:void 0;return new l.K(this.context.device,Object.assign({},this.getShaders(),{id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new c.V({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array([0,-1,0,0,1,0,1,-1,0,1,1,0])}}}),parameters:e,isInstanced:!0}))}}u.layerName="LineLayer",u.defaultProps=p;const g=u},21410:(e,t,n)=>{n.d(t,{A:()=>_});var i=n(3002),s=n(30428),o=n(28756),r=n(8961),a=n(25337),l=n(8274),c=n(50364),d=n(1746);class h extends c.A{constructor(e){super(Object.assign({},e,{attributes:{positions:{size:3,padding:18,initialize:!0,type:e.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}}))}get(e){return this.attributes[e]}getGeometryFromBuffer(e){return this.normalize?super.getGeometryFromBuffer(e):null}normalizeGeometry(e){return this.normalize?function(e,t,n,i){let s;if(Array.isArray(e[0])){const n=e.length*t;s=new Array(n);for(let i=0;i<e.length;i++)for(let n=0;n<t;n++)s[i*t+n]=e[i][n]||0}else s=e;return n?(0,d.Mk)(s,{size:t,gridResolution:n}):i?(0,d.Iy)(s,{size:t}):s}(e,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):e}getGeometrySize(e){if(p(e)){let t=0;for(const n of e)t+=this.getGeometrySize(n);return t}const t=this.getPathLength(e);return t<2?0:this.isClosed(e)?t<3?0:t+2:t}updateGeometryAttributes(e,t){if(0!==t.geometrySize)if(e&&p(e))for(const n of e){const e=this.getGeometrySize(n);t.geometrySize=e,this.updateGeometryAttributes(n,t),t.vertexStart+=e}else this._updateSegmentTypes(e,t),this._updatePositions(e,t)}_updateSegmentTypes(e,t){const n=this.attributes.segmentTypes,i=!!e&&this.isClosed(e),{vertexStart:s,geometrySize:o}=t;n.fill(0,s,s+o),i?(n[s]=4,n[s+o-2]=4):(n[s]+=1,n[s+o-2]+=2),n[s+o-1]=4}_updatePositions(e,t){const{positions:n}=this.attributes;if(!n||!e)return;const{vertexStart:i,geometrySize:s}=t,o=new Array(3);for(let r=i,a=0;a<s;r++,a++)this.getPointOnPath(e,a,o),n[3*r]=o[0],n[3*r+1]=o[1],n[3*r+2]=o[2]}getPathLength(e){return e.length/this.positionSize}getPointOnPath(e,t,n){void 0===n&&(n=[]);const{positionSize:i}=this;t*i>=e.length&&(t+=1-e.length/i);const s=t*i;return n[0]=e[s],n[1]=e[s+1],n[2]=3===i&&e[s+2]||0,n}isClosed(e){if(!this.normalize)return Boolean(this.opts.loop);const{positionSize:t}=this,n=e.length-t;return e[0]===e[n]&&e[1]===e[n+1]&&(2===t||e[2]===e[n+2])}}function p(e){return Array.isArray(e[0])}const u="uniform pathUniforms {\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  float jointType;\n  float capType;\n  float miterLimit;\n  bool billboard;\n  highp int widthUnits;\n} path;\n",g={name:"path",vs:u,fs:u,uniformTypes:{widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",jointType:"f32",capType:"f32",miterLimit:"f32",billboard:"f32",widthUnits:"i32"}},f=[0,0,0,255],m={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:e=>e.path},getColor:{type:"accessor",value:f},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},v={enter:(e,t)=>t.length?t.subarray(t.length-e.length):e};class y extends i.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME path-layer-vertex-shader\nin vec2 positions;\nin float instanceTypes;\nin vec3 instanceStartPositions;\nin vec3 instanceEndPositions;\nin vec3 instanceLeftPositions;\nin vec3 instanceRightPositions;\nin vec3 instanceLeftPositions64Low;\nin vec3 instanceStartPositions64Low;\nin vec3 instanceEndPositions64Low;\nin vec3 instanceRightPositions64Low;\nin float instanceStrokeWidths;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nuniform float opacity;\nout vec4 vColor;\nout vec2 vCornerOffset;\nout float vMiterLength;\nout vec2 vPathPosition;\nout float vPathLength;\nout float vJointType;\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\nfloat flipIfTrue(bool flag) {\nreturn -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\nvec3 prevPoint, vec3 currPoint, vec3 nextPoint,\nvec2 width\n) {\nbool isEnd = positions.x > 0.0;\nfloat sideOfPath = positions.y;\nfloat isJoint = float(sideOfPath == 0.0);\nvec3 deltaA3 = (currPoint - prevPoint);\nvec3 deltaB3 = (nextPoint - currPoint);\nmat3 rotationMatrix;\nbool needsRotation = !path.billboard && project_needs_rotation(currPoint, rotationMatrix);\nif (needsRotation) {\ndeltaA3 = deltaA3 * rotationMatrix;\ndeltaB3 = deltaB3 * rotationMatrix;\n}\nvec2 deltaA = deltaA3.xy / width;\nvec2 deltaB = deltaB3.xy / width;\nfloat lenA = length(deltaA);\nfloat lenB = length(deltaB);\nvec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\nvec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\nvec2 perpA = vec2(-dirA.y, dirA.x);\nvec2 perpB = vec2(-dirB.y, dirB.x);\nvec2 tangent = dirA + dirB;\ntangent = length(tangent) > 0. ? normalize(tangent) : perpA;\nvec2 miterVec = vec2(-tangent.y, tangent.x);\nvec2 dir = isEnd ? dirA : dirB;\nvec2 perp = isEnd ? perpA : perpB;\nfloat L = isEnd ? lenA : lenB;\nfloat sinHalfA = abs(dot(miterVec, perp));\nfloat cosHalfA = abs(dot(dirA, miterVec));\nfloat turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\nfloat cornerPosition = sideOfPath * turnDirection;\nfloat miterSize = 1.0 / max(sinHalfA, EPSILON);\nmiterSize = mix(\nmin(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\nmiterSize,\nstep(0.0, cornerPosition)\n);\nvec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n* (sideOfPath + isJoint * turnDirection);\nbool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\nbool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\nbool isCap = isStartCap || isEndCap;\nif (isCap) {\noffsetVec = mix(perp * sideOfPath, dir * path.capType * 4.0 * flipIfTrue(isStartCap), isJoint);\nvJointType = path.capType;\n} else {\nvJointType = path.jointType;\n}\nvPathLength = L;\nvCornerOffset = offsetVec;\nvMiterLength = dot(vCornerOffset, miterVec * turnDirection);\nvMiterLength = isCap ? isJoint : vMiterLength;\nvec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\nvPathPosition = vec2(\ndot(offsetFromStartOfPath, perp),\ndot(offsetFromStartOfPath, dir)\n);\ngeometry.uv = vPathPosition;\nfloat isValid = step(instanceTypes, 3.5);\nvec3 offset = vec3(offsetVec * width * isValid, 0.0);\nif (needsRotation) {\noffset = rotationMatrix * offset;\n}\nreturn offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\nif (position.w < EPSILON) {\nfloat r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\nposition = refPosition + (position - refPosition) * r;\n}\n}\nvoid main() {\ngeometry.pickingColor = instancePickingColors;\nvColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);\nfloat isEnd = positions.x;\nvec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\nvec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\nvec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\nvec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\nvec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\nvec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\ngeometry.worldPosition = currPosition;\nvec2 widthPixels = vec2(clamp(\nproject_size_to_pixel(instanceStrokeWidths * path.widthScale, path.widthUnits),\npath.widthMinPixels, path.widthMaxPixels) / 2.0);\nvec3 width;\nif (path.billboard) {\nvec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\nvec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\nvec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\nclipLine(prevPositionScreen, currPositionScreen);\nclipLine(nextPositionScreen, currPositionScreen);\nclipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\nwidth = vec3(widthPixels, 0.0);\nDECKGL_FILTER_SIZE(width, geometry);\nvec3 offset = getLineJoinOffset(\nprevPositionScreen.xyz / prevPositionScreen.w,\ncurrPositionScreen.xyz / currPositionScreen.w,\nnextPositionScreen.xyz / nextPositionScreen.w,\nproject_pixel_size_to_clipspace(width.xy)\n);\nDECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\ngl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n} else {\nprevPosition = project_position(prevPosition, prevPosition64Low);\ncurrPosition = project_position(currPosition, currPosition64Low);\nnextPosition = project_position(nextPosition, nextPosition64Low);\nwidth = vec3(project_pixel_size(widthPixels), 0.0);\nDECKGL_FILTER_SIZE(width, geometry);\nvec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\ngeometry.position = vec4(currPosition + offset, 1.0);\ngl_Position = project_common_position_to_clipspace(geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME path-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 vCornerOffset;\nin float vMiterLength;\nin vec2 vPathPosition;\nin float vPathLength;\nin float vJointType;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = vPathPosition;\nif (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\nif (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\ndiscard;\n}\nif (vJointType < 0.5 && vMiterLength > path.miterLimit + 1.0) {\ndiscard;\n}\n}\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[s.A,o.A,g]})}get wrapLongitude(){return!1}getBounds(){var e;return null==(e=this.getAttributeManager())?void 0:e.getBounds(["vertexPositions"])}initializeState(){const e=!0;this.getAttributeManager().addInstanced({vertexPositions:{size:3,vertexOffset:1,type:"float64",fp64:this.use64bitPositions(),transition:v,accessor:"getPath",update:this.calculatePositions,noAlloc:e,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:"uint8",update:this.calculateSegmentTypes,noAlloc:e},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:v,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",accessor:"getColor",transition:v,defaultValue:f},instancePickingColors:{size:4,type:"uint8",accessor:(e,t)=>{let{index:n,target:i}=t;return this.encodePickingColor(e&&e.__source?e.__source.index:n,i)}}}),this.setState({pathTesselator:new h({fp64:this.use64bitPositions()})})}updateState(e){super.updateState(e);const{props:t,changeFlags:n}=e,i=this.getAttributeManager();if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPath)){const{pathTesselator:e}=this.state,s=t.data.attributes||{};e.updateGeometry({data:t.data,geometryBuffer:s.getPath,buffers:s,normalize:!t._pathType,loop:"loop"===t._pathType,getGeometry:t.getPath,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:n.dataChanged}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),n.dataChanged||i.invalidateAll()}var s;n.extensionsChanged&&(null==(s=this.state.model)||s.destroy(),this.state.model=this._getModel(),i.invalidateAll())}getPickingInfo(e){const t=super.getPickingInfo(e),{index:n}=t,i=this.props.data;return i[0]&&i[0].__source&&(t.object=i.find((e=>e.__source.index===n))),t}disablePickingIndex(e){const t=this.props.data;if(t[0]&&t[0].__source)for(let n=0;n<t.length;n++)t[n].__source.index===e&&this._disablePickingIndex(n);else super.disablePickingIndex(e)}draw(e){let{uniforms:t}=e;const{jointRounded:n,capRounded:i,billboard:s,miterLimit:o,widthUnits:a,widthScale:l,widthMinPixels:c,widthMaxPixels:d}=this.props,h=this.state.model,p={jointType:Number(n),capType:Number(i),billboard:s,widthUnits:r.p5[a],widthScale:l,miterLimit:o,widthMinPixels:c,widthMaxPixels:d};h.shaderInputs.setProps({path:p}),h.draw(this.context.renderPass)}_getModel(){return new l.K(this.context.device,Object.assign({},this.getShaders(),{id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new a.V({topology:"triangle-list",attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0}))}calculatePositions(e){const{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateSegmentTypes(e){const{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("segmentTypes")}}y.defaultProps=m,y.layerName="PathLayer";const _=y},23010:(e,t,n)=>{n.d(t,{A:()=>v});var i=n(3002),s=n(30428),o=n(27972),r=n(28756),a=n(8961),l=n(8274),c=n(25337),d=n(37072);const h="uniform pointCloudUniforms {\n  float radiusPixels;\n  highp int sizeUnits;\n} pointCloud;\n",p={name:"pointCloud",source:"struct PointCloudUniforms {\n  radiusPixels: f32,\n  sizeUnits: i32,\n};\n\n@group(0) @binding(3)\nvar<uniform> pointCloud: PointCloudUniforms;\n",vs:h,fs:h,uniformTypes:{radiusPixels:"f32",sizeUnits:"i32"}},u=[0,0,0,255],g=[0,0,1],f={sizeUnits:"pixels",pointSize:{type:"number",min:0,value:10},getPosition:{type:"accessor",value:e=>e.position},getNormal:{type:"accessor",value:g},getColor:{type:"accessor",value:u},material:!0,radiusPixels:{deprecatedFor:"pointSize"}};class m extends i.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME point-cloud-layer-vertex-shader\nin vec3 positions;\nin vec3 instanceNormals;\nin vec4 instanceColors;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec3 instancePickingColors;\nout vec4 vColor;\nout vec2 unitPosition;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\ngeometry.normal = project_normal(instanceNormals);\nunitPosition = positions.xy;\ngeometry.uv = unitPosition;\ngeometry.pickingColor = instancePickingColors;\nvec3 offset = vec3(positions.xy * project_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\nvec3 lightColor = lighting_getLightColor(instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\nvColor = vec4(lightColor, instanceColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME point-cloud-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 unitPosition;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = unitPosition.xy;\nfloat distToCenter = length(unitPosition);\nif (distToCenter > 1.0) {\ndiscard;\n}\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",source:"struct ConstantAttributes {\n  instanceNormals: vec3<f32>,\n  instanceColors: vec4<f32>,\n  instancePositions: vec3<f32>,\n  instancePositions64Low: vec3<f32>,\n  instancePickingColors: vec3<f32>\n};\n\nconst constants = ConstantAttributes(\n  vec3<f32>(1.0, 0.0, 0.0),\n  vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  vec3<f32>(0.0),\n  vec3<f32>(0.0),\n  vec3<f32>(0.0)\n);\n\nstruct Attributes {\n  @builtin(instance_index) instanceIndex : u32,\n  @builtin(vertex_index) vertexIndex : u32,\n  @location(0) positions: vec3<f32>,\n  @location(1) instancePositions: vec3<f32>,\n  @location(2) instancePositions64Low: vec3<f32>,\n  @location(3) instanceNormals: vec3<f32>,\n  @location(4) instanceColors: vec4<f32>,\n  @location(5) instancePickingColors: vec3<f32>\n};\n\nstruct Varyings {\n  @builtin(position) position: vec4<f32>,\n  @location(0) vColor: vec4<f32>,\n  @location(1) unitPosition: vec2<f32>,\n};\n\n@vertex\nfn vertexMain(attributes: Attributes) -> Varyings {\n  var varyings: Varyings;\n  \n  // var geometry: Geometry;\n  // geometry.worldPosition = instancePositions;\n  // geometry.normal = project_normal(instanceNormals);\n\n  // position on the containing square in [-1, 1] space\n  varyings.unitPosition = attributes.positions.xy;\n  geometry.uv = varyings.unitPosition;\n  geometry.pickingColor = attributes.instancePickingColors;\n\n  // Find the center of the point and add the current vertex\n  let offset = vec3<f32>(attributes.positions.xy * project_unit_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);\n  // DECKGL_FILTER_SIZE(offset, geometry);\n\n  varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);\n  // DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  let clipPixels = project_pixel_size_to_clipspace(offset.xy);\n  varyings.position.x += clipPixels.x;\n  varyings.position.y += clipPixels.y;\n\n  // Apply lighting\n  let lightColor = lighting_getLightColor2(attributes.instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n\n  // Apply opacity to instance color, or return instance picking color\n  varyings.vColor = vec4(lightColor, attributes.instanceColors.a * color.opacity);\n  // DECKGL_FILTER_COLOR(vColor, geometry);\n\n  return varyings;\n}\n\n@fragment\nfn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {\n  // var geometry: Geometry;\n  // geometry.uv = unitPosition.xy;\n\n  let distToCenter = length(varyings.unitPosition);\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  var fragColor: vec4<f32>;\n\n  fragColor = varyings.vColor;\n  // DECKGL_FILTER_COLOR(fragColor, geometry);\n\n  // Apply premultiplied alpha as required by transparent canvas\n  fragColor = deckgl_premultiplied_alpha(fragColor);\n\n  return fragColor;\n}\n",modules:[s.A,o.A,d.J,r.A,p]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceNormals:{size:3,transition:!0,accessor:"getNormal",defaultValue:g},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:u}})}updateState(e){const{changeFlags:t,props:n}=e;var i;(super.updateState(e),t.extensionsChanged)&&(null==(i=this.state.model)||i.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll());t.dataChanged&&function(e){const{header:t,attributes:n}=e;if(t&&n&&(e.length=t.vertexCount,n.POSITION&&(n.instancePositions=n.POSITION),n.NORMAL&&(n.instanceNormals=n.NORMAL),n.COLOR_0)){const{size:e,value:t}=n.COLOR_0;n.instanceColors={size:e,type:"unorm8",value:t}}}(n.data)}draw(e){let{uniforms:t}=e;const{pointSize:n,sizeUnits:i}=this.props,s=this.state.model,o={sizeUnits:a.p5[i],radiusPixels:n};s.shaderInputs.setProps({pointCloud:o}),"webgpu"===this.context.device.type&&(s.instanceCount=this.props.data.length),s.draw(this.context.renderPass)}_getModel(){const e="webgpu"===this.context.device.type?{depthWriteEnabled:!0,depthCompare:"less-equal"}:void 0,t=[];for(let n=0;n<3;n++){const e=n/3*Math.PI*2;t.push(2*Math.cos(e),2*Math.sin(e),0)}return new l.K(this.context.device,Object.assign({},this.getShaders(),{id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new c.V({topology:"triangle-list",attributes:{positions:new Float32Array(t)}}),parameters:e,isInstanced:!0}))}}m.layerName="PointCloudLayer",m.defaultProps=f;const v=m},10800:(e,t,n)=>{n.d(t,{A:()=>u});var i=n(33847),s=n(18120),o=n(33698),r=n(39738),a=n(21410),l=n(2714),c=n(33822);const d=[0,0,0,255],h={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:e=>e.polygon},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:d},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0};class p extends i.A{initializeState(){this.state={paths:[],pathsDiff:null},this.props.getLineDashArray&&s.A.removed("getLineDashArray","PathStyleExtension")()}updateState(e){let{changeFlags:t}=e;const n=t.dataChanged||t.updateTriggersChanged&&(t.updateTriggersChanged.all||t.updateTriggersChanged.getPolygon);if(n&&Array.isArray(t.dataChanged)){const e=this.state.paths.slice(),n=t.dataChanged.map((t=>(0,c.J)({data:e,getIndex:e=>e.__source.index,dataRange:t,replace:this._getPaths(t)})));this.setState({paths:e,pathsDiff:n})}else n&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(e){void 0===e&&(e={});const{data:t,getPolygon:n,positionFormat:i,_normalize:s}=this.props,r=[],a="XY"===i?2:3,{startRow:c,endRow:d}=e,{iterable:h,objectInfo:p}=(0,o.X)(t,c,d);for(const o of h){p.index++;let e=n(o,p);s&&(e=l.S8(e,a));const{holeIndices:t}=e,i=e.positions||e;if(t)for(let n=0;n<=t.length;n++){const e=i.slice(t[n-1]||0,t[n]||i.length);r.push(this.getSubLayerRow({path:e},o,p.index))}else r.push(this.getSubLayerRow({path:i},o,p.index))}return r}renderLayers(){const{data:e,_dataDiff:t,stroked:n,filled:i,extruded:s,wireframe:o,_normalize:l,_windingOrder:c,elevationScale:h,transitions:p,positionFormat:u}=this.props,{lineWidthUnits:g,lineWidthScale:f,lineWidthMinPixels:m,lineWidthMaxPixels:v,lineJointRounded:y,lineMiterLimit:_,lineDashJustified:x}=this.props,{getFillColor:w,getLineColor:b,getLineWidth:P,getLineDashArray:S,getElevation:C,getPolygon:j,updateTriggers:A,material:L}=this.props,{paths:M,pathsDiff:T}=this.state,E=this.getSubLayerClass("fill",r.A),O=this.getSubLayerClass("stroke",a.A),I=this.shouldRenderSubLayer("fill",M)&&new E({_dataDiff:t,extruded:s,elevationScale:h,filled:i,wireframe:o,_normalize:l,_windingOrder:c,getElevation:C,getFillColor:w,getLineColor:s&&o?b:d,material:L,transitions:p},this.getSubLayerProps({id:"fill",updateTriggers:A&&{getPolygon:A.getPolygon,getElevation:A.getElevation,getFillColor:A.getFillColor,lineColors:s&&o,getLineColor:A.getLineColor}}),{data:e,positionFormat:u,getPolygon:j});return[!s&&I,!s&&n&&this.shouldRenderSubLayer("stroke",M)&&new O({_dataDiff:T&&(()=>T),widthUnits:g,widthScale:f,widthMinPixels:m,widthMaxPixels:v,jointRounded:y,miterLimit:_,dashJustified:x,_pathType:"loop",transitions:p&&{getWidth:p.getLineWidth,getColor:p.getLineColor,getPath:p.getPolygon},getColor:this.getSubLayerAccessor(b),getWidth:this.getSubLayerAccessor(P),getDashArray:this.getSubLayerAccessor(S)},this.getSubLayerProps({id:"stroke",updateTriggers:A&&{getWidth:A.getLineWidth,getColor:A.getLineColor,getDashArray:A.getLineDashArray}}),{data:M,positionFormat:u,getPath:e=>e.path}),s&&I]}}p.layerName="PolygonLayer",p.defaultProps=h;const u=p},80458:(e,t,n)=>{n.d(t,{A:()=>f});var i=n(3002),s=n(30428),o=n(27972),r=n(28756),a=n(8961),l=n(8274),c=n(25337);const d="uniform scatterplotUniforms {\n  float radiusScale;\n  float radiusMinPixels;\n  float radiusMaxPixels;\n  float lineWidthScale;\n  float lineWidthMinPixels;\n  float lineWidthMaxPixels;\n  float stroked;\n  float filled;\n  bool antialiasing;\n  bool billboard;\n  highp int radiusUnits;\n  highp int lineWidthUnits;\n} scatterplot;\n",h={name:"scatterplot",vs:d,fs:d,source:"",uniformTypes:{radiusScale:"f32",radiusMinPixels:"f32",radiusMaxPixels:"f32",lineWidthScale:"f32",lineWidthMinPixels:"f32",lineWidthMaxPixels:"f32",stroked:"f32",filled:"f32",antialiasing:"f32",billboard:"f32",radiusUnits:"i32",lineWidthUnits:"i32"}},p=[0,0,0,255],u={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:e=>e.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:p},getLineColor:{type:"accessor",value:p},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class g extends i.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME scatterplot-layer-vertex-shader\nin vec3 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin float instanceRadius;\nin float instanceLineWidths;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\nout vec4 vFillColor;\nout vec4 vLineColor;\nout vec2 unitPosition;\nout float innerUnitRadius;\nout float outerRadiusPixels;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\nouterRadiusPixels = clamp(\nproject_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),\nscatterplot.radiusMinPixels, scatterplot.radiusMaxPixels\n);\nfloat lineWidthPixels = clamp(\nproject_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),\nscatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels\n);\nouterRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;\nfloat edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\nunitPosition = edgePadding * positions.xy;\ngeometry.uv = unitPosition;\ngeometry.pickingColor = instancePickingColors;\ninnerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;\nif (scatterplot.billboard) {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = edgePadding * positions * outerRadiusPixels;\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vFillColor, geometry);\nvLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME scatterplot-layer-fragment-shader\nprecision highp float;\nin vec4 vFillColor;\nin vec4 vLineColor;\nin vec2 unitPosition;\nin float innerUnitRadius;\nin float outerRadiusPixels;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = unitPosition;\nfloat distToCenter = length(unitPosition) * outerRadiusPixels;\nfloat inCircle = scatterplot.antialiasing ?\nsmoothedge(distToCenter, outerRadiusPixels) :\nstep(distToCenter, outerRadiusPixels);\nif (inCircle == 0.0) {\ndiscard;\n}\nif (scatterplot.stroked > 0.5) {\nfloat isLine = scatterplot.antialiasing ?\nsmoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\nstep(innerUnitRadius * outerRadiusPixels, distToCenter);\nif (scatterplot.filled > 0.5) {\nfragColor = mix(vFillColor, vLineColor, isLine);\n} else {\nif (isLine == 0.0) {\ndiscard;\n}\nfragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n}\n} else if (scatterplot.filled < 0.5) {\ndiscard;\n} else {\nfragColor = vFillColor;\n}\nfragColor.a *= inCircle;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",source:"// Main shaders\n\nstruct ScatterplotUniforms {\n  radiusScale: f32,\n  radiusMinPixels: f32,\n  radiusMaxPixels: f32,\n  lineWidthScale: f32,\n  lineWidthMinPixels: f32,\n  lineWidthMaxPixels: f32,\n  stroked: f32,\n  filled: i32,\n  antialiasing: i32,\n  billboard: i32,\n  radiusUnits: i32,\n  lineWidthUnits: i32,\n};\n\nstruct ConstantAttributeUniforms {\n instancePositions: vec3<f32>,\n instancePositions64Low: vec3<f32>,\n instanceRadius: f32,\n instanceLineWidths: f32,\n instanceFillColors: vec4<f32>,\n instanceLineColors: vec4<f32>,\n instancePickingColors: vec3<f32>,\n\n instancePositionsConstant: i32,\n instancePositions64LowConstant: i32,\n instanceRadiusConstant: i32,\n instanceLineWidthsConstant: i32,\n instanceFillColorsConstant: i32,\n instanceLineColorsConstant: i32,\n instancePickingColorsConstant: i32\n};\n\n@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;\n\nstruct ConstantAttributes {\n  instancePositions: vec3<f32>,\n  instancePositions64Low: vec3<f32>,\n  instanceRadius: f32,\n  instanceLineWidths: f32,\n  instanceFillColors: vec4<f32>,\n  instanceLineColors: vec4<f32>,\n  instancePickingColors: vec3<f32>\n};\n\nconst constants = ConstantAttributes(\n  vec3<f32>(0.0),\n  vec3<f32>(0.0),\n  0.0,\n  0.0,\n  vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  vec3<f32>(0.0)\n);\n\nstruct Attributes {\n  @builtin(instance_index) instanceIndex : u32,\n  @builtin(vertex_index) vertexIndex : u32,\n  @location(0) positions: vec3<f32>,\n  @location(1) instancePositions: vec3<f32>,\n  @location(2) instancePositions64Low: vec3<f32>,\n  @location(3) instanceRadius: f32,\n  @location(4) instanceLineWidths: f32,\n  @location(5) instanceFillColors: vec4<f32>,\n  @location(6) instanceLineColors: vec4<f32>,\n  @location(7) instancePickingColors: vec3<f32>\n};\n\nstruct Varyings {\n  @builtin(position) position: vec4<f32>,\n  @location(0) vFillColor: vec4<f32>,\n  @location(1) vLineColor: vec4<f32>,\n  @location(2) unitPosition: vec2<f32>,\n  @location(3) innerUnitRadius: f32,\n  @location(4) outerRadiusPixels: f32,\n};\n\n@vertex\nfn vertexMain(attributes: Attributes) -> Varyings {\n  var varyings: Varyings;\n\n  // Draw an inline geometry constant array clip space triangle to verify that rendering works.\n  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));\n  // if (attributes.instanceIndex == 0) {\n  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);\n  //   return varyings;\n  // }\n\n  // var geometry: Geometry;\n  // geometry.worldPosition = instancePositions;\n\n  // Multiply out radius and clamp to limits\n  varyings.outerRadiusPixels = clamp(\n    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),\n    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels\n  );\n\n  // Multiply out line width and clamp to limits\n  let lineWidthPixels = clamp(\n    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),\n    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;\n  // Expand geometry to accommodate edge smoothing\n  let edgePadding = select(\n    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,\n    1.0,\n    scatterplot.antialiasing != 0\n  );\n\n  // position on the containing square in [-1, 1] space\n  varyings.unitPosition = edgePadding * attributes.positions.xy;\n  geometry.uv = varyings.unitPosition;\n  geometry.pickingColor = attributes.instancePickingColors;\n\n  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;\n\n  if (scatterplot.billboard != 0) {\n    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);\n    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);\n    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;\n    // DECKGL_FILTER_SIZE(offset, geometry);\n    let clipPixels = project_pixel_size_to_clipspace(offset.xy);\n    varyings.position.x = clipPixels.x;\n    varyings.position.y = clipPixels.y;\n  } else {\n    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);\n    // DECKGL_FILTER_SIZE(offset, geometry);\n    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);\n    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);\n  }\n\n  // Apply opacity to instance color, or return instance picking color\n  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * color.opacity);\n  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);\n  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * color.opacity);\n  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);\n\n  return varyings;\n}\n\n@fragment\nfn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {\n  // var geometry: Geometry;\n  // geometry.uv = unitPosition;\n\n  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;\n  let inCircle = select(\n    smoothedge(distToCenter, varyings.outerRadiusPixels),\n    step(distToCenter, varyings.outerRadiusPixels),\n    scatterplot.antialiasing != 0\n  );\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  var fragColor: vec4<f32>;\n\n  if (scatterplot.stroked != 0) {\n    let isLine = select(\n      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),\n      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),\n      scatterplot.antialiasing != 0\n    );\n\n    if (scatterplot.filled != 0) {\n      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);\n    }\n  } else if (scatterplot.filled == 0) {\n    discard;\n  } else {\n    fragColor = varyings.vFillColor;\n  }\n\n  fragColor.a *= inCircle;\n  // DECKGL_FILTER_COLOR(fragColor, geometry);\n\n  // Apply premultiplied alpha as required by transparent canvas\n  fragColor = deckgl_premultiplied_alpha(fragColor);\n\n  return fragColor;\n  // return vec4<f32>(0, 0, 1, 1);\n}\n",modules:[s.A,o.A,r.A,h]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){var t;(super.updateState(e),e.changeFlags.extensionsChanged)&&(null==(t=this.state.model)||t.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw(e){let{uniforms:t}=e;const{radiusUnits:n,radiusScale:i,radiusMinPixels:s,radiusMaxPixels:o,stroked:r,filled:l,billboard:c,antialiasing:d,lineWidthUnits:h,lineWidthScale:p,lineWidthMinPixels:u,lineWidthMaxPixels:g}=this.props,f={stroked:r,filled:l,billboard:c,antialiasing:d,radiusUnits:a.p5[n],radiusScale:i,radiusMinPixels:s,radiusMaxPixels:o,lineWidthUnits:a.p5[h],lineWidthScale:p,lineWidthMinPixels:u,lineWidthMaxPixels:g},m=this.state.model;m.shaderInputs.setProps({scatterplot:f}),"webgpu"===this.context.device.type&&(m.instanceCount=this.props.data.length),m.draw(this.context.renderPass)}_getModel(){const e="webgpu"===this.context.device.type?{depthWriteEnabled:!0,depthCompare:"less-equal"}:void 0;return new l.K(this.context.device,Object.assign({},this.getShaders(),{id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new c.V({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,-1,1,0,1,1,0])}}}),isInstanced:!0,parameters:e}))}}g.defaultProps=u,g.layerName="ScatterplotLayer";const f=g},2714:(e,t,n)=>{n.d(t,{$q:()=>f,A4:()=>c,Dt:()=>l,S8:()=>p});var i=n(29469),s=n(1746);const o=s.rJ.CLOCKWISE,r=s.rJ.COUNTER_CLOCKWISE,a={isClosed:!0};function l(e){return"positions"in e?e.positions:e}function c(e){return"holeIndices"in e?e.holeIndices:null}function d(e,t,n,i,o){let r=t;const l=n.length;for(let s=0;s<l;s++)for(let t=0;t<i;t++)e[r++]=n[s][t]||0;if(!function(e){const t=e[0],n=e[e.length-1];return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]}(n))for(let s=0;s<i;s++)e[r++]=n[0][s]||0;return a.start=t,a.end=r,a.size=i,(0,s.UD)(e,o,a),r}function h(e,t,n,i,o,r,l){void 0===o&&(o=0);const c=(r=r||n.length)-o;if(c<=0)return t;let d=t;for(let s=0;s<c;s++)e[d++]=n[o+s];if(!function(e,t,n,i){for(let s=0;s<t;s++)if(e[n+s]!==e[i-t+s])return!1;return!0}(n,i,o,r))for(let s=0;s<i;s++)e[d++]=n[o+s];return a.start=t,a.end=d,a.size=i,(0,s.UD)(e,l,a),d}function p(e,t){!function(e){if(e=e&&e.positions||e,!Array.isArray(e)&&!ArrayBuffer.isView(e))throw new Error("invalid polygon")}(e);const n=[],i=[];if("positions"in e){const{positions:s,holeIndices:a}=e;if(a){let e=0;for(let l=0;l<=a.length;l++)e=h(n,e,s,t,a[l-1],a[l],0===l?o:r),i.push(e);return i.pop(),{positions:n,holeIndices:i}}e=s}if(!function(e){return Array.isArray(e[0])}(e))return h(n,0,e,t,0,n.length,o),n;if(!function(e){return e.length>=1&&e[0].length>=2&&Number.isFinite(e[0][0])}(e)){let s=0;for(const[a,l]of e.entries())s=d(n,s,l,t,0===a?o:r),i.push(s);return i.pop(),{positions:n,holeIndices:i}}return d(n,0,e,t,o),n}function u(e,t,n){const i=e.length/3;let s=0;for(let o=0;o<i;o++){const r=(o+1)%i;s+=e[3*o+t]*e[3*r+n],s-=e[3*r+t]*e[3*o+n]}return Math.abs(s/2)}function g(e,t,n,i){const s=e.length/3;for(let o=0;o<s;o++){const s=3*o,r=e[s+0],a=e[s+1],l=e[s+2];e[s+t]=r,e[s+n]=a,e[s+i]=l}}function f(e,t,n,s){let o=c(e);o&&(o=o.map((e=>e/t)));let r=l(e);const a=s&&3===t;if(n){const e=r.length;r=r.slice();const i=[];for(let s=0;s<e;s+=t){i[0]=r[s],i[1]=r[s+1],a&&(i[2]=r[s+2]);const e=n(i);r[s]=e[0],r[s+1]=e[1],a&&(r[s+2]=e[2])}}if(a){const e=u(r,0,1),t=u(r,0,2),i=u(r,1,2);if(!e&&!t&&!i)return[];e>t&&e>i||(t>i?(n||(r=r.slice()),g(r,0,2,1)):(n||(r=r.slice()),g(r,2,0,1)))}return(0,i.Ay)(r,o,t)}},39738:(e,t,n)=>{n.d(t,{A:()=>S});var i=n(3002),s=n(30428),o=n(28756),r=n(8961),a=n(8274),l=n(25337),c=n(37072),d=n(2714),h=n(50364),p=n(1746);class u extends h.A{constructor(e){const{fp64:t,IndexType:n=Uint32Array}=e;super(Object.assign({},e,{attributes:{positions:{size:3,type:t?Float64Array:Float32Array},vertexValid:{type:Uint16Array,size:1},indices:{type:n,size:1}}}))}get(e){const{attributes:t}=this;return"indices"===e?t.indices&&t.indices.subarray(0,this.vertexCount):t[e]}updateGeometry(e){super.updateGeometry(e);const t=this.buffers.indices;if(t)this.vertexCount=(t.value||t).length;else if(this.data&&!this.getGeometry)throw new Error("missing indices buffer")}normalizeGeometry(e){if(this.normalize){const t=d.S8(e,this.positionSize);return this.opts.resolution?(0,p.wk)(d.Dt(t),d.A4(t),{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0}):this.opts.wrapLongitude?(0,p.Eg)(d.Dt(t),d.A4(t),{size:this.positionSize,maxLatitude:86,edgeTypes:!0}):t}return e}getGeometrySize(e){if(g(e)){let t=0;for(const n of e)t+=this.getGeometrySize(n);return t}return d.Dt(e).length/this.positionSize}getGeometryFromBuffer(e){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(e):null}updateGeometryAttributes(e,t){if(e&&g(e))for(const n of e){const e=this.getGeometrySize(n);t.geometrySize=e,this.updateGeometryAttributes(n,t),t.vertexStart+=e,t.indexStart=this.indexStarts[t.geometryIndex+1]}else{const n=e;this._updateIndices(n,t),this._updatePositions(n,t),this._updateVertexValid(n,t)}}_updateIndices(e,t){let{geometryIndex:n,vertexStart:i,indexStart:s}=t;const{attributes:o,indexStarts:r,typedArrayManager:a}=this;let l=o.indices;if(!l||!e)return;let c=s;const h=d.$q(e,this.positionSize,this.opts.preproject,this.opts.full3d);l=a.allocate(l,s+h.length,{copy:!0});for(let d=0;d<h.length;d++)l[c++]=h[d]+i;r[n+1]=s+h.length,o.indices=l}_updatePositions(e,t){let{vertexStart:n,geometrySize:i}=t;const{attributes:{positions:s},positionSize:o}=this;if(!s||!e)return;const r=d.Dt(e);for(let a=n,l=0;l<i;a++,l++){const e=r[l*o],t=r[l*o+1],n=o>2?r[l*o+2]:0;s[3*a]=e,s[3*a+1]=t,s[3*a+2]=n}}_updateVertexValid(e,t){let{vertexStart:n,geometrySize:i}=t;const{positionSize:s}=this,o=this.attributes.vertexValid,r=e&&d.A4(e);if(e&&e.edgeTypes?o.set(e.edgeTypes,n):o.fill(1,n,n+i),r)for(let a=0;a<r.length;a++)o[n+r[a]/s-1]=0;o[n+i-1]=0}}function g(e){return Array.isArray(e)&&e.length>0&&!Number.isFinite(e[0])}const f="uniform solidPolygonUniforms {\n  bool extruded;\n  bool isWireframe;\n  float elevationScale;\n} solidPolygon;\n",m={name:"solidPolygon",vs:f,fs:f,uniformTypes:{extruded:"f32",isWireframe:"f32",elevationScale:"f32"}},v="in vec4 fillColors;\nin vec4 lineColors;\nin vec3 pickingColors;\nout vec4 vColor;\nstruct PolygonProps {\nvec3 positions;\nvec3 positions64Low;\nvec3 normal;\nfloat elevations;\n};\nvec3 project_offset_normal(vec3 vector) {\nif (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\nproject.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\nreturn normalize(vector * project.commonUnitsPerWorldUnit);\n}\nreturn project_normal(vector);\n}\nvoid calculatePosition(PolygonProps props) {\nvec3 pos = props.positions;\nvec3 pos64Low = props.positions64Low;\nvec3 normal = props.normal;\nvec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;\ngeometry.worldPosition = props.positions;\ngeometry.pickingColor = pickingColors;\nif (solidPolygon.extruded) {\npos.z += props.elevations * solidPolygon.elevationScale;\n}\ngl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nif (solidPolygon.extruded) {\n#ifdef IS_SIDE_VERTEX\nnormal = project_offset_normal(normal);\n#else\nnormal = project_normal(normal);\n#endif\ngeometry.normal = normal;\nvec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\nvColor = vec4(lightColor, colors.a * layer.opacity);\n} else {\nvColor = vec4(colors.rgb, colors.a * layer.opacity);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",y="#version 300 es\n#define SHADER_NAME solid-polygon-layer-vertex-shader\nin vec3 vertexPositions;\nin vec3 vertexPositions64Low;\nin float elevations;\n"+v+"\nvoid main(void) {\nPolygonProps props;\nprops.positions = vertexPositions;\nprops.positions64Low = vertexPositions64Low;\nprops.elevations = elevations;\nprops.normal = vec3(0.0, 0.0, 1.0);\ncalculatePosition(props);\n}\n",_="#version 300 es\n#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\nin vec2 positions;\nin vec3 vertexPositions;\nin vec3 nextVertexPositions;\nin vec3 vertexPositions64Low;\nin vec3 nextVertexPositions64Low;\nin float elevations;\nin float instanceVertexValid;\n"+v+"\nvoid main(void) {\nif(instanceVertexValid < 0.5){\ngl_Position = vec4(0.);\nreturn;\n}\nPolygonProps props;\nvec3 pos;\nvec3 pos64Low;\nvec3 nextPos;\nvec3 nextPos64Low;\n#if RING_WINDING_ORDER_CW == 1\npos = vertexPositions;\npos64Low = vertexPositions64Low;\nnextPos = nextVertexPositions;\nnextPos64Low = nextVertexPositions64Low;\n#else\npos = nextVertexPositions;\npos64Low = nextVertexPositions64Low;\nnextPos = vertexPositions;\nnextPos64Low = vertexPositions64Low;\n#endif\nprops.positions = mix(pos, nextPos, positions.x);\nprops.positions64Low = mix(pos64Low, nextPos64Low, positions.x);\nprops.normal = vec3(\npos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),\nnextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),\n0.0);\nprops.elevations = elevations * positions.y;\ncalculatePosition(props);\n}\n",x=[0,0,0,255],w={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",_full3d:!1,elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:e=>e.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:x},getLineColor:{type:"accessor",value:x},material:!0},b={enter:(e,t)=>t.length?t.subarray(t.length-e.length):e};class P extends i.A{getShaders(e){return super.getShaders({vs:"top"===e?y:_,fs:"#version 300 es\n#define SHADER_NAME solid-polygon-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\nfragColor = vColor;\ngeometry.uv = vec2(0.);\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[s.A,c.J,o.A,m]})}get wrapLongitude(){return!1}getBounds(){var e;return null==(e=this.getAttributeManager())?void 0:e.getBounds(["vertexPositions"])}initializeState(){const{viewport:e}=this.context;let{coordinateSystem:t}=this.props;const{_full3d:n}=this.props;let i;e.isGeospatial&&t===r.rf.DEFAULT&&(t=r.rf.LNGLAT),t===r.rf.LNGLAT&&(i=n?e.projectPosition.bind(e):e.projectFlat.bind(e)),this.setState({numInstances:0,polygonTesselator:new u({preproject:i,fp64:this.use64bitPositions(),IndexType:Uint32Array})});const s=this.getAttributeManager(),o=!0;s.remove(["instancePickingColors"]),s.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:o},vertexPositions:{size:3,type:"float64",stepMode:"dynamic",fp64:this.use64bitPositions(),transition:b,accessor:"getPolygon",update:this.calculatePositions,noAlloc:o,shaderAttributes:{nextVertexPositions:{vertexOffset:1}}},instanceVertexValid:{size:1,type:"uint16",stepMode:"instance",update:this.calculateVertexValid,noAlloc:o},elevations:{size:1,stepMode:"dynamic",transition:b,accessor:"getElevation"},fillColors:{size:this.props.colorFormat.length,type:"unorm8",stepMode:"dynamic",transition:b,accessor:"getFillColor",defaultValue:x},lineColors:{size:this.props.colorFormat.length,type:"unorm8",stepMode:"dynamic",transition:b,accessor:"getLineColor",defaultValue:x},pickingColors:{size:4,type:"uint8",stepMode:"dynamic",accessor:(e,t)=>{let{index:n,target:i}=t;return this.encodePickingColor(e&&e.__source?e.__source.index:n,i)}}})}getPickingInfo(e){const t=super.getPickingInfo(e),{index:n}=t,i=this.props.data;return i[0]&&i[0].__source&&(t.object=i.find((e=>e.__source.index===n))),t}disablePickingIndex(e){const t=this.props.data;if(t[0]&&t[0].__source)for(let n=0;n<t.length;n++)t[n].__source.index===e&&this._disablePickingIndex(n);else super.disablePickingIndex(e)}draw(e){let{uniforms:t}=e;const{extruded:n,filled:i,wireframe:s,elevationScale:o}=this.props,{topModel:r,sideModel:a,wireframeModel:l,polygonTesselator:c}=this.state,d={extruded:Boolean(n),elevationScale:o,isWireframe:!1};l&&s&&(l.setInstanceCount(c.instanceCount-1),l.shaderInputs.setProps({solidPolygon:Object.assign({},d,{isWireframe:!0})}),l.draw(this.context.renderPass)),a&&i&&(a.setInstanceCount(c.instanceCount-1),a.shaderInputs.setProps({solidPolygon:d}),a.draw(this.context.renderPass)),r&&i&&(r.setVertexCount(c.vertexCount),r.shaderInputs.setProps({solidPolygon:d}),r.draw(this.context.renderPass))}updateState(e){super.updateState(e),this.updateGeometry(e);const{props:t,oldProps:n,changeFlags:i}=e,s=this.getAttributeManager();var o;(i.extensionsChanged||t.filled!==n.filled||t.extruded!==n.extruded)&&(null==(o=this.state.models)||o.forEach((e=>e.destroy())),this.setState(this._getModels()),s.invalidateAll())}updateGeometry(e){let{props:t,oldProps:n,changeFlags:i}=e;if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPolygon)){const{polygonTesselator:e}=this.state,n=t.data.attributes||{};e.updateGeometry({data:t.data,normalize:t._normalize,geometryBuffer:n.getPolygon,buffers:n,getGeometry:t.getPolygon,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:i.dataChanged,full3d:t._full3d}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),i.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(){const{id:e,filled:t,extruded:n}=this.props;let i,s,o;if(t){const t=this.getShaders("top");t.defines.NON_INSTANCED_MODEL=1;const n=this.getAttributeManager().getBufferLayouts({isInstanced:!1});i=new a.K(this.context.device,Object.assign({},t,{id:e+"-top",topology:"triangle-list",bufferLayout:n,isIndexed:!0,userData:{excludeAttributes:{instanceVertexValid:!0}}}))}if(n){const t=this.getAttributeManager().getBufferLayouts({isInstanced:!0});s=new a.K(this.context.device,Object.assign({},this.getShaders("side"),{id:e+"-side",bufferLayout:t,geometry:new l.V({topology:"triangle-strip",attributes:{positions:{size:2,value:new Float32Array([1,0,0,0,1,1,0,1])}}}),isInstanced:!0,userData:{excludeAttributes:{indices:!0}}})),o=new a.K(this.context.device,Object.assign({},this.getShaders("side"),{id:e+"-wireframe",bufferLayout:t,geometry:new l.V({topology:"line-strip",attributes:{positions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),isInstanced:!0,userData:{excludeAttributes:{indices:!0}}}))}return{models:[s,o,i].filter(Boolean),topModel:i,sideModel:s,wireframeModel:o}}calculateIndices(e){const{polygonTesselator:t}=this.state;e.startIndices=t.indexStarts,e.value=t.get("indices")}calculatePositions(e){const{polygonTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateVertexValid(e){e.value=this.state.polygonTesselator.get("vertexValid")}}P.defaultProps=w,P.layerName="SolidPolygonLayer";const S=P},50740:(e,t,n)=>{n.d(t,{A:()=>d});var i=n(18120),s=n(78243);const o="uniform sdfUniforms {\n  float gamma;\n  bool enabled;\n  float buffer;\n  float outlineBuffer;\n  vec4 outlineColor;\n} sdf;\n",r={name:"sdf",vs:o,fs:o,uniformTypes:{gamma:"f32",enabled:"f32",buffer:"f32",outlineBuffer:"f32",outlineColor:"vec4<f32>"}},a=.75,l=[];class c extends s.A{getShaders(){const e=super.getShaders();return Object.assign({},e,{modules:[...e.modules,r],fs:"#version 300 es\n#define SHADER_NAME multi-icon-layer-fragment-shader\nprecision highp float;\nuniform sampler2D iconsTexture;\nin vec4 vColor;\nin vec2 vTextureCoords;\nin vec2 uv;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = uv;\nif (!bool(picking.isActive)) {\nfloat alpha = texture(iconsTexture, vTextureCoords).a;\nvec4 color = vColor;\nif (sdf.enabled) {\nfloat distance = alpha;\nalpha = smoothstep(sdf.buffer - sdf.gamma, sdf.buffer + sdf.gamma, distance);\nif (sdf.outlineBuffer > 0.0) {\nfloat inFill = alpha;\nfloat inBorder = smoothstep(sdf.outlineBuffer - sdf.gamma, sdf.outlineBuffer + sdf.gamma, distance);\ncolor = mix(sdf.outlineColor, vColor, inFill);\nalpha = inBorder;\n}\n}\nfloat a = alpha * color.a;\nif (a < icon.alphaCutoff) {\ndiscard;\n}\nfragColor = vec4(color.rgb, a * layer.opacity);\n}\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n"})}initializeState(){super.initializeState();this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:"uint8",size:3,accessor:(e,t)=>{let{index:n,target:i}=t;return this.encodePickingColor(n,i)}}})}updateState(e){super.updateState(e);const{props:t,oldProps:n}=e;let{outlineColor:s}=t;s!==n.outlineColor&&(s=s.map((e=>e/255)),s[3]=Number.isFinite(s[3])?s[3]:1,this.setState({outlineColor:s})),!t.sdf&&t.outlineWidth&&i.A.warn(this.id+": fontSettings.sdf is required to render outline")()}draw(e){const{sdf:t,smoothing:n,outlineWidth:i}=this.props,{outlineColor:s}=this.state,o=i?Math.max(n,a*(1-i)):-1,r=this.state.model,l={buffer:a,outlineBuffer:o,gamma:n,enabled:Boolean(t),outlineColor:s};if(r.shaderInputs.setProps({sdf:l}),super.draw(e),t&&i){const{iconManager:e}=this.state;e.getTexture()&&(r.shaderInputs.setProps({sdf:Object.assign({},l,{outlineBuffer:a})}),r.draw(this.context.renderPass))}}getInstanceOffset(e){return e?Array.from(e).flatMap((e=>super.getInstanceOffset(e))):l}getInstanceColorMode(e){return 1}getInstanceIconFrame(e){return e?Array.from(e).flatMap((e=>super.getInstanceIconFrame(e))):l}}c.defaultProps={getIconOffsets:{type:"accessor",value:e=>e.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}},c.layerName="MultiIconLayer";const d=c},47495:(e,t,n)=>{n.d(t,{A:()=>u});var i=n(3002),s=n(30428),o=n(28756),r=n(8961),a=n(25337),l=n(8274);const c="uniform textBackgroundUniforms {\n  bool billboard;\n  float sizeScale;\n  float sizeMinPixels;\n  float sizeMaxPixels;\n  vec4 borderRadius;\n  vec4 padding;\n  highp int sizeUnits;\n  bool stroked;\n} textBackground;\n",d={name:"textBackground",vs:c,fs:c,uniformTypes:{billboard:"f32",sizeScale:"f32",sizeMinPixels:"f32",sizeMaxPixels:"f32",borderRadius:"vec4<f32>",padding:"vec4<f32>",sizeUnits:"i32",stroked:"f32"}},h={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,borderRadius:{type:"object",value:0},padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:e=>e.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class p extends i.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME text-background-layer-vertex-shader\nin vec2 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceRects;\nin float instanceSizes;\nin float instanceAngles;\nin vec2 instancePixelOffsets;\nin float instanceLineWidths;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\nout vec4 vFillColor;\nout vec4 vLineColor;\nout float vLineWidth;\nout vec2 uv;\nout vec2 dimensions;\nvec2 rotate_by_angle(vec2 vertex, float angle) {\nfloat angle_radian = radians(angle);\nfloat cos_angle = cos(angle_radian);\nfloat sin_angle = sin(angle_radian);\nmat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\nreturn rotationMatrix * vertex;\n}\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\ngeometry.uv = positions;\ngeometry.pickingColor = instancePickingColors;\nuv = positions;\nvLineWidth = instanceLineWidths;\nfloat sizePixels = clamp(\nproject_size_to_pixel(instanceSizes * textBackground.sizeScale, textBackground.sizeUnits),\ntextBackground.sizeMinPixels, textBackground.sizeMaxPixels\n);\ndimensions = instanceRects.zw * sizePixels + textBackground.padding.xy + textBackground.padding.zw;\nvec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-textBackground.padding.xy, textBackground.padding.zw, positions);\npixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\npixelOffset += instancePixelOffsets;\npixelOffset.y *= -1.0;\nif (textBackground.billboard)  {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = vec3(pixelOffset, 0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\nDECKGL_FILTER_SIZE(offset_common, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vFillColor, geometry);\nvLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME text-background-layer-fragment-shader\nprecision highp float;\nin vec4 vFillColor;\nin vec4 vLineColor;\nin float vLineWidth;\nin vec2 uv;\nin vec2 dimensions;\nout vec4 fragColor;\nfloat round_rect(vec2 p, vec2 size, vec4 radii) {\nvec2 pixelPositionCB = (p - 0.5) * size;\nvec2 sizeCB = size * 0.5;\nfloat maxBorderRadius = min(size.x, size.y) * 0.5;\nvec4 borderRadius = vec4(min(radii, maxBorderRadius));\nborderRadius.xy =\n(pixelPositionCB.x > 0.0) ? borderRadius.xy : borderRadius.zw;\nborderRadius.x = (pixelPositionCB.y > 0.0) ? borderRadius.x : borderRadius.y;\nvec2 q = abs(pixelPositionCB) - sizeCB + borderRadius.x;\nreturn -(min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - borderRadius.x);\n}\nfloat rect(vec2 p, vec2 size) {\nvec2 pixelPosition = p * size;\nreturn min(min(pixelPosition.x, size.x - pixelPosition.x),\nmin(pixelPosition.y, size.y - pixelPosition.y));\n}\nvec4 get_stroked_fragColor(float dist) {\nfloat isBorder = smoothedge(dist, vLineWidth);\nreturn mix(vFillColor, vLineColor, isBorder);\n}\nvoid main(void) {\ngeometry.uv = uv;\nif (textBackground.borderRadius != vec4(0.0)) {\nfloat distToEdge = round_rect(uv, dimensions, textBackground.borderRadius);\nif (textBackground.stroked) {\nfragColor = get_stroked_fragColor(distToEdge);\n} else {\nfragColor = vFillColor;\n}\nfloat shapeAlpha = smoothedge(-distToEdge, 0.0);\nfragColor.a *= shapeAlpha;\n} else {\nif (textBackground.stroked) {\nfloat distToEdge = rect(uv, dimensions);\nfragColor = get_stroked_fragColor(distToEdge);\n} else {\nfragColor = vFillColor;\n}\n}\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[s.A,o.A,d]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){super.updateState(e);const{changeFlags:t}=e;var n;t.extensionsChanged&&(null==(n=this.state.model)||n.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw(e){let{uniforms:t}=e;const{billboard:n,sizeScale:i,sizeUnits:s,sizeMinPixels:o,sizeMaxPixels:a,getLineWidth:l}=this.props;let{padding:c,borderRadius:d}=this.props;c.length<4&&(c=[c[0],c[1],c[0],c[1]]),Array.isArray(d)||(d=[d,d,d,d]);const h=this.state.model,p={billboard:n,stroked:Boolean(l),borderRadius:d,padding:c,sizeUnits:r.p5[s],sizeScale:i,sizeMinPixels:o,sizeMaxPixels:a};h.shaderInputs.setProps({textBackground:p}),h.draw(this.context.renderPass)}_getModel(){return new l.K(this.context.device,Object.assign({},this.getShaders(),{id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new a.V({topology:"triangle-strip",vertexCount:4,attributes:{positions:{size:2,value:new Float32Array([0,0,1,0,0,1,1,1])}}}),isInstanced:!0}))}}p.defaultProps=h,p.layerName="TextBackgroundLayer";const u=p},83667:(e,t,n)=>{n.d(t,{A:()=>C});var i=n(33847),s=n(18120),o=n(33698),r=n(50740),a=n(75228);const l=[];function c(e,t,n,i){let s=0;for(let r=t;r<n;r++){var o;s+=(null==(o=i[e[r]])?void 0:o.layoutWidth)||0}return s}function d(e,t,n,i,s,o){let r=t,a=0;for(let l=t;l<n;l++){const t=c(e,l,l+1,s);a+t>i&&(r<l&&o.push(l),r=l,a=0),a+=t}return a}function h(e,t,n,i,s,o){void 0===s&&(s=0),void 0===o&&(o=e.length);const r=[];return"break-all"===t?d(e,s,o,n,i,r):function(e,t,n,i,s,o){let r=t,a=t,l=t,h=0;for(let p=t;p<n;p++)if(" "===e[p]?l=p+1:" "!==e[p+1]&&p+1!==n||(l=p+1),l>a){let t=c(e,a,l,s);h+t>i&&(r<a&&(o.push(a),r=a,h=0),t>i&&(t=d(e,a,l,i,s,o),r=o[o.length-1])),a=l,h+=t}}(e,s,o,n,i,r),r}function p(e,t,n,i,o,r){let a=0,l=0;for(let c=t;c<n;c++){const t=e[c],n=i[t];n?(l||(l=n.layoutHeight),o[c]=a+n.layoutWidth/2,a+=n.layoutWidth):(s.A.warn("Missing character: "+t+" ("+t.codePointAt(0)+")")(),o[c]=a,a+=32)}r[0]=a,r[1]=l}class u{constructor(e){void 0===e&&(e=5),this._cache={},this._order=[],this.limit=e}get(e){const t=this._cache[e];return t&&(this._deleteOrder(e),this._appendOrder(e)),t}set(e,t){this._cache[e]?(this.delete(e),this._cache[e]=t,this._appendOrder(e)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[e]=t,this._appendOrder(e))}delete(e){this._cache[e]&&(delete this._cache[e],this._deleteOrder(e))}_deleteOrder(e){const t=this._order.indexOf(e);t>=0&&this._order.splice(t,1)}_appendOrder(e){this._order.push(e)}}const g={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:function(){const e=[];for(let t=32;t<128;t++)e.push(String.fromCharCode(t));return e}(),fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12,smoothing:.1};let f=new u(3);function m(e,t){for(let n=0;n<e.length;n++)t.data[4*n+3]=e[n]}function v(e,t,n,i){e.font=i+" "+n+"px "+t,e.fillStyle="#000",e.textBaseline="alphabetic",e.textAlign="left"}class y{constructor(){this.props=Object.assign({},g)}get atlas(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){const{fontSize:e,buffer:t}=this.props;return(1.2*e+2*t)/e}setProps(e){void 0===e&&(e={}),Object.assign(this.props,e),this._key=this._getKey();const t=function(e,t){let n;n="string"==typeof t?new Set(Array.from(t)):new Set(t);const i=f.get(e);if(!i)return n;for(const s in i.mapping)n.has(s)&&n.delete(s);return n}(this._key,this.props.characterSet),n=f.get(this._key);if(n&&0===t.size)return void(this._atlas!==n&&(this._atlas=n));const i=this._generateFontAtlas(t,n);this._atlas=i,f.set(this._key,i)}_generateFontAtlas(e,t){const{fontFamily:n,fontWeight:i,fontSize:s,buffer:o,sdf:r,radius:l,cutoff:c}=this.props;let d=t&&t.data;d||(d=document.createElement("canvas"),d.width=1024);const h=d.getContext("2d",{willReadFrequently:!0});v(h,n,s,i);const{mapping:p,canvasHeight:u,xOffset:g,yOffset:f}=function(e){let{characterSet:t,getFontWidth:n,fontHeight:i,buffer:s,maxCanvasWidth:o,mapping:r={},xOffset:a=0,yOffset:l=0}=e,c=0,d=a;const h=i+2*s;for(const u of t)if(!r[u]){const e=n(u);d+e+2*s>o&&(d=0,c++),r[u]={x:d+s,y:l+c*h+s,width:e,height:h,layoutWidth:e,layoutHeight:i},d+=e+2*s}return{mapping:r,xOffset:d,yOffset:l+c*h,canvasHeight:(p=l+(c+1)*h,Math.pow(2,Math.ceil(Math.log2(p))))};var p}(Object.assign({getFontWidth:e=>h.measureText(e).width,fontHeight:1.2*s,buffer:o,characterSet:e,maxCanvasWidth:1024},t&&{mapping:t.mapping,xOffset:t.xOffset,yOffset:t.yOffset}));if(d.height!==u){const e=h.getImageData(0,0,d.width,d.height);d.height=u,h.putImageData(e,0,0)}if(v(h,n,s,i),r){const t=new a.A({fontSize:s,buffer:o,radius:l,cutoff:c,fontFamily:n,fontWeight:""+i});for(const n of e){const{data:e,width:i,height:o,glyphTop:r}=t.draw(n);p[n].width=i,p[n].layoutOffsetY=.9*s-r;const a=h.createImageData(i,o);m(e,a),h.putImageData(a,p[n].x,p[n].y)}}else for(const a of e)h.fillText(a,p[a].x,p[a].y+o+.9*s);return{xOffset:g,yOffset:f,mapping:p,data:d,width:d.width,height:d.height}}_getKey(){const{fontFamily:e,fontWeight:t,fontSize:n,buffer:i,sdf:s,radius:o,cutoff:r}=this.props;return s?e+" "+t+" "+n+" "+i+" "+o+" "+r:e+" "+t+" "+n+" "+i}}var _=n(47495);const x={start:1,middle:0,end:-1},w={top:1,center:0,bottom:-1},b=[0,0,0,255],P={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:b},getBorderWidth:{type:"accessor",value:0},backgroundBorderRadius:{type:"object",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:g.characterSet},fontFamily:g.fontFamily,fontWeight:g.fontWeight,lineHeight:1,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:b},fontSettings:{type:"object",value:{},compare:1},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:e=>e.text},getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:b},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class S extends i.A{constructor(){super(...arguments),this.getBoundingRect=(e,t)=>{let{size:[n,i]}=this.transformParagraph(e,t);const{fontSize:s}=this.state.fontAtlasManager.props;n/=s,i/=s;const{getTextAnchor:o,getAlignmentBaseline:r}=this.props;return[(x["function"==typeof o?o(e,t):o]-1)*n/2,(w["function"==typeof r?r(e,t):r]-1)*i/2,n,i]},this.getIconOffsets=(e,t)=>{const{getTextAnchor:n,getAlignmentBaseline:i}=this.props,{x:s,y:o,rowWidth:r,size:[a,l]}=this.transformParagraph(e,t),c=x["function"==typeof n?n(e,t):n],d=w["function"==typeof i?i(e,t):i],h=s.length,p=new Array(2*h);let u=0;for(let g=0;g<h;g++){const e=(1-c)*(a-r[g])/2;p[u++]=(c-1)*a/2+e+s[g],p[u++]=(d-1)*l/2+o[g]}return p}}initializeState(){this.state={styleVersion:0,fontAtlasManager:new y},this.props.maxWidth>0&&s.A.once(1,"v8.9 breaking change: TextLayer maxWidth is now relative to text size")()}updateState(e){const{props:t,oldProps:n,changeFlags:i}=e;(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getText))&&this._updateText();(this._updateFontAtlas()||t.lineHeight!==n.lineHeight||t.wordBreak!==n.wordBreak||t.maxWidth!==n.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo(e){let{info:t}=e;return t.object=t.index>=0?this.props.data[t.index]:null,t}_updateFontAtlas(){const{fontSettings:e,fontFamily:t,fontWeight:n}=this.props,{fontAtlasManager:i,characterSet:s}=this.state,o=Object.assign({},e,{characterSet:s,fontFamily:t,fontWeight:n});if(!i.mapping)return i.setProps(o),!0;for(const r in o)if(o[r]!==i.props[r])return i.setProps(o),!0;return!1}_updateText(){var e;const{data:t,characterSet:n}=this.props,i=null==(e=t.attributes)?void 0:e.getText;let s,{getText:r}=this.props,a=t.startIndices;const l="auto"===n&&new Set;if(i&&a){const{texts:e,characterCount:n}=function(e){let{value:t,length:n,stride:i,offset:s,startIndices:o,characterSet:r}=e;const a=t.BYTES_PER_ELEMENT,l=i?i/a:1,c=s?s/a:0,d=o[n]||Math.ceil((t.length-c)/l),h=r&&new Set,p=new Array(n);let u=t;if(l>1||c>0){u=new(0,t.constructor)(d);for(let e=0;e<d;e++)u[e]=t[e*l+c]}for(let g=0;g<n;g++){const e=o[g],t=o[g+1]||d,n=u.subarray(e,t);p[g]=String.fromCodePoint.apply(null,n),h&&n.forEach(h.add,h)}if(h)for(const g of h)r.add(String.fromCodePoint(g));return{texts:p,characterCount:d}}(Object.assign({},ArrayBuffer.isView(i)?{value:i}:i,{length:t.length,startIndices:a,characterSet:l}));s=n,r=(t,n)=>{let{index:i}=n;return e[i]}}else{const{iterable:e,objectInfo:n}=(0,o.X)(t);a=[0],s=0;for(const t of e){n.index++;const e=Array.from(r(t,n)||"");l&&e.forEach(l.add,l),s+=e.length,a.push(s)}}this.setState({getText:r,startIndices:a,numInstances:s,characterSet:l||n})}transformParagraph(e,t){const{fontAtlasManager:n}=this.state,i=n.mapping,s=this.state.getText,{wordBreak:o,lineHeight:r,maxWidth:a}=this.props;return function(e,t,n,i,s){const o=Array.from(e),r=o.length,a=new Array(r),c=new Array(r),d=new Array(r),u=("break-word"===n||"break-all"===n)&&isFinite(i)&&i>0,g=[0,0],f=[0,0];let m=0,v=0,y=0;for(let x=0;x<=r;x++){const e=o[x];if("\n"!==e&&x!==r||(y=x),y>v){const e=u?h(o,n,i,s,v,y):l;for(let n=0;n<=e.length;n++){const i=0===n?v:e[n-1],r=n<e.length?e[n]:y;p(o,i,r,s,a,f);for(let e=i;e<r;e++){var _;const t=(null==(_=s[o[e]])?void 0:_.layoutOffsetY)||0;c[e]=m+f[1]/2+t,d[e]=f[0]}m+=f[1]*t,g[0]=Math.max(g[0],f[0])}v=y}"\n"===e&&(a[v]=0,c[v]=0,d[v]=0,v++)}return g[1]=m,{x:a,y:c,rowWidth:d,size:g}}(s(e,t)||"",r,o,a*n.props.fontSize,i)}renderLayers(){const{startIndices:e,numInstances:t,getText:n,fontAtlasManager:{scale:i,atlas:s,mapping:o},styleVersion:a}=this.state,{data:l,_dataDiff:c,getPosition:d,getColor:h,getSize:p,getAngle:u,getPixelOffset:f,getBackgroundColor:m,getBorderColor:v,getBorderWidth:y,backgroundBorderRadius:x,backgroundPadding:w,background:b,billboard:P,fontSettings:S,outlineWidth:C,outlineColor:j,sizeScale:A,sizeUnits:L,sizeMinPixels:M,sizeMaxPixels:T,transitions:E,updateTriggers:O}=this.props,I=this.getSubLayerClass("characters",r.A),R=this.getSubLayerClass("background",_.A);return[b&&new R({getFillColor:m,getLineColor:v,getLineWidth:y,borderRadius:x,padding:w,getPosition:d,getSize:p,getAngle:u,getPixelOffset:f,billboard:P,sizeScale:A,sizeUnits:L,sizeMinPixels:M,sizeMaxPixels:T,transitions:E&&{getPosition:E.getPosition,getAngle:E.getAngle,getSize:E.getSize,getFillColor:E.getBackgroundColor,getLineColor:E.getBorderColor,getLineWidth:E.getBorderWidth,getPixelOffset:E.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:O.getPosition,getAngle:O.getAngle,getSize:O.getSize,getFillColor:O.getBackgroundColor,getLineColor:O.getBorderColor,getLineWidth:O.getBorderWidth,getPixelOffset:O.getPixelOffset,getBoundingRect:{getText:O.getText,getTextAnchor:O.getTextAnchor,getAlignmentBaseline:O.getAlignmentBaseline,styleVersion:a}}}),{data:l.attributes&&l.attributes.background?{length:l.length,attributes:l.attributes.background}:l,_dataDiff:c,autoHighlight:!1,getBoundingRect:this.getBoundingRect}),new I({sdf:S.sdf,smoothing:Number.isFinite(S.smoothing)?S.smoothing:g.smoothing,outlineWidth:C/(S.radius||g.radius),outlineColor:j,iconAtlas:s,iconMapping:o,getPosition:d,getColor:h,getSize:p,getAngle:u,getPixelOffset:f,billboard:P,sizeScale:A*i,sizeUnits:L,sizeMinPixels:M*i,sizeMaxPixels:T*i,transitions:E&&{getPosition:E.getPosition,getAngle:E.getAngle,getColor:E.getColor,getSize:E.getSize,getPixelOffset:E.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{all:O.getText,getPosition:O.getPosition,getAngle:O.getAngle,getColor:O.getColor,getSize:O.getSize,getPixelOffset:O.getPixelOffset,getIconOffsets:{getTextAnchor:O.getTextAnchor,getAlignmentBaseline:O.getAlignmentBaseline,styleVersion:a}}}),{data:l,_dataDiff:c,startIndices:e,numInstances:t,getIconOffsets:this.getIconOffsets,getIcon:n})]}static set fontAtlasCacheLimit(e){!function(e){s.A.assert(Number.isFinite(e)&&e>=3,"Invalid cache limit"),f=new u(e)}(e)}}S.defaultProps=P,S.layerName="TextLayer";const C=S},33822:(e,t,n)=>{function i(e){let{data:t,getIndex:n,dataRange:i,replace:s}=e;const{startRow:o=0,endRow:r=1/0}=i,a=t.length;let l=a,c=a;for(let p=0;p<a;p++){const e=n(t[p]);if(l>p&&e>=o&&(l=p),e>=r){c=p;break}}let d=l;const h=c-l!==s.length?t.slice(c):void 0;for(let p=0;p<s.length;p++)t[d++]=s[p];if(h){for(let e=0;e<h.length;e++)t[d++]=h[e];t.length=d}return{startRow:l,endRow:l+s.length}}n.d(t,{J:()=>i})},96864:(e,t,n)=>{n.d(t,{A:()=>v});var i=n(96540),s=n(36378);const o="undefined"!=typeof window?i.useLayoutEffect:i.useEffect;function r(e,t){for(;e;){if(e===t)return!0;e=Object.getPrototypeOf(e)}return!1}var a=n(49398),l=n(3002);const c={position:"absolute",zIndex:-1};function d(e,t){if("function"==typeof e)return e(t);if(Array.isArray(e))return e.map((e=>d(e,t)));if(h(e)){if(null==(n=e.props)?void 0:n.mapStyle)return t.style=c,(0,i.cloneElement)(e,t);if(function(e){const t=e.type;return t&&t.deckGLViewProps}(e))return(0,i.cloneElement)(e,t)}var n;return e}function h(e){return e&&"object"==typeof e&&"type"in e||!1}function p(e){if("function"==typeof e)return(0,i.createElement)(a.A,{},e);if(Array.isArray(e))return e.map(p);if(h(e)){if(e.type===i.Fragment)return p(e.props.children);if(r(e.type,a.A))return e}return e}const u=(0,i.createContext)();const g={mixBlendMode:null};function f(e){e.redrawReason&&(e.deck._drawLayers(e.redrawReason),e.redrawReason=null)}function m(e,t){const[n,c]=(0,i.useState)(0),m=(0,i.useRef)({control:null,version:n,forceUpdate:()=>c((e=>e+1))}).current,v=(0,i.useRef)(null),y=(0,i.useRef)(null),_=(0,i.useMemo)((()=>function(e){let{children:t,layers:n=[],views:s=null}=e;const o=[],c=[],d={};return i.Children.forEach(p(t),(e=>{if(h(e)){const t=e.type;if(r(t,l.A)){const n=function(e,t){const n={},i=e.defaultProps||{};for(const s in t)i[s]!==t[s]&&(n[s]=t[s]);return new e(n)}(t,e.props);c.push(n)}else o.push(e);if(r(t,a.A)&&t!==a.A&&e.props.id){const n=new t(e.props);d[n.id]=n}}else e&&o.push(e)})),Object.keys(d).length>0&&(Array.isArray(s)?s.forEach((e=>{d[e.id]=e})):s&&(d[s.id]=s),s=Object.values(d)),n=c.length>0?[...c,...n]:n,{layers:n,children:o,views:s}}(e)),[e.layers,e.views,e.children]);let x=!0;const w=t=>x&&e.viewState?(m.viewStateUpdateRequested=t,null):(m.viewStateUpdateRequested=null,null==e.onViewStateChange?void 0:e.onViewStateChange(t)),b=t=>{x?m.interactionStateUpdateRequested=t:(m.interactionStateUpdateRequested=null,null==e.onInteractionStateChange||e.onInteractionStateChange(t))},P=(0,i.useMemo)((()=>{const t=Object.assign({widgets:[]},e,{style:null,width:"100%",height:"100%",parent:v.current,canvas:y.current,layers:_.layers,views:_.views,onViewStateChange:w,onInteractionStateChange:b});return delete t._customRender,m.deck&&m.deck.setProps(t),t}),[e]);(0,i.useEffect)((()=>{const t=e.Deck||s.A;return m.deck=function(e,t,n){var i;const s=new t(Object.assign({},n,{_customRender:"webgpu"===(null==(i=n.deviceProps)||null==(i=i.adapters)||null==(i=i[0])?void 0:i.type)?void 0:t=>{e.redrawReason=t;const n=s.getViewports();e.lastRenderedViewports!==n?e.forceUpdate():f(e)}}));return s}(m,t,Object.assign({},P,{parent:v.current,canvas:y.current})),()=>{var e;return null==(e=m.deck)?void 0:e.finalize()}}),[]),o((()=>{var e;f(m);const{viewStateUpdateRequested:t,interactionStateUpdateRequested:n}=m;t&&w(t),n&&b(n),null!=(e=m.deck)&&e.isInitialized&&m.deck.redraw("Initial render")})),(0,i.useImperativeHandle)(t,(()=>function(e){return{get deck(){return e.deck},pickObject:t=>e.deck.pickObject(t),pickMultipleObjects:t=>e.deck.pickMultipleObjects(t),pickObjects:t=>e.deck.pickObjects(t)}}(m)),[]);const S=m.deck&&m.deck.isInitialized?m.deck.getViewports():void 0,{ContextProvider:C,width:j="100%",height:A="100%",id:L,style:M}=e,{containerStyle:T,canvasStyle:E}=(0,i.useMemo)((()=>function(e){let{width:t,height:n,style:i}=e;const s={position:"absolute",zIndex:0,left:0,top:0,width:t,height:n},o={left:0,top:0};if(i)for(const r in i)r in g?o[r]=i[r]:s[r]=i[r];return{containerStyle:s,canvasStyle:o}}({width:j,height:A,style:M})),[j,A,M]);if(!m.viewStateUpdateRequested&&m.lastRenderedViewports===S||m.version!==n){m.lastRenderedViewports=S,m.version=n;const e=function(e){let{children:t,deck:n,ContextProvider:s=u.Provider}=e;const{viewManager:o}=n||{};if(!o||!o.views.length)return[];const l={},c=o.views[0].id;for(const i of t){let e=c,t=i;h(i)&&r(i.type,a.A)&&(e=i.props.id||c,t=i.props.children);const n=o.getViewport(e),s=o.getViewState(e);if(n){s.padding=n.padding;const{x:i,y:o,width:r,height:a}=n;t=d(t,{x:i,y:o,width:r,height:a,viewport:n,viewState:s}),l[e]||(l[e]={viewport:n,children:[]}),l[e].children.push(t)}}return Object.keys(l).map((e=>{const{viewport:t,children:o}=l[e],{x:r,y:a,width:c,height:d}=t,h={position:"absolute",left:r,top:a,width:c,height:d},p="view-"+e,u=(0,i.createElement)("div",{key:p,id:p,style:h},...o),g={deck:n,viewport:t,container:n.canvas.offsetParent,eventManager:n.eventManager,onViewStateChange:t=>{t.viewId=e,n._onViewStateChange(t)},widgets:[]},f="view-"+e+"-context";return(0,i.createElement)(s,{key:f,value:g},u)}))}({children:_.children,deck:m.deck,ContextProvider:C}),t=(0,i.createElement)("canvas",{key:"canvas",id:L||"deckgl-overlay",ref:y,style:E});m.control=(0,i.createElement)("div",{id:(L||"deckgl")+"-wrapper",ref:v,style:T},[t,e])}return x=!1,m.control}const v=i.forwardRef(m)}}]);