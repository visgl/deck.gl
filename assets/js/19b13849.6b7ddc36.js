"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7270],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>y});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(a),h=r,y=d["".concat(l,".").concat(h)]||d[h]||u[h]||i;return a?n.createElement(y,o(o({ref:t},p),{},{components:a})):n.createElement(y,o({ref:t},p))}));function y(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},33782:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(83117),r=(a(67294),a(3905));const i={},o="Using Layers",s={unversionedId:"developer-guide/using-layers",id:"developer-guide/using-layers",title:"Using Layers",description:'The "Layer" is a core concept of deck.gl. A deck.gl layer is a packaged visualization type that takes a collection of datums, associate each with positions, colors, extrusions, etc., and renders them on a map.',source:"@site/../docs/developer-guide/using-layers.md",sourceDirName:"developer-guide",slug:"/developer-guide/using-layers",permalink:"/docs/developer-guide/using-layers",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/using-layers.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Learning Resources",permalink:"/docs/get-started/learning-resources"},next:{title:"Adding Interactivity",permalink:"/docs/developer-guide/interactivity"}},l={},c=[{value:"Constructing a Layer Instance",id:"constructing-a-layer-instance",level:2},{value:"Layer ID",id:"layer-id",level:3},{value:"Data",id:"data",level:3},{value:"Accessors",id:"accessors",level:3},{value:"Other Layer Props",id:"other-layer-props",level:3},{value:"Rendering Layers",id:"rendering-layers",level:2},{value:"FAQ",id:"faq",level:2},{value:"Should I be Creating New Layers on Every Render?",id:"should-i-be-creating-new-layers-on-every-render",level:3},{value:"The Reactive Programming Paradigm",id:"the-reactive-programming-paradigm",level:4},{value:"Creating Layer Instances Is Cheap",id:"creating-layer-instances-is-cheap",level:4},{value:"Why Doesn&#39;t My Layer Update with New Props?",id:"why-doesnt-my-layer-update-with-new-props",level:3}],p={toc:c},d="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(d,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"using-layers"},"Using Layers"),(0,r.kt)("p",null,'The "Layer" is a core concept of deck.gl. A deck.gl layer is a packaged visualization type that takes a collection of datums, associate each with positions, colors, extrusions, etc., and renders them on a map.'),(0,r.kt)("p",null,"deck.gl provides an extensive ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/layers/"},"layer catalog")," and is designed to compose many layers together to form complex visuals."),(0,r.kt)("h2",{id:"constructing-a-layer-instance"},"Constructing a Layer Instance"),(0,r.kt)("p",null,"A layer is instantiated with a ",(0,r.kt)("inlineCode",{parentName:"p"},"properties")," object:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {ScatterplotLayer} from 'deck.gl';\n\nconst layer = new ScatterplotLayer({\n  id: 'bart-stations',\n  data: [\n    {name: 'Colma', passengers: 4214, coordinates: [-122.466233, 37.684638]},\n    {name: 'Civic Center', passengers: 24798, coordinates: [-122.413756,37.779528]},\n    ...\n  ],\n  stroked: false,\n  filled: true,\n  getPosition: d => d.coordinates,\n  getRadius: d => Math.sqrt(d.passengers),\n  getFillColor: [255, 200, 0]\n});\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"properties")," are settings that the layer uses to build the visualization. Users of a layer typically specify the following types of props:"),(0,r.kt)("h3",{id:"layer-id"},"Layer ID"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," prop is the unique identifier of this layer among all layers. Constructing a new layer instance in its own does not have any performance impact, as deck.gl only does the expensive calculations when a layer is ",(0,r.kt)("strong",{parentName:"p"},"created")," (an id appearing for the first time) or ",(0,r.kt)("strong",{parentName:"p"},"updated")," (different props are passed in for the same id). Read more about this in ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/custom-layers/layer-lifecycle"},"layer lifecycle"),"."),(0,r.kt)("p",null,"It is recommend that this prop is set explicitly to avoid collision."),(0,r.kt)("h3",{id:"data"},"Data"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," prop specifies data source of this layer's visualization. The value is expected to be a collection (typically a JavaScript array) of data objects with similar structure, such as rows in a table. deck.gl layers are able to handle millions of data objects very efficiently."),(0,r.kt)("p",null,"The value of this prop can be ",(0,r.kt)("inlineCode",{parentName:"p"},"Array"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Map"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Set"),", any object that contains a ",(0,r.kt)("inlineCode",{parentName:"p"},"length")," field, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise")," that resolves to any of the above, or an URL to a JSON array. See ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer#data"},"data prop")," documentation for details."),(0,r.kt)("h3",{id:"accessors"},"Accessors"),(0,r.kt)("p",null,"An accessor is a prop that maps an object in ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," to its visual configuration, e.g. the radius of a circle, the color of a line, etc. All accessor prop names start with ",(0,r.kt)("inlineCode",{parentName:"p"},"get"),"."),(0,r.kt)("p",null,"If an accessor prop is set to a function, when the layer is about to be drawn on screen for the first time, the layer will traverse the ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," stream and call the accessor function with each element."),(0,r.kt)("p",null,"The accessor function receives two arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"object")," - the current element in the data stream. If ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," is an array or an iterable, the element of the current iteration is used. If ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," is a non-iterable object, this argument is always ",(0,r.kt)("inlineCode",{parentName:"li"},"null"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"objectInfo")," (Object) - contextual information of the current element. Contains the following fields:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"index")," (Number) - the index of the current iteration"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"data")," - the value of the ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," prop"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"target")," (Array) - a pre-allocated array. The accessor function can optionally fill data into this array and return it, instead of creating a new array for every object. In some browsers this improves performance significantly by reducing garbage collection.")))),(0,r.kt)("p",null,"The accessor function is typically expected to return either a number or an array."),(0,r.kt)("p",null,"Some accessors also support constant values instead of functions. When a constant value is provided, it is applied to all objects in the data stream."),(0,r.kt)("h3",{id:"other-layer-props"},"Other Layer Props"),(0,r.kt)("p",null,"The rest of the props are typically numeric or boolean values that apply to the whole layer. These include props that define the render options (opacity, extrusion of the PolygonLayer, font family of the TextLayer, etc.), ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/coordinate-systems"},"coordinate system"),", and ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/interactivity"},"interactivity"),"."),(0,r.kt)("h2",{id:"rendering-layers"},"Rendering Layers"),(0,r.kt)("p",null,"deck.gl allows you to render multiple layers using the same or different data sets. You simply provide an array of layer instances and deck.gl will render them in order (and handle interactivity when hovering clicking etc)."),(0,r.kt)("p",null,"This allows you to compose visualizations using several primitive layers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {PathLayer, ScatterplotLayer, ArcLayer} from '@deck.gl/layers';\n\n// A layers array contains deck.gl layer instances. It can also be nested, or contain empty objects\nconst layers = [\n  new PathLayer({id: 'paths', data: ...}),\n  shouldRenderPoints ? [\n    new ScatterplotLayer({id: 'big-points', data: ...}),\n    new ScatterplotLayer({id: 'small-points', data: ...})\n  ] : null,\n  new ArcLayer({id: 'arcs', data: ...})\n];\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Use with pure JS\nimport {Deck} from '@deck.gl/core';\nconst deck = new Deck({...});\ndeck.setProps({layers});\n\n// Use with React\nimport DeckGL from '@deck.gl/react';\n<DeckGL ... layers={layers} />\n")),(0,r.kt)("h2",{id:"faq"},"FAQ"),(0,r.kt)("h3",{id:"should-i-be-creating-new-layers-on-every-render"},"Should I be Creating New Layers on Every Render?"),(0,r.kt)("h4",{id:"the-reactive-programming-paradigm"},"The Reactive Programming Paradigm"),(0,r.kt)("p",null,"deck.gl's architecture is based on the reactive programming paradigm:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'In a reactive application, a complete UI description is "re-rendered" every time something in the application state changes (in the case of a deck.gl application, a new list of layers is created whenever something changes).'),(0,r.kt)("li",{parentName:"ul"},'The UI framework (in this case, deck.gl) makes the choices about what to update, by comparing (or "diffing") the newly rendered UI description with the last rendered UI description.'),(0,r.kt)("li",{parentName:"ul"},"The framework then makes the minimal necessary changes to account for the differences, and then redraws."),(0,r.kt)("li",{parentName:"ul"},'The required changes are made to "GPU state" in case of deck.gl, and to the Browser\'s DOM (HTML element tree) in case of React.')),(0,r.kt)("h4",{id:"creating-layer-instances-is-cheap"},"Creating Layer Instances Is Cheap"),(0,r.kt)("p",null,"The deck.gl model means that applications are expected to create a new set of layers every time application state changes, which can seem surprisingly inefficient to someone who hasn't done reactive programming before. The trick is that layers are just descriptor objects that are very cheap to instantiate, and internally, the new layers are efficiently matched against existing layers so that no updates are performed unless actually needed."),(0,r.kt)("p",null,'So, even though the application creates new "layers", those layers are only "descriptors" containing props that specify what needs to be rendered and how. All calculated state (WebGL2/WebGPU "programs", "vertex attributes" etc) are stored in a state object and this state object is moved forward to the newly matched layer on every render cycle.  The new layer ends up with the state of the old layer (and the props of the new layer), while the old layer is simply discarded for garbage collection.'),(0,r.kt)("p",null,"The application does not have to be aware about this, as long as it keeps rendering new layers with the same ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," they will be matched and the existing state of that layer will be updated accordingly."),(0,r.kt)("p",null,"The constant creation and disposal of layer instances may seem wasteful, however the creation and recycling of JavaScript objects is quite efficient in modern JavaScript environments, and this is very similar to how React works where every render cycle generates a new tree of ReactElement instances, so the model is proven."),(0,r.kt)("p",null,"For more details on layer creation, update and destruction, read about ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/custom-layers/layer-lifecycle"},"Layer Lifecycle"),"."),(0,r.kt)("h3",{id:"why-doesnt-my-layer-update-with-new-props"},"Why Doesn't My Layer Update with New Props?"),(0,r.kt)("p",null,'Since the reactive programming frameworks conceptually render the entire UI every render cycle, and achieves efficiency by comparing and "diffing" changes between render cycles, it is important that comparisons are fast. Because of this, deck.gl uses shallow equality as the default comparison method for most props.'),(0,r.kt)("p",null,"An exception is the accessors. Changing the value of an accessor (i.e. supplying a different function to the accessor prop) will not in itself trigger an attribute update. This is because the function identity is a poor indicator of whether an update is needed, and the convenience of using local functions as prop values."),(0,r.kt)("p",null,"Consider the code below, ",(0,r.kt)("inlineCode",{parentName:"p"},"getRadius")," is shallowly changed every time ",(0,r.kt)("inlineCode",{parentName:"p"},"render()")," is called, even if its execution result would not change:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function render() {\n  const layer = new ScatterplotLayer({\n    ...\n    getColor: x => x.color, // this creates a new function every render\n    getRadius: this._getRadius.bind(this) // bind generates a new function every render\n  });\n  deck.setProps([layer]);\n}\n")),(0,r.kt)("p",null,"In another example, ",(0,r.kt)("inlineCode",{parentName:"p"},"getColor")," is shallowly changed, so would its execution result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const DATA = [...];\n\nfunction setPillColor(index, color) {\n  DATA[index].pill = color;\n  render();\n}\n\nfunction render() {\n  const layer = new ScatterplotLayer({\n    data: DATA,\n    ...\n    getColor: object => object.pill === 'red' ? [255, 0, 0] : [0, 0, 255], // Does not trigger an attribute update!\n  });\n  deck.setProps([layer]);\n}\n")),(0,r.kt)("p",null,"There is no way for deck.gl to know what the programmer intended just by looking at or comparing the functions that are supplied to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Layer"),"s accessor props. Because recalculating attributes can be potentially expensive, deck.gl by default ignores shallow changes in accessor props. This is designed to provide the best performance to the most common use cases without compromising convenience."),(0,r.kt)("p",null,"Instead, the ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer#updatetriggers"},(0,r.kt)("inlineCode",{parentName:"a"},"updateTriggers"))," property gives you fine grained control, enabling you to tell deck.gl exactly which attributes need to change, and when."),(0,r.kt)("p",null,"Read more about this behavior in ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/performance"},"Performance Optimization"),"."))}u.isMDXComponent=!0}}]);