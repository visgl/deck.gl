"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[3074],{35983:(i,t,n)=>{function e(i){let t=1/0,n=1/0,e=1/0,o=-1/0,r=-1/0,l=-1/0;const s=i.POSITION?i.POSITION.value:[],h=s&&s.length;for(let c=0;c<h;c+=3){const i=s[c],h=s[c+1],a=s[c+2];t=i<t?i:t,n=h<n?h:n,e=a<e?a:e,o=i>o?i:o,r=h>r?h:r,l=a>l?a:l}return[[t,n,e],[o,r,l]]}n.d(t,{l:()=>e})},25337:(i,t,n)=>{n.d(t,{V:()=>o});var e=n(4500);class o{id;topology;vertexCount;indices;attributes;userData={};constructor(i){const{attributes:t={},indices:n=null,vertexCount:o=null}=i;this.id=i.id||(0,e.L)("geometry"),this.topology=i.topology,n&&(this.indices=ArrayBuffer.isView(n)?{value:n,size:1}:n),this.attributes={};for(const[e,r]of Object.entries(t)){const i=ArrayBuffer.isView(r)?{value:r}:r;if(!ArrayBuffer.isView(i.value))throw new Error(`${this._print(e)}: must be typed array or object with value as typed array`);if("POSITION"!==e&&"positions"!==e||i.size||(i.size=3),"indices"===e){if(this.indices)throw new Error("Multiple indices detected");this.indices=i}else this.attributes[e]=i}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=o||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(i){return`Geometry ${this.id} attribute ${i}`}_setAttributes(i,t){return this}_calculateVertexCount(i,t){if(t)return t.value.length;let n=1/0;for(const e of Object.values(i)){const{value:i,size:t,constant:o}=e;!o&&i&&void 0!==t&&t>=1&&(n=Math.min(n,i.length/t))}return n}}},49042:(i,t,n)=>{n.d(t,{q:()=>e});const e={props:{},uniforms:{},name:"picking",uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:[0,0,0],highlightColor:[0,1,1,1]},vs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n",getUniforms:function(i={},t){const n={};if(void 0===i.highlightedObjectColor);else if(null===i.highlightedObjectColor)n.isHighlightActive=!1;else{n.isHighlightActive=!0;const t=i.highlightedObjectColor.slice(0,3);n.highlightedObjectColor=t}if(i.highlightColor){const t=Array.from(i.highlightColor,(i=>i/255));Number.isFinite(t[3])||(t[3]=1),n.highlightColor=t}void 0!==i.isActive&&(n.isActive=Boolean(i.isActive),n.isAttribute=Boolean(i.isAttribute));void 0!==i.useFloatColors&&(n.useFloatColors=Boolean(i.useFloatColors));return n}}},10513:(i,t,n)=>{n.d(t,{x:()=>l});var e=n(29651);const o="precision highp int;\n\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  vec3 color;\n};\n\nstruct PointLight {\n  vec3 color;\n  vec3 position;\n  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform lightingUniforms {\n  int enabled;\n  int lightType;\n\n  int directionalLightCount;\n  int pointLightCount;\n\n  vec3 ambientColor;\n\n  vec3 lightColor0;\n  vec3 lightPosition0;\n  vec3 lightDirection0;\n  vec3 lightAttenuation0;\n\n  vec3 lightColor1;\n  vec3 lightPosition1;\n  vec3 lightDirection1;\n  vec3 lightAttenuation1;\n\n  vec3 lightColor2;\n  vec3 lightPosition2;\n  vec3 lightDirection2;\n  vec3 lightAttenuation2;\n} lighting;\n\nPointLight lighting_getPointLight(int index) {\n  switch (index) {\n    case 0:\n      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);\n    case 1:\n      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);\n    case 2:\n    default:  \n      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);\n  }\n}\n\nDirectionalLight lighting_getDirectionalLight(int index) {\n  switch (index) {\n    case 0:\n      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);\n    case 1:\n      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);\n    case 2:\n    default:   \n      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);\n  }\n} \n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n// #endif\n";var r;!function(i){i[i.POINT=0]="POINT",i[i.DIRECTIONAL=1]="DIRECTIONAL"}(r||(r={}));const l={props:{},uniforms:{},name:"lighting",defines:{MAX_LIGHTS:3},uniformTypes:{enabled:"i32",lightType:"i32",directionalLightCount:"i32",pointLightCount:"i32",ambientLightColor:"vec3<f32>",lightColor0:"vec3<f32>",lightPosition0:"vec3<f32>",lightDirection0:"vec3<f32>",lightAttenuation0:"vec3<f32>",lightColor1:"vec3<f32>",lightPosition1:"vec3<f32>",lightDirection1:"vec3<f32>",lightAttenuation1:"vec3<f32>",lightColor2:"vec3<f32>",lightPosition2:"vec3<f32>",lightDirection2:"vec3<f32>",lightAttenuation2:"vec3<f32>"},defaultUniforms:{enabled:1,lightType:r.POINT,directionalLightCount:0,pointLightCount:0,ambientLightColor:[.1,.1,.1],lightColor0:[1,1,1],lightPosition0:[1,1,2],lightDirection0:[1,1,1],lightAttenuation0:[1,0,0],lightColor1:[1,1,1],lightPosition1:[1,1,2],lightDirection1:[1,1,1],lightAttenuation1:[1,0,0],lightColor2:[1,1,1],lightPosition2:[1,1,2],lightDirection2:[1,1,1],lightAttenuation2:[1,0,0]},source:"// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  color: vec3<f32>,\n};\n\nstruct PointLight {\n  color: vec3<f32>,\n  position: vec3<f32>,\n  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  color: vec3<f32>,\n  direction: vec3<f32>,\n};\n\nstruct lightingUniforms {\n  enabled: i32,\n  poightCount: i32,\n  directionalLightCount: i32,\n\n  ambientColor: vec3<f32>,\n\n  // TODO - support multiple lights by uncommenting arrays below\n  lightType: i32,\n  lightColor: vec3<f32>,\n  lightDirection: vec3<f32>,\n  lightPosition: vec3<f32>,\n  lightAttenuation: vec3<f32>,\n\n  // AmbientLight ambientLight;\n  // PointLight pointLight[MAX_LIGHTS];\n  // DirectionalLight directionalLight[MAX_LIGHTS];\n};\n\n// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)\n@binding(1) @group(0) var<uniform> lighting : lightingUniforms;\n\nfn lighting_getPointLight(index: i32) -> PointLight {\n  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);\n}\n\nfn lighting_getDirectionalLight(index: i32) -> DirectionalLight {\n  return DirectionalLight(lighting.lightColor, lighting.lightDirection);\n} \n\nfn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n",vs:o,fs:o,getUniforms:function(i,t={}){if(!(i=i?{...i}:i))return{...l.defaultUniforms};i.lights&&(i={...i,...h(i.lights),lights:void 0});const{ambientLight:n,pointLights:e,directionalLights:o}=i||{};if(!(n||e&&e.length>0||o&&o.length>0))return{...l.defaultUniforms,enabled:0};const r={...l.defaultUniforms,...t,...s({ambientLight:n,pointLights:e,directionalLights:o})};void 0!==i.enabled&&(r.enabled=i.enabled?1:0);return r}};function s({ambientLight:i,pointLights:t=[],directionalLights:n=[]}){const o={};o.ambientLightColor=c(i);let l=0;for(const e of t){o.lightType=r.POINT;const i=l;o[`lightColor${i}`]=c(e),o[`lightPosition${i}`]=e.position,o[`lightAttenuation${i}`]=e.attenuation||[1,0,0],l++}for(const e of n){o.lightType=r.DIRECTIONAL;const i=l;o[`lightColor${i}`]=c(e),o[`lightDirection${i}`]=e.direction,l++}return l>3&&e.R.warn("MAX_LIGHTS exceeded")(),o.directionalLightCount=n.length,o.pointLightCount=t.length,o}function h(i){const t={pointLights:[],directionalLights:[]};for(const n of i||[])switch(n.type){case"ambient":t.ambientLight=n;break;case"directional":t.directionalLights?.push(n);break;case"point":t.pointLights?.push(n)}return t}function c(i={}){const{color:t=[0,0,0],intensity:n=1}=i;return t.map((i=>i*n/255))}},77422:(i,t,n)=>{n.d(t,{I:()=>h});var e=n(54272),o=n(54901),r=n(73731),l=n(83588),s=n(68225);class h extends e.M{constructor(i=0,t=0){super(2),(0,o.cy)(i)&&1===arguments.length?this.copy(i):(o.$W.debug&&((0,r.ws)(i),(0,r.ws)(t)),this[0]=i,this[1]=t)}set(i,t){return this[0]=i,this[1]=t,this.check()}copy(i){return this[0]=i[0],this[1]=i[1],this.check()}fromObject(i){return o.$W.debug&&((0,r.ws)(i.x),(0,r.ws)(i.y)),this[0]=i.x,this[1]=i.y,this.check()}toObject(i){return i.x=this[0],i.y=this[1],i}get ELEMENTS(){return 2}horizontalAngle(){return Math.atan2(this.y,this.x)}verticalAngle(){return Math.atan2(this.x,this.y)}transform(i){return this.transformAsPoint(i)}transformAsPoint(i){return(0,l.Z0)(this,this,i),this.check()}transformAsVector(i){return(0,s.B$)(this,this,i),this.check()}transformByMatrix3(i){return(0,l.ei)(this,this,i),this.check()}transformByMatrix2x3(i){return(0,l.l0)(this,this,i),this.check()}transformByMatrix2(i){return(0,l.ZF)(this,this,i),this.check()}}},54869:(i,t,n)=>{function e(i,t,n,e){return new(n||(n=Promise))((function(o,r){function l(i){try{h(e.next(i))}catch(t){r(t)}}function s(i){try{h(e.throw(i))}catch(t){r(t)}}function h(i){var t;i.done?o(i.value):(t=i.value,t instanceof n?t:new n((function(i){i(t)}))).then(l,s)}h((e=e.apply(i,t||[])).next())}))}function o(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}n.d(t,{aH:()=>h}),"function"==typeof SuppressedError&&SuppressedError;var r=o((function i(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var e,o,r;if(Array.isArray(t)){if((e=t.length)!=n.length)return!1;for(o=e;0!=o--;)if(!i(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((e=(r=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=e;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,r[o]))return!1;for(o=e;0!=o--;){var l=r[o];if(!i(t[l],n[l]))return!1}return!0}return t!=t&&n!=n}));const l="__googleMapsScriptId";var s;!function(i){i[i.INITIALIZED=0]="INITIALIZED",i[i.LOADING=1]="LOADING",i[i.SUCCESS=2]="SUCCESS",i[i.FAILURE=3]="FAILURE"}(s||(s={}));class h{constructor({apiKey:i,authReferrerPolicy:t,channel:n,client:e,id:o=l,language:s,libraries:c=[],mapIds:a,nonce:g,region:u,retries:d=3,url:f="https://maps.googleapis.com/maps/api/js",version:p}){if(this.callbacks=[],this.done=!1,this.loading=!1,this.errors=[],this.apiKey=i,this.authReferrerPolicy=t,this.channel=n,this.client=e,this.id=o||l,this.language=s,this.libraries=c,this.mapIds=a,this.nonce=g,this.region=u,this.retries=d,this.url=f,this.version=p,h.instance){if(!r(this.options,h.instance.options))throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(h.instance.options)}`);return h.instance}h.instance=this}get options(){return{version:this.version,apiKey:this.apiKey,channel:this.channel,client:this.client,id:this.id,libraries:this.libraries,language:this.language,region:this.region,mapIds:this.mapIds,nonce:this.nonce,url:this.url,authReferrerPolicy:this.authReferrerPolicy}}get status(){return this.errors.length?s.FAILURE:this.done?s.SUCCESS:this.loading?s.LOADING:s.INITIALIZED}get failed(){return this.done&&!this.loading&&this.errors.length>=this.retries+1}createUrl(){let i=this.url;return i+="?callback=__googleMapsCallback&loading=async",this.apiKey&&(i+=`&key=${this.apiKey}`),this.channel&&(i+=`&channel=${this.channel}`),this.client&&(i+=`&client=${this.client}`),this.libraries.length>0&&(i+=`&libraries=${this.libraries.join(",")}`),this.language&&(i+=`&language=${this.language}`),this.region&&(i+=`&region=${this.region}`),this.version&&(i+=`&v=${this.version}`),this.mapIds&&(i+=`&map_ids=${this.mapIds.join(",")}`),this.authReferrerPolicy&&(i+=`&auth_referrer_policy=${this.authReferrerPolicy}`),i}deleteScript(){const i=document.getElementById(this.id);i&&i.remove()}load(){return this.loadPromise()}loadPromise(){return new Promise(((i,t)=>{this.loadCallback((n=>{n?t(n.error):i(window.google)}))}))}importLibrary(i){return this.execute(),google.maps.importLibrary(i)}loadCallback(i){this.callbacks.push(i),this.execute()}setScript(){var i,t;if(document.getElementById(this.id))return void this.callback();const n={key:this.apiKey,channel:this.channel,client:this.client,libraries:this.libraries.length&&this.libraries,v:this.version,mapIds:this.mapIds,language:this.language,region:this.region,authReferrerPolicy:this.authReferrerPolicy};Object.keys(n).forEach((i=>!n[i]&&delete n[i])),(null===(t=null===(i=null===window||void 0===window?void 0:window.google)||void 0===i?void 0:i.maps)||void 0===t?void 0:t.importLibrary)||(i=>{let t,n,o,r="The Google Maps JavaScript API",l="google",s="importLibrary",h="__ib__",c=document,a=window;a=a[l]||(a[l]={});const g=a.maps||(a.maps={}),u=new Set,d=new URLSearchParams,f=()=>t||(t=new Promise(((s,a)=>e(this,void 0,void 0,(function*(){var e;for(o in yield n=c.createElement("script"),n.id=this.id,d.set("libraries",[...u]+""),i)d.set(o.replace(/[A-Z]/g,(i=>"_"+i[0].toLowerCase())),i[o]);d.set("callback",l+".maps."+h),n.src=this.url+"?"+d,g[h]=s,n.onerror=()=>t=a(Error(r+" could not load.")),n.nonce=this.nonce||(null===(e=c.querySelector("script[nonce]"))||void 0===e?void 0:e.nonce)||"",c.head.append(n)})))));g[s]?console.warn(r+" only loads once. Ignoring:",i):g[s]=(i,...t)=>u.add(i)&&f().then((()=>g[s](i,...t)))})(n);const o=this.libraries.map((i=>this.importLibrary(i)));o.length||o.push(this.importLibrary("core")),Promise.all(o).then((()=>this.callback()),(i=>{const t=new ErrorEvent("error",{error:i});this.loadErrorCallback(t)}))}reset(){this.deleteScript(),this.done=!1,this.loading=!1,this.errors=[],this.onerrorEvent=null}resetIfRetryingFailed(){this.failed&&this.reset()}loadErrorCallback(i){if(this.errors.push(i),this.errors.length<=this.retries){const i=this.errors.length*Math.pow(2,this.errors.length);console.error(`Failed to load Google Maps script, retrying in ${i} ms.`),setTimeout((()=>{this.deleteScript(),this.setScript()}),i)}else this.onerrorEvent=i,this.callback()}callback(){this.done=!0,this.loading=!1,this.callbacks.forEach((i=>{i(this.onerrorEvent)})),this.callbacks=[]}execute(){if(this.resetIfRetryingFailed(),!this.loading)if(this.done)this.callback();else{if(window.google&&window.google.maps&&window.google.maps.version)return console.warn("Google Maps already loaded outside @googlemaps/js-api-loader. This may result in undesirable behavior as options and script parameters may not match."),void this.callback();this.loading=!0,this.setScript()}}}},28453:(i,t,n)=>{n.d(t,{R:()=>l,x:()=>s});var e=n(96540);const o={},r=e.createContext(o);function l(i){const t=e.useContext(r);return e.useMemo((function(){return"function"==typeof i?i(t):{...t,...i}}),[t,i])}function s(i){let t;return t=i.disableParentContext?"function"==typeof i.components?i.components(o):i.components||o:l(i.components),e.createElement(r.Provider,{value:t},i.children)}},7743:(i,t,n)=>{n.d(t,{A:()=>l});var e=n(93279),o=n(45046);function r(i,t){var n=(0,e.tR)(i[1]),o=(0,e.tR)(t[1]),r=(0,e.tR)(t[0]-i[0]);r>Math.PI&&(r-=2*Math.PI),r<-Math.PI&&(r+=2*Math.PI);var l=Math.log(Math.tan(o/2+Math.PI/4)/Math.tan(n/2+Math.PI/4)),s=Math.atan2(r,l);return((0,e.nv)(s)+360)%360}const l=function(i,t,n){var e;return void 0===n&&(n={}),(e=n.final?r((0,o.uG)(t),(0,o.uG)(i)):r((0,o.uG)(i),(0,o.uG)(t)))>180?-(360-e):e}},78664:(i,t,n)=>{n.d(t,{A:()=>r});var e=n(93279),o=n(45046);const r=function(i,t,n){void 0===n&&(n={});var r=(0,o.uG)(i),l=(0,o.uG)(t);l[0]+=l[0]-r[0]>180?-360:r[0]-l[0]>180?360:0;var s=function(i,t,n){var o=n=void 0===n?e.zX:Number(n),r=i[1]*Math.PI/180,l=t[1]*Math.PI/180,s=l-r,h=Math.abs(t[0]-i[0])*Math.PI/180;h>Math.PI&&(h-=2*Math.PI);var c=Math.log(Math.tan(l/2+Math.PI/4)/Math.tan(r/2+Math.PI/4)),a=Math.abs(c)>1e-11?s/c:Math.cos(r);return Math.sqrt(s*s+a*a*h*h)*o}(r,l);return(0,e.I3)(s,"meters",n.units)}}}]);