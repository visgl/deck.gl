"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7760],{14169:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"developer-guide/custom-layers/layer-lifecycle","title":"Layer Lifecycle","description":"Every deck.gl layer subclass can define certain methods that get called","source":"@site/../docs/developer-guide/custom-layers/layer-lifecycle.md","sourceDirName":"developer-guide/custom-layers","slug":"/developer-guide/custom-layers/layer-lifecycle","permalink":"/docs/developer-guide/custom-layers/layer-lifecycle","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/custom-layers/layer-lifecycle.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Writing Your Own Layer","permalink":"/docs/developer-guide/custom-layers/"},"next":{"title":"Picking","permalink":"/docs/developer-guide/custom-layers/picking"}}');var i=r(74848),t=r(28453);const c={},s="Layer Lifecycle",l={},d=[{value:"deck.gl Rendering Cycles",id:"deckgl-rendering-cycles",level:2},{value:"Layer Lifecycle Stages",id:"layer-lifecycle-stages",level:2},{value:"Initialization",id:"initialization",level:3},{value:"Updating",id:"updating",level:3},{value:"Rendering",id:"rendering",level:3},{value:"Picking",id:"picking",level:3},{value:"Finalization",id:"finalization",level:3},{value:"Comparison with React&#39;s Lifecycle",id:"comparison-with-reacts-lifecycle",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"layer-lifecycle",children:"Layer Lifecycle"})}),"\n",(0,i.jsx)(n.p,{children:"Every deck.gl layer subclass can define certain methods that get called\nat certain points in its lifecycle. The layer can specify how its state\nis initialized and finalized, if and how it should react to property changes,\nand how it should draw and pick the layer."}),"\n",(0,i.jsx)(n.h2,{id:"deckgl-rendering-cycles",children:"deck.gl Rendering Cycles"}),"\n",(0,i.jsxs)(n.p,{children:["Internally, deck.gl sets up the animation loop and calls provided\ncallbacks on initial load and for each rendered frame.\nWhen the deck.gl layer list is drawn to screen, it matches the new Layer\ninstances with the instances from the previous render call, uniquely identified\nby their ",(0,i.jsx)(n.code,{children:"id"})," property.\nEvery time you create a new layer with the same ",(0,i.jsx)(n.code,{children:"id"}),' property as a layer you\nrendered last time, deck.gl consider the new layer instance an "update" of the\nold instance.']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"layer.state"})," is an object that is internal to an instance of a layer.\nWhen a new layer instance is matched to an existing layer instance by ",(0,i.jsx)(n.code,{children:"id"}),",\nthe state object of the old layer becomes accessible to the new layer.\nLayers can use the state object to store persistent information cross rendering cycles."]}),"\n",(0,i.jsx)(n.h2,{id:"layer-lifecycle-stages",children:"Layer Lifecycle Stages"}),"\n",(0,i.jsx)(n.h3,{id:"initialization",children:"Initialization"}),"\n",(0,i.jsxs)(n.p,{children:["Initialization happens only once for each layer that is being added, i.e. a layer from the\ncurrent rendering cycle whose ",(0,i.jsx)(n.code,{children:"id"})," does not get matched with any layer in the previous\ncycle.\n",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/layer#initializestate",children:(0,i.jsx)(n.code,{children:"layer.initializeState()"})})," is called at\nthis stage."]}),"\n",(0,i.jsxs)(n.p,{children:["At the end of initialization,\n",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/layer#updatestate",children:(0,i.jsx)(n.code,{children:"layer.updateState()"})})," is called\nbefore the first render."]}),"\n",(0,i.jsx)(n.h3,{id:"updating",children:"Updating"}),"\n",(0,i.jsx)(n.p,{children:"Updating happens when a new layer has been matched with a layer from the previous\nrendering cycle (resulting in new props being passed to that layer),\nor when context has changed and layers are about to be drawn."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/docs/api-reference/core/layer#shouldupdatestate",children:(0,i.jsx)(n.code,{children:"layer.shouldUpdateState()"})}),"\nis called to determine if the layer needs an update. The default implementation updates on prop and data changes, but not on viewport changes, so screen-space based layers may want to override this (see e.g. ScreenGridLayer).\nUnder more complicated circumstances, additional checks can be supplied through the\n",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/layer#datacomparator",children:(0,i.jsx)(n.code,{children:"dataComparator"})}),"\nprop."]}),"\n",(0,i.jsxs)(n.p,{children:["If the layer does need to be updated,\n",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/layer#updatestate",children:(0,i.jsx)(n.code,{children:"layer.updateState()"})}),"\nis called to perform any necessary operation before the layer is rendered.\nThis usually involves recalculating an attribute by calling\n",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/attribute-manager#invalidate",children:(0,i.jsx)(n.code,{children:"state.attributeManager.invalidate"})}),"\nand updating uniforms by calling ",(0,i.jsx)(n.code,{children:"model.shaderInputs.setProps({...})"}),".\nBy default, when ",(0,i.jsx)(n.code,{children:"props.data"})," changes, all attributes are invalidated and recalculated."]}),"\n",(0,i.jsxs)(n.p,{children:["A composite layer may use\n",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/composite-layer#renderlayers",children:(0,i.jsx)(n.code,{children:"compositeLayer.renderLayers()"})}),'\nto insert one or more deck.gl layers after itself.\nThe generated layers will then be matched and updated,\nallowing the decomposition of the drawing of a complex data set\ninto "primitive" layers.']}),"\n",(0,i.jsx)(n.h3,{id:"rendering",children:"Rendering"}),"\n",(0,i.jsx)(n.p,{children:"Rendering happens during each rendering cycle to draw the layer to the WebGL2/WebGPU context."}),"\n",(0,i.jsxs)(n.p,{children:["For primitive layers, ",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/layer#draw",children:(0,i.jsx)(n.code,{children:"layer.draw()"})}),"\nis called at this stage, which invokes the layers' ",(0,i.jsx)(n.code,{children:"model.render"})," calls.\nFor composite layers, ",(0,i.jsx)(n.code,{children:"layer.renderLayers"})," is called to generate sublayers."]}),"\n",(0,i.jsx)(n.h3,{id:"picking",children:"Picking"}),"\n",(0,i.jsx)(n.p,{children:"Happens when a pointer moves over or clicks on the deck.gl canvas."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/docs/api-reference/core/layer#draw",children:(0,i.jsx)(n.code,{children:"layer.draw()"})})," of all pickable layers\nare called with special uniforms to draw into an off-screen picking buffer."]}),"\n",(0,i.jsxs)(n.p,{children:["When a layer is picked,\n",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/layer#getpickinginfo",children:(0,i.jsx)(n.code,{children:"layer.getPickingInfo()"})}),"\nis called to generate the ",(0,i.jsx)(n.code,{children:"info"})," object of information about what has been picked.\nThis object is then passed to the ",(0,i.jsx)(n.code,{children:"onHover"})," or ",(0,i.jsx)(n.code,{children:"onClick"})," callbacks of the layer."]}),"\n",(0,i.jsxs)(n.p,{children:["Read more about ",(0,i.jsx)(n.a,{href:"/docs/developer-guide/custom-layers/picking",children:"how picking works"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"finalization",children:"Finalization"}),"\n",(0,i.jsxs)(n.p,{children:["Happens for each layer that is being removed, i.e. a layer from the previous\nrendering cycle whose ",(0,i.jsx)(n.code,{children:"id"})," did not get matched with any layer in the current\ncycle.\n",(0,i.jsx)(n.a,{href:"/docs/api-reference/core/layer#finalizestate",children:(0,i.jsx)(n.code,{children:"layer.finalizeState()"})}),"\nis called just before the reference to the state of that layer\nis released."]}),"\n",(0,i.jsx)(n.h2,{id:"comparison-with-reacts-lifecycle",children:"Comparison with React's Lifecycle"}),"\n",(0,i.jsxs)(n.p,{children:["If you are familiar with React and the\n",(0,i.jsx)(n.a,{href:"https://facebook.github.io/react/docs/component-specs.html",children:"React component lifecycle"}),"\nyou will quickly understand the deck.gl layer lifecycle as it is based on\nsimilar ideas. In particular, experience with the React lifecycle should help\nyou understand property change management and how to use the\n",(0,i.jsx)(n.code,{children:"shouldUpdateState"})," and ",(0,i.jsx)(n.code,{children:"updateState"})," methods."]}),"\n",(0,i.jsx)(n.p,{children:"Still, there are a couple of notable differences between the lifecycle\nmethods provided by the two frameworks:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["deck.gl performs preliminary analysis on certain props and context and\nprovides a ",(0,i.jsx)(n.code,{children:"changeFlags"})," object to your ",(0,i.jsx)(n.code,{children:"shouldUpdateState"})," and\n",(0,i.jsx)(n.code,{children:"updateState"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["deck.gl's ",(0,i.jsx)(n.code,{children:"updateState"})," method is called both on layer initialization and\non when props or context is updated. This is different from React's\n",(0,i.jsx)(n.code,{children:"willReceiveProps"})," that is not called when the component is initially created,\nThe deck.gl model avoids requiring the same property checks to be performed\ntwice in both the constructor and ",(0,i.jsx)(n.code,{children:"willReceiveProps"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["deck.gl separates rendering into the ",(0,i.jsx)(n.code,{children:"draw"})," and ",(0,i.jsx)(n.code,{children:"renderLayers"})," methods,\nwhere React just needs ",(0,i.jsx)(n.code,{children:"render"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["deck.gl's ",(0,i.jsx)(n.code,{children:"pick"})," and ",(0,i.jsx)(n.code,{children:"pickInfo"})," methods have no correspondence in\nReact's lifecycle."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),": deck.gl uses a simpler component model than React.\nWhile React backs instance with a separate component, deck.gl just transfers\nthe old layers' state objects to any new matched layers."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),": the data prop, attribute props and the viewport context are\ncentral to deck.gl layers and get special handling. React is more generic\nand leaves the interpretation of most props to the component."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>s});var a=r(96540);const i={},t=a.createContext(i);function c(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);