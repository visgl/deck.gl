"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[6449],{54225:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"api-reference/aggregation-layers/cpu-aggregator","title":"CPUAggregator","description":"The CPUAggregator implements the Aggregator interface by performing aggregation on the CPU.","source":"@site/../docs/api-reference/aggregation-layers/cpu-aggregator.md","sourceDirName":"api-reference/aggregation-layers","slug":"/api-reference/aggregation-layers/cpu-aggregator","permalink":"/docs/api-reference/aggregation-layers/cpu-aggregator","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/deck.gl/tree/master/website/../docs/api-reference/aggregation-layers/cpu-aggregator.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Aggregator Interface","permalink":"/docs/api-reference/aggregation-layers/aggregator"},"next":{"title":"WebGLAggregator","permalink":"/docs/api-reference/aggregation-layers/webgl-aggregator"}}');var a=r(74848),o=r(28453);const i={},s="CPUAggregator",c={},l=[{value:"Example",id:"example",level:2},{value:"Constructor",id:"constructor",level:2},{value:"Props",id:"props",level:2},{value:"<code>customOperations</code> (Function[])",id:"customoperations",level:4},{value:"Source",id:"source",level:2}];function g(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"cpuaggregator",children:"CPUAggregator"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"CPUAggregator"})," implements the ",(0,a.jsx)(n.a,{href:"/docs/api-reference/aggregation-layers/aggregator",children:"Aggregator"})," interface by performing aggregation on the CPU."]}),"\n",(0,a.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,a.jsxs)(n.p,{children:["This example implements an aggregator that makes a ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Histogram",children:"histogram"}),' that calculates "weight" distribution by "position".']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import {CPUAggregator} from '@deck.gl/aggregation-layers';\n\nconst aggregator = new CPUAggregator({\n  dimensions: 1,\n  getBin: {\n    sources: ['position'],\n    getValue: (data: {position: number}, index: number, options: {binSize: number}) =>\n      [Math.floor(data.position / options.binSize)]\n  },\n  getValue: [\n    {\n      sources: ['weight'],\n      getValue: (data: {weight: number}) => data.weight\n    }\n  ]\n});\n\nconst position = new Attribute(device, {id: 'position', size: 1});\nposition.setData({value: new Float32Array(...)});\nconst weight = new Attribute(device, {id: 'weight', size: 1});\nposition.setData({value: new Float32Array(...)});\n\naggregator.setProps({\n  pointCount: data.length,\n  operations: ['SUM'],\n  binOptions: {\n    binSize: 1\n  },\n  attributes: {position, weight}\n});\n\naggregator.update();\n"})}),"\n",(0,a.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"new CPUAggregator(props);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Arguments:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"dimensions"})," (number) - size of bin IDs, either 1 or 2"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getBin"})," (VertexAccessor) - accessor to map each data point to a bin ID","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"sources"})," (string[]) - attribute names needed for the calculation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getValue"})," (",(0,a.jsx)(n.code,{children:"(data: object, index: number, options: object) => number[] | null"}),") - callback to retrieve the bin ID for each data point.\nBin ID should be an array with [dimensions] elements; or null if the data point should be skipped"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getValue"})," (VertexAccessor[]) - accessor to map each data point to a weight value, defined per channel. Each accsor should contain these fields:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"sources"})," (string[]) - attribute names needed for the calculation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getValue"})," (",(0,a.jsx)(n.code,{children:"(data: object, index: number, options: object) => number"}),") - callback to retrieve the value for each data point."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"props",children:"Props"}),"\n",(0,a.jsxs)(n.p,{children:["Requires all ",(0,a.jsx)(n.a,{href:"/docs/api-reference/aggregation-layers/aggregator#setprops",children:"Aggregator"})," props, and the following:"]}),"\n",(0,a.jsxs)(n.h4,{id:"customoperations",children:[(0,a.jsx)(n.code,{children:"customOperations"})," (Function[])"]}),"\n",(0,a.jsx)(n.p,{children:"Overrides built-in aggregation operation with a custom reducer.\nEach element can optionally be a callback with the following signature:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"(pointIndices: number[], getValue: (index: number) => number) => number;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If a custom operation is defined, the corresponding element in the ",(0,a.jsx)(n.code,{children:"operations"})," array will be ignored."]}),"\n",(0,a.jsx)(n.p,{children:"Example to calculate the median for channel 1:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function median(pointIndices: number[], getValue: (index: number) => number) {\n  const values = pointIndices.map(getValue);\n  values.sort((a, b) => a - b);\n  return values[values.length >> 1];\n}\n\naggregator.setProps({\n  customOperations: [null, median, null]\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"source",children:"Source"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://github.com/visgl/deck.gl/tree/9.1-release/modules/aggregation-layers/src/common/aggregator/cpu-aggregator/cpu-aggregator.ts",children:"modules/aggregation-layers/src/common/aggregator/cpu-aggregator/cpu-aggregator.ts"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(g,{...e})}):g(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>s});var t=r(96540);const a={},o=t.createContext(a);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);