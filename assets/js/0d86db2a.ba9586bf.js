"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5144],{54005:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"api-reference/core/attribute-manager","title":"AttributeManager","description":"The AttributeManager is used internally by deck.gl layers. Unless you are writing custom deck.gl layers, or you are working with some very narrow advanced performance optimization use cases, you do not need to use this class.","source":"@site/../docs/api-reference/core/attribute-manager.md","sourceDirName":"api-reference/core","slug":"/api-reference/core/attribute-manager","permalink":"/docs/api-reference/core/attribute-manager","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/deck.gl/tree/master/website/../docs/api-reference/core/attribute-manager.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Deck","permalink":"/docs/api-reference/core/deck"},"next":{"title":"Widget","permalink":"/docs/api-reference/core/widget"}}');var d=n(74848),s=n(28453);const i={},a="AttributeManager",l={},c=[{value:"Static Methods",id:"static-methods",level:2},{value:"<code>setDefaultLogFunctions</code>",id:"setdefaultlogfunctions",level:4},{value:"Constructor",id:"constructor",level:2},{value:"Methods",id:"methods",level:2},{value:"<code>add</code>",id:"add",level:4},{value:"<code>addInstanced</code>",id:"addinstanced",level:4},{value:"<code>remove</code>",id:"remove",level:4},{value:"<code>invalidate</code>",id:"invalidate",level:4},{value:"<code>invalidateAll</code>",id:"invalidateall",level:4},{value:"<code>update</code>",id:"update",level:4},{value:"<code>getBufferLayouts</code>",id:"getbufferlayouts",level:4},{value:"Remarks",id:"remarks",level:2},{value:"Attribute Type",id:"attribute-type",level:3},{value:"Source",id:"source",level:2}];function o(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(t.header,{children:(0,d.jsx)(t.h1,{id:"attributemanager",children:"AttributeManager"})}),"\n",(0,d.jsxs)(t.blockquote,{children:["\n",(0,d.jsxs)(t.p,{children:["The ",(0,d.jsx)(t.code,{children:"AttributeManager"})," is used internally by deck.gl layers. Unless you are writing custom deck.gl layers, or you are working with some very narrow advanced performance optimization use cases, you do not need to use this class."]}),"\n"]}),"\n",(0,d.jsxs)(t.p,{children:["The ",(0,d.jsx)(t.code,{children:"AttributeManager"})," class provides automated attribute allocations and updates."]}),"\n",(0,d.jsx)(t.p,{children:"Summary:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsx)(t.li,{children:"keeps track of valid state for each attribute"}),"\n",(0,d.jsx)(t.li,{children:"auto reallocates attributes when needed"}),"\n",(0,d.jsx)(t.li,{children:"auto updates attributes with registered updater functions"}),"\n",(0,d.jsx)(t.li,{children:"allows overriding with application supplied buffers"}),"\n"]}),"\n",(0,d.jsxs)(t.p,{children:["For more information consult the ",(0,d.jsx)(t.a,{href:"/docs/developer-guide/custom-layers/attribute-management",children:"Attribute Management"})," article."]}),"\n",(0,d.jsx)(t.h2,{id:"static-methods",children:"Static Methods"}),"\n",(0,d.jsx)(t.h4,{id:"setdefaultlogfunctions",children:(0,d.jsx)(t.code,{children:"setDefaultLogFunctions"})}),"\n",(0,d.jsx)(t.p,{children:"Sets log functions to help trace or time attribute updates.\nDefault logging uses the deck.gl logger."}),"\n",(0,d.jsx)(t.p,{children:"Note that the app may not be in control of when update is called,\nso hooks are provided for update start and end."}),"\n",(0,d.jsx)(t.p,{children:"Parameters:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"opts.onUpdateStart"})," (Function) - callback, called before an attribute starts updating"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"opts.onUpdate"})," (Function) - callback, called when update is performed. Receives an argument ",(0,d.jsx)(t.code,{children:"message"})," detailing the update operation."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"opts.onUpdateEnd"})," (Function) - callback, called after an attribute is updated. Receives an argument ",(0,d.jsx)(t.code,{children:"message"})," detailing the update operation."]}),"\n"]}),"\n",(0,d.jsx)(t.h2,{id:"constructor",children:"Constructor"}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-js",children:"new AttributeManager({id: 'attribute-manager'});\n"})}),"\n",(0,d.jsx)(t.p,{children:"Parameters:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"id"})," (string, optional) - identifier (for debugging)"]}),"\n"]}),"\n",(0,d.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,d.jsx)(t.h4,{id:"add",children:(0,d.jsx)(t.code,{children:"add"})}),"\n",(0,d.jsx)(t.p,{children:"Adds attribute descriptions to the AttributeManager that describe\nthe attributes that should be auto-calculated."}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-js",children:"attributeManager.add({\n  positions: {size: 2, accessor: 'getPosition', update: calculatePositions},\n  colors: {size: 4, type: 'unorm8', accessor: 'getColor', update: calculateColors}\n});\n"})}),"\n",(0,d.jsx)(t.p,{children:"Takes a single parameter as a map of attribute descriptor objects:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsx)(t.li,{children:"keys are attribute names"}),"\n",(0,d.jsxs)(t.li,{children:["values are objects with attribute definitions:","\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:["luma.gl ",(0,d.jsx)(t.a,{href:"https://luma.gl/docs/api-reference-legacy/classes/accessor",children:"accessor parameters"}),":","\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"type"}),' (string, optional) - data type of the attribute, see "Remarks" section below. Default ',(0,d.jsx)(t.code,{children:"'float32'"}),"."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"size"})," (number) - number of elements per vertex"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(t.li,{children:["deck.gl attribute configurations:","\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"stepMode"})," (string, optional) - One of ",(0,d.jsx)(t.code,{children:"'vertex'"}),", ",(0,d.jsx)(t.code,{children:"'instance'"})," and ",(0,d.jsx)(t.code,{children:"'dynamic'"}),". If set to ",(0,d.jsx)(t.code,{children:"'dynamic'"}),", will be resolved to ",(0,d.jsx)(t.code,{children:"'instance'"})," when this attribute is applied to an instanced model, and ",(0,d.jsx)(t.code,{children:"'vertex'"})," otherwise. Default ",(0,d.jsx)(t.code,{children:"'vertex'"}),"."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"isIndexed"})," (boolean, optional) - if this is an index attribute\n(a.k.a. indices). Default to ",(0,d.jsx)(t.code,{children:"false"}),"."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"accessor"})," (string | string[] | Function) - accessor name(s) that will\ntrigger an update of this attribute when changed. Used with\n",(0,d.jsx)(t.a,{href:"/docs/api-reference/core/layer#updatetriggers",children:(0,d.jsx)(t.code,{children:"updateTriggers"})}),"."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"transform"})," (Function, optional) - callback to process the result returned by ",(0,d.jsx)(t.code,{children:"accessor"}),"."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"update"})," (Function, optional) - the function to be called when data changes. If not supplied, the attribute will be auto-filled with ",(0,d.jsx)(t.code,{children:"accessor"}),"."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"defaultValue"})," (number | number[], optional) - Default ",(0,d.jsx)(t.code,{children:"[0, 0, 0, 0]"}),"."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"noAlloc"})," (boolean, optional) - if this attribute should not be\nautomatically allocated. Default to ",(0,d.jsx)(t.code,{children:"false"}),"."]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"shaderAttributes"})," (object, optional) - If this attribute maps to multiple\nattributes in the vertex shader, that mapping can be defined here. All\n",(0,d.jsx)(t.code,{children:"shaderAttributes"})," will share a single buffer created based on the ",(0,d.jsx)(t.code,{children:"size"}),"\nparameter. This can be used to interleave attributes. Each shader attribute object may contain any of the following:","\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"size"})," (number) - number of elements per vertex"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"vertexOffset"})," (number) - offset of the attribute by vertex (stride). Default ",(0,d.jsx)(t.code,{children:"0"}),"."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"elementOffset"})," (number) - offset of the attribute by element. default ",(0,d.jsx)(t.code,{children:"0"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(t.h4,{id:"addinstanced",children:(0,d.jsx)(t.code,{children:"addInstanced"})}),"\n",(0,d.jsxs)(t.p,{children:["Shorthand for ",(0,d.jsx)(t.code,{children:"add()"})," in which all attributes ",(0,d.jsx)(t.code,{children:"stepMode"})," field are set to ",(0,d.jsx)(t.code,{children:"'instance'"}),"."]}),"\n",(0,d.jsx)(t.h4,{id:"remove",children:(0,d.jsx)(t.code,{children:"remove"})}),"\n",(0,d.jsx)(t.p,{children:"Removes defined attributes."}),"\n",(0,d.jsx)(t.p,{children:"Parameters:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"attributeNames"})," (string[]) - Array of attribute names to be removed"]}),"\n"]}),"\n",(0,d.jsx)(t.h4,{id:"invalidate",children:(0,d.jsx)(t.code,{children:"invalidate"})}),"\n",(0,d.jsx)(t.p,{children:"Mark an attribute as need update."}),"\n",(0,d.jsx)(t.p,{children:"Parameters:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"name"})," (string) - Either the name of the attribute, or the name of an accessor. If an name of accessor is provided, all attributes with that accessor are invalidated."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"dataRange"})," (object, optional) - A partial range of the attribute to invalidate, in the shape of ",(0,d.jsx)(t.code,{children:"{startRow, endRow}"}),". Start (included) and end (excluded) are indices into the data array. If not provided, recalculate the  attribute for all data."]}),"\n"]}),"\n",(0,d.jsx)(t.h4,{id:"invalidateall",children:(0,d.jsx)(t.code,{children:"invalidateAll"})}),"\n",(0,d.jsx)(t.p,{children:"Mark all attributes as need update."}),"\n",(0,d.jsx)(t.p,{children:"Parameters:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"dataRange"})," (object, optional) - A partial range of the attributes to invalidate, in the shape of ",(0,d.jsx)(t.code,{children:"{startRow, endRow}"}),". Start (included) and end (excluded) are indices into the data array. If not provided, recalculate the  attributes for all data."]}),"\n"]}),"\n",(0,d.jsx)(t.h4,{id:"update",children:(0,d.jsx)(t.code,{children:"update"})}),"\n",(0,d.jsx)(t.p,{children:"Ensure all attribute buffers are updated from props or data."}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-js",children:"attributeManager.update({\n    data,\n    numInstances,\n    transitions,\n    startIndex,\n    endIndex,\n    props = {},\n    buffers = {},\n    context = {},\n    ignoreUnknownAttributes = false\n});\n"})}),"\n",(0,d.jsx)(t.p,{children:"Parameters:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"data"})," (object) - data (iterable object)"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"numInstances"})," (number) - count of data"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"buffers"})," (object) - pre-allocated buffers"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"props"})," (object) - passed to updaters"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"context"}),' (object) - Used as "this" context for updaters']}),"\n"]}),"\n",(0,d.jsx)(t.p,{children:"Notes:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsx)(t.li,{children:'Any preallocated buffers in "buffers" matching registered attribute names will be used. No update will happen in this case.'}),"\n",(0,d.jsx)(t.li,{children:"Calls onUpdateStart and onUpdateEnd log callbacks before and after."}),"\n"]}),"\n",(0,d.jsx)(t.h4,{id:"getbufferlayouts",children:(0,d.jsx)(t.code,{children:"getBufferLayouts"})}),"\n",(0,d.jsx)(t.p,{children:"Returns WebGPU-style buffer layout descriptors."}),"\n",(0,d.jsx)(t.p,{children:"Parameters:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"modelInfo"})," (object) - a luma.gl ",(0,d.jsx)(t.code,{children:"Model"})," or a similarly shaped object","\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"isInstanced"})," (boolean) - used to resolve ",(0,d.jsx)(t.code,{children:"stepMode: 'dynamic'"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(t.h2,{id:"remarks",children:"Remarks"}),"\n",(0,d.jsx)(t.h3,{id:"attribute-type",children:"Attribute Type"}),"\n",(0,d.jsxs)(t.p,{children:["The following ",(0,d.jsx)(t.code,{children:"type"})," values are supported for attribute definitions:"]}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"type"}),(0,d.jsx)(t.th,{children:"value array type"}),(0,d.jsx)(t.th,{children:"notes"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"float32"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Float32Array"})}),(0,d.jsx)(t.td,{})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"float64"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Float64Array"})}),(0,d.jsxs)(t.td,{children:["Because 64-bit floats are not supported by WebGL, the value is converted to an interleaved ",(0,d.jsx)(t.code,{children:"Float32Array"})," before uploading to the GPU. It is exposed to the vertex shader as two attributes, ",(0,d.jsx)(t.code,{children:"<attribute_name>"})," and ",(0,d.jsx)(t.code,{children:"<attribute_name>64Low"}),", the sum of which is the 64-bit value."]})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"sint8"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Int8Array"})}),(0,d.jsx)(t.td,{})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"snorm8"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Int8Array"})}),(0,d.jsx)(t.td,{children:"Normalized"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint8"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Uint8ClampedArray"})}),(0,d.jsx)(t.td,{})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"unorm8"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Uint8ClampedArray"})}),(0,d.jsx)(t.td,{children:"Normalized"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"sint16"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Int16Array"})}),(0,d.jsx)(t.td,{})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"snorm16"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Int16Array"})}),(0,d.jsx)(t.td,{children:"Normalized"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint16"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Uint16Array"})}),(0,d.jsx)(t.td,{})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"unorm16"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Uint16Array"})}),(0,d.jsx)(t.td,{children:"Normalized"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"sint32"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Int32Array"})}),(0,d.jsx)(t.td,{})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint32"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Uint32Array"})}),(0,d.jsx)(t.td,{})]})]})]}),"\n",(0,d.jsx)(t.h2,{id:"source",children:"Source"}),"\n",(0,d.jsx)(t.p,{children:(0,d.jsx)(t.a,{href:"https://github.com/visgl/deck.gl/tree/9.2-release/modules/core/src/lib/attribute/attribute-manager.ts",children:"modules/core/src/lib/attribute-manager.ts"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,d.jsx)(t,{...e,children:(0,d.jsx)(o,{...e})}):o(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var r=n(96540);const d={},s=r.createContext(d);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);