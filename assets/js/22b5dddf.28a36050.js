"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[9301],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),u=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(a),m=n,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||i;return a?r.createElement(h,o(o({ref:t},c),{},{components:a})):r.createElement(h,o({ref:t},c))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:n,o[1]=l;for(var u=2;u<i;u++)o[u]=a[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},65111:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var r=a(83117),n=(a(67294),a(3905));const i={},o="Attribute Management",l={unversionedId:"developer-guide/custom-layers/attribute-management",id:"developer-guide/custom-layers/attribute-management",title:"Attribute Management",description:"Overview",source:"@site/../docs/developer-guide/custom-layers/attribute-management.md",sourceDirName:"developer-guide/custom-layers",slug:"/developer-guide/custom-layers/attribute-management",permalink:"/docs/developer-guide/custom-layers/attribute-management",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/custom-layers/attribute-management.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Property Types",permalink:"/docs/developer-guide/custom-layers/prop-types"},next:{title:"Writing Shaders",permalink:"/docs/developer-guide/custom-layers/writing-shaders"}},s={},u=[{value:"Overview",id:"overview",level:2},{value:"GPU Performance Challenges",id:"gpu-performance-challenges",level:2},{value:"Automatic Attribute Generation",id:"automatic-attribute-generation",level:2},{value:"Accessors, Shallow Comparisons and updateTriggers",id:"accessors-shallow-comparisons-and-updatetriggers",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Manual Buffer Management",id:"manual-buffer-management",level:3},{value:"More information",id:"more-information",level:2},{value:"Introduction to Vertex Attributes",id:"introduction-to-vertex-attributes",level:3},{value:"Introduction to Instanced Vertex Attributes",id:"introduction-to-instanced-vertex-attributes",level:3},{value:"Learning More",id:"learning-more",level:3}],c={toc:u},d="wrapper";function p(e){let{components:t,...a}=e;return(0,n.kt)(d,(0,r.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"attribute-management"},"Attribute Management"),(0,n.kt)("h2",{id:"overview"},"Overview"),(0,n.kt)("p",null,"deck.gl layers' public API were designed to follow a Reactive programming\nparadigm."),(0,n.kt)("p",null,'The challenge is that in the "reactive" model, every change to application state causes everything to be re-rendered. This is not an issue for UI rendering for general purpose apps, but for high performance, graphics intensive and sometime 3D contents to be rendered by the GPU, huge memory buffers (so called "vertex attributes", or just "attributes" for short) must be prepared and transferred to the GPUs before any draw calls got executed on the GPUs.'),(0,n.kt)("h2",{id:"gpu-performance-challenges"},"GPU Performance Challenges"),(0,n.kt)("p",null,'Creating and transferring new GPU buffers before every draw call would result in unacceptable performance even for moderately complex models. Just like in React (which "renders" to the browser\'s slow-updating DOM), the challenge becomes to detect which part of the visualization is changed to limit both attributes recalculation and re-rendering to the minimum.'),(0,n.kt)("p",null,"Since the length of attributes are usually proportional of to the number of data elements being visualized (hundreds of thousands or even multiple millions of elements are not uncommon in big data visualizations), efficient attribute updates is critical."),(0,n.kt)("p",null,"deck.gl alleviates the burden of layer developers by providing an ",(0,n.kt)("inlineCode",{parentName:"p"},"AttributeManager")," class to manage the lifecycle of those GPU attributes. Note that it is completely possible for a layer to use custom code to manage attribute updates, however most layers rely on the ",(0,n.kt)("inlineCode",{parentName:"p"},"AttributeManager")," class to handle GPU buffer management for them."),(0,n.kt)("h2",{id:"automatic-attribute-generation"},"Automatic Attribute Generation"),(0,n.kt)("p",null,"Automated attribute generation and management is suitable when a set of vertex shader attributes are generated by iteration over a data array, and updates to these attributes are needed either when the data itself changes, or when other data relevant to the calculations change."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"First the application registers descriptions of its dynamic vertex attributes using AttributeManager.add()."),(0,n.kt)("li",{parentName:"ul"},"Then, when any change that affects attributes is detected by the application, the app will call AttributeManager.invalidate()."),(0,n.kt)("li",{parentName:"ul"},"Finally before it renders, it calls AttributeManager.update() to ensure that attributes are automatically rebuilt if anything has been invalidated.")),(0,n.kt)("p",null,"The application provided update functions describe how attributes should be updated from a data array and are expected to traverse that data array (or iterable) and fill in the attribute's typed array."),(0,n.kt)("p",null,'Note that the attribute manager intentionally does not do advanced change detection, but instead makes it easy to build such detection by offering the ability to "invalidate" each attribute separately.'),(0,n.kt)("h3",{id:"accessors-shallow-comparisons-and-updatetriggers"},"Accessors, Shallow Comparisons and updateTriggers"),(0,n.kt)("p",null,'The layer will expect each object to provide a number of "attributes" that it can use to set the GL buffers. By default, the layer will look for these attributes to be available as fields directly on the objects during iteration over the supplied data set. To gain more control of attribute access and/or to do on-the-fly calculation of attributes.'),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Note"),": A layer only renders when a property change is detected. For performance reasons, property change detection uses shallow compare, which means that mutating an element inside a buffer or a mutable data array does not register as a property change, and thus does not trigger a re-render."),(0,n.kt)("p",null,"To force trigger a render after mutating buffers, simply increment the ",(0,n.kt)("inlineCode",{parentName:"p"},"renderCount")," property. To force trigger a buffer update after mutating data, increment the ",(0,n.kt)("inlineCode",{parentName:"p"},"updateCount")," property."),(0,n.kt)("h2",{id:"advanced-topics"},"Advanced Topics"),(0,n.kt)("h3",{id:"manual-buffer-management"},"Manual Buffer Management"),(0,n.kt)("p",null,"While most apps rely on their layers to automatically generate appropriate GPU buffers from their props, it is possible for applications to take control of buffer generation and supply the buffers as properties."),(0,n.kt)("p",null,"While this allows for ultimate performance and control of updates, as well as potential sharing of buffers between layers, the application will need to generate attributes in exactly the format that the layer shaders expect, creating a strong coupling between the application and the layer."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Note:")," The application can provide some buffers and let others be managed by the layer. As an example management of the ",(0,n.kt)("inlineCode",{parentName:"p"},"instancePickingColors")," buffer is normally left to the layer."),(0,n.kt)("h2",{id:"more-information"},"More information"),(0,n.kt)("h3",{id:"introduction-to-vertex-attributes"},"Introduction to Vertex Attributes"),(0,n.kt)("p",null,"deck.gl layers use WebGL2/WebGPU to render visualization elements. In this programming model, all geometry elements are made of a set of vertices, and each vertex has multiple attributes to determine how it will be rendered to the screen. These attributes are called ",(0,n.kt)("strong",{parentName:"p"},"vertex attributes")," and are provided by users using JavaScript typed arrays (e.g. ",(0,n.kt)("inlineCode",{parentName:"p"},"Float32Array")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"Uint8Array"),")."),(0,n.kt)("p",null,"During rendering, these vertex attributes will become available in vertex shaders executing on the GPU."),(0,n.kt)("p",null,"Part of designing a new layer is creating an elegant mapping from a set of data properties in JavaScript to a set of GPU vertex attributes, and then implementing the code that generates the typed arrays that represent the geometry so that GPU calls can be performed efficiently later when drawing the layer."),(0,n.kt)("h3",{id:"introduction-to-instanced-vertex-attributes"},"Introduction to Instanced Vertex Attributes"),(0,n.kt)("p",null,"Even for GPU-accelerated rendering, setting up draw calls and dispatching them to the GPU can quickly become a performance bottleneck for visualizing big data. Therefore, each deck.gl layer aspires to use as few GPU draw calls as possible to draw everything contained in the data."),(0,n.kt)("p",null,"Here the ",(0,n.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/drawArraysInstanced"},(0,n.kt)("inlineCode",{parentName:"a"},"Instanced Rendering"))," comes into play. While some vertex attributes will still describe the geometry of each object (or instance), other vertex attributes will describe what is different between each object or instance. The latter kind of attributes are called instanced attributes."),(0,n.kt)("h3",{id:"learning-more"},"Learning More"),(0,n.kt)("p",null,"While you can certainly start consulting detailed WebGL2/WebGPU resources to learn more about vertex attributes, be aware that many available resources can get quite technical, involving more concepts than you may need at this point."),(0,n.kt)("p",null,"If you are new to these concepts, we have found that a great way to learn more is simply to copy an existing deck.gl layer and start extending/modifying its functionality."))}p.isMDXComponent=!0}}]);