"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[6199],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,f=u["".concat(s,".").concat(m)]||u[m]||c[m]||a;return n?i.createElement(f,o(o({ref:t},d),{},{components:n})):i.createElement(f,o({ref:t},d))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<a;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},68226:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var i=n(87462),r=(n(67294),n(3905));const a={},o="TransitionInterpolator",l={unversionedId:"api-reference/core/transition-interpolator",id:"api-reference/core/transition-interpolator",title:"TransitionInterpolator",description:"Base interpolator class that provides common functionality required to interpolate between two View States. This class is not intended to be used directly. See View State Transitions for backgrounds.",source:"@site/../docs/api-reference/core/transition-interpolator.md",sourceDirName:"api-reference/core",slug:"/api-reference/core/transition-interpolator",permalink:"/docs/api-reference/core/transition-interpolator",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/api-reference/core/transition-interpolator.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"FlyToInterpolator",permalink:"/docs/api-reference/core/fly-to-interpolator"},next:{title:"LightingEffect",permalink:"/docs/api-reference/core/lighting-effect"}},s={},p=[{value:"Example",id:"example",level:2},{value:"Constructor",id:"constructor",level:2},{value:"Interface",id:"interface",level:2},{value:"<code>getDuration</code>",id:"getduration",level:4},{value:"<code>initializeProps</code>",id:"initializeprops",level:4},{value:"<code>interpolateProps</code>",id:"interpolateprops",level:4},{value:"Source",id:"source",level:2}],d={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"transitioninterpolator"},"TransitionInterpolator"),(0,r.kt)("p",null,"Base interpolator class that provides common functionality required to interpolate between two ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/views"},"View States"),". This class is not intended to be used directly. See ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/animations-and-transitions#camera-transitions"},"View State Transitions")," for backgrounds."),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {TransitionInterpolator} from '@deck.gl/core';\n\n// Interpolate between two values\nfunction lerp(from, to, t) {\n  return from + (to - from) * t;\n}\n\n/*\n * This interpolator moves the camera along a straight path on the Web Mercator map\n * Horizontally it moves in the direction that is shorter\n */\nclass SphericalLinearInterpolator extends TransitionInterpolator {\n  constructor({speed = 100} = {}) {\n    super(['longitude', 'latitude']);\n\n    // degrees per second\n    this.speed = speed;\n  }\n\n  getDuration(startViewState, endViewState) {\n    const deltaLat = Math.abs(startViewState.latitude - endViewState.latitude);\n    let deltaLng = Math.abs(startViewState.longitude - endViewState.longitude);\n    // Transition to the destination longitude along the smaller half of the circle\n    if (deltaLng > 180) deltaLng = 360 - deltaLng;\n    return Math.max(deltaLng, deltaLat) / this.speed * 1000;\n  }\n\n  initializeProps(startViewState, endViewState) {\n    const fromLng = startViewState.longitude;\n    let toLng = endViewState.longitude;\n    // Transition to the destination longitude along the smaller half of the latitude circle\n    if (toLng > fromLng + 180) toLng -= 360;\n    if (toLng < fromLng - 180) toLng += 360;\n\n    return {\n      start: {longitude: fromLng, latitude: startViewState.latitude},\n      end: {longitude: toLng, latitude: endViewState.latitude}\n    };\n  }\n\n  interpolateProps(start, end, t) {\n    const latitude = lerp(start.latitude, end.latitude, t);\n    let longitude = lerp(start.longitude, end.longitude, t);\n    // Put longitude back into the [-180, 180] range\n    if (longitude > 180) longitude -= 360;\n    if (longitude < -180) longitude += 360;\n\n    return {longitude, latitude};\n  }\n}\n")),(0,r.kt)("h2",{id:"constructor"},"Constructor"),(0,r.kt)("p",null,"Parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"opts")," (object | string[])",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If an object is provided, it should contain the following fields:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"compare")," (string[]) - prop names used in equality check. Transition is triggered if some of the ",(0,r.kt)("inlineCode",{parentName:"li"},"compare")," props are not deeply equal."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extract")," (string[]) - prop names needed for interpolation. See ",(0,r.kt)("inlineCode",{parentName:"li"},"initializeProps")," below."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"required")," (string[]) - prop names that must be supplied. See ",(0,r.kt)("inlineCode",{parentName:"li"},"initializeProps")," below."))),(0,r.kt)("li",{parentName:"ul"},"If an array is provided, the same list of prop names is used for all three above.")))),(0,r.kt)("h2",{id:"interface"},"Interface"),(0,r.kt)("h4",{id:"getduration"},(0,r.kt)("inlineCode",{parentName:"h4"},"getDuration")),(0,r.kt)("p",null,"This method can be optionally implemented by a subclass. If implemented, the user can specify ",(0,r.kt)("inlineCode",{parentName:"p"},"transitionDuration: 'auto'")," when using this interpolator, and the duration will be dynamically computed using this method."),(0,r.kt)("p",null,"Receives the following arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"startViewState")," (object) - the view state that is transitioning from."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endViewState")," (object) - the view state that is transitioning to.")),(0,r.kt)("p",null,"Returns:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A number in milliseconds representing the target duration of the transition. If ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),", transition is disabled.")),(0,r.kt)("h4",{id:"initializeprops"},(0,r.kt)("inlineCode",{parentName:"h4"},"initializeProps")),(0,r.kt)("p",null,"Called when a transition is about to be triggered. This can be used to preprocess values for use in every transition frame by ",(0,r.kt)("inlineCode",{parentName:"p"},"interpolateProps"),"."),(0,r.kt)("p",null,"Receives the following arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"startViewState")," (object) - the view state that is transitioning from."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endViewState")," (object) - the view state that is transitioning to.")),(0,r.kt)("p",null,"Returns:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An object in the shape of ",(0,r.kt)("inlineCode",{parentName:"li"},"{start, end}")," that will be passed to ",(0,r.kt)("inlineCode",{parentName:"li"},"interpolateProps"),".")),(0,r.kt)("p",null,"The default implementation takes all values of the ",(0,r.kt)("inlineCode",{parentName:"p"},"extract")," prop names from the start and end view states."),(0,r.kt)("p",null,"If some ",(0,r.kt)("inlineCode",{parentName:"p"},"required")," prop names are missing from the view state, an error will be thrown."),(0,r.kt)("h4",{id:"interpolateprops"},(0,r.kt)("inlineCode",{parentName:"h4"},"interpolateProps")),(0,r.kt)("p",null,"This method must be implemented by a subclasses."),(0,r.kt)("p",null,"Receives the following arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"start")," (object) - descriptor of the state that is transitioning from, generated by ",(0,r.kt)("inlineCode",{parentName:"li"},"initializeProps"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"end")," (object) - descriptor of the state that is transitioning to, generated by ",(0,r.kt)("inlineCode",{parentName:"li"},"initializeProps"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"t")," (number) - current time into the transition, between ",(0,r.kt)("inlineCode",{parentName:"li"},"0")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"1"),".")),(0,r.kt)("p",null,"Returns:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An object that contains the interpolated view state fields.")),(0,r.kt)("h2",{id:"source"},"Source"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/visgl/deck.gl/tree/9.0-release/modules/core/src/transitions/transition-interpolator.ts"},"modules/core/src/transitions/transition-interpolator.ts")))}c.isMDXComponent=!0}}]);