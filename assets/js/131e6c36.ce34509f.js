"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[8407],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},w=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),w=a,u=d["".concat(s,".").concat(w)]||d[w]||m[w]||r;return n?i.createElement(u,o(o({ref:t},c),{},{components:n})):i.createElement(u,o({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=w;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:a,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}w.displayName="MDXCreateElement"},97787:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var i=n(83117),a=(n(67294),n(3905));const r={},o="Views and Projections",l={unversionedId:"developer-guide/views",id:"developer-guide/views",title:"Views and Projections",description:"The same data can be drawn differently to screen based on what projection method is used. deck.gl's view system defines how one or more cameras should be set up to look at your data objects. The default view used in deck.gl is the MapView, which implements the Web Mercator projection.",source:"@site/../docs/developer-guide/views.md",sourceDirName:"developer-guide",slug:"/developer-guide/views",permalink:"/docs/developer-guide/views",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/views.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Coordinate Systems",permalink:"/docs/developer-guide/coordinate-systems"},next:{title:"View State Transitions",permalink:"/docs/developer-guide/view-state-transitions"}},s={},p=[{value:"View, View State and Viewport",id:"view-view-state-and-viewport",level:2},{value:"View",id:"view",level:3},{value:"View State",id:"view-state",level:3},{value:"Viewport",id:"viewport",level:3},{value:"Types of Views",id:"types-of-views",level:2},{value:"Examples",id:"examples",level:2},{value:"Using a View Class",id:"using-a-view-class",level:3},{value:"Using a View Class with View State",id:"using-a-view-class-with-view-state",level:3},{value:"Using Multiple Views",id:"using-multiple-views",level:3},{value:"Using Multiple Views with View States",id:"using-multiple-views-with-view-states",level:3},{value:"Rendering Layers in Multiple Views",id:"rendering-layers-in-multiple-views",level:3},{value:"Picking in Multiple Views",id:"picking-in-multiple-views",level:3},{value:"Auto-Positioning React/HTML Components Behind Views",id:"auto-positioning-reacthtml-components-behind-views",level:3},{value:"Performance Notes",id:"performance-notes",level:2}],c={toc:p},d="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"views-and-projections"},"Views and Projections"),(0,a.kt)("p",null,"The same data can be drawn differently to screen based on what projection method is used. deck.gl's view system defines how one or more cameras should be set up to look at your data objects. The default view used in deck.gl is the ",(0,a.kt)("a",{parentName:"p",href:"/docs/api-reference/core/map-view"},"MapView"),", which implements the ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Web_Mercator_projection"},"Web Mercator projection"),".\nThe view system is designed to be flexible and composable and can handle many different configurations such as side-by-side views, overlapping views etc. If you plan to work with non-geospatial data, or show more than a single standard viewport, it may be worth spending some time to get familiar with the ",(0,a.kt)("inlineCode",{parentName:"p"},"View")," API."),(0,a.kt)("p",null,"View classes enable applications to specify one or more rectangular viewports and control what should be rendered inside each view."),(0,a.kt)("table",{style:{border:0},align:"top"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("td",{style:{verticalAlign:"top"}},(0,a.kt)("img",{height:"200",src:"https://raw.github.com/visgl/deck.gl-data/master/images/docs/minimap.gif"}),(0,a.kt)("p",null,(0,a.kt)("i",null,'A "minimap" app, implemented as two overlapping, partially synchronized MapViews'))),(0,a.kt)("td",{style:{verticalAlign:"top"}},(0,a.kt)("img",{height:"200",src:"https://raw.github.com/visgl/deck.gl-data/master/images/docs/first-person-view.gif"}),(0,a.kt)("p",null,(0,a.kt)("i",null,"A vehicle log rendered from the driver's perspective, implemented with FirstPersonView"))),(0,a.kt)("td",{style:{verticalAlign:"top"}},(0,a.kt)("img",{height:"200",src:"https://raw.github.com/visgl/deck.gl-data/master/images/docs/orthographic-view.gif"}),(0,a.kt)("p",null,(0,a.kt)("i",null,"A graph, implemented with OrthographicView")))))),(0,a.kt)("h2",{id:"view-view-state-and-viewport"},"View, View State and Viewport"),(0,a.kt)("h3",{id:"view"},"View"),(0,a.kt)("p",null,"A ",(0,a.kt)("a",{parentName:"p",href:"/docs/api-reference/core/view"},"View")," instance defines the following information:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A unique ",(0,a.kt)("inlineCode",{parentName:"li"},"id"),"."),(0,a.kt)("li",{parentName:"ul"},"The position and extent of the view on the canvas: ",(0,a.kt)("inlineCode",{parentName:"li"},"x"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"y"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"width"),", and ",(0,a.kt)("inlineCode",{parentName:"li"},"height"),"."),(0,a.kt)("li",{parentName:"ul"},"Certain camera parameters specifying how your data should be projected into this view, e.g. field of view, near/far planes, perspective vs. orthographic, etc."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"/docs/api-reference/core/controller"},"controller")," to be used for this view. A controller listens to pointer events and touch gestures, and translates user input into changes in the view state. If enabled, the camera becomes interactive.")),(0,a.kt)("p",null,"To summarize, a ",(0,a.kt)("inlineCode",{parentName:"p"},"View"),' instance wraps the "hard configuration" of a camera. Once defined, it does not need to change frequently.'),(0,a.kt)("p",null,"deck.gl allows multiple views to be specified, allowing the application to divide the screen into multiple similar or different views. These views can be synchronized or separately controlled by the user or the application."),(0,a.kt)("h3",{id:"view-state"},"View State"),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"View")," instance must be used in combination with a ",(0,a.kt)("inlineCode",{parentName:"p"},"viewState")," object. As the name suggests, the object describes the state of a ",(0,a.kt)("inlineCode",{parentName:"p"},"View")," instance. The view state object defines the temporary properties of a view at runtime, like the camera position, orientation, zoom, etc. If the view is interactive, every time the user pans/rotates/zooms, the view state will be updated to reflect the change."),(0,a.kt)("p",null,"To summarize, a ",(0,a.kt)("inlineCode",{parentName:"p"},"viewState"),' object describes the "real-time properties" of a camera. It may be updated continuously during interaction and/or transition.'),(0,a.kt)("h3",{id:"viewport"},"Viewport"),(0,a.kt)("p",null,"A ",(0,a.kt)("a",{parentName:"p",href:"/docs/api-reference/core/viewport"},"Viewport"),' instance is the camera itself. It is "resolved" from a ',(0,a.kt)("inlineCode",{parentName:"p"},"View")," instance and its ",(0,a.kt)("inlineCode",{parentName:"p"},"viewState"),". It handles the mathematical operations such as coordinate projection/unprojection, the calculation of projection matrices, and other GLSL uniforms needed by the shaders."),(0,a.kt)("p",null,"Whenever ",(0,a.kt)("inlineCode",{parentName:"p"},"viewState")," updates, the view creates a new viewport under the hood. Typically, the deck.gl user does not need to work with viewports directly. In certain use cases, the JavaScript functions offered by a ",(0,a.kt)("inlineCode",{parentName:"p"},"Viewport")," instance can be handy for projecting and unprojecting coordinates."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"If you are using the Deck canvas as an ",(0,a.kt)("a",{parentName:"p",href:"../get-started/using-with-map"},"overlay on a base map rendered by another library"),", you may need to update the viewport using the API provided by that library rather than by deck.gl.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck, MapView} from '@deck.gl/core';\n\nconst deck = new Deck({\n  ...\n  views: [new MapView()],\n  onClick: ({layer, object}) => {\n    if (layer) {\n      // The viewport is a WebMercatorViewport instance\n      const {viewport} = layer.context;\n      const {longitude, latitude, zoom} = viewport.fitBounds([\n        [object.minLng, object.minLat],\n        [object.maxLng, object.maxLat]\n      ]);\n      // Zoom to the object\n      deck.setProps({\n        viewState: {longitude, latitude, zoom}\n      });\n    }\n  }\n});\n")),(0,a.kt)("h2",{id:"types-of-views"},"Types of Views"),(0,a.kt)("p",null,"deck.gl offers a set of ",(0,a.kt)("inlineCode",{parentName:"p"},"View")," classes that package the camera and controller logic that you need to visualize and interact with your data. You may choose one or multiple ",(0,a.kt)("inlineCode",{parentName:"p"},"View")," classes based on the type of data (e.g. geospatial, 2D chart) and the desired perspective (top down, first-person, etc)."),(0,a.kt)("p",null,"Note that the set of view state parameters that will be used varies between Views. Consult each view class' documentation for a full list of parameters supported."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"View Class"),(0,a.kt)("th",{parentName:"tr",align:null},"Use Case"),(0,a.kt)("th",{parentName:"tr",align:null},"Status"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"/docs/api-reference/core/view"},(0,a.kt)("inlineCode",{parentName:"a"},"View"))),(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null},"The base view has to be supplied with raw view and projection matrices. It is typically only instantiated directly if the application needs to work with views that have been supplied from external sources, such as the ",(0,a.kt)("a",{parentName:"td",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API"},"WebVR API"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"/docs/api-reference/core/map-view"},(0,a.kt)("inlineCode",{parentName:"a"},"MapView"))," (default)"),(0,a.kt)("td",{parentName:"tr",align:null},"geospatial"),(0,a.kt)("td",{parentName:"tr",align:null},"full support"),(0,a.kt)("td",{parentName:"tr",align:null},"This view renders data using the ",(0,a.kt)("a",{parentName:"td",href:"https://en.wikipedia.org/wiki/Web_Mercator_projection"},"Web Mercator projection")," and is designed to match an external base map library such as Mapbox or Google Maps.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"/docs/api-reference/core/globe-view"},(0,a.kt)("inlineCode",{parentName:"a"},"GlobeView"))),(0,a.kt)("td",{parentName:"tr",align:null},"geospatial"),(0,a.kt)("td",{parentName:"tr",align:null},"experimental"),(0,a.kt)("td",{parentName:"tr",align:null},"This view renders data as a 3D globe.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"/docs/api-reference/core/first-person-view"},(0,a.kt)("inlineCode",{parentName:"a"},"FirstPersonView"))),(0,a.kt)("td",{parentName:"tr",align:null},"geospatial"),(0,a.kt)("td",{parentName:"tr",align:null},"full support"),(0,a.kt)("td",{parentName:"tr",align:null},"The camera is positioned in a provided geolocation and looks in a provided direction, similar to that of a ",(0,a.kt)("a",{parentName:"td",href:"https://en.wikipedia.org/wiki/First-person_(gaming)"},"first-person game"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"/docs/api-reference/core/orthographic-view"},(0,a.kt)("inlineCode",{parentName:"a"},"OrthographicView"))),(0,a.kt)("td",{parentName:"tr",align:null},"info-vis (2D)"),(0,a.kt)("td",{parentName:"tr",align:null},"full support"),(0,a.kt)("td",{parentName:"tr",align:null},"The camera looks at a target point from top-down. Does not rotate.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"/docs/api-reference/core/orbit-view"},(0,a.kt)("inlineCode",{parentName:"a"},"OrbitView"))),(0,a.kt)("td",{parentName:"tr",align:null},"info-vis (3D)"),(0,a.kt)("td",{parentName:"tr",align:null},"full support"),(0,a.kt)("td",{parentName:"tr",align:null},"The camera looks at a target point from a provided direction. Rotates around the target.")))),(0,a.kt)("h2",{id:"examples"},"Examples"),(0,a.kt)("h3",{id:"using-a-view-class"},"Using a View Class"),(0,a.kt)("p",null,"If the ",(0,a.kt)("inlineCode",{parentName:"p"},"views")," prop of ",(0,a.kt)("inlineCode",{parentName:"p"},"Deck")," is not specified, deck.gl will automatically create a ",(0,a.kt)("inlineCode",{parentName:"p"},"MapView")," that fills the whole canvas, so basic geospatial applications often do not have to specify any ",(0,a.kt)("inlineCode",{parentName:"p"},"View"),"s."),(0,a.kt)("p",null,"If using non-geospatial data, you will need to manually create a view that is appropriate for info-vis, e.g.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck, OrthographicView} from '@deck.gl/core';\n\nconst deck = new Deck({\n  ...\n  views: new OrthographicView()\n});\n")),(0,a.kt)("h3",{id:"using-a-view-class-with-view-state"},"Using a View Class with View State"),(0,a.kt)("p",null,"If ",(0,a.kt)("inlineCode",{parentName:"p"},"initialViewState"),' is provided, deck.gl automatically tracks the view states of interactive views (used as a "stateful" component):'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck, MapView} from '@deck.gl/core';\n\nconst deck = new Deck({\n  ...\n  views: new MapView(),\n  controller: true, // applies to the first view\n  initialViewState: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 10,\n    pitch: 0,\n    bearing: 0\n  }\n});\n")),(0,a.kt)("p",null,"If you need to manage and manipulate the view state outside of deck.gl, you may do so by providing an external ",(0,a.kt)("inlineCode",{parentName:"p"},"viewState"),' prop (used as a "stateless" component). In this case, you also need to listen to the ',(0,a.kt)("inlineCode",{parentName:"p"},"onViewStateChange")," callback and update the ",(0,a.kt)("inlineCode",{parentName:"p"},"viewState")," object yourself:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import React, {useState, useCallback} from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {OrthographicView} from '@deck.gl/core';\n\nfunction App() {\n  const [viewState, setViewState] = useState({\n    target: [0, 0, 0],\n    rotationX: 0,\n    rotationOrbit: 0,\n    zoom: 1\n  })\n\n  const onViewStateChange = useCallback(({viewState}) => {\n    // Manipulate view state\n    viewState.target[0] = Math.min(viewState.target[0], 10);\n    // Save the view state and trigger rerender\n    setViewState(viewState);\n  }, []);\n\n  return <DeckGL\n    views={new OrthographicView()}\n    controller={true}\n    viewState={viewState}\n    onViewStateChange={onViewStateChange}\n  />;\n}\n")),(0,a.kt)("h3",{id:"using-multiple-views"},"Using Multiple Views"),(0,a.kt)("p",null,"deck.gl also supports multiple views by taking a ",(0,a.kt)("inlineCode",{parentName:"p"},"views")," prop that is a list of ",(0,a.kt)("inlineCode",{parentName:"p"},"View")," instances."),(0,a.kt)("p",null,"Views allow the application to specify the position and extent of the viewport (i.e. the target rendering area on the screen) with ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," (left), ",(0,a.kt)("inlineCode",{parentName:"p"},"y")," (top), ",(0,a.kt)("inlineCode",{parentName:"p"},"width")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"height"),". These can be specified in either numbers or CSS-like percentage strings (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"width: '50%'"),"), which is evaluated at runtime when the canvas resizes."),(0,a.kt)("p",null,'Common examples in 3D applications that render a 3D scene multiple times with different "cameras":'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"To show views from multiple viewpoints (cameras), e.g. in a split screen setup."),(0,a.kt)("li",{parentName:"ul"},'To show a detail view (e.g, first person), and an overlaid, smaller "map" view (e.g. third person or top down, zoomed out to show where the primary viewpoint is).'),(0,a.kt)("li",{parentName:"ul"},"To support stereoscopic rendering (e.g. VR), where left and right views are needed, providing the necessary parallax between left and right eye."),(0,a.kt)("li",{parentName:"ul"},"For rendering into offscreen framebuffers, which can then be used for e.g. advanced visual effects, screen shot solutions, overlays onto DOM elements outside of the primary deck.gl canvas (e.g. a video).")),(0,a.kt)("p",null,"Example of using with the ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API"},"WebVR API"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck, View} from '@deck.gl/core';\n\nconst deck = new Deck({\n  ...\n  views: [\n    new View({\n      id: 'left-eye',\n      width: '50%',\n      viewMatrix: leftViewMatrix,\n      projectionMatrix: leftProjectionMatrix\n    }),\n    new View({\n      id: 'right-eye',\n      x: '50%',\n      width: '50%',\n      viewMatrix: rightViewMatrix,\n      projectionMatrix: rightProjectionMatrix\n    })\n  ]\n});\n")),(0,a.kt)("p",null,'Views can also overlap, (e.g. having a small "mini" map in the bottom middle of the screen overlaid over the main view)'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck, FirstPersonView, MapView} from '@deck.gl/core';\n\nconst deck = new Deck({\n  ...\n  views: [\n    new FirstPersonView({\n      id: 'first-person',\n      controller: true\n    }),\n    new MapView({\n      id: 'mini-map',\n      x: '80%',\n      y: '80%',\n      height: '15%',\n      width: '15%',\n      clear: true,\n      controller: true\n    })\n  ]\n});\n")),(0,a.kt)("h3",{id:"using-multiple-views-with-view-states"},"Using Multiple Views with View States"),(0,a.kt)("p",null,"When using multiple views, each ",(0,a.kt)("inlineCode",{parentName:"p"},"View")," can either have its own independent view state, or share the same view state as other views. To define the view state of a specific view, add a key to the ",(0,a.kt)("inlineCode",{parentName:"p"},"viewState")," object that matches its view id:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import React, {useState, useCallback} from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {FirstPersonView, MapView} from '@deck.gl/core';\n\nfunction App() {\n  const [viewStates, setViewStates] = useState({\n    longitude: -122.4,\n    latitude: 37.8,\n    pitch: 0,\n    bearing: 0,\n    zoom: 10\n  });\n\n  const onViewStateChange = useCallback(({viewId, viewState}) => {\n    if (viewId === 'main') {\n      setViewStates(currentViewStates => ({\n        main: viewState,\n        minimap: {\n          ...currentViewStates.minimap,\n          longitude: viewState.longitude,\n          latitude: viewState.latitude\n        }\n      }));\n    } else {\n      setViewStates(currentViewStates => ({\n        main: {\n          ...currentViewStates.main,\n          longitude: viewState.longitude,\n          latitude: viewState.latitude\n        },\n        minimap: viewState\n      }));\n    }\n  }, []);\n\n  render() {\n    return <DeckGL\n      views={views: [\n        new MapView({id: 'main', controller: true}),\n        new MapView({id: 'minimap', x: 10, y: 10, width: '20%', height: '20%', controller: true})\n      ]}\n      viewState={viewStates}\n      onViewStateChange={onViewStateChange}\n    />;\n  }\n}\n")),(0,a.kt)("h3",{id:"rendering-layers-in-multiple-views"},"Rendering Layers in Multiple Views"),(0,a.kt)("p",null,"By default, all visible layers are rendered into all the views. This may not be the case if certain layers are designed to go into one particular view."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Deck")," class' ",(0,a.kt)("inlineCode",{parentName:"p"},"layerFilter")," prop has access to information of the view via the ",(0,a.kt)("inlineCode",{parentName:"p"},"viewport")," argument. It can be used to determine which layers to draw in which view: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck, FirstPersonView, MapView} from '@deck.gl/core';\nimport {MeshLayer, GeoJsonLayer} from '@deck.gl/layers';\n\nfunction layerFilter({layer, viewport}) {\n  if (viewport.id === 'first-person' && layer.id === 'car') {\n    // Do not draw the car layer in the first person view\n    return false;\n  }\n  return true;\n}\n\nconst deck = new Deck({\n  ...\n  layerFilter,\n  layers: [\n    new MeshLayer({id: 'car', ...}),\n    new GeoJsonLayer({id: 'streets', ...})\n  ],\n  views: [\n    new FirstPersonView({id: 'first-person', ...}),\n    new MapView({id: 'mini-map', ...})\n  ]\n});\n")),(0,a.kt)("p",null,"Some layers, including ",(0,a.kt)("inlineCode",{parentName:"p"},"TileLayer"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"HeatmapLayer")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ScreenGridLayer"),", perform expensive operations (data fetching/aggregation) on viewport change. Therefore, it is generally NOT recommended to render them into multiple views. If you do need to show e.g. tiled base map in multiple views, create one layer instance for each view and limit their rendering with ",(0,a.kt)("inlineCode",{parentName:"p"},"layerFilter"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const deck = new Deck({\n  ...\n  views: [\n    new MapView({id: 'main', ...}),\n    new MapView({id: 'mini-map', ...})\n  ],\n  layers: [\n    new TileLayer({id: 'tiles-for-main', ...}),\n    new TileLayer({id: 'tiles-for-mini-map', ...})\n  ],\n  layerFilter: ({layer, viewport} => {\n    return layer.id === `tiles-for-${viewport.id}`;\n  });\n});\n")),(0,a.kt)("p",null,"Starting with v8.5, ",(0,a.kt)("inlineCode",{parentName:"p"},"Tile3DLayer")," supports rendering in multiple views with a single tile cache."),(0,a.kt)("h3",{id:"picking-in-multiple-views"},"Picking in Multiple Views"),(0,a.kt)("p",null,"deck.gl's built-in picking support extends naturally to multiple viewports. The picking process renders all viewports."),(0,a.kt)("p",null,"Note that the ",(0,a.kt)("inlineCode",{parentName:"p"},"pickInfo")," object does not contain a viewport reference, so you will not be able to tell which viewport was used to pick an object."),(0,a.kt)("p",null,"Similar to the above example, you may control which layer is pickable in which view by supplying a ",(0,a.kt)("inlineCode",{parentName:"p"},"layerFilter"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function layerFilter({layer, viewport, isPicking}) {\n  if (isPicking && viewport.id === 'first-person' && layer.id === 'car') {\n    // Do not pick the car layer in the first person view\n    return false;\n  }\n  return true;\n}\n")),(0,a.kt)("h3",{id:"auto-positioning-reacthtml-components-behind-views"},"Auto-Positioning React/HTML Components Behind Views"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"This feature is currently only implemented in the React version of deck.gl.")),(0,a.kt)("p",null,"One of the core features of deck.gl is enabling perfectly synchronized visualization overlays on top other React components and DOM elements."),(0,a.kt)("p",null,"When using a single ",(0,a.kt)("inlineCode",{parentName:"p"},"View"),", the child components of ",(0,a.kt)("inlineCode",{parentName:"p"},"DeckGL")," are positioned to fill the entire canvas. In this example the ",(0,a.kt)("inlineCode",{parentName:"p"},"StaticMap")," component gets automatically positioned under the default ",(0,a.kt)("inlineCode",{parentName:"p"},"MapView"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {StaticMap} from 'react-map-gl';\nimport DeckGL from '@deck.gl/react';\n\nfunction App() {\n  return (\n    <DeckGL initialViewState={...} layers={...} controller={true}>\n      <StaticMap />\n    </DeckGL>\n  );\n}\n")),(0,a.kt)("p",null,"When using multiple views, you can wrap component(s) in a ",(0,a.kt)("inlineCode",{parentName:"p"},"View"),' tag to align its position and size with a specific view. In the following example, the mapbox component is positioned and stretched to fit the "minimap" view:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {StaticMap} from 'react-map-gl';\nimport {View, FirstPersonView, MapView} from '@deck.gl/core';\nimport DeckGL from '@deck.gl/react';\n\nconst views = [\n  new FirstPersonView({id: 'first-person', ...}),\n  new MapView({id: 'minimap', ...})\n];\n\nfunction App() {\n  return (\n    <DeckGL views={views} initialViewState={...} layers={...} >\n      <View id=\"minimap\">\n        <StaticMap />\n      </View>\n    </DeckGL>\n  );\n}\n")),(0,a.kt)("h2",{id:"performance-notes"},"Performance Notes"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"views")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"viewState")," props are deep compared to determine if anything changed, so there is little performance cost if new view instances are constructed each render."),(0,a.kt)("p",null,"When ",(0,a.kt)("inlineCode",{parentName:"p"},"views"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"viewState")," do change, new viewports are constructed. At this point, layers can get a chance to update their state, with the ",(0,a.kt)("inlineCode",{parentName:"p"},"changeFlags")," argument containing ",(0,a.kt)("inlineCode",{parentName:"p"},"viewportChanged: true"),". During interaction and transition, this may happen many times a second, raising performance concern if many layers need to recompute their states. By default, most layers ignore viewport changes, so the ",(0,a.kt)("inlineCode",{parentName:"p"},"updateState")," lifecycle method do not get called if nothing else change."),(0,a.kt)("p",null,"However, some layers do need to update state when viewport changes (e.g. the ",(0,a.kt)("a",{parentName:"p",href:"/docs/api-reference/geo-layers/tile-layer"},"TileLayer"),"). To make sure ",(0,a.kt)("inlineCode",{parentName:"p"},"updateState")," is called, the layer needs to override ",(0,a.kt)("inlineCode",{parentName:"p"},"shouldUpdateState"),"."),(0,a.kt)("p",null,"Read more in ",(0,a.kt)("a",{parentName:"p",href:"/docs/developer-guide/custom-layers/layer-lifecycle"},"Layer Lifecycles"),"."))}m.isMDXComponent=!0}}]);