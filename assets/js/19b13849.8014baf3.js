"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7270],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(n),g=r,h=p["".concat(s,".").concat(g)]||p[g]||u[g]||l;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=g;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),r=n(86010);const l={tabItem:"tabItem_Ymn6"};function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(l.tabItem,i),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>w});var a=n(83117),r=n(67294),l=n(86010),i=n(12466),o=n(16550),s=n(91980),c=n(67392),d=n(50012);function p(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function u(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=null!=t?t:p(n);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,n])}function g(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),l=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=n?n:null}({queryString:t,groupId:n});return[(0,s._X)(l),(0,r.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(a.location.search);t.set(l,e),a.replace({...a.location,search:t.toString()})}),[l,a])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,l=u(e),[i,o]=(0,r.useState)((()=>function(e){var t;let{defaultValue:n,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!g({value:n,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+n+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return n}const r=null!=(t=a.find((e=>e.default)))?t:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:l}))),[s,c]=h({queryString:n,groupId:a}),[p,m]=function(e){let{groupId:t}=e;const n=function(e){return e?"docusaurus.tab."+e:null}(t),[a,l]=(0,d.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&l.set(e)}),[n,l])]}({groupId:a}),y=(()=>{const e=null!=s?s:p;return g({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{y&&o(y)}),[y]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!g({value:e,tabValues:l}))throw new Error("Can't select invalid tab value="+e);o(e),c(e),m(e)}),[c,m,l]),tabValues:l}}var y=n(72389);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function k(e){let{className:t,block:n,selectedValue:o,selectValue:s,tabValues:c}=e;const d=[],{blockElementScrollPositionUntilNextRender:p}=(0,i.o5)(),u=e=>{const t=e.currentTarget,n=d.indexOf(t),a=c[n].value;a!==o&&(p(t),s(a))},g=e=>{var t;let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{var a;const t=d.indexOf(e.currentTarget)+1;n=null!=(a=d[t])?a:d[0];break}case"ArrowLeft":{var r;const t=d.indexOf(e.currentTarget)-1;n=null!=(r=d[t])?r:d[d.length-1];break}}null==(t=n)||t.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":n},t)},c.map((e=>{let{value:t,label:n,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>d.push(e),onKeyDown:g,onClick:u},i,{className:(0,l.Z)("tabs__item",f.tabItem,null==i?void 0:i.className,{"tabs__item--active":o===t})}),null!=n?n:t)})))}function b(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function v(e){const t=m(e);return r.createElement("div",{className:(0,l.Z)("tabs-container",f.tabList)},r.createElement(k,(0,a.Z)({},e,t)),r.createElement(b,(0,a.Z)({},e,t)))}function w(e){const t=(0,y.Z)();return r.createElement(v,(0,a.Z)({key:String(t)},e))}},33782:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>p});var a=n(83117),r=(n(67294),n(3905)),l=n(74866),i=n(85162);const o={},s="Using Layers",c={unversionedId:"developer-guide/using-layers",id:"developer-guide/using-layers",title:"Using Layers",description:'The "Layer" is a core concept of deck.gl. A deck.gl layer is a packaged visualization type that takes a collection of datums, associate each with positions, colors, shapes, extrusions, etc., and renders them on a map.',source:"@site/../docs/developer-guide/using-layers.md",sourceDirName:"developer-guide",slug:"/developer-guide/using-layers",permalink:"/docs/developer-guide/using-layers",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/using-layers.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Learning Resources",permalink:"/docs/get-started/learning-resources"},next:{title:"Interactivity",permalink:"/docs/developer-guide/interactivity"}},d={},p=[{value:"Constructing a Layer Instance",id:"constructing-a-layer-instance",level:2},{value:"Layer ID",id:"layer-id",level:3},{value:"Data",id:"data",level:3},{value:"Accessors",id:"accessors",level:3},{value:"Other Layer Props",id:"other-layer-props",level:3},{value:"Rendering Layers",id:"rendering-layers",level:2},{value:"Updating Layers",id:"updating-layers",level:3},{value:"FAQ",id:"faq",level:2},{value:"Should I be Creating New Layers on Every Render?",id:"should-i-be-creating-new-layers-on-every-render",level:3},{value:"The Reactive Programming Paradigm",id:"the-reactive-programming-paradigm",level:4},{value:"Creating Layer Instances Is Cheap",id:"creating-layer-instances-is-cheap",level:4},{value:"Why Doesn&#39;t My Layer Update with New Props?",id:"why-doesnt-my-layer-update-with-new-props",level:3}],u={toc:p},g="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(g,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"using-layers"},"Using Layers"),(0,r.kt)("p",null,'The "Layer" is a core concept of deck.gl. A deck.gl layer is a packaged visualization type that takes a collection of datums, associate each with positions, colors, shapes, extrusions, etc., and renders them on a map.'),(0,r.kt)("p",null,"deck.gl provides an extensive ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/layers/"},"layer catalog")," and is designed to compose many layers together to form complex visuals."),(0,r.kt)("h2",{id:"constructing-a-layer-instance"},"Constructing a Layer Instance"),(0,r.kt)("p",null,'A layer is instantiated with one or more "properties" object:'),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {ScatterplotLayer} from '@deck.gl/layers';\n\nconst layer = new ScatterplotLayer({\n  id: 'bart-stations',\n  data: [\n    {name: 'Colma', passengers: 4214, coordinates: [-122.466233, 37.684638]},\n    {name: 'Civic Center', passengers: 24798, coordinates: [-122.413756,37.779528]},\n    // ...\n  ],\n  stroked: false,\n  filled: true,\n  getPosition: d => d.coordinates,\n  getRadius: d => Math.sqrt(d.passengers),\n  getFillColor: [255, 200, 0]\n});\n"))),(0,r.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import {ScatterplotLayer} from '@deck.gl/layers';\n\ntype BartStation = {\n  name: string;\n  passengers: number;\n  coordinates: [longitude: number, latitude: number];\n};\n\nconst layer = new ScatterplotLayer<BartStation>({\n  id: 'bart-stations',\n  data: [\n    {name: 'Colma', passengers: 4214, coordinates: [-122.466233, 37.684638]},\n    {name: 'Civic Center', passengers: 24798, coordinates: [-122.413756,37.779528]},\n    // ...\n  ],\n  stroked: false,\n  filled: true,\n  getPosition: (d: BartStation) => d.coordinates,\n  getRadius: (d: BartStation) => Math.sqrt(d.passengers),\n  getFillColor: [255, 200, 0]\n});\n")))),(0,r.kt)("p",null,'The properties, or "props" for short, are settings that the layer uses to build the visualization. Users of a layer typically pass the following types of props to the layer\'s constructor:'),(0,r.kt)("h3",{id:"layer-id"},"Layer ID"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," prop is the unique identifier of this layer among all layers. Constructing a new layer instance in its own does not have any performance impact, as deck.gl only does the expensive calculations when a layer is ",(0,r.kt)("strong",{parentName:"p"},"created")," (an id appearing for the first time) or ",(0,r.kt)("strong",{parentName:"p"},"updated")," (different props are passed in for the same id). Read more about this in ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/custom-layers/layer-lifecycle"},"layer lifecycle"),"."),(0,r.kt)("p",null,"It is recommend that this prop is set explicitly to avoid collision."),(0,r.kt)("h3",{id:"data"},"Data"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," prop specifies data source of this layer's visualization. The value is expected to be a collection (typically a JavaScript array) of data objects with similar structure, such as rows in a table. deck.gl layers are able to handle millions of data objects very efficiently."),(0,r.kt)("p",null,"The value of this prop can be ",(0,r.kt)("inlineCode",{parentName:"p"},"Array"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Map"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Set"),", any object that contains a ",(0,r.kt)("inlineCode",{parentName:"p"},"length")," field, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise")," that resolves to any of the above, or an URL to load such an object from. See ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer#data"},"data prop")," documentation for details."),(0,r.kt)("h3",{id:"accessors"},"Accessors"),(0,r.kt)("p",null,"An accessor is a prop that maps an object in ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," to its visual configuration, e.g. the radius of a circle, the color of a line, etc. All accessor prop names start with ",(0,r.kt)("inlineCode",{parentName:"p"},"get"),"."),(0,r.kt)("p",null,"If an accessor prop is set to a function, when the layer is about to be drawn on screen for the first time, the layer will traverse the ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," stream and call the accessor function with each element."),(0,r.kt)("p",null,"The accessor function receives two arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"object")," - the current element in the data stream. If ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," is an array or an iterable, the element of the current iteration is used. If ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," is a non-iterable object, this argument is always ",(0,r.kt)("inlineCode",{parentName:"li"},"null"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"objectInfo")," (object) - contextual information of the current element. Contains the following fields:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"index")," (number) - the index of the current iteration"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"data")," - the value of the ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," prop"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"target")," (number[]) - a pre-allocated array. The accessor function can optionally fill data into this array and return it, instead of creating a new array for every object. In some browsers this improves performance significantly by reducing garbage collection.")))),(0,r.kt)("p",null,"The accessor function is typically expected to return either a number or an array."),(0,r.kt)("p",null,"If an accessor prop is set to a constant value, the value is applied to all objects in the data stream."),(0,r.kt)("h3",{id:"other-layer-props"},"Other Layer Props"),(0,r.kt)("p",null,"The rest of the props are typically numeric or boolean values that apply to the whole layer. These include props that define the render options (opacity, extrusion of the PolygonLayer, font family of the TextLayer, etc.), ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/coordinate-systems"},"coordinate system"),", and ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/interactivity"},"interactivity"),"."),(0,r.kt)("h2",{id:"rendering-layers"},"Rendering Layers"),(0,r.kt)("p",null,"deck.gl allows you to render multiple layers using the same or different data sets. You simply provide an array of layer instances to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/deck"},"Deck")," class (pure JS) or ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/react/deckgl"},"DeckGL")," component (React) and they will be rendered in order."),(0,r.kt)("p",null,"This allows you to compose visualizations using several primitive layers."),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck} from '@deck.gl/core';\nimport {ScatterplotLayer, TextLayer} from '@deck.gl/layers';\n\n// a JSON file of flight locations in the shape of [{lon: -122.39, lat: 37.62, alt: 1800, callSign: 'SKW 3342'}, ...]\nconst flights = '/path/to/data.json';\n\nconst layers = [\n  new ScatterplotLayer({\n    id: 'circles',\n    data: flights,\n    getPosition: d => [d.lon, d.lat, d.alt],\n    getFillColor: [255, 255, 255],\n    getRadius: 3,\n    radiusUnits: 'pixels'\n  }),\n  new TextLayer({\n    id: 'labels',\n    data: flights,\n    getText: d => d.callSign,\n    getPosition: d => [d.lon, d.lat, d.alt],\n    getSize: 12\n  })\n];\n\nconst deckInstance = new Deck({\n  initialViewState: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 8\n  },\n  controller: true\n  layers\n});\n"))),(0,r.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import {Deck, LayersList} from '@deck.gl/core';\nimport {ScatterplotLayer, TextLayer} from '@deck.gl/layers';\n\ntype Flight = {\n  callSign: string;\n  lon: number;\n  lat: number;\n  alt: number;\n};\n\n// a JSON file of flight locations in the shape of Flight[]\nconst flights = '/path/to/data.json';\n\nconst layers: LayersList = [\n  new ScatterplotLayer<Flight>({\n    id: 'circles',\n    data: flights,\n    getPosition:  (d: Flight) => [d.lng, d.lat, d.alt],\n    getFillColor: [255, 255, 255],\n    getRadius: 3,\n    radiusUnits: 'pixels'\n  }),\n  new TextLayer<Flight>({\n    id: 'labels',\n    data: flights,\n    getText: (d: Flight) => d.callSign,\n    getPosition: (d: Flight) => [d.lng, d.lat, d.alt],\n    getSize: 12\n  })\n];\n\nconst deckInstance = new Deck({\n  initialViewState: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 8\n  },\n  controller: true\n  layers\n});\n"))),(0,r.kt)(i.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import React from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {LayersList} from '@deck.gl/core';\nimport {ScatterplotLayer, TextLayer} from '@deck.gl/layers';\n\ntype Flight = {\n  callSign: string;\n  lon: number;\n  lat: number;\n  alt: number;\n};\n\nfunction App() {\n  // a JSON file of flight locations in the shape of Flight[]\n  const flights = '/path/to/data.json';\n\n  const layers: LayersList = [\n    new ScatterplotLayer<Flight>({\n      id: 'circles',\n      data: flights,\n      getPosition:  (d: Flight) => [d.lng, d.lat, d.alt],\n      getFillColor: [255, 255, 255],\n      getRadius: 3,\n      radiusUnits: 'pixels'\n    }),\n    new TextLayer<Flight>({\n      id: 'labels',\n      data: flights,\n      getText: (d: Flight) => d.callSign,\n      getPosition: (d: Flight) => [d.lng, d.lat, d.alt],\n      getSize: 12\n    })\n  ];\n\n  return <DeckGL\n    initialViewState={{\n      longitude: -122.4,\n      latitude: 37.8,\n      zoom: 8\n    }}\n    controller\n    layers={layers} />\n}\n")))),(0,r.kt)("h3",{id:"updating-layers"},"Updating Layers"),(0,r.kt)("p",null,"Once a layer is instantiated, its props cannot be modified. Some prop (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"data"),") may be a deeply nested object, but even if you change one of its nested elements, the change is not monitored. To update an existing layer, you create a new layer instance of the same id, and provide this new instance to the ",(0,r.kt)("inlineCode",{parentName:"p"},"layers")," prop of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Deck")," class or ",(0,r.kt)("inlineCode",{parentName:"p"},"DeckGL")," component."),(0,r.kt)("p",null,"The following example updates its layers' ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," regularly by polling a server:"),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck} from '@deck.gl/core';\nimport {ScatterplotLayer, TextLayer} from '@deck.gl/layers';\n\nconst deckInstance = new Deck({\n  initialViewState: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 8\n  },\n  controller: true\n});\n\nupdate();\n\nasync function update() {\n  // `queryServer` is a hypothetical function that contacts a server to fetch a list of flight locations\n  // in the shape of [{lon: -122.39, lat: 37.62, alt: 1800, callSign: 'SKW 3342'}, ...]\n  const flights = await queryServer({time: Date.now()});\n\n  deckInstance.setProps({\n    layers: [\n      new ScatterplotLayer({\n        id: 'circles',\n        data: flights,\n        getPosition: d => [d.lng, d.lat, d.alt],\n        getFillColor: [255, 0, 0],\n        getRadius: 3,\n        radiusUnits: 'pixels'\n      }),\n      new TextLayer({\n        id: 'labels',\n        data: flights,\n        getText: d => d.callSign,\n        getPosition: d => [d.lon, d.lat, d.alt],\n        getSize: 12\n      })\n    ]\n  });\n\n  // refresh again after 60 seconds\n  setTimeout(update, 60000);\n}\n"))),(0,r.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import {Deck, LayersList} from '@deck.gl/core';\nimport {ScatterplotLayer, TextLayer} from '@deck.gl/layers';\n\ntype Flight = {\n  callSign: string;\n  lon: number;\n  lat: number;\n  alt: number;\n};\n\nconst deckInstance = new Deck({\n  initialViewState: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 8\n  },\n  controller: true\n});\n\nupdate();\n\nasync function update() {\n  // `queryServer` is a hypothetical function that contacts a server to fetch a list of flight locations\n  const flights: Flight[] = await queryServer({time: Date.now()});\n\n  deckInstance.setProps({\n    layers: [\n      new ScatterplotLayer<Flight>({\n        id: 'circles',\n        data: flights,\n        getPosition: (d: Flight) => [d.lng, d.lat, d.alt],\n        getFillColor: [255, 0, 0],\n        getRadius: 3,\n        radiusUnits: 'pixels'\n      }),\n      new TextLayer<Flight>({\n        id: 'labels',\n        data: flights,\n        getText: (d: Flight) => d.callSign,\n        getPosition: (d: Flight) => [d.lng, d.lat, d.alt],\n        getSize: 12\n      })\n    ]\n  });\n\n  // refresh again after 60 seconds\n  setTimeout(update, 60000);\n}\n"))),(0,r.kt)(i.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import React, {useState, useEffect} from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {LayersList} from '@deck.gl/core';\nimport {ScatterplotLayer} from '@deck.gl/layers';\n\ntype Flight = {\n  callSign: string;\n  lon: number;\n  lat: number;\n  alt: number;\n};\n\nfunction App() {\n  const [flights, setFlights] = useState<Flight[]>([]);\n\n  useEffect(() => {\n    const update = async () => {\n      // `queryServer` is a hypothetical function that contacts a server to fetch a list of flight locations\n      const newFlights: Flight[] = await queryServer({time: Date.now()});\n      setFlight(newFlights);\n      // refresh again after 60 seconds\n      setTimeout(update, 60000);\n    };\n\n    update();\n  }, []);\n\n  const layers: LayersList = [\n    new ScatterplotLayer<Flight>({\n      id: 'circles',\n      data: flights,\n      getPosition:  (d: Flight) => [d.lng, d.lat, d.alt],\n      getFillColor: [255, 0, 0],\n      getRadius: 3,\n      radiusUnits: 'pixels'\n    }),\n    new TextLayer<Flight>({\n      id: 'labels',\n      data: flights,\n      getText: (d: Flight) => d.callSign,\n      getPosition: (d: Flight) => [d.lng, d.lat, d.alt],\n      getSize: 12\n    })\n  ];\n\n  return <DeckGL\n    initialViewState={{\n      longitude: -122.4,\n      latitude: 37.8,\n      zoom: 8\n    }}\n    controller\n    layers={layers} />\n}\n")))),(0,r.kt)("h2",{id:"faq"},"FAQ"),(0,r.kt)("h3",{id:"should-i-be-creating-new-layers-on-every-render"},"Should I be Creating New Layers on Every Render?"),(0,r.kt)("h4",{id:"the-reactive-programming-paradigm"},"The Reactive Programming Paradigm"),(0,r.kt)("p",null,"deck.gl's architecture is based on the reactive programming paradigm:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'In a reactive application, a complete UI description is "re-rendered" every time something in the application state changes (in the case of a deck.gl application, a new list of layers is created whenever something changes).'),(0,r.kt)("li",{parentName:"ul"},'The UI framework (in this case, deck.gl) makes the choices about what to update, by comparing (or "diffing") the newly rendered UI description with the last rendered UI description.'),(0,r.kt)("li",{parentName:"ul"},"The framework then makes the minimal necessary changes to account for the differences, and then redraws."),(0,r.kt)("li",{parentName:"ul"},'The required changes are made to "GPU state" in case of deck.gl, and to the Browser\'s DOM (HTML element tree) in case of React.')),(0,r.kt)("h4",{id:"creating-layer-instances-is-cheap"},"Creating Layer Instances Is Cheap"),(0,r.kt)("p",null,"The deck.gl model means that applications are expected to create a new set of layers every time application state changes, which can seem surprisingly inefficient to someone who hasn't done reactive programming before. The trick is that layers are just descriptor objects that are very cheap to instantiate, and internally, the new layers are efficiently matched against existing layers so that no updates are performed unless actually needed."),(0,r.kt)("p",null,'So, even though the application creates new "layers", those layers are only "descriptors" containing props that specify what needs to be rendered and how. All calculated state (WebGL2/WebGPU "programs", "vertex attributes" etc) are stored in a state object and this state object is moved forward to the newly matched layer on every render cycle.  The new layer ends up with the state of the old layer (and the props of the new layer), while the old layer is simply discarded for garbage collection.'),(0,r.kt)("p",null,"The application does not have to be aware about this, as long as it keeps rendering new layers with the same ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," they will be matched and the existing state of that layer will be updated accordingly."),(0,r.kt)("p",null,"The constant creation and disposal of layer instances may seem wasteful, however the creation and recycling of JavaScript objects is quite efficient in modern JavaScript environments, and this is very similar to how React works where every render cycle generates a new tree of ReactElement instances, so the model is proven."),(0,r.kt)("p",null,"For more details on layer creation, update and destruction, read about ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/custom-layers/layer-lifecycle"},"Layer Lifecycle"),"."),(0,r.kt)("h3",{id:"why-doesnt-my-layer-update-with-new-props"},"Why Doesn't My Layer Update with New Props?"),(0,r.kt)("p",null,'Since the reactive programming frameworks conceptually render the entire UI every render cycle, and achieves efficiency by comparing and "diffing" changes between render cycles, it is important that comparisons are fast. Because of this, deck.gl uses shallow equality as the default comparison method for most props.'),(0,r.kt)("p",null,"An exception is the accessors. Changing the value of an accessor (i.e. supplying a different function to the accessor prop) will not in itself trigger an attribute update. This is because the function identity is a poor indicator of whether an update is needed, and the convenience of using local functions as prop values."),(0,r.kt)("p",null,"Consider the code below, ",(0,r.kt)("inlineCode",{parentName:"p"},"getRadius")," is shallowly changed every time ",(0,r.kt)("inlineCode",{parentName:"p"},"render()")," is called, even if its execution result would not change:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function render() {\n  const layer = new ScatterplotLayer({\n    ...\n    getColor: x => x.color, // this creates a new function every render\n    getRadius: this._getRadius.bind(this) // bind generates a new function every render\n  });\n  deck.setProps([layer]);\n}\n")),(0,r.kt)("p",null,"In another example, ",(0,r.kt)("inlineCode",{parentName:"p"},"getColor")," is shallowly changed, so would its execution result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const DATA = [...];\n\nfunction setPillColor(index, color) {\n  DATA[index].pill = color;\n  render();\n}\n\nfunction render() {\n  const layer = new ScatterplotLayer({\n    data: DATA,\n    ...\n    getColor: object => object.pill === 'red' ? [255, 0, 0] : [0, 0, 255], // Does not trigger an attribute update!\n  });\n  deck.setProps([layer]);\n}\n")),(0,r.kt)("p",null,"There is no way for deck.gl to know what the programmer intended just by looking at or comparing the functions that are supplied to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Layer"),"s accessor props. Because recalculating attributes can be potentially expensive, deck.gl by default ignores shallow changes in accessor props. This is designed to provide the best performance to the most common use cases without compromising convenience."),(0,r.kt)("p",null,"Instead, the ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer#updatetriggers"},(0,r.kt)("inlineCode",{parentName:"a"},"updateTriggers"))," property gives you fine grained control, enabling you to tell deck.gl exactly which attributes need to change, and when."),(0,r.kt)("p",null,"Read more about this behavior in ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer-guide/performance"},"Performance Optimization"),"."))}h.isMDXComponent=!0}}]);