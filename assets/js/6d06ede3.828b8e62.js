"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[268],{93865:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"api-reference/aggregation-layers/overview","title":"Aggregation Layers","description":"Layers that aggregate the input data and visualize them in alternative representations, such as grid and hexagon binning, contour, and heatmap.","source":"@site/../docs/api-reference/aggregation-layers/overview.md","sourceDirName":"api-reference/aggregation-layers","slug":"/api-reference/aggregation-layers/overview","permalink":"/docs/api-reference/aggregation-layers/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/deck.gl/tree/master/website/../docs/api-reference/aggregation-layers/overview.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"WMSLayer (Experimental)","permalink":"/docs/api-reference/geo-layers/wms-layer"},"next":{"title":"AggregationLayer (Experimental)","permalink":"/docs/api-reference/aggregation-layers/aggregation-layer"}}');var i=n(74848),t=n(28453);const s={},o="Aggregation Layers",l={},c=[{value:"CPU vs GPU Aggregation",id:"cpu-vs-gpu-aggregation",level:2},{value:"Considerations",id:"considerations",level:3},{value:"Performance Metrics",id:"performance-metrics",level:3},{value:"Advanced usage",id:"advanced-usage",level:2}];function d(e){const r={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"aggregation-layers",children:"Aggregation Layers"})}),"\n",(0,i.jsx)(r.p,{children:"Layers that aggregate the input data and visualize them in alternative representations, such as grid and hexagon binning, contour, and heatmap."}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"/docs/api-reference/aggregation-layers/contour-layer",children:"ContourLayer"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"/docs/api-reference/aggregation-layers/grid-layer",children:"GridLayer"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"/docs/api-reference/aggregation-layers/heatmap-layer",children:"HeatmapLayer"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"/docs/api-reference/aggregation-layers/hexagon-layer",children:"HexagonLayer"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"/docs/api-reference/aggregation-layers/screen-grid-layer",children:"ScreenGridLayer"})}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"cpu-vs-gpu-aggregation",children:"CPU vs GPU Aggregation"}),"\n",(0,i.jsx)(r.p,{children:"In the right context, enabling GPU aggregation can significantly speed up your application. This section offers in-depth insights into the performance and limitations that should be factored into leveraging this functionality."}),"\n",(0,i.jsx)(r.h3,{id:"considerations",children:"Considerations"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Compaibility"}),": The client-side features required by GPU aggregation has been universally supported by evergreen browsers for a while and represent 95%+ of the global market. However, users have reported that driver discrepancies in certain devices/chips can affect the outcome."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Data size"}),": The time it takes for CPU to perform aggregation is generally linear to the size of the input data. GPU aggegation requires some up-front overhead in setting up shaders and uploading buffers, but the margin to process more data is very small. When working with large datasets (>100K) GPU is much faster than CPU. With small datasets, GPU could be slower than CPU."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Data distribution"}),": The memory needed by CPU aggregation is proportional to the number of cells that contain at least one data point. The memory needed by GPU aggregation is proportional to all possible cells, including the empty ones in between. GPU performs better with densely concentrated data points than sparse and sprawling data points."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Filtering"}),": GPU-based extentions such as ",(0,i.jsx)(r.a,{href:"/docs/api-reference/extensions/data-filter-extension",children:"DataFilterExtension"}),", ",(0,i.jsx)(r.a,{href:"/docs/api-reference/extensions/mask-extension",children:"MaskExtension"})," only work with GPU aggregation."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Precision"}),": GPU shaders only support 32-bit floating numbers. While this layer implement mitigations to compensate for precision loss, it is expected if GPU aggregation does not produce identical results as the CPU. There are tests in place to ensure acceptable consistency between CPU and GPU aggregation."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Access to binned points"}),": GPU aggregation does not expose which data points are contained in a specific cell. If this is a requirement, for example, displaying a list of locations upon selecting a cell, then you need to either use CPU aggregation, or manually filter data on the fly."]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,i.jsx)(r.p,{children:"The following table compares the performance between CPU and GPU aggregations using random data:"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"#objects"}),(0,i.jsx)(r.th,{children:"CPU #iterations/sec"}),(0,i.jsx)(r.th,{children:"GPU #iterations/sec"}),(0,i.jsx)(r.th,{children:"Notes"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"25K"}),(0,i.jsx)(r.td,{children:"535"}),(0,i.jsx)(r.td,{children:"359"}),(0,i.jsxs)(r.td,{children:["GPU is ",(0,i.jsx)("b",{style:{color:"red"},children:"33%"})," slower"]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"100K"}),(0,i.jsx)(r.td,{children:"119"}),(0,i.jsx)(r.td,{children:"437"}),(0,i.jsxs)(r.td,{children:["GPU is ",(0,i.jsx)("b",{style:{color:"green"},children:"267%"})," faster"]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"1M"}),(0,i.jsx)(r.td,{children:"12.7"}),(0,i.jsx)(r.td,{children:"158"}),(0,i.jsxs)(r.td,{children:["GPU is ",(0,i.jsx)("b",{style:{color:"green"},children:"1144%"})," faster"]})]})]})]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.em,{children:"Numbers are collected on a 2016 15-inch Macbook Pro (CPU: 2.8 GHz Intel Core i7 and GPU: AMD Radeon R9 M370X 2 GB)"})}),"\n",(0,i.jsx)(r.h2,{id:"advanced-usage",children:"Advanced usage"}),"\n",(0,i.jsx)(r.p,{children:"It is possible to implement a custom aggregation layer, or even perform aggregation without layers, using the utilities from this module."}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/api-reference/aggregation-layers/aggregation-layer",children:"AggregationLayer"})," class"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/api-reference/aggregation-layers/aggregator",children:"Aggregator"})," interface, implemented by","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"/docs/api-reference/aggregation-layers/cpu-aggregator",children:"CPUAggregator"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"/docs/api-reference/aggregation-layers/webgl-aggregator",children:"WebGLAggregator"})}),"\n"]}),"\n"]}),"\n"]})]})}function g(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>o});var a=n(96540);const i={},t=a.createContext(i);function s(e){const r=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(t.Provider,{value:r},e.children)}}}]);