"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5242],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return t?a.createElement(h,i(i({ref:n},p),{},{components:t})):a.createElement(h,i({ref:n},p))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},84255:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(83117),r=(t(67294),t(3905));const o={},i="Performance Optimization",l={unversionedId:"developer-guide/performance",id:"developer-guide/performance",title:"Performance Optimization",description:"General Performance Expectations",source:"@site/../docs/developer-guide/performance.md",sourceDirName:"developer-guide",slug:"/developer-guide/performance",permalink:"/docs/developer-guide/performance",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/performance.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Using Lighting",permalink:"/docs/developer-guide/using-lighting"},next:{title:"About 64-bit Layers",permalink:"/docs/developer-guide/fp64"}},s={},c=[{value:"General Performance Expectations",id:"general-performance-expectations",level:2},{value:"Layer Update Performance",id:"layer-update-performance",level:2},{value:"Minimize data changes",id:"minimize-data-changes",level:3},{value:"Avoid unnecessary shallow change in data prop",id:"avoid-unnecessary-shallow-change-in-data-prop",level:4},{value:"Use updateTriggers",id:"use-updatetriggers",level:4},{value:"Handle incremental data loading",id:"handle-incremental-data-loading",level:4},{value:"Favor layer visibility over addition and removal",id:"favor-layer-visibility-over-addition-and-removal",level:4},{value:"Optimize Accessors",id:"optimize-accessors",level:3},{value:"Favor constants over callback functions",id:"favor-constants-over-callback-functions",level:4},{value:"Use trivial functions as accessors",id:"use-trivial-functions-as-accessors",level:4},{value:"Use Binary Data",id:"use-binary-data",level:3},{value:"Supply binary blobs to the data prop",id:"supply-binary-blobs-to-the-data-prop",level:4},{value:"Supply attributes directly",id:"supply-attributes-directly",level:4},{value:"Layer Rendering Performance",id:"layer-rendering-performance",level:2},{value:"Layer Picking Performance",id:"layer-picking-performance",level:2},{value:"Number of Layers",id:"number-of-layers",level:2},{value:"Common Issues",id:"common-issues",level:2}],p={toc:c},d="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"performance-optimization"},"Performance Optimization"),(0,r.kt)("h2",{id:"general-performance-expectations"},"General Performance Expectations"),(0,r.kt)("p",null,"There are mainly two aspects that developers usually consider regarding the\nperformance of any computer programs: the time and the memory consumption, both of which obviously depends on the specs of the hardware deck.gl is ultimately running on."),(0,r.kt)("p",null,"On 2015 MacBook Pros with dual graphics cards, most basic layers\n(like ",(0,r.kt)("inlineCode",{parentName:"p"},"ScatterplotLayer"),") renders fluidly at 60 FPS during pan and zoom\noperations up to about 1M (one million) data items, with framerates dropping into low double digits (10-20FPS) when the data sets approach 10M items."),(0,r.kt)("p",null,"Even if interactivity is not an issue, browser limitations on how big chunks of contiguous memory can be allocated (e.g. Chrome caps individual allocations at 1GB) will cause most layers to crash during GPU buffer generation somewhere between 10M and 100M items. You would need to break up your data into chunks and use multiple deck.gl layers to get past this limit."),(0,r.kt)("p",null,"Modern phones (recent iPhones and higher-end Android phones) are surprisingly capable in terms of rendering performance, but are considerably more sensitive to memory pressure than laptops, resulting in browser restarts or page reloads. They also tend to load data significantly slower than desktop computers, so some tuning is usually needed to ensure a good overall user experience on mobile."),(0,r.kt)("h2",{id:"layer-update-performance"},"Layer Update Performance"),(0,r.kt)("p",null,"Layer update happens when the layer is first created, or when some layer props change. During an update, deck.gl may load necessary resources (e.g. image textures), generate GPU buffers, and upload them to the GPU, all of which may take some time to complete, depending on the number of items in your ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," prop. Therefore, the key to performant deck.gl applications is to minimize layer updates wherever possible."),(0,r.kt)("h3",{id:"minimize-data-changes"},"Minimize data changes"),(0,r.kt)("p",null,"When the ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," prop changes, the layer will recalculate all of its GPU buffers. The time required for this is proportional to the number of items in your\n",(0,r.kt)("inlineCode",{parentName:"p"},"data")," prop.\nThis step is the most expensive operation that a layer does - also on CPU - potentially affecting the responsiveness of the application. It may take\nmultiple seconds for multi-million item layers, and if your ",(0,r.kt)("inlineCode",{parentName:"p"},"data"),' prop is updated\nfrequently (e.g. animations), "stutter" can be visible even for layers with just a few thousand items.'),(0,r.kt)("p",null,"Some good places to check for performance improvements are:"),(0,r.kt)("h4",{id:"avoid-unnecessary-shallow-change-in-data-prop"},"Avoid unnecessary shallow change in data prop"),(0,r.kt)("p",null,"  The layer does a shallow comparison between renders to determine if it needs to regenerate buffers. If\nnothing has changed, make sure you supply the ",(0,r.kt)("em",{parentName:"p"},"same")," data object every time you render. If the data object has to change shallowly for some reason, consider using the ",(0,r.kt)("inlineCode",{parentName:"p"},"dataComparator")," prop to supply a custom comparison logic."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Bad\nconst DATA = [...];\nconst filters = {minTime: -1, maxTime: Infinity};\n\nfunction setFilters(minTime, maxTime) {\n  filters.minTime = minTime;\n  filters.maxTime = maxTime;\n  render();\n}\n\nfunction render() {\n  const layer = new ScatterplotLayer({\n    // `filter` creates a new array every time `render` is called, even if the filters have not changed\n    data: DATA.filter(d => d.time >= filters.minTime && d.time <= filters.maxTime),\n    ...\n  });\n\n  deck.setProps({layers: [layer]});\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Good\nconst DATA = [...];\nlet filteredData = DATA;\nconst filters = {minTime: -1, maxTime: Infinity};\n\nfunction setFilters(minTime, maxTime) {\n  filters.minTime = minTime;\n  filters.maxTime = maxTime;\n  // filtering is performed only once when the filters change\n  filteredData = DATA.filter(d => d.time >= minTime && d.time <= maxTime);\n  render();\n}\n\nfunction render() {\n  const layer = new ScatterplotLayer({\n    data: filteredData,\n    ...\n  });\n\n  deck.setProps({layers: [layer]});\n}\n")),(0,r.kt)("h4",{id:"use-updatetriggers"},"Use updateTriggers"),(0,r.kt)("p",null,"  So ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," has indeed changed. Do we have an entirely new collection of objects? Or did just certain fields changed in each row? Remember that changing ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," will update ",(0,r.kt)("em",{parentName:"p"},"all")," buffers, so if, for example, object positions have not changed, it will be a waste of time to recalculate them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Bad\nconst DATA = [...];\nlet currentYear = null;\nlet currentData = DATA;\n\nfunction selectYear(year) {\n  currentYear = year;\n  currentData = DATA.map(d => ({\n    position: d.position,\n    population: d.populationsByYear[year]\n  }));\n  render();\n}\n\nfunction render() {\n  const layer = new ScatterplotLayer({\n    // `data` changes every time year changed, but positions don't need to update\n    data: currentData,\n    getPosition: d => d.position,\n    getRadius: d => Math.sqrt(d.population),\n    ...\n  });\n\n  deck.setProps({layers: [layer]});\n}\n")),(0,r.kt)("p",null,"  In this case, it is more efficient to use ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer#updatetriggers"},(0,r.kt)("inlineCode",{parentName:"a"},"updateTriggers"))," to invalidate only the selected attributes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Good\nconst DATA = [...];\nlet currentYear = null;\n\nfunction selectYear(year) {\n  currentYear = year;\n  render();\n}\n\nfunction render() {\n  const layer = new ScatterplotLayer({\n    // `data` never changes\n    data: DATA,\n    getPosition: d => d.position,\n    // radius depends on `currentYear`\n    getRadius: d => Math.sqrt(d.populationsByYear[currentYear]),\n    updateTriggers: {\n      // This tells deck.gl to recalculate radius when `currentYear` changes\n      getRadius: currentYear\n    },\n    ...\n  });\n\n  deck.setProps({layers: [layer]});\n}\n")),(0,r.kt)("h4",{id:"handle-incremental-data-loading"},"Handle incremental data loading"),(0,r.kt)("p",null,"  A common technique for handling big datasets on the client side is to load data in chunks. We want to update the visualization whenever a new chunk comes in. If we append the new chunk to an existing data array, deck.gl will recalculate the whole buffers, even for the previously loaded chunks where nothing have changed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Bad\nlet loadedData = [];\n\nfunction onNewDataArrive(chunk) {\n  loadedData = loadedData.concat(chunk);\n  render();\n}\n\nfunction render() {\n  const layer = new ScatterplotLayer({\n    // If we have 1 million rows loaded and 100,000 new rows arrive,\n    // we end up recalculating the buffers for all 1,100,000 rows\n    data: loadedData,\n    ...\n  });\n\n  deck.setProps({layers: [layer]});\n}\n")),(0,r.kt)("p",null,"  To avoid doing this, we instead generate one layer for each chunk:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Good\nconst dataChunks = [];\n\nfunction onNewDataArrive(chunk) {\n  dataChunks.push(chunk);\n  render();\n}\n\nfunction render() {\n  const layers = dataChunks.map((chunk, chunkIndex) => new ScatterplotLayer({\n    // Important: each layer must have a consistent & unique id\n    id: `chunk-${chunkIndex}`,\n    // If we have 10 100,000-row chunks already loaded and a new one arrive,\n    // the first 10 layers will see no prop change\n    // only the 11th layer's buffers need to be generated\n    data: chunk,\n    ...\n  }));\n\n  deck.setProps({layers});\n}\n")),(0,r.kt)("p",null,"  Starting v7.2.0, support for async iterables is added to efficiently update layers with incrementally loaded data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Create an async iterable\nasync function* getData() {\n  for (let i = 0; i < 10; i++) {\n    await const chunk = fetchChunk(...);\n    yield chunk;\n  }\n}\n\nfunction render() {\n  const layer = new ScatterplotLayer({\n    // When a new chunk arrives, deck.gl only updates the sub buffers for the new rows\n    data: getData(),\n    ...\n  });\n\n  deck.setProps({layers: [layer]});\n}\n")),(0,r.kt)("p",null,"  See ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer#basic-properties"},"Layer properties")," for details."),(0,r.kt)("h4",{id:"favor-layer-visibility-over-addition-and-removal"},"Favor layer visibility over addition and removal"),(0,r.kt)("p",null,"  Removing a layer will lose all of its internal states, including generated buffers. If the layer is added back later, all the GPU resources need to be regenerated again. In the use cases where layers need to be toggled frequently (e.g. via a control panel), there might be a significant perf penalty:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Bad\nconst DATA = [...];\nconst layerVisibility = {circles: true, labels: true}\n\nfunction toggleLayer(key) {\n  layerVisibility[key] = !layerVisibility[key];\n  render();\n}\n\nfunction render() {\n  const layers = [\n    // when visibility goes from on to off to on, this layer will be completely removed and then regenerated\n    layerVisibility.circles && new ScatterplotLayer({\n      data: DATA,\n      ...\n    }),\n    layerVisibility.labels && new TextLayer({\n      data: DATA,\n      ...\n    })\n  ];\n\n  deck.setProps({layers});\n}\n")),(0,r.kt)("p",null,"  The ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer#visible"},(0,r.kt)("inlineCode",{parentName:"a"},"visible"))," prop is a cheap way to temporarily disable a layer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Good\nconst DATA = [...];\nconst layerVisibility = {circles: true, labels: true}\n\nfunction toggleLayer(key) {\n  layerVisibility[key] = !layerVisibility[key];\n  render();\n}\n\nfunction render() {\n  const layers = [\n    // when visibility is off, this layer's internal states will be retained in memory, making turning it back on instant\n    new ScatterplotLayer({\n      data: DATA,\n      visible: layerVisibility.circles,\n      ...\n    }),\n    new TextLayer({\n      data: DATA,\n      visible: layerVisibility.labels,\n      ...\n    })\n  ];\n\n  deck.setProps({layers});\n}\n")),(0,r.kt)("h3",{id:"optimize-accessors"},"Optimize Accessors"),(0,r.kt)("p",null,"99% of the CPU time that deck.gl spends in updating buffers is calling the accessors you supply to the layer. Since they are called on every data object, any performance issue in the accessors is amplified by the size of your data."),(0,r.kt)("h4",{id:"favor-constants-over-callback-functions"},"Favor constants over callback functions"),(0,r.kt)("p",null,"  Most accessors accept constant values as well as functions. Constant props are extremely cheap to update in comparison. Use ",(0,r.kt)("inlineCode",{parentName:"p"},"ScatterplotLayer")," as an example, the following two prop settings yield exactly the same visual outcome:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"getFillColor: [255, 0, 0, 128]")," - deck.gl uploads 4 numbers to the GPU.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"getFillColor: d => [255, 0, 0, 128]")," - deck.gl first builds a typed array of ",(0,r.kt)("inlineCode",{parentName:"p"},"4 * data.length")," elements, call the accessor ",(0,r.kt)("inlineCode",{parentName:"p"},"data.length")," times to fill it, then upload it to the GPU."),(0,r.kt)("p",{parentName:"li"},"Aside from accessors, most layers also offer one or more ",(0,r.kt)("inlineCode",{parentName:"p"},"*Scale")," props that are uniform multipliers on top of the per-object value. Always consider using them before invoking the accessors:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Bad\nconst DATA = [...];\n\nfunction animate() {\n  render();\n  requestAnimationFrame(animate);\n}\n\nfunction render() {\n  const scale = Date.now() % 2000;\n\n  const layer = new ScatterplotLayer({\n    data: DATA,\n    getRadius: object => object.size * scale,\n    // deck.gl will call `getRadius` for ALL data objects every animation frame, which will likely choke the app\n    updateTriggers: {\n      getRadius: scale\n    },\n    ...\n  });\n\n  deck.setProps({layers: [layer]});\n}\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Good\nconst DATA = [...];\n\nfunction animate() {\n  render();\n  requestAnimationFrame(animate);\n}\n\nfunction render() {\n  const scale = Date.now() % 2000;\n\n  const layer = new ScatterplotLayer({\n    data: DATA,\n    getRadius: object => object.size,\n    // This has virtually no cost to update, easily getting 60fps animation\n    radiusScale: scale,\n    ...\n  });\n\n  deck.setProps({layers: [layer]});\n}\n")))),(0,r.kt)("h4",{id:"use-trivial-functions-as-accessors"},"Use trivial functions as accessors"),(0,r.kt)("p",null,"  Whenever possible, make the accessors trivial functions and utilize pre-defined and/or pre-computed data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Bad\nconst DATA = [...];\n\nfunction render() {\n  const layer = new ScatterplotLayer({\n    data: DATA,\n    getFillColor: object => {\n      // This line creates a new values array from each object\n      // which can incur significant cost in garbage collection\n      const maxPopulation = Math.max.apply(null, Object.values(object.populationsByYear));\n      // This switch case creates a new color array for each object\n      // which can also incur significant cost in garbage collection\n      if (maxPopulation > 1000000) {\n        return [255, 0, 0];\n      } else if (maxPopulation > 100000) {\n        return [0, 255, 0];\n      } else {\n        return [0, 0, 255];\n      }\n    },\n    getRadius: object => {\n      // This line duplicates what's done in `getFillColor` and doubles the cost\n      const maxPopulation = Math.max.apply(null, Object.values(object.populationsByYear));\n      return Math.sqrt(maxPopulation);\n    }\n    ...\n  });\n\n  deck.setProps({layers: [layer]});\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Good\nconst DATA = [...];\n\n// Use a for loop to avoid creating new objects\nfunction getMaxPopulation(populationsByYear) {\n  let maxPopulation = 0;\n  for (const year in populationsByYear) {\n    const population = populationsByYear[year];\n    if (population > maxPopulation) {\n      maxPopulation = population;\n    }\n  }\n  return maxPopulation;\n}\n\n// Calculate max population once and store it in the data\nDATA.forEach(d => {\n  d.maxPopulation = getMaxPopulation(d.populationsByYear);\n});\n\n// Use constant color values to avoid generating new arrays\nconst COLORS = {\n  ONE_MILLION: [255, 0, 0],\n  HUNDRED_THOUSAND: [0, 255, 0],\n  OTHER: [0, 0, 255]\n};\n\nfunction render() {\n  const layer = new ScatterplotLayer({\n    data: DATA,\n    getFillColor: object => {\n      if (object.maxPopulation > 1000000) {\n        return COLORS.ONE_MILLION;\n      } else if (maxPopulation > 100000) {\n        return COLORS.HUNDRED_THOUSAND;\n      } else {\n        return COLORS.OTHER;\n      }\n    },\n    getRadius: object => Math.sqrt(object.maxPopulation),\n    ...\n  });\n\n  deck.setProps({layers: [layer]});\n}\n")),(0,r.kt)("h3",{id:"use-binary-data"},"Use Binary Data"),(0,r.kt)("p",null,"When creating data-intensive applications, it is often desirable to offload client-side data processing to the server or web workers."),(0,r.kt)("p",null,"The server can send data to the client more efficiently using binary formats, e.g. ",(0,r.kt)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers"},"protobuf"),", ",(0,r.kt)("a",{parentName:"p",href:"https://arrow.apache.org/"},"Arrow")," or simply a custom binary blob."),(0,r.kt)("p",null,"Some deck.gl applications use web workers to load data and generate attributes to get the processing off the main thread. Modern worker implementations allow ownership of typed arrays to be ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage#Parameters"},"transferred directly")," between threads at virtually no cost, bypassing serialization and deserialization of JSON objects."),(0,r.kt)("h4",{id:"supply-binary-blobs-to-the-data-prop"},"Supply binary blobs to the data prop"),(0,r.kt)("p",null,"  Assume we have the data source encoded in the following format:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// lon1, lat1, radius1, red1, green1, blue1, lon2, lat2, ...\nconst binaryData = new Float32Array([-122.4, 37.78, 1000, 255, 200, 0, -122.41, 37.775, 500, 200, 0, 0, -122.39, 37.8, 500, 0, 40, 200]);\n")),(0,r.kt)("p",null,"  Upon receiving the typed arrays, the application can of course re-construct a classic JavaScript array:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Bad\nconst data = [];\nfor (let i = 0; i < binaryData.length; i += 6) {\n  data.push({\n    position: binaryData.subarray(i, i + 2),\n    radius: binaryData[i + 2],\n    color: binaryData.subarray(i + 3, i + 6)\n  });\n}\n\nnew ScatterplotLayer({\n  data,\n  getPosition: d => d.position,\n  getRadius: d => d.radius,\n  getFillColor: d => d.color\n});\n")),(0,r.kt)("p",null,"  However, in addition to requiring custom repacking code, this array will take valuable CPU time to create, and significantly more memory to store than its binary form. In performance-sensitive applications that constantly push a large volume of data (e.g. animations), this method will not be efficient enough."),(0,r.kt)("p",null,"  Alternatively, one may supply a non-iterable object (not Array or TypedArray) to the ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," object. In this case, it must contain a ",(0,r.kt)("inlineCode",{parentName:"p"},"length")," field that specifies the total number of objects. Since ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," is not iterable, each accessor will not receive a valid ",(0,r.kt)("inlineCode",{parentName:"p"},"object")," argument, and therefore responsible of interpreting the input data's buffer layout:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Good\n// Note: binaryData.length does not equal the number of items,\n// which is why we need to wrap it in an object that contains a custom `length` field\nconst DATA = {src: binaryData, length: binaryData.length / 6}\n\nnew ScatterplotLayer({\n  data: DATA,\n  getPosition: (object, {index, data}) => {\n    return data.src.subarray(index * 6, index * 6 + 2);\n  },\n  getRadius: (object, {index, data}) => {\n    return data.src[index * 6 + 2];\n  },\n  getFillColor: (object, {index, data, target}) => {\n    return data.src.subarray(index * 6 + 3, index * 6 + 6);\n  }\n})\n")),(0,r.kt)("p",null,"  Optionally, the accessors can utilize the pre-allocated ",(0,r.kt)("inlineCode",{parentName:"p"},"target")," array in the second argument to further avoid creating new objects:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Good\nconst DATA = {src: binaryData, length: binaryData.length / 6}\n\nnew ScatterplotLayer({\n  data: DATA,\n  getPosition: (object, {index, data, target}) => {\n    target[0] = data.src[index * 6];\n    target[1] = data.src[index * 6 + 1];\n    target[2] = 0;\n    return target;\n  },\n  getRadius: (object, {index, data}) => {\n    return data.src[index * 6 + 2];\n  },\n  getFillColor: (object, {index, data, target}) => {\n    target[0] = data.src[index * 6 + 3];\n    target[1] = data.src[index * 6 + 4];\n    target[2] = data.src[index * 6 + 5];\n    target[3] = 255;\n    return target;\n  }\n})\n")),(0,r.kt)("h4",{id:"supply-attributes-directly"},"Supply attributes directly"),(0,r.kt)("p",null,"  While the built-in attribute generation functionality is a major part of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Layer"),"s functionality, it can become a major bottleneck in performance since it is done on CPU in the main thread. If the application needs to push many data changes frequently, for example to render animations, data updates can block rendering and user interaction. In this case, the application should consider precalculated attributes on the back end or in web workers. "),(0,r.kt)("p",null,"  Deck.gl layers accepts external attributes as either a typed array or a luma.gl Buffers. Such attributes, if prepared carefully, can be directly utilized by the GPU, thus bypassing the CPU-bound attribute generation completely."),(0,r.kt)("p",null,"  This technique offers the maximum performance possible in terms of data throughput, and is commonly used in heavy-duty, performance-sensitive applications."),(0,r.kt)("p",null,"  To generate an attribute buffer for a layer, take the results returned from each object by the ",(0,r.kt)("inlineCode",{parentName:"p"},"get*")," accessors and flatten them into a typed array. For example, consider the following layers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Calculate attributes on the main thread\nnew PointCloudLayer({\n  // data format: [{position: [0, 0, 0], color: [255, 0, 0]}, ...]\n  data: POINT_CLOUD_DATA,\n  getPosition: d => d.position,\n  getColor: d => d.color,\n  getNormal: [0, 0, 1]\n})\n")),(0,r.kt)("p",null,"  Should we move the attribute generation to a web worker:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Worker\n// positions can be sent as either float32 or float64, depending on precision requirements\n// point[0].x, point[0].y, point[0].z, point[1].x, point[1].y, point[1].z, ...\nconst positions = new Float64Array(POINT_CLOUD_DATA.flatMap(d => d.position));\n// point[0].r, point[0].g, point[0].b, point[1].r, point[1].g, point[1].b, ...\nconst colors = new Uint8Array(POINT_CLOUD_DATA.flatMap(d => d.color));\n\n// send back to main thread\npostMessage({pointCount: POINT_CLOUD_DATA.length, positions, colors}, [positions.buffer, colors.buffer]);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Main thread\n// `data` is received from the worker\nnew PointCloudLayer({\n  data: {\n    // this is required so that the layer knows how many points to draw\n    length: data.pointCount,\n    attributes: {\n      getPosition: {value: data.positions, size: 3},\n      getColor: {value: data.colors, size: 3},\n    }\n  },\n  // constant accessor works without raw data\n  getNormal: [0, 0, 1]\n});\n")),(0,r.kt)("p",null,"  Note that instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"getPosition"),", we supply a ",(0,r.kt)("inlineCode",{parentName:"p"},"data.attributes.getPosition")," object. This object defines the buffer from which ",(0,r.kt)("inlineCode",{parentName:"p"},"PointCloudLayer")," should access its positions data. See the base ",(0,r.kt)("inlineCode",{parentName:"p"},"Layer")," class' ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer#basic-properties"},"data prop")," for details."),(0,r.kt)("p",null,"  It is also possible to use interleaved or custom layout external buffers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Worker\n// point[0].x, point[0].y, point[0].z, point[0].r, point[0].g, point[0].b, point[1].x, point[1].y, point[1].z, point[1].r, point[1].g, point[1].b, ...\nconst positionsAndColors = new Float32Array(POINT_CLOUD_DATA.flatMap(d => [\n  d.position[0],\n  d.position[1],\n  d.position[2],\n  // colors must be normalized if sent as floats\n  d.color[0] / 255,\n  d.color[1] / 255,\n  d.color[2] / 255\n]));\n\n// send back to main thread\npostMessage({pointCount: POINT_CLOUD_DATA.length, positionsAndColors}, [positionsAndColors.buffer]);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {Buffer} from '@luma.gl/core';\nconst buffer = new Buffer(gl, {data: data.positionsAndColors});\n\nnew PointCloudLayer({\n  data: {\n    length : data.pointCount,\n    attributes: {\n      getPosition: {buffer, size: 3, offset: 0, stride: 24},\n      getColor: {buffer, size: 3, offset: 12, stride: 24},\n    }\n  },\n  // constant accessor works without raw data\n  getNormal: [0, 0, 1]\n});\n")),(0,r.kt)("p",null,"  See full example in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/visgl/deck.gl/tree/9.0-release/examples/experimental/interleaved-buffer"},"examples/experimental/interleaved-buffer"),"."),(0,r.kt)("p",null,"  Note that external attributes only work with primitive layers, not composite layers, because composite layers often need to preprocess the data before passing it to the sub layers. Some layers that deal with variable-width data, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"PathLayer"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SolidPolygonLayer"),", require additional information passed along with ",(0,r.kt)("inlineCode",{parentName:"p"},"data.attributes"),". Consult each layer's documentation before use."),(0,r.kt)("h2",{id:"layer-rendering-performance"},"Layer Rendering Performance"),(0,r.kt)("p",null,"Layer rendering time (for large data sets) is essentially proportional to:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The number of vertex shader invocations,\nwhich corresponds to the number of items in the layer's ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," prop"),(0,r.kt)("li",{parentName:"ol"},"The number of fragment shader invocations, which corresponds to the total\nnumber of pixels drawn.")),(0,r.kt)("p",null,"Thus it is possible to render a scatterplot layer with 10M items with reasonable\nframe rates on recent GPUs, provided that the radius (number of pixels) of each\npoint is small."),(0,r.kt)("p",null,"It is good to be aware that excessive overdraw (drawing many objects/pixels on top of each other) can generate very high fragment counts and thus hurt performance. As an example, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Scatterplot")," radius of 5 pixels generates ~ 100 pixels per point. If you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"Scatterplot")," layer with 10 million points, this can result in up to 1 billion fragment shader invocations per frame. While dependent on zoom levels (clipping will improve performance to some extent) this many fragments will certainly strain even a recent MacBook Pro GPU."),(0,r.kt)("h2",{id:"layer-picking-performance"},"Layer Picking Performance"),(0,r.kt)("p",null,"deck.gl performs picking by drawing the layer into an off screen picking buffer. This essentially means that every layer that supports picking will be drawn off screen when panning and hovering. The picking is performed using the same GPU code that does the visual rendering, so the performance should be easy to predict."),(0,r.kt)("p",null,"Picking limitations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The picking system can only distinguish between 16M items per layer."),(0,r.kt)("li",{parentName:"ul"},"The picking system can only handle 256 layers with the pickable flag set to true.")),(0,r.kt)("h2",{id:"number-of-layers"},"Number of Layers"),(0,r.kt)("p",null,"The layer count of an advanced deck.gl application tends to gradually increase, especially when using composite layers. We have built and optimized a highly complex application using close to 100 deck.gl layers (this includes hierarchies of sublayers rendered by custom composite layers rendering other composite layers) without seeing any performance issues related to the number of layers. If you really need to, it is probably possible to go a little higher (a few hundred layers). Just keep in mind that deck.gl was not designed to be used with thousands of layers."),(0,r.kt)("h2",{id:"common-issues"},"Common Issues"),(0,r.kt)("p",null,"A couple of particular things to watch out for that tend to have a big impact on performance:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If not needed disable Retina/High DPI rendering. It generates 4x the number of pixels (fragments) and can have a big performance impact that depends on which computer or monitor is being used. This feature can be controlled using ",(0,r.kt)("inlineCode",{parentName:"li"},"useDevicePixels")," prop of ",(0,r.kt)("inlineCode",{parentName:"li"},"DeckGL")," component and it is on by default."),(0,r.kt)("li",{parentName:"ul"},"Avoid using luma.gl debug mode in production. It queries the GPU error status after each operation which has a big impact on performance.")),(0,r.kt)("p",null,"Smaller considerations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Enabling picking can have a small performance penalty so make sure the ",(0,r.kt)("inlineCode",{parentName:"li"},"pickable")," property is ",(0,r.kt)("inlineCode",{parentName:"li"},"false")," in layers that do not need picking (this is the default value).")))}u.isMDXComponent=!0}}]);