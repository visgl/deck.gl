/* eslint-disable max-statements */
import AttributeTransitionManager from '@deck.gl/core/lib/attribute/attribute-transition-manager';
import Attribute from '@deck.gl/core/lib/attribute/attribute';
import test from 'tape-promise/tape';
import type {Buffer} from '@luma.gl/core';
import {Timeline} from '@luma.gl/engine';
import {device} from '@deck.gl/test-utils';

const TEST_ATTRIBUTES = (function () {
  const indices = new Attribute(device, {
    id: 'indices',
    isIndexed: true,
    size: 1,
    update: () => {}
  });
  indices.setData({value: new Float32Array([0, 1, 2, 1, 3, 2])});

  const instancePositions = new Attribute(device, {
    id: 'instancePositions',
    size: 3,
    accessor: ['getPosition', 'getElevation'],
    update: () => {},
    transition: true
  });
  instancePositions.setData({value: new Float32Array(12)});

  const instanceSizes = new Attribute(device, {
    id: 'instanceSizes',
    size: 1,
    accessor: 'getSize',
    defaultValue: 1,
    transition: true
  });
  instanceSizes.setData({value: new Float32Array(4)});

  return {indices, instancePositions, instanceSizes};
})();

test('AttributeTransitionManager#constructor', t => {
  let manager = new AttributeTransitionManager(device, {id: 'attribute-transition'});
  t.ok(manager, 'AttributeTransitionManager is constructed');

  manager.finalize();
  t.pass('AttributeTransitionManager is finalized');

  t.throws(
    () => new AttributeTransitionManager(null, {id: 'attribute-transition'}),
    'AttributeTransitionManager is constructed without device'
  );

  t.end();
});

test('AttributeTransitionManager#update', async t => {
  const timeline = new Timeline();
  const manager = new AttributeTransitionManager(device, {id: 'attribute-transition', timeline});
  const attributes = Object.assign({}, TEST_ATTRIBUTES);

  attributes.indices.setNeedsRedraw('initial');
  attributes.instanceSizes.setNeedsRedraw('initial');
  attributes.instancePositions.setNeedsRedraw('initial');

  manager.update({attributes, transitions: {}, numInstances: 4});
  t.notOk(manager.hasAttribute('indices'), 'no transition for indices');
  t.notOk(manager.hasAttribute('instanceSizes'), 'no transition for instanceSizes');
  t.notOk(manager.hasAttribute('instancePositions'), 'no transition for instancePositions');

  manager.update({attributes, transitions: {getSize: 1000, getElevation: 1000}, numInstances: 0});
  t.notOk(manager.hasAttribute('indices'), 'no transition for indices');
  t.ok(manager.hasAttribute('instanceSizes'), 'added transition for instanceSizes');
  t.ok(manager.hasAttribute('instancePositions'), 'added transition for instancePositions');

  // byteLength = max(numInstances, 1) * 4. Later reallocation may skip the padding.
  const sizeTransition = manager.transitions.instanceSizes;
  t.is(sizeTransition.buffers[0].byteLength, 4, 'buffer has correct size');

  const positionTransform = manager.transitions.instancePositions.transform;
  t.ok(positionTransform, 'transform is constructed for instancePositions');
  delete attributes.instancePositions;

  manager.update({attributes, transitions: {getSize: 1000, getElevation: 1000}, numInstances: 4});
  t.ok(manager.hasAttribute('instanceSizes'), 'added transition for instanceSizes');
  t.notOk(manager.hasAttribute('instancePositions'), 'removed transition for instancePositions');
  t.notOk(positionTransform._handle, 'instancePositions transform is deleted');
  t.is(sizeTransition.buffers[0].byteLength, 4 * 4, 'buffer has correct size');

  attributes.instanceSizes.setData({value: new Float32Array(10).fill(1)});
  manager.update({attributes, transitions: {getSize: 1000}, numInstances: 10});
  manager.run();
  let transitioningBuffer = manager.getAttributes().instanceSizes.getBuffer();
  let actual = await readArray(transitioningBuffer);
  t.deepEquals(actual, [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], 'buffer is extended with new data');
  t.is(transitioningBuffer.byteLength, 10 * 4, 'buffer has correct size');

  attributes.instanceSizes.setData({constant: true, value: [2]});
  manager.update({attributes, transitions: {getSize: 1000}, numInstances: 12});
  manager.run();
  transitioningBuffer = manager.getAttributes().instanceSizes.getBuffer();
  actual = await readArray(transitioningBuffer);
  t.deepEquals(actual, [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2], 'buffer is extended with new data');
  t.is(transitioningBuffer.byteLength, 12 * 4, 'buffer has correct size');

  manager.finalize();
  t.notOk(transitioningBuffer._handle, 'transform buffer is deleted');
  t.notOk(manager.transitions.instanceSizes, 'transition is deleted');

  t.end();
});

test('AttributeTransitionManager#transition', async t => {
  const timeline = new Timeline();
  const manager = new AttributeTransitionManager(device, {id: 'attribute-transition', timeline});
  const attributes = Object.assign({}, TEST_ATTRIBUTES);

  let startCounter = 0;
  let interruptCounter = 0;
  let endCounter = 0;
  const transitions = {
    getSize: {
      duration: 1000,
      onStart: () => {
        startCounter++;
      },
      onInterrupt: () => {
        interruptCounter++;
      },
      onEnd: () => {
        endCounter++;
      }
    }
  };

  attributes.instanceSizes.setData({value: new Float32Array(4).fill(1)});
  attributes.instanceSizes.setNeedsRedraw('initial');

  timeline.setTime(0);
  manager.update({attributes, transitions, numInstances: 4});
  manager.run();
  t.is(startCounter, 1, 'transition starts');

  timeline.setTime(500);
  attributes.instanceSizes.needsRedraw({clearChangedFlags: true});
  manager.update({attributes, transitions, numInstances: 4});
  manager.run();
  t.is(startCounter, 1, 'no new transition is triggered');

  timeline.setTime(1000);
  attributes.instanceSizes.setData({value: new Float32Array(4).fill(3)});
  attributes.instanceSizes.setNeedsRedraw('update');
  manager.update({attributes, transitions, numInstances: 4});
  manager.run();
  t.is(interruptCounter, 1, 'transition is interrupted');
  t.is(startCounter, 2, 'new transition is triggered');

  timeline.setTime(1500);
  manager.run();
  let actual = await readArray(manager.getAttributes().instanceSizes.getBuffer());
  t.deepEquals(
    actual.slice(0, 4).map(Math.round), // TODO(v9): Confirm rounding 1.75 → 2 is valid?
    [2, 2, 2, 2],
    'attribute in transition'
  );

  attributes.instanceSizes.setData({value: new Float32Array(4).fill(4)});
  attributes.instanceSizes.setNeedsRedraw('update');

  manager.update({attributes, transitions, numInstances: 4});
  manager.run();
  t.is(interruptCounter, 2, 'transition is interrupted');
  t.is(startCounter, 3, 'new transition is triggered');

  timeline.setTime(2000);
  manager.run();
  actual = await readArray(manager.getAttributes().instanceSizes.getBuffer());
  t.deepEquals(
    actual.slice(0, 4).map(Math.round), // TODO(v9): Confirm rounding 2.875 → 3 is valid?
    [3, 3, 3, 3],
    'attribute in transition'
  );

  timeline.setTime(2500);
  manager.run();
  t.is(endCounter, 1, 'transition ends');

  manager.finalize();
  t.end();
});

async function readArray(buffer: Buffer): Promise<number[]> {
  const result = await buffer.readAsync();
  return Array.from(new Float32Array(result.buffer, result.byteOffset, result.byteLength / 4));
}
