import Attribute, {AttributeOptions} from './attribute';
import {IShaderAttribute} from './shader-attribute';
import {NumericArray} from '../../types/types';
import type {Device} from '@luma.gl/api';
import type {Stats} from 'probe.gl';
import type {Timeline} from '@luma.gl/engine';
export default class AttributeManager {
  /**
   * @classdesc
   * Automated attribute generation and management. Suitable when a set of
   * vertex shader attributes are generated by iteration over a data array,
   * and updates to these attributes are needed either when the data itself
   * changes, or when other data relevant to the calculations change.
   *
   * - First the application registers descriptions of its dynamic vertex
   *   attributes using AttributeManager.add().
   * - Then, when any change that affects attributes is detected by the
   *   application, the app will call AttributeManager.invalidate().
   * - Finally before it renders, it calls AttributeManager.update() to
   *   ensure that attributes are automatically rebuilt if anything has been
   *   invalidated.
   *
   * The application provided update functions describe how attributes
   * should be updated from a data array and are expected to traverse
   * that data array (or iterable) and fill in the attribute's typed array.
   *
   * Note that the attribute manager intentionally does not do advanced
   * change detection, but instead makes it easy to build such detection
   * by offering the ability to "invalidate" each attribute separately.
   */
  id: string;
  device: Device;
  attributes: Record<string, Attribute>;
  updateTriggers: {
    [name: string]: string[];
  };
  needsRedraw: string | boolean;
  userData: any;
  private stats?;
  private attributeTransitionManager;
  constructor(
    device: Device,
    {
      id,
      stats,
      timeline
    }?: {
      id?: string;
      stats?: Stats;
      timeline?: Timeline;
    }
  );
  finalize(): void;
  getNeedsRedraw(opts?: {clearRedrawFlags?: boolean}): string | false;
  setNeedsRedraw(): void;
  add(attributes: {[id: string]: AttributeOptions}): void;
  addInstanced(attributes: {[id: string]: AttributeOptions}): void;
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(attributeNameArray: string[]): void;
  invalidate(
    triggerName: string,
    dataRange?: {
      startRow?: number;
      endRow?: number;
    }
  ): void;
  invalidateAll(dataRange?: {startRow?: number; endRow?: number}): void;
  /** Ensure all attribute buffers are updated from props or data. */
  update({
    data,
    numInstances,
    startIndices,
    transitions,
    props,
    buffers,
    context
  }: {
    data: any;
    numInstances: number;
    startIndices?: NumericArray | null;
    transitions: any;
    props: any;
    buffers: any;
    context: any;
  }): void;
  updateTransition(): boolean;
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes(): {
    [id: string]: Attribute;
  };
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes(opts?: {clearChangedFlags?: boolean}): {
    [id: string]: Attribute;
  };
  getShaderAttributes(
    attributes?: {
      [id: string]: Attribute;
    },
    excludeAttributes?: Record<string, boolean>
  ): {
    [id: string]: IShaderAttribute;
  };
  private _add;
  private _createAttribute;
  private _mapUpdateTriggersToAttributes;
  private _invalidateTrigger;
  private _updateAttribute;
}
// # sourceMappingURL=attribute-manager.d.ts.map
