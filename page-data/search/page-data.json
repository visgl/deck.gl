{"componentChunkName":"component---node-modules-gatsby-theme-ocular-src-react-templates-search-jsx","path":"/search","result":{"pageContext":{"data":[{"excerpt":"Introduction deck.gl is designed to simplify high-performance, WebGL-based visualization of large data sets. Users can quickly get impressive visual results with minimal effort by composing existing layers, or leverage deck.gl's extensible architecture to address custom needs. deck.gl maps  data  (usually an array of JSON objects) into a stack of visual  layers  - e.g. icons, polygons, texts; and look at them with  views : e.g. map, first-person, orthographic. deck.gl handles a number of challenges out of the box: Performant rendering and updating of large data sets Interactive event handling such as picking, highlighting and filtering Cartographic projections and integration with major basemap providers including Mapbox, Google Maps and ESRI A catalog of proven, well-tested layers Deck.gl is designed to be highly customizable. All layers come with flexible APIs to allow programmatic control of each aspect of the rendering. All core classes such are easily extendable by the users to address custom use cases. Flavors Script Tag Get started Full examples NPM Module Pure JS Get started Full examples React Get started Full examples Python Get started Examples Third-Party Bindings deckgl-typings  (Typescript) mapdeck  (R) vega-deck.gl  ( Vega ) earthengine-layers  ( Google Earth Engine ) deck.gl-native  (C++) Ecosystem deck.gl is one of the main frameworks in the  vis.gl  framework suite. deck.gl is developed in parallel with a number of companion modules, including: luma.gl  - A general purpose WebGL library designed to be interoperable both with the raw WebGL API and (as far as possible) with other WebGL libraries. In particular, luma.gl does not claim ownership of the WebGL context, and can work with any supplied context, including contexts created by the application or other WebGL libraries. loaders.gl  - a suite of framework-independent loaders for file formats focused on visualization of big data, including point clouds, 3D geometries, images, geospatial formats as well as tabular data. react-map-gl  - A React wrapper around Mapbox GL which works seamlessly with deck.gl. nebula.gl  - A high-performance feature editing framework for deck.gl. Learning deck.gl How you approach learning deck.gl will depend on your previous knowledge and how you want to use it. Getting familiar with the various layers and their props, and reading the basic articles in the deck.gl developer guide should of course be one of the first steps. Exploring the deck.gl examples is a good starting point. In-depth tutorials for how to develop deck.gl applications are available on the  Vis Academy  website. And our  blog  contains a lot of additional information that might be helpful. But where to go after that? Learning Reactive UI Programming deck.gl is designed according to functional UI programming principles, popularized by frameworks like React. The key to writing good, performant deck.gl applications and layers lies in knowing how to minimize updates and redundant calculations, understanding concepts like \"shallow equality\" etc. This is critical when using deck.gl with React, but can still be helpful to understand when using deck.gl in non-React contexts. There is an impressive amount of information (documentation, blog posts, educational videos, etc.) on the reactive programming paradigm in relation to modern web frameworks such as React, Flux and Redux. Where to start depends mostly on your application architecture choices. Exploring such information will take you beyond what we can cover in the basic deck.gl developer guide article on Updates. Understanding WebGL Knowledge of WebGL is only needed if you want to create custom layers in deck.gl. Note that while trying out a new ambitious rendering approach for a new layer will likely require deeper knowledge, it is often possible to modify or extend existing deck.gl layers (including modifying the shader code) with a surprisingly limited amount of WebGL knowledge. There are many web resources for learning WebGL.  luma.gl  can be a good start.","headings":[{"value":"Introduction","depth":1},{"value":"Flavors","depth":2},{"value":"Script Tag","depth":3},{"value":"NPM Module","depth":3},{"value":"Pure JS","depth":4},{"value":"React","depth":4},{"value":"Python","depth":3},{"value":"Third-Party Bindings","depth":3},{"value":"Ecosystem","depth":2},{"value":"Learning deck.gl","depth":2},{"value":"Learning Reactive UI Programming","depth":3},{"value":"Understanding WebGL","depth":3}],"slug":"docs","title":"Introduction"},{"excerpt":"Roadmap Interested in what is coming down the road? We are trying to make the deck.gl roadmap as public as possible. We are currently using the following ways to share information about the direction of deck.gl. Roadmap Document  - (this document) A high-level summary of our current direction for future releases. Blog  - We use the  vis.gl blog  blog to share information about what we are doing. RFCs  - A wealth of technical detail around planned features is available in our RFCs (Requests For Comments). RFCs are technical writeups that describe a proposed feature. RFCs are available  here . Experimental exports  - We are making unfinished features available as experimental exports. This gives users a clear indication about what is coming and even allow early adopters a chance to play with and provide comments on these features. Experimental Layers  - We are publishing a number of work-in-progress layers to make it easy to experiment with them in applications, see below. Github issues  - As always, github issues are a good way to see what is being discussed and join the discussions. Experimental Layers The  @deck.gl/experimental-layers  is available as of deck.gl v5.2 and contains early versions of future layers. There are a number of interesting layers in this module, however there are caveats: We do not provide website documentation for these layers, so if you want to use these layers you may need to refer directly to the deck.gl source code. While we make reasonable attempts to not break things, we do not guarantee that they will be stable between releases. To prevent surprises, you may want to pin the version of the   @deck.gl/experimental-layers  module in your  package.json . Worst case, if you have to upgrade and some unexpected change happens, you can copy the source code of the affected layer(s) to your app. deck.gl v6.0 These are some of the big priorities for our next release: Aggregation  - Improve and generalize automatic data aggregation (the current HexagonLayer and GridLayer are examples of what to expect). Better Infovis Support  - Better support for non-geospatial visualizations. (Don't worry if you are a geospatial user, deck.gl will remain a \"geospatial-first\" library since that is the more difficult use case.) Better GPGPU/WebGL2 Support  - Many stones are still left unturned here. Expect better performance, and new features for WebGL2 capable browsers (such as animations of entire attributes). Visual Effects  - Shadows, blur, postprocessing etc. This continues to be strong goal that we intend to make progress on. Transitions and Animations  - 5.0 introduces viewport transitions. Expect to see similar support for layer properties and attributes. Viewport transitions feature is available in the  experimental  namespace, and for additional details check the  RFC . deck.gl v5.2 These are some of things we tackled in our most recent release Pure JavaScript Support  - the deck.gl npm module currently has a hard dependency on React, however in v5.0 the internal code is effectively 100% independent of React. We intend to split the library into a core module exposing a \"pure\" JavaScript API and an (optional) module containing the React integration. (Don't worry if you are a React user, deck.gl will continue to be \"React-first\", designed from the ground up with the \"reactive programming paradigm\" in mind. We just want non-React users to also be able use deck.gl). Multi-viewport Support  - Extensive work has been done in v5.0, and we expect to finalize and make much of this functionality official in next release. For now, multiviewport features are available in the  experimental  namespace. For additional details check the  RFCs . Multiple Modules  - In addition, in the future we plan to publish separate modules with deck.gl layers. Code Size  - deck.gl has gone through rapid development and we need to overhaul the code and build processes to reduce the size. Details on Planned Features Controller Support for Multiple Viewports TBA - This is a planned feature for a future release Restrict Event Handling to match Viewport Size  - Controllers need to be able to be restricted to a certain area (in terms of event handling). Some controllers are completely general (just general drag up/down): When working with a map controller, especially panning and zooming, the point under the mouse represents a grab point or a reference for the operation and mapping event coordinates correctly is imporant for the experience. Controllers might not be designed to receive coordinates from outside their viewports. Basically, if the map backing one WebMercator viewport doesn't fill the entire canvas, and the application wants to use a MapControls Controllers will also benefit from be able to feed multiple viewports of different types. There are limits to this of course, in particular it would be nice if for instance a geospatially neabled FirstPerson controller can feed both a  FirstPersonViewport  and a  WebMercatorViewport . Various different viewports must be created from one set of parameters. Contrast this to deck.gl v4.1, where the idea was that each the of Viewport was associated with a specific controller (WebMercatorViewport has a MapController, etc). Using Multiple Controllers  An application having multiple viewports might want to use different interaction in each viewport - this has multiple complications... Switching Controllers  - An application that wants to switch between Viewports might want to switch between controllers, ideally this should not require too much coding effort. Experimental Features in Current Release Multi-Viewport Support Multi-viewport support was added during deck.gl 5.0 development. The APIs are still not considered stable so the related classes are exported as part of the \"experimental\" namespace, and in most cases. deck.gl now allows you to divide your screen into multiple viewports and render your layers from different perspectives, using the experimental  _viewports  property. It is e.g. possible to render a top-down map view next to a first person view for dramatic new perspectives on your data. E.g. an app can allow your users to \"walk around\" in the city onto which its data is overlaid. WebVR Support and Example Multi viewport support can be used to integrate with the WebVR API and create dual WebVR compatible viewports that render a first person view of your data for left and right eye respectively which will display as stereoscopic 3D in supporting hardware. Automatic Positioning of React Children under Viewports In addition, a new  viewId  React property can be added to  DeckGL 's children. This will synchronize the position of the react component with the corresponding deck.gl viewport, which makes it trivial to precisely position e.g. multiple \"base maps\" and other background or foreground HTML components in multi-viewport layouts. The  viewportId  prop also automatically hides the react children when a viewport with the corresponding id is not present or when viewport parameters can not be supported by the underlying map component. Orbit Controller and Orbit Viewport Support TBA All Viewports Now Geospatially Enabled All  Viewport  classes are now geospatially enabled: they now take an optional  longitude / latitude  reference point. In this mode,  position s will be treated as meter offsets from that reference point per  COORDINATE_SYSTEM.METER_OFFSET  conventions. This means that you can now use a FirstPersonViewport (the successor to the  PerspectiveViewport  with layers encoded in  COORDINATE_SYSTEM.LNG_LAT  and  COORDINATE_SYSTEM.METER_OFFSETS ) and place a camera anywhere in the scene (in contrast to the  WebMercatorViewport  which only allows you to look \"down\" on a position on the map). Viewports even accept a  modelMatrix  to allow viewport/camera positions to be specified in exactly the same coordinates as  METER_OFFSET  layers, making it possible to place a camera at the exact location any of your existing data points without having to think or do any math.","headings":[{"value":"Roadmap","depth":1},{"value":"Experimental Layers","depth":2},{"value":"deck.gl v6.0","depth":2},{"value":"deck.gl v5.2","depth":2},{"value":"Details on Planned Features","depth":2},{"value":"Controller Support for Multiple Viewports","depth":3},{"value":"Experimental Features in Current Release","depth":2},{"value":"Multi-Viewport Support","depth":3},{"value":"WebVR Support and Example","depth":3},{"value":"Automatic Positioning of React Children under Viewports","depth":3},{"value":"Orbit Controller and Orbit Viewport Support","depth":3},{"value":"All Viewports Now Geospatially Enabled","depth":3}],"slug":"docs/roadmap","title":"Roadmap"},{"excerpt":"Frequently Asked Questions deck.gl is designed to be easy to use, however it is built on top of a complex technology (WebGL) and supports a functional/reactive programming paradigm which many users are initially unfamiliar with. Installing npm modules, learning React, it is just too much! Not to worry, there are easier ways to use deck.gl: Scripting  - deck.gl has a scripting API that allows you get started just by adding a  <script>  statement to your HTML to use standard JavaScript. For an easy introduction to deck.gl scripting, see our  blog post . JSON Layers  - It is even possible to use deck.gl without programming, by specifying deck.gl layers using a simple JSON format. See  JSON Layer Browser . kepler.gl  - If scripting JSON is also too much, and you just want to play around with deck.gl visualizations in a polished application user interface, please check out  kepler.gl . Layer pixels render randomly on top of each other You are likely experiencing a well-known issue in 3D graphics known as Z-fighting. The good news is that there are many ways to mitigate Z-fighting and deck.gl provides several mechanisms to help you. To get started, see the  tips and tricks  article. Should I really regenerate all layers every time something changes? Q: If I wanted to, say, change the opacity of a layer, Is my only option to create a new layer with the same Id and different properties? Yes. deck.gl is a \"reactive\" application architecture and is optimized to be used like this. The layer and its props are essentially only a \"descriptor\", deck.gl matches and \"diffs\" the layers under the hood and only does the necessary changes based on actual differences compared to last layer. This is a \"functional\" take on programming, and it parallels key ideas in the widely used React library. The reactive architecture has big benefits when writing larger prgrams, but these are not as evident when writing smaller scripts. If you are coming from a more \"imperative\" programming experience, it can initially seem a little counter-intuitive (especially from a performance perspective). But in spite of how the API looks, performance should be very good, if this is not the case you are likely doing something else wrong. For more information, see the article about  updates . I can't \"extend\" my Custom Layer Q: Why does deck.gl call  Object.seal  on the  Layer  base class? I can't add members to my subclass. An important thing to understand about layer instances is that they are essentially just \"disposable descriptors\". All permanent state is stored in the  layer.state  object, which \"moves\" between layers. Every time you change your layer, you create a new layer and pass it to Deck or DeckGL. Internally DeckGL matches new layers with old layers, and the old layers are released for garbage collection. So storing data on the layer itself typically does not make sense. How do I  debug  deck.gl applications? Both deck.gl and luma.gl have powerful logging capabilities. See the article about  debugging . How do I  test  deck.gl applications? Q: It is hard to test webgl based applications, assuming deck.gl is no different? Check out  @deck.gl/test-utils , which (among other things) supports visual regression testing.","headings":[{"value":"Frequently Asked Questions","depth":1},{"value":"Installing npm modules, learning React, it is just too much!","depth":2},{"value":"Layer pixels render randomly on top of each other","depth":2},{"value":"Should I really regenerate all layers every time something changes?","depth":2},{"value":"I can't \"extend\" my Custom Layer","depth":2},{"value":"How do I debug deck.gl applications?","depth":2},{"value":"How do I test deck.gl applications?","depth":2}],"slug":"docs/faq","title":"Frequently Asked Questions"},{"excerpt":"Contributing to deck.gl Thanks for taking the time to contribute! PRs and bug reports are welcome, and we are actively looking for new maintainers. Setting Up Dev Environment The  master  branch is the active development branch. Building deck.gl locally from the source requires node.js  >=14 . Further limitations on the Node version may be imposed by  puppeteer  and  headless-gl .\nWe use  yarn  to manage the dependencies of deck.gl. See  additional instructions  for Windows, Linux and Apple M1. Run the layer browser application: If you consider opening a PR, here is some documentation to get you started: vis.gl  developer process deck.gl API design guidelines Testing examples with modified deck.gl source Each example can be run so that it is built against the deck.gl source code in this repo instead of building against the installed version of deck.gl. This enables using the examples to debug the main deck.gl library source. To do so use the  yarn start-local  command present in each example's directory. See  webpack.config.local.js  for details. Working with other vis.gl dependencies Deck.gl has a number of dependencies that fall under vis.gl, and there may be times when it is necessary to make a change in one of these.\nThus for development it is necessary to checkout a copy of such a dependency and make local changes. When running an example using  yarn start-local  you can use local version of  luma.gl  or  math.gl  by appending the  --env.local-luma  or  --env.local-math  option. Specific module overrides To get the local build of deck.gl to pick up the local code rather than the modules from npm, there are two important config files: ocular-dev-tools.config.js  - See  Ocular documentation for details examples/webpack.config.local.js Note that the configuration in  examples/webpack.config.local.js  will potentially override the ocular configuration. Community Governance vis.gl is part of the  OpenJS Foundation . See the organization's  Technical Charter . Technical Steering Committee deck.gl development is governed by the vis.gl Technical Steering Committee (TSC). Current members: Ib Green Xiaoji Chen  - chairperson Alberto Asuero Maintainers Andrew Duberstein  - pydeck, json Xintong Xia  - layers Georgios Karnas  - glTF Kyle Barron  - tiles Chris Gervang  - terrain Dario D'Amico  - ArcGIS Javier Aragón  - MVT, CARTO Víctor Velarde  - MVT, CARTO Felix Palmer  - MVT, GoogleMaps, CARTO Ilan Gold  - tiles Maintainers of deck.gl have commit access to this GitHub repository, and take part in the decision making process. If you are interested in becoming a maintainer, read the  governance guidelines . The vis.gl TSC meets monthly and publishes meeting notes via a  mailing list .\nThis mailing list can also be utilized to reach out to the TSC. Code of Conduct Please be mindful of and adhere to the Linux Foundation's  Code of Conduct  when contributing to deck.gl. Troubleshooting Develop on Linux To run the test suite, you may need to install additional dependencies (verified on Ubuntu LTS): headless-gl dependencies  for the Node tests puppeteer dependencies  for the integration tests Verify that everything works by running  yarn test . Develop on Windows It's possible to set up the dev environment in  Windows Subsystem for Linux . To run the Node tests, you need to set up OpenGL support via X11 forwarding: Install  VcXsrv . Run  xlaunch.exe , choose multiple windows, display 0, start no client, disable native opengl, disable access control.  reference If working with WSL2, allow WSL to access your X server with  firewall rules . Set the  DISPLAY  environment variable: You can test that it is set up successfully with: You should see a window open with gears turning at this point. Follow instructions for  developing on linux . Develop on MacOs on Apple Silicon (M1 chip) To install dependencies specify that you explicitly need the arm64 version After this  yarn bootstrap  can be run with","headings":[{"value":"Contributing to deck.gl","depth":1},{"value":"Setting Up Dev Environment","depth":2},{"value":"Testing examples with modified deck.gl source","depth":2},{"value":"Working with other vis.gl dependencies","depth":3},{"value":"Specific module overrides","depth":3},{"value":"Community Governance","depth":2},{"value":"Technical Steering Committee","depth":3},{"value":"Maintainers","depth":3},{"value":"Code of Conduct","depth":2},{"value":"Troubleshooting","depth":2},{"value":"Develop on Linux","depth":3},{"value":"Develop on Windows","depth":3},{"value":"Develop on MacOs on Apple Silicon (M1 chip)","depth":3}],"slug":"docs/contributing","title":"Contributing to deck.gl"},{"excerpt":"Upgrade Guide Upgrading from deck.gl v8.7 to v8.8 Breaking changes In order to generalize the  TileLayer  to work with non-OSM indexing systems, the  Tile  class no longer has  x ,  y , and  z  as top level properties, but instead an  index  property with shape  {x, y, z} . This affects the following callback props: getTileData({x, y, z, ...opts})  -->  getTileData({index: {x, y, z}, ...opts}) onViewportLoad(tiles) onTileLoad(tile) onTileUnload(tile) onTileError(tile) pickingInfo.tile  returned by  onHover ,  onClick  etc. The base  Effect  class is removed. Custom effects should implement the new  interface Effect  in TypeScript. CARTO format  prop is removed from  CartoLayer , with  format  is fixed to  'tilejson' .  CartoLayer  no longer creates non-tiled layers. Use the  fetchLayerData  function with  GeoJSONLayer  for static queries and tables. Upgrading from deck.gl v8.6 to v8.7 Deprecations Core H3HexagonLayer  now uses flat shading when it renders a  ColumnLayer . This change improves the visual consistency when using  highPrecision: 'auto' . To revert to the old behavior, set the following prop: H3ClusterLayer  sublayer is now called  'cell'  not  'cluster-region' CARTO CartoBQTilerLayer  is removed. Use  CartoLayer  instead with  type  set to  MAP_TYPES.TILESET . CartoSQLLayer  is removed. Use  CartoLayer  instead with  type  set to  MAP_TYPES.QUERY . API_VERSIONS.V3  is the default for the CARTO module API calls. Use  setDefaultCredentials  to explicitly specify  V2 . Upgrading from deck.gl v8.5 to v8.6 Changes to layer prop defaults H3HexagonLayer 's  highPrecision  prop now defaults to  'auto' . Explicitly setting  highPrecision: false  now forces the layer to use low-precision (instanced rendering) mode. MVTLayer 's  binary  prop now defaults to  true . Meter size projection Dimensions (radius/width/size) that are defined in meters are now projected accurately in the  MapView  according to the Web Mercator projection. This means that scatterplot radius, path widths etc. may now appear larger than they used to at high latitudes, reflecting the  distortion of the Mercator projection . The visual difference is visible when viewing a dataset covering a large range of latitudes on a global scale. This change is technically a bug fix. However, if you have been using meter sizes to visualize non-cartographic values (e.g. population, income), the Mercator distortion may be undesirable. If this is the case, consider moving to  radiusUnits / widthUnits / sizeUnits :  'common' , as detailed in the updated documentation on the  unit system . As a stop-gap measure, applications can revert to the old projection behavior with the following prop on  Deck / DeckGL : Note that this flag may be removed in a future release. Layer filtering H3HexagonLayer 's  highPrecision  prop default value is changed to  'auto' . Setting  highPrecision  to  false  now forces instanced rendering. See updated  layer documentation  for details. layerFilter  is now only called with top-level layers. For example, if you have a  GeoJsonLayer  with  id: 'regions' , in previous versions the callback would look like: Now the callback can be: This change is intended to make this callback easier to use for the most common use cases. Using this callback to filter out specific nested sub layers is no longer supportd. Instead, you need to either set the  _subLayerProps  prop (stock layer) or implement the  filterSubLayer  method (custom layer). If a composite layer has  visible: false , all of the layers generated by it will also be hidden regardless of their own  visible  prop. In previous versions, a descendant layer may be visible as long as it has  visible: true , which often led to confusing behavior if a composite layer does not propagate its props correctly. Upgrading from deck.gl v8.4 to v8.5 Transpilation The module entry point is now only lightly transpiled for the most commonly used evergreen browsers. This change offers significant savings on bundle size. If your application needs to support older browsers such as IE 11, make sure to include  node_modules  in your babel config. Layers Breaking changes A bug is fixed in projecting sizes in billboard mode. Pixel sizes now match their CSS counterparts and objects now have the same size whether in billboard mode or not. As a result, some items are now 1.5 times bigger than they used to be in many common cases, because previously you didn't get the sizes you were asking for. This change affects the following layers when used with a  MapView : ArcLayer ,  LineLayer  and  PointCloudLayer IconLayer  and  TextLayer  with the default  billboard  prop PathLayer  with  billboard: true After upgrading to v8.5, in order to maintain the same appearance in these cases, you need to multiply the objects' width/size by  2/3 . This can be done by either changing the accessor ( getWidth / getSize ) or the scaling prop ( sizeScale / widthScale ). TextLayer 's default  fontSettings  have changed. When using  sdf , the default  buffer  is now  4  and the default  radius  is now  12 . GeoJsonLayer 's  lineJointRounded  prop now only controls line joints. To use rounded line caps, set  lineCapRounded  to  true . Dashed lines via  PathStyleExtension  now draw rounded dash caps if  capRounded  is  true . @deck.gl/geo-layers  now depends on  @deck.gl/extensions . HeatmapLayer 's  colorDomain  prop has redefined the unit of its values. See updated  layer documentation  for details. TileLayer  no longer uses  tileSize  to offset zoom in non-geospatial views. It is recommended to use the new  zoomOffset  prop to affect the  zoom  resolution at which tiles are fetched. MVTLayer  and  TerrainLayer 's default loaders no longer support parsing on the main thread. This does not change the layers' default behavior, just reduces the bundle size by dropping unused code. Should you need to use the layers in an environment where web worker is not available, or debug the loaders, follow the examples in  loaders and workers . TerrainLayer 's  workerUrl  prop is removed, use  loadOptions.terrain.workerUrl  instead. Deprecations TextLayer 's  backgroundColor  prop is deprecated. Use  background: true  and  getBackgroundColor  instead. PathLayer 's  rounded  prop is deprecated, replaced by two separate flags  jointRounded  and  capRounded . GeoJsonLayer 's  getRadius  props is deprecated, replaced by  getPointRadius . CartoBQTilerLayer  is deprecated and will be removed in 8.6. Use  CartoLayer  instead with  type  set to  MAP_TYPES.TILESET . CartoSQLLayer  is deprecated and will be removed in 8.6. Use  CartoLayer  instead with  type  set to  MAP_TYPES.QUERY . onError Callback Deck 's default  onError  callback is changed to  console.error . Explicitly setting  onError  to  null  now silently ignores all errors, instead of logging them to console. loaders.gl v3.0 deck.gl now depends on  @loaders.gl/core@^3.0.0 . It is strongly recommended that you upgrade all loaders.gl dependencies to v3 as v2.x loaders are not tested with the v3.0 core. Visit loaders.gl's  upgrade guide  for instructions on each loader module. OrbitView OrbitView  no longer allows  orbitAxis  to be specified in the view state. Set  orbitAxis  in the  OrbitView  constructor instead. Upgrading from deck.gl v8.3 to v8.4 wrapLongitude The behavior of  wrapLongitude  has changed. Before, setting this prop to  true  would project vertices to a copy of the map that is closer to the current center. Starting with v8.4, enabling this prop would \"normalize\" the geometry to the  -180, 180  longitude range. See the following list for layer-specific changes: LineLayer  and  ArcLayer : always draw the shortest path between source and target positions. If the shortest path crosses the 180th meridian, it is split into two segments. Layers that draw each object with a single position anchor, e.g.  ScatterplotLayer ,  IconLayer ,  TextLayer : move the anchor point into the  [-180, 180]  range. This change makes layers render more predictably at low zoom levels. To draw horizontally continuous map with multiple copies of the world, use  MapView  with the  repeat  option: pickingInfo A legacy field  pickingInfo.lngLat  has been removed. Use  pickingInfo.coordinate  instead. Layers MVTLayer 's  onHover  and  onClick  callbacks now yield the  info.object  feature coordinates in WGS84 standard. ScenegraphLayer  now has built-in support for  GLTFLoader . It's no longer necessary to call  registerLoaders  before using it. SolidPolygonLayer  now enforces the winding order for outer polygons and holes. This ensures the correct orientation of an extruded polygon's surfaces, and therefore consistent culling and lighting effect results. This may change the visual outcome of your layers if the winding order was wrongly deduced in the previous versions. When using this layer with  _normalize: false , a new prop  _windingOrder  can be used to specify the winding order used by your polygon data. ColumnLayer  now enforces the winding order for vertices. This may change the lighting effect appearance in  HexagonLayer  and  H3HexagonLayer  slightly. TileLayer 's  onViewportLoad  callback now receives as argument an array of loaded  Tile  instances. At previous version the argument was an array of tile content. Upgrading from deck.gl v8.2 to v8.3 The following is added to the default image loading options:  {imagebitmap: {premultiplyAlpha: 'none'}}  (previously  default ). This generates more visually similar outcome between  ImageBitmap  and  Image  formats (see changes in 8.2 below). You can override this behavior with the  loadOptions  prop of a layer. See  ImageLoader options  for more information. Upgrading from deck.gl v8.1 to v8.2 The  TileLayer  now rounds the current  zoom  to determine the  z  at which to load tiles. This will load less tiles than the previous version. You can adjust the  tileSize  prop to modify this behavior. Image URLs are now by default loaded in the  ImageBitmap  format, versus  Image  in the previous version. This improves the performance of loading textures. You may override this by supplying the  loadOptions  prop of a layer: See  ImageLoader options ; Upgrading from deck.gl v8.0 to v8.1 Breaking Changes s2-geometry  is no longer a dependency of  @deck.gl/geo-layers . If you were using this module in an application, it needs to be explicitly added to package.json. deck.gl no longer crashes if one of the layers encounters an error during update and/or render. By default, errors are now logged to the console. Specify the  onError  callback to manually handle errors in your application. Deck  now reacts to changes in the  initialViewState  prop. In 8.0 and earlier versions, this prop was not monitored after the deck instance was constructed. Starting 8.1, if  initialViewState  changes deeply, the camera will be reset. It is recommended that you use a constant for  initialViewState  to achieve behavior consistent with the previous versions. Tile3DLayer A new prop  loader  needs to be provided, one of  CesiumIonLoader ,  Tiles3DLoader  from ( @loaders.gl/3d-tiles ) or  I3SLoader  from ( @loaders.gl/i3s ). The  loadOptions  prop is now used for passing all loaders.gl options, not just  Tileset3D . To revert back to the 8.0 behavior, use  {tileset: {throttleRequest: true}} . _ionAccessId  and  _ionAccesToken  props are removed. To render an ion dataset with  Tile3DLayer , follow this example: Upgrading from deck.gl v7.x to v8.0 Breaking Changes Defaults The  opacity  prop of all layers is now default to  1  (used to be  0.8 ). SimpleMeshLayer  and  ScenegraphLayer :  modelMatrix  will be composed to instance transformation matrix (derived from  layer props  getOrientation ,  getScale ,  getTranslation  and  getTransformMatrix ) under  CARTESIAN  and  METER_OFFSETS   coordinates . Removed ArcLayer  props getStrokeWidth : use  getWidth LineLayer  props getStrokeWidth : use  getWidth PathLayer  props getDashArray : use  PathStyleExtension PolygonLayer  and  GeoJsonLayer  props getLineDashArray : use  PathStyleExtension H3HexagonLayer  props getColor : use  getFillColor  and  getLineColor Tile3DLayer  props: onTileLoadFail : use  onTileError TileLayer  props: onViewportLoaded : use  onViewportLoad project  shader module project_scale : use  project_size project_to_clipspace : use  project_position_to_clipspace project_pixel_to_clipspace : use  project_pixel_size_to_clipspace WebMercatorViewport  class getLocationAtPoint : use  getMapCenterByLngLatPosition lngLatDeltaToMeters metersToLngLatDelta Layer  class setLayerNeedsUpdate : use  setNeedsUpdate setUniforms : use  model.setUniforms use64bitProjection projectFlat : use  projectPosition PerspectiveView  class - use  FirstPersonView ThirdPersonView  class - use  MapView  (geospatial) or  OrbitView  (info-vis) COORDINATE_SYSTEM  enum LNGLAT_DEPRECATED : use  LNGLAT METERS : use  METER_OFFSETS React DeckGL  no longer injects its children with view props ( width ,  height ,  viewState  etc.). If your custom component needs these props, consider using the  ContextProvider  or a render callback: The children of  DeckGL  are now placed above the canvas by default (except the react-map-gl base map). Wrap them in e.g.  <div style={{zIndex: -1}}>  if they are intended to be placed behind the canvas. Debugging deck.gl now removes most logging when bundling under  NODE_ENV=production . Standalone bundle The pre-bundled version, a.k.a. the  scripting API  has been aligned with the interface of the core  Deck  class. Top-level view state props such as  longitude ,  latitude ,  zoom  are no longer supported. To specify the default view state, use  initialViewState . controller  is no longer on by default, use  controller: true . Textures In older versions of deck, we used to set  UNPACK_FLIP_Y_WEBGL  by default when creating textures from images. This is removed in v8.0 to better align with  WebGL best practice . As a result, the texCoords in the shaders of  BitmapLayer ,  IconLayer  and  TextLayer  are y-flipped. This only affects users who extend these layers. Users of  SimpleMeshLayer  with texture will need to flip their texture image vertically. The change has allowed us to support loading textures from  ImageBitmap , in use cases such as rendering to  OffscreenCanvas  on a web worker. projection system The  common space  is no longer scaled to the current zoom level. This is part of an effort to make the geometry calculation more consistent and predictable. While one old common unit is equivalent to 1 screen pixel at the viewport center, one new common unit is equivalent to  viewport.scale  pixels at the viewport center. viewport.distanceScales  keys are renamed: pixelsPerMeter  ->  unitsPerMeter metersPerPixel  ->  metersPerUnit Low part of a  DOUBLE  attribute is renamed from  *64xyLow  to  *64Low  and uses the same size as the high part. This mainly affect position attributes, e.g. all  vec2 positions64xyLow  and  vec2 instancePositions64xyLow  are now  vec3 positions64Low  and  vec3 instancePositions64Low . project :  vec3 project_position(vec3 position, vec2 position64xyLow)  is now  vec3 project_position(vec3 position, vec3 position64Low) . project :  vec4 project_position(vec4 position, vec2 position64xyLow)  is now  vec4 project_position(vec4 position, vec3 position64Low) . project32  and  project64 :  vec4 project_position_to_clipspace(vec3 position, vec2 position64xyLow, vec3 offset)  is now  vec4 project_position_to_clipspace(vec3 position, vec3 position64Low, vec3 offset) . The shader module  project64  is no longer included in  @deck.gl/core  and  deck.gl . You can still import it from  @deck.gl/extensions . Shader modules This change affects custom layers. deck.gl is no longer registering shaders by default. This means any  modules  array defined in  layer.getShaders()  or  new Model()  must now use the full shader module objects, instead of just their names. All supported shader modules can be imported from  @deck.gl/core . Should now become Auto view state update A bug was fixed where initial view state tracking could sometimes overwrite user-provided  viewState  prop. Apps that rely on auto view state update by specifying  initialViewState  should make sure that  viewState  is never assigned. If manual view state update is desired, use  viewState  and  onViewStateChange  instead. See  developer guide  for examples. We have fixed a bug when using  initialViewState  with multiple views. In the past, the state change in one view is unintendedly propagated to all views. As a result of this fix, multiple views (e.g. mini map) are no longer synchronized by default. To synchronize them, define the views with an explicit  viewState.id : See  View class  documentation for details. Upgrading from deck.gl v7.2 to v7.3 Core layer.setLayerNeedsUpdate  is renamed to  layer.setNeedsUpdate()  and the old name will be removed in the next major release. Previously deprecated  Layer  class method,  screenToDevicePixels , is removed. Use luma.gl  utility methods  instead. Layers ScreenGridLayer : support is now limited to browsers that implement either WebGL2 or the  OES_texture_float  extension.  coverage stats Some shader attributes are renamed for consistency: Layer Old New LineLayer instanceSourceTargetPositions64xyLow.xy instanceSourcePositions64xyLow instanceSourceTargetPositions64xyLow.zw instanceTargetPositions64xyLow PathLayer instanceLeftStartPositions64xyLow.xy instanceLeftPositions64xyLow instanceLeftStartPositions64xyLow.zw instanceStartPositions64xyLow instanceEndRightPositions64xyLow.xy instanceEndPositions64xyLow instanceEndRightPositions64xyLow.zw instanceRightPositions64xyLow ArcLayer instancePositions64Low instancePositions64xyLow ScenegraphLayer instancePositions64xy instancePositions64xyLow SimpleMeshLayer instancePositions64xy instancePositions64xyLow @deck.gl/json Non-breaking Change: The  _JSONConverter  class has been renamed to  JSONConverter  (deprecated alias still available). Non-breaking Change: The  _JSONConverter.convertJson()  method has been renamed to  JSONConverter.convert()   (deprecated stub still available). Breaking Change: The  _JSONConverter  no longer automatically injects deck.gl  View  classes and enumerations. If required need to import and add these to your  JSONConfiguration . Removed: The  JSONLayer  is no longer included in this module. The code for this layer has been moved to an example in  /test/apps/json-layer , and would need to be copied into applications to be used. Upgrading from deck.gl v7.1 to v7.2 Breaking Changes Layer methods Following  Layer  class methods have been removed : Removed Alternate Comment use64bitProjection use  Fp64Extension details in  fp64 prop  section below is64bitEnabled use  Fp64Extension details in  fp64 prop  section below updateAttributes _updateAttributes method is renamed fp64 prop The deprecated  fp64  prop is removed. The current 32-bit projection is generally precise enough for almost all use cases. If you previously use this feature:   It can be changed to: Color Attributes and Uniforms All core layer shaders now receive  normalized  color attributes and uniforms. If you were previously subclassing a core layer with custom vertex shaders, you should expect the color attributes to be in  [0, 1]  range instead of  [0, 255] . project64 Shader Module The  project64  shader module is no longer registered by default. If you were previously using a custom layer that depends on this module:   It can be changed to: CPU Grid layer and Hexagon layer updateTriggers getElevationValue ,  getElevationWeight  and  getColorValue ,  getColorWeight  are now compared using  updateTriggers  like other layer  accessors . Update them without passing updateTriggers will no longer trigger layer update. Deprecations IE support is deprecated and will be removed in the next major release. Upgrading from deck.gl v7.0 to v7.1 Breaking Changes Fixed a bug where  coordinateOrigin 's  z  is not applied in  METER_OFFSETS  and  LNGLAT_OFFSETS  coordinate systems. If your application was subclassing  GridLayer , you should now subclass  CPUGridLayer  instead, and either use it directly, or provide it as the sublayer class for  GridLayer  using  _subLayerProps : Deprecations getColor  props in  ColumnLayer  and  H3HexagonLayer  are deprecated. Use  getLineColor  and  getFillColor  instead. Upgrading from deck.gl v6.4 to v7.0 Submodule Structure and Dependency Changes  @deck.gl/core  is moved from  dependencies  to  devDependencies  for all submodules. This will reduce the runtime error caused by installing multiple copies of the core. The master module  deck.gl  now include all submodules except   @deck.gl/test-utils . See  list of submodules  for details. ContourLayer ,  GridLayer ,  HexagonLayer  and  ScreenGridLayer  are moved from   @deck.gl/layers  to   @deck.gl/aggregation-layers . No action is required if you are importing them from  deck.gl .  @deck.gl/experimental-layers  is deprecated. Experimental layers will be exported from their respective modules with a  _  prefix. BitmapLayer  is moved to   @deck.gl/layers . MeshLayer  is renamed to  SimpleMeshLayer  and moved to   @deck.gl/mesh-layers . TileLayer  and  TripsLayer  are moved to   @deck.gl/geo-layers . Deck Class Breaking Changes: onLayerHover  and  onLayerClick  props are replaced with  onHover  and  onClick . The first argument passed to the callback will always be a valid  picking info  object, and the second argument is the pointer event. This change makes these two events behave consistently with other event callbacks. Layers Deprecations: ArcLayer  and  LineLayer 's  getStrokeWidth  props are deprecated. Use  getWidth  instead. Breaking Changes: HexagonCellLayer  is removed. Use  ColumnLayer  with  diskResolution: 6  instead. A bug in projecting elevation was fixed in  HexagonLayer ,  GridLayer  and  GridCellLayer . The resulting heights of extruded grids/hexagons have changed. You may adjust them to match previous behavior by tweaking  elevationScale . The following former experimental layers' APIs are redesigned as they graduate to official layers. Refer to their documentations for details: BitmapLayer SimpleMeshLayer TileLayer TripsLayer Lighting The old experimental prop  lightSettings  in many 3D layers is no longer supported. The new and improved settings are split into two places: a  material  prop for each 3D layer and a shared set of lights specified by  LightingEffect  with the  effects prop of Deck .\nCheck  Using Lighting  in developer guide for more details. Views v7.0 includes major bug fixes for  OrbitView  and  OrthographicView . Their APIs are also changed for better clarity and consistency. Breaking Changes: View state:  zoom  is now logarithmic in all  View  classes.  zoom: 0  maps one unit in world space to one pixel in screen space. View state:  minZoom  and  maxZoom  now default to no limit. View state:  offset  (pixel-shift of the viewport center) is removed, use  target  (world position  [x, y, z]  of the viewport center) instead. Constructor prop: added  target  to specify the viewport center in world position. OrthographicView 's constructor props  left ,  right ,  top  and  bottom  are removed. Use  target  to specify viewport center. OrbitView 's constructor prop  distance  and static method  getDistance  are removed. Use  fovy  and  zoom  instead. project Shader Module Deprecations: project_scale  ->  project_size project_to_clipspace  ->  project_common_position_to_clipspace project_to_clipspace_fp64  ->  project_common_position_to_clipspace_fp64 project_pixel_to_clipspace  ->  project_pixel_size_to_clipspace React If you are using DeckGL with react-map-gl,   @deck.gl/react@^7.0.0  no longer works with react-map-gl v3.x. Upgrading from deck.gl v6.3 to v6.4 OrthographicView The experimental  OrthographicView  class has the following breaking changes: zoom  is reversed (larger value means zooming in) and switched to logarithmic scale. Changed view state defaults: zoom  -  1  ->  0 offset  -  [0, 1]  ->  [0, 0] minZoom  -  0.1  ->  -10 eye ,  lookAt  and  up  are now set in the   OrthographicView  constructor instead of  viewState . ScatterplotLayer Deprecations: outline  is deprecated: use  stroked  instead. strokeWidth  is deprecated: use  getLineWidth  instead. Note that while  strokeWidth  is in pixels, line width is now specified in meters. The old appearance can be achieved by using  lineWidthMinPixels  and/or  lineWidthMaxPixels . getColor  is deprecated: use  getFillColor  and  getLineColor  instead. Breaking changes: outline  /  stroked  no longer turns off fill. Use  filled: false  instead. GeoJsonLayer Breaking changes: stroked ,  getLineWidth  and  getLineColor  props now apply to point features (rendered with a ScatterplotLayer) in addition to polygon features. To revert to the old appearance, supply a  _subLayerProps  override: Upgrading from deck.gl v6.2 to v6.3 GridLayer and HexagonLayer Shallow changes in  getColorValue  and  getElevationValue  props are now ignored by default. To trigger an update, use the  updateTriggers  prop. This new behavior is aligned with other core layers and improves runtime performance. Prop Types in Custom Layers Although the  prop types system  is largely backward-compatible, it is possible that some custom layers may stop updating when a certain prop changes. This is because the automatically deduced prop type from  defaultProps  does not match its desired usage. Switch to explicit descriptors will fix the issue, e.g. from: To: Upgrading from deck.gl v6.1 to v6.2 fp64 The default coordinate system  COORDINATE_SYSTEM.LNGLAT  is upgraded to offer high-precision results in a way that is much faster and more cross-platform compatible. The  fp64  layer prop is ignored when using this new coordinate system. You can get the old fp64 mode back by using  coordinateSystem: COORDINATE_SYSTEM.LNGLAT_DEPRECATED  with  fp64: true . Upgrading from deck.gl v5.3 to v6.0 luma.gl v6.0 deck.gl v6.0 brings in luma.gl v6.0 which is a major release with a few breaking changes. The change that is most likely to affect deck.gl applications is probably that the way the  GL  constant is imported has changed. For details, see to the luma.gl  Upgrade Guide . Pixel sizes Pixel sizes in line, icon and text layers now match their HTML/SVG counterparts. To achieve the same rendering output as v5, you should use half the previous value in the following props: ArcLayer.getStrokeWidth LineLayer.getStrokeWidth IconLayer.getSize  or  IconLayer.sizeScale TextLayer.getSize  or  TextLayer.sizeScale PointCloudLayer.radiusPixels Accessors All layer accessors that support constant values have had their default values changed to constants. For example,  ScatterplotLayer 's default  getRadius  prop is changed from  d => d.radius || 1  to  1 . All dynamic attributes now must be explicitly specified. This change makes sure that using default values results in best performance. Views and Controllers (React only) Viewport constraint props:  maxZoom ,  minZoom ,  maxPitch ,  minPitch  are no longer supported by the  DeckGL  component. They must be specified as part of the  viewState  object. (React only)  ViewportController  React component has been removed. The functionality is now built in to the  Deck  and  DeckGL  classes. Deck.onViewportChange(viewport)  etc callbacks are no longer supported. Use  Deck.onViewStateChange({viewState}) DeckGL.viewport  and  DeckGL.viewports  props are no longer supported. Use  DeckGL.views . ScreenGridLayer minColor  and  maxColor  props are deprecated. Use  colorRange  and  colorDomain  props. Shader Modules Some previously deprecated  project_  module GLSL functions have now been removed. Attribute isGeneric  field of attribute object returned by  AttributeManager 's update callbacks is replaced by  constant . For more details check  attribute manager . Upgrading from deck.gl v5.2 to v5.3 Viewport classes Continuing the changes that started in 5.2: while the base  Viewport  class will remain supported, the various  Viewport  subclasses are now deprecated. For now, if for projection purposes you need to create a  Viewport  instance matching one of your  View  instances you can use  View.makeViewport : Layer properties Layer Removed Prop New Prop Comment ArcLayer strokeWidth getStrokeWidth Can be set to constant value LineLayer strokeWidth getStrokeWidth Can be set to constant value Pure JS applications Core layers are broken out from   @deck.gl/core  to a new submodule   @deck.gl/layers . Non-React users of deck.gl should now install both submodules: And import layers from the new submodule instead of core: Users of  deck.gl  are not affected by this change. Upgrading from deck.gl v5.1 to v5.2 DeckGL component DeckGL.viewports  and  DeckGL.viewport  are deprecated and should be replaced with  DeckGL.views . Viewport classes A number of  Viewport  subclasses have been deprecated. They should be replaced with their  View  counterparts. Experimental Features Some experimental exports have been removed: The experimental React controller components ( MapController  and  OrbitController ) have been removed. These are now replaced with JavaScript classes that can be used with the  Deck.controller  /  DeckGL.controller  property. Upgrading from deck.gl v5 to v5.1 N/A Upgrading from deck.gl v4.1 to v5 Dependencies deck.gl 4.1 requires luma.gl as peer dependency, but 5.0 specifies it as a normal \"dependency\". This means that many applications no longer need to list luma.gl in their package.json. Applications that do might get multiple copies of luma.gl installed, which will not work.  luma.gl will detect this situation during run-time throwing an exception , but  npm and yarn will not detect it during install time . Thus your build can look successful during upgrade but fail during runtime. Layer Props Coordinate system related props have been renamed for clarity. The old props are no longer supported and will generate errors when used. Layer Removed Prop New Prop Comment Layer projectionMode coordinateSystem Any constant from  COORDINATE_SYSTEM Layer projectionOrigin coordinateOrigin lng, lat Note; There is also an important semantical change in that using  coordinateSystem  instead of  projectionMode  causes the superimposed  METER_OFFSET  system's y-axis to point north instead of south. This was always the intention so in some sense this was regarded as a bug fix. DeckGL component Following methods and props have been renamed for clarity. The semantics are unchanged. The old props are still available but will generate a deprecation warning. Old Method New Method Comment queryObject pickObject These names were previously aligned with react-map-gl, but ended up confusing users. Since rest of the deck.gl documentation talks extensively about \"picking\" it made sense to stay with that terminology. queryVisibleObjects pickObjects The word \"visible\" was intended to remind the user that this function only selects the objects that are actually visible in at least one pixel, but again it confused more than it helped. Removed picking Uniforms Removed uniform Comment renderPickingBuffer picking shader module pickingEnabled picking shader module selectedPickingColor picking shader module The shader uniforms are used for implementing picking in custom shaders, these uniforms are no longer set by the deck.gl. Custom shaders can now use luma.gl  picking shader module . Initial WebGL State Following WebGL parameters are set during DeckGL component initialization. WebGL State Value depthTest true depthFunc gl.LEQUAL blendFuncSeparate gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA All our layers enable depth test so we are going set this state during initialization. We are also changing blend function for more appropriate rendering when multiple elements are blended. For any custom needs, these parameters can be overwritten by updating them in  onWebGLInitialized  callback or by passing them in  parameters  object to  drawLayer  method of  Layer  class. assembleShaders The  assembleShaders  function was moved to luma.gl in v4.1 and is no longer re-exported from deck.gl. As described in v4.1 upgrade guide please use  Model  class instead or import it from luma.gl. Removed Immutable support ScatterplotLayer  and  PolygonLayer  supported immutable/ES6 containers using  get  method, due to performance reasons this support has been dropped. Upgrading from deck.gl v4 to v4.1 deck.gl v4.1 is a backward-compatible release. Most of the functionality and APIs remain unchanged but there are smaller changes that might requires developers' attention if they  develop custom layers . Note that applications that are only using the provided layers should not need to make any changes issues. Dependencies Be aware that deck.gl 4.1 bumps the luma.gl peer dependency from 3.0 to 4.0. There have been instances where this was not detected by the installer during update. Layer Life Cycle Optimization shouldUpdateState  - deck.gl v4.1 contains additional optimizations of the layer lifecycle and layer diffing algorithms. Most of these changes are completely under the hood but one  visible change is that the default implementation of  Layer.shouldUpdate  no longer returns true if only the viewport has changed. This means that layers that need to update state in response to changes in screen space (viewport) will need to redefine  shouldUpdate : Note that this change has already been done in all the provided deck.gl layers that are screen space based, including the  ScreenGridLayer  and the  HexagonLayer . luma.gl  Model  class API change deck.gl v4.1 bumps luma.gl to from v3 to v4. This is major release that brings full WebGL2 enablement to deck.gl. This should not affect you if you are mainly using the provided deck.gl layers but if you are writing your own layers using luma.gl classes you may want to look at the upgrade guide of luma.gl. The  gl  parameter is provided as a separate argument in luma.gl v4, instead of part of the options object. Shader Assembly Custom layers are  no longer expected  to call  assembleShaders  directly. Instead, the new  Model  class from luma.gl v4 will take shaders and the modules they are using as parameters and assemble shaders automatically. Removed Layers Layer Status Replacement ChoroplethLayer Removed GeoJsonLayer ,  PolygonLayer  and  PathLayer ChoroplethLayer64 Removed GeoJsonLayer ,  PolygonLayer  and  PathLayer ExtrudedChoroplethLayer Removed GeoJsonLayer ,  PolygonLayer  and  PathLayer ChoroplethLayer, ChoroplethLayer64, ExtrudedChoroplethLayer These set of layers were deprecated in deck.gl v4, and are now removed in v5. You can still get same functionality using more unified, flexible and performant layers:\n  GeoJsonLayer ,  PolygonLayer  and  PathLayer . Upgrading from deck.gl v3 to v4 Changed Import: The  DeckGL  React component A small but breaking change that will affect all applications is that the 'deck.gl/react' import is no longer available. As of v4.0, the app is required to import deck.gl as follows: While it would have been preferable to avoid this change, a significant modernization of the deck.gl build process and preparations for \"tree-shaking\" support combined to make it impractical to keep supporting the old import style. Deprecated/Removed Layers Layer Status Replacement ChoroplethLayer Deprecated GeoJsonLayer ,  PolygonLayer  and  PathLayer ChoroplethLayer64 Deprecated GeoJsonLayer ,  PolygonLayer  and  PathLayer ExtrudedChoroplethLayer Deprecated GeoJsonLayer ,  PolygonLayer  and  PathLayer EnhancedChoroplethLayer Moved to examples PathLayer ChoroplethLayer, ChoroplethLayer64, ExtrudedChoroplethLayer These set of layers are deprecated in deck.gl v4, with their functionality completely substituted by more unified, flexible and performant new layers:\n  GeoJsonLayer ,  PolygonLayer  and  PathLayer . Developers should be able to just supply the same geojson data that are used with  ChoroplethLayer s to the new  GeoJsonLayer . The props of the  GeoJsonLayer  are a bit different from the old  ChoroplethLayer , so proper testing is recommended to achieve satisfactory result. EnhancedChoroplethLayer This was a a sample layer in deck.gl v3 and has now been moved to a stand-alone example and is no longer exported from the deck.gl npm module. Developers can either copy this layer from the example folder into their application's source tree, or consider using the new  PathLayer  which also handles wide lines albeit in a slightly different way. Removed, Changed and Deprecated Layer Properties Layer Old Prop New Prop Comment Layer dataIterator N/A Prop was not functional in v3 ScatterplotLayer radius radiusScale Default has changed from 30 to 1 ScatterplotLayer drawOutline outline ScreenGridLayer unitWidth cellSizePixels ScreenGridLayer unitHeight cellSizePixels Note about  strokeWidth  props All line based layers ( LineLayer and  ArcLayer and the ScatterplotLayer in outline mode) now use use shaders to render an exact pixel thickness on lines, instead of using the GL.LINE` drawing mode. This particular change was caused by browsers dropping support for this feature ( Chrome  and  Firefox ). Also  GL.LINE  mode rendering always had significant limitations in terms of lack of support for mitering, unreliable support for anti-aliasing and platform dependent line width limits so this should represent an improvement in visual quality and consistency for these layers. Removed prop:  Layer.dataIterator This prop has been removed in deck.gl v4. Note that it was not functioning as documented in deck.gl v3. Renamed Props: The  ...Scale  suffix Props that have their name end of  Scale  is a set of props that multiply some existing value for all objects in the layers. These props usually correspond to WebGL shader uniforms that \"scaling\" all values of specific attributes simultaneously. For API consistency reasons these have all been renamed with the suffix  ..Scale . See the property table above. Removed lifecycle method:  Layer.willReceiveProps This lifecycle was deprecated in v3 and is now removed in v4. Use  Layer.updateState  instead. Changes to  updateTriggers Update triggers can now be specified by referring to the name of the accessor, instead of the name of the actual WebGL attribute. Note that this is supported on all layers supplied by deck.gl v4, but if you are using older layers, they need a small addition to their attribute definitions to specify the name of the accessor. AttributeManager changes Removed method:  AttributeManager.setLogFunctions Use the new static function  AttributeManager.setDefaultLogFunctions  to set loggers for all AttributeManagers (i.e. for all layers). Removed method:  AttributeManager.addDynamic This method has been deprecated since version 2.5 and is now removed in v4. Use  AttributeManager.add()  instead.","headings":[{"value":"Upgrade Guide","depth":1},{"value":"Upgrading from deck.gl v8.7 to v8.8","depth":2},{"value":"Breaking changes","depth":4},{"value":"CARTO","depth":4},{"value":"Upgrading from deck.gl v8.6 to v8.7","depth":2},{"value":"Deprecations","depth":4},{"value":"Core","depth":5},{"value":"CARTO","depth":5},{"value":"Upgrading from deck.gl v8.5 to v8.6","depth":2},{"value":"Changes to layer prop defaults","depth":3},{"value":"Meter size projection","depth":3},{"value":"Layer filtering","depth":3},{"value":"Upgrading from deck.gl v8.4 to v8.5","depth":2},{"value":"Transpilation","depth":3},{"value":"Layers","depth":3},{"value":"Breaking changes","depth":4},{"value":"Deprecations","depth":4},{"value":"onError Callback","depth":3},{"value":"loaders.gl v3.0","depth":3},{"value":"OrbitView","depth":3},{"value":"Upgrading from deck.gl v8.3 to v8.4","depth":2},{"value":"wrapLongitude","depth":3},{"value":"pickingInfo","depth":3},{"value":"Layers","depth":3},{"value":"Upgrading from deck.gl v8.2 to v8.3","depth":2},{"value":"Upgrading from deck.gl v8.1 to v8.2","depth":2},{"value":"Upgrading from deck.gl v8.0 to v8.1","depth":2},{"value":"Breaking Changes","depth":3},{"value":"Tile3DLayer","depth":5},{"value":"Upgrading from deck.gl v7.x to v8.0","depth":2},{"value":"Breaking Changes","depth":3},{"value":"Defaults","depth":5},{"value":"Removed","depth":5},{"value":"React","depth":5},{"value":"Debugging","depth":5},{"value":"Standalone bundle","depth":5},{"value":"Textures","depth":5},{"value":"projection system","depth":5},{"value":"Shader modules","depth":5},{"value":"Auto view state update","depth":5},{"value":"Upgrading from deck.gl v7.2 to v7.3","depth":2},{"value":"Core","depth":4},{"value":"Layers","depth":4},{"value":"@deck.gl/json","depth":4},{"value":"Upgrading from deck.gl v7.1 to v7.2","depth":2},{"value":"Breaking Changes","depth":4},{"value":"Layer methods","depth":5},{"value":"fp64 prop","depth":5},{"value":"Color Attributes and Uniforms","depth":5},{"value":"project64 Shader Module","depth":5},{"value":"CPU Grid layer and Hexagon layer updateTriggers","depth":4},{"value":"Deprecations","depth":4},{"value":"Upgrading from deck.gl v7.0 to v7.1","depth":2},{"value":"Breaking Changes","depth":4},{"value":"Deprecations","depth":4},{"value":"Upgrading from deck.gl v6.4 to v7.0","depth":2},{"value":"Submodule Structure and Dependency Changes","depth":4},{"value":"Deck Class","depth":4},{"value":"Layers","depth":4},{"value":"Lighting","depth":4},{"value":"Views","depth":4},{"value":"project Shader Module","depth":4},{"value":"React","depth":4},{"value":"Upgrading from deck.gl v6.3 to v6.4","depth":2},{"value":"OrthographicView","depth":4},{"value":"ScatterplotLayer","depth":4},{"value":"GeoJsonLayer","depth":4},{"value":"Upgrading from deck.gl v6.2 to v6.3","depth":2},{"value":"GridLayer and HexagonLayer","depth":4},{"value":"Prop Types in Custom Layers","depth":4},{"value":"Upgrading from deck.gl v6.1 to v6.2","depth":2},{"value":"fp64","depth":4},{"value":"Upgrading from deck.gl v5.3 to v6.0","depth":2},{"value":"luma.gl v6.0","depth":4},{"value":"Pixel sizes","depth":4},{"value":"Accessors","depth":4},{"value":"Views and Controllers","depth":4},{"value":"ScreenGridLayer","depth":4},{"value":"Shader Modules","depth":4},{"value":"Attribute","depth":4},{"value":"Upgrading from deck.gl v5.2 to v5.3","depth":2},{"value":"Viewport classes","depth":3},{"value":"Layer properties","depth":3},{"value":"Pure JS applications","depth":3},{"value":"Upgrading from deck.gl v5.1 to v5.2","depth":2},{"value":"DeckGL component","depth":3},{"value":"Viewport classes","depth":3},{"value":"Experimental Features","depth":3},{"value":"Upgrading from deck.gl v5 to v5.1","depth":2},{"value":"Upgrading from deck.gl v4.1 to v5","depth":2},{"value":"Dependencies","depth":3},{"value":"Layer Props","depth":3},{"value":"DeckGL component","depth":3},{"value":"Removed picking Uniforms","depth":3},{"value":"Initial WebGL State","depth":3},{"value":"assembleShaders","depth":3},{"value":"Removed Immutable support","depth":3},{"value":"Upgrading from deck.gl v4 to v4.1","depth":2},{"value":"Dependencies","depth":3},{"value":"Layer Life Cycle Optimization","depth":3},{"value":"luma.gl Model class API change","depth":3},{"value":"Shader Assembly","depth":3},{"value":"Removed Layers","depth":3},{"value":"Upgrading from deck.gl v3 to v4","depth":2},{"value":"Changed Import: The DeckGL React component","depth":3},{"value":"Deprecated/Removed Layers","depth":3},{"value":"Removed, Changed and Deprecated Layer Properties","depth":3},{"value":"Note about strokeWidth props","depth":4},{"value":"Removed prop: Layer.dataIterator","depth":4},{"value":"Renamed Props: The ...Scale suffix","depth":4},{"value":"Removed lifecycle method: Layer.willReceiveProps","depth":4},{"value":"Changes to updateTriggers","depth":4},{"value":"AttributeManager changes","depth":3},{"value":"Removed method: AttributeManager.setLogFunctions","depth":4},{"value":"Removed method: AttributeManager.addDynamic","depth":4}],"slug":"docs/upgrade-guide","title":"Upgrade Guide"},{"excerpt":"ContourLayer The  ContourLayer  aggregates data into iso-lines or iso-bands for a given threshold and cell size.  Isoline  represents collection of line segments that separate the area above and below a given threshold.  Isoband  represents a collection of polygons (filled) that fill the area containing values in a given threshold range. To generate an  Isoline  single threshold value is needed, to generate an  Isoband  an Array with two values needed. Data is first aggregated using given cell size and resulting scalar field is used to run  Marching Squares  algorithm that generates a set of vertices to form Isolines or Isobands. In below documentation  Isoline  and  Isoband  is referred as  contour . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Render Options cellSize  (Number, optional)  Default:  1000 Size of each cell in meters gpuAggregation  (bool, optional) Default: true When set to true and browser supports GPU aggregation, aggregation is performed on GPU. GPU aggregation can be 2 to 3 times faster depending upon number of points and number of cells. NOTE: GPU Aggregation requires WebGL2 support by the browser. When  gpuAggregation  is set to true and browser doesn't support WebGL2, aggregation falls back to CPU. aggregation  (String, optional) Default: 'SUM' Defines the type of aggregation operation, valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'. When no value or an invalid value is set, 'SUM' is used as aggregation. SUM : Grid cell contains sum of all weights that fall into it. MEAN : Grid cell contains mean of all weights that fall into it. MIN : Grid cell contains minimum of all weights that fall into it. MAX : Grid cell contains maximum of all weights that fall into it. contours  (Array, optional) Default:  [{threshold: 1}] Array of objects with following keys threshold  (Number or Array) : Isolines:  threshold  value must be a single  Number , Isolines are generated based on this threshold value. Isobands:  threshold  value must be an Array of two  Number s. Isobands are generated using  [threshold[0], threshold[1])  as threshold range, i.e area that has values  >= threshold[0]  and  < threshold[1]  are rendered with corresponding color. NOTE:  threshold[0]  is inclusive and  threshold[1]  is not inclusive. color  (Array, optional) : RGBA color array to be used to render the contour, if not specified a default value of  [255, 255, 255, 255]  is used. When a three component RGB array specified, a default value of 255 is used for Alpha. strokeWidth  (Number, optional) : Applicable for  Isoline s only, width of the Isoline in pixels, if not specified a default value of  1  is used. zIndex  (Number, optional) : Defines z order of the contour. Contour with higher  zIndex  value is rendered above contours with lower  zIndex  values. When visualizing overlapping contours,  zIndex  along with  zOffset  (defined below) can be used to precisely layout contours. This also avoids z-fighting rendering issues. If not specified a unique value from  0  to  n  (number of contours) is assigned. NOTE: Like any other layer prop, a shallow comparison is performed on  contours  prop to determine if it is changed. This prop should be set to an array object, that changes only when contours need to be changed. zOffset  (Number, optional) Default:  0.005 A very small z offset that is added for each vertex of a contour (Isoline or Isoband). This is needed to control the layout of contours, especially when rendering overlapping contours. Imagine a case where an Isoline is specified which is overlapped with an Isoband. To make sure the Isoline is visible we need to render this above the Isoband. Data Accessors getPosition  ( Function , optional) Default:  object => object.position Method called to retrieve the position of each object. getWeight  ( Function , optional) Default:  1 The weight of each object. If a number is provided, it is used as the weight for all objects. If a function is provided, it is called on each object to retrieve its weight. Sub Layers The  ContourLayer  renders the following sublayers: lines  - For Isolines, rendered by  LineLayer bands  - For Isobands, rendered by  SolidPolygonLayer Source modules/aggregation-layers/src/contour-layer","headings":[{"value":"ContourLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"cellSize (Number, optional) transition-enabled","depth":5},{"value":"gpuAggregation (bool, optional)","depth":5},{"value":"aggregation (String, optional)","depth":5},{"value":"contours (Array, optional)","depth":5},{"value":"zOffset (Number, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional)","depth":5},{"value":"getWeight (Function, optional)","depth":5},{"value":"Sub Layers","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/aggregation-layers/contour-layer","title":"ContourLayer"},{"excerpt":"AggregationLayer All of the layers in  @deck.gl/aggregation-layers  module perform some sort of data aggregation. All these layers perform aggregation with different parameters (CPU vs GPU, aggregation to rectangular bins vs hexagon bins, world space vs screen space, aggregation of single weight vs multiple weights etc). AggregationLayer  and  GridAggregationLayer  perform most of the common tasks for aggregation with flexibility of customizations. This document describes what  AggregationLayer  does and how to use it in other aggregation layers. AggregationLayer  is subclassed form  CompositeLayer  and all layers in  @deck.gl/aggregation-layers  are subclassed from this Layer. Integration with  AttributeManager This layer creates  AttributeManager  and makes it available for its subclasses. Any aggregation layer can add attributes to the  AttributeManager  and retrieve them using  getAttributes  method. This enables using  AttributeManager 's features and optimization for using attributes. Also manual iteration of  data  prop can be removed and attributes can be directly set on GPU aggregation models or accessed directly for CPU aggregation. Example: Adding attributes to an aggregation layer updateState() During update state, Subclasses of  AggregationLayer  must first call 'super.updateState()', which calls updateShaders(shaders)  : Subclasses can override this if they need to update shaders, for example, when performing GPU aggregation, aggregation shaders must be merged with argument of this function  to correctly apply  extensions . _updateAttributes : This checks and updates attributes based on updated props. Checking if aggregation is dirty Dimensions Typical aggregation, involves : Group the input data points into bins Compute the aggregated value for each bin For example, when  cellSize  or  data  is changed, layer needs to perform both  1  and  2  steps, when a parameter affecting a bin's value is changed (like  getWeight  accessor), layer only need to perform step  2 . When doing CPU Aggregation, both above steps are performed individually. But for GPU aggregation, both are merged into single render call. To support what state is dirty, constructor takes  dimensions  object, which contains, several keyed dimensions. It must contain  data  dimension that defines, when re-aggregation needs to be performed. isAggregationDirty() This helper can be used if a dimension is changed. Sublayers can defined custom dimensions and call this method to check if a dimension is changed. isAttributeChanged() AggregationLayer  tracks what attributes are changed in each update cycle. Super classes can use  isAttributeChanged()  method to check if a specific attribute is changed or any attribute is changed.","headings":[{"value":"AggregationLayer","depth":1},{"value":"Integration with AttributeManager","depth":2},{"value":"updateState()","depth":2},{"value":"Checking if aggregation is dirty","depth":2},{"value":"Dimensions","depth":3},{"value":"isAggregationDirty()","depth":3},{"value":"isAttributeChanged()","depth":3}],"slug":"docs/api-reference/aggregation-layers/aggregation-layer","title":"AggregationLayer"},{"excerpt":"GridAggregationLayer This layer performs some common tasks required to perform aggregation to grid cells, especially it takes care of deciding CPU vs GPU aggregation, allocating resources for GPU aggregation and uploading results. This in an abstract layer, subclassed form  AggregationLayer ,  GPUGridLayer ,  ScreenGridLayer  and  ContourLayer  are subclassed from this layer. updateState() During  updateState() , it calls  updateAggregationState()  which sub classes must implement. During this method, sub classes must set following aggregation flags and aggregation params. Aggregation Flags gpuAggregation : When  true  aggregation happens on GPU, otherwise on CPU. aggregationDataDirty  : When  true  data is re-aggregated. aggregationWeightsDirty  : This flag is applicable only for CPU aggregation. When  true , bin's aggregated values are re computed. Aggregation Parameters gridOffset  : Grid's cell size in the format {xOffset, yOffset}. projectPoints  : Should be  true  when doing screen space aggregation, when  false  it implies world space aggregation. attributes  : Layer's current set of attributes which provide position and weights to CPU/GPU aggregators. viewport  : current viewport object. posOffset  : Offset to be added to object's position before aggregating. boundingBox  : Bounding box of the input data.\nFollowing are applicable for GPU aggregation only: translation  :  xTranslation, yTranslation , position translation to be applied on positions. scaling  :  xScale, yScale, flag , scaling to be applied on positions. When scaling not needed  flag  should be set to  0 . vertexCount  : Number of objects to be aggregated. moduleSettings  : Object with set of fields required for applying shader modules. updateResults() When aggregation performed on CPU, aggregation result is in JS Array objects. Subclasses can override this method to consume aggregation data. This method is called with an object with following fields: aggregationData  ( Float32Array ) - Array containing aggregation data per grid cell. Four elements per grid cell in the format  [value, 0, 0, count] , where  value  is the aggregated weight value, up to 3 different weights.  count  is the number of objects aggregated to the grid cell. maxMinData  ( Float32Array ) - Array with four values in format,  [maxValue, 0, 0, minValue] , where  maxValue  is max of all aggregated cells. maxData  ( Float32Array ) - Array with four values in format,  [maxValue, 0, 0, count] , where  maxValue  is max of all aggregated cells and  count  is total number aggregated objects. minData  ( Float32Array ) - Array with four values in format,  [minValue, 0, 0, count] , where  minValue  is min of all aggregated cells and  count  is total number aggregated objects. NOTE: The goal is to match format of CPU aggregation results to that of GPU aggregation, so consumers of this data (Sublayers) don't have to change. allocateResources() Called with following arguments to allocated resources required to hold aggregation results. numRow  ( Number ) - Number of rows in the grid. numCol  ( Number ) - Number of columns in the grid.","headings":[{"value":"GridAggregationLayer","depth":1},{"value":"updateState()","depth":2},{"value":"Aggregation Flags","depth":3},{"value":"Aggregation Parameters","depth":2},{"value":"updateResults()","depth":2},{"value":"allocateResources()","depth":2}],"slug":"docs/api-reference/aggregation-layers/grid-aggregation-layer","title":"GridAggregationLayer"},{"excerpt":"CPUGridLayer The  CPUGridLayer  aggregates data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. Aggregation is performed on CPU. CPUGridLayer  is one of the sublayers for  GridLayer , and is provided to customize CPU Aggregation for advanced use cases. For any regular use case,  GridLayer  is recommended. CPUGridLayer  is a  CompositeLayer . Note:  The  CPUGridLayer  at the moment only works with  COORDINATE_SYSTEM.LNGLAT . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  and  CompositeLayer  properties. Render Options cellSize  (Number, optional)  Default:  1000 Size of each cell in meters colorDomain  (Array, optional) Default:  [min(colorWeight), max(colorWeight)] Color scale domain, default is set to the extent of aggregated weights in each cell.\nYou can control how the colors of cells are mapped to weights by passing in an arbitrary color domain.\nThis is useful when you want to render different data input with the same color mapping for comparison. colorRange  (Array, optional) Default:  colorbrewer   6-class YlOrRd   Specified as an array of colors  color1, color2, ... . Each color is an array of 3 or 4 values  R, G, B  or  R, G, B, A , representing intensities of Red, Green, Blue and Alpha channels.  Each intensity is a value between 0 and 255. When Alpha not provided a value of 255 is used. colorDomain  is divided into  colorRange.length  equal segments, each mapped to one color in  colorRange . coverage  (Number, optional)  Default:  1 Cell size multiplier, clamped between 0 - 1. The displayed size of cell is calculated by  coverage * cellSize .\nNote: coverage does not affect how objects are binned. elevationDomain  (Array, optional) Default:  [0, max(elevationWeight)] Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\nYou can control how the elevations of cells are mapped to weights by passing in an arbitrary elevation domain.\nThis is useful when you want to render different data input with the same elevation scale for comparison. elevationRange  (Array, optional) Default:  [0, 1000] Elevation scale output range elevationScale  (Number, optional)  Default:  1 Cell elevation multiplier.\nThis is a handy property to scale all cells without updating the data. extruded  (Boolean, optional) Default:  true Whether to enable cell elevation. If set to false, all cell will be flat. upperPercentile  (Number, optional)  Default:  100 Filter cells and re-calculate color by  upperPercentile . Cells with value\nlarger than the upperPercentile will be hidden. lowerPercentile  (Number, optional)  Default:  0 Filter cells and re-calculate color by  lowerPercentile . Cells with value\nsmaller than the lowerPercentile will be hidden. elevationUpperPercentile  (Number, optional)  Default:  100 Filter cells and re-calculate elevation by  elevationUpperPercentile . Cells with elevation value\nlarger than the elevationUpperPercentile will be hidden. elevationLowerPercentile  (Number, optional)  Default:  0 Filter cells and re-calculate elevation by  elevationLowerPercentile . Cells with elevation value\nsmaller than the elevationLowerPercentile will be hidden. colorScaleType  (String, optional) Default: 'quantize' Scaling function used to determine the color of the grid cell, default value is 'quantize'. Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'. material  (Object, optional) Default:  true This is an object that contains material props for  lighting effect  applied on extruded polygons.\nCheck  the lighting guide  for configurable settings. colorAggregation  (String, optional) Default: 'SUM' Defines the operation used to aggregate all data object weights to calculate a cell's color value. Valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'. 'SUM' is used when an invalid value is provided. getColorWeight  and  colorAggregation  together determine the elevation value of each cell. If the  getColorValue  prop is supplied, they will be ignored. Example 1 : Using count of data elements that fall into a cell to encode the its color Using  getColorValue Using  getColorWeight  and  colorAggregation Example 2 : Using mean value of 'SPACES' field of data elements to encode the color of the cell Using  getColorValue Using  getColorWeight  and  colorAggregation If your use case requires aggregating using an operation that is not one of 'SUM', 'MEAN', 'MAX' and 'MIN',  getColorValue  should be used to define such custom aggregation function. elevationAggregation  (String, optional) Default: 'SUM' Defines the operation used to aggregate all data object weights to calculate a cell's elevation value. Valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'. 'SUM' is used when an invalid value is provided. getElevationWeight  and  elevationAggregation  together determine the elevation value of each cell. If the  getElevationValue  prop is supplied, they will be ignored. Example 1 : Using count of data elements that fall into a cell to encode the its elevation Using  getElevationValue Using  getElevationWeight  and  elevationAggregation Example 2 : Using maximum value of 'SPACES' field of data elements to encode the elevation of the cell Using  getElevationValue Using  getElevationWeight  and  elevationAggregation If your use case requires aggregating using an operation that is not one of 'SUM', 'MEAN', 'MAX' and 'MIN',  getElevationValue  should be used to define such custom aggregation function. Data Accessors getPosition  ( Function , optional) Default:  object => object.position Method called to retrieve the position of each object. getColorWeight  (Function, optional)  Default:  1 The weight of a data object used to calculate the color value for a cell. If a number is provided, it is used as the weight for all objects. If a function is provided, it is called on each object to retrieve its weight. getColorValue  (Function, optional)  Default:  null After data objects are aggregated into cells, this accessor is called on each cell to get the value that its color is based on. If supplied, this will override the effect of  getColorWeight  and  colorAggregation  props. Arguments: objects  (Array) - a list of objects whose positions fall inside this cell. objectInfo  (Object) - contains the following fields: indices  (Array) - the indices of  objects  in the original data data  - the value of the  data  prop. getElevationWeight  (Function, optional)  Default:  1 The weight of a data object used to calculate the elevation value for a cell. If a number is provided, it is used as the weight for all objects. If a function is provided, it is called on each object to retrieve its weight. getElevationValue  (Function, optional)  Default:  null After data objects are aggregated into cells, this accessor is called on each cell to get the value that its elevation is based on. If supplied, this will override the effect of  getElevationWeight  and  elevationAggregation  props. Arguments: objects  (Array) - a list of objects whose positions fall inside this cell. objectInfo  (Object) - contains the following fields: indices  (Array) - the indices of  objects  in the original data data  - the value of the  data  prop. Callbacks onSetColorDomain  (Function, optional) Default:  ([min, max]) => {} This callback will be called when cell color domain has been calculated. onSetElevationDomain  (Function, optional) Default:  ([min, max]) => {} This callback will be called when cell elevation domain has been calculated. Sub Layers The CPUGridLayer renders the following sublayers: grid-cell  - a  GridCellLayer  rendering the aggregated columns. Source modules/aggregation-layers/src/cpu-grid-layer","headings":[{"value":"CPUGridLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"cellSize (Number, optional) transition-enabled","depth":5},{"value":"colorDomain (Array, optional)","depth":5},{"value":"colorRange (Array, optional)","depth":5},{"value":"coverage (Number, optional) transition-enabled","depth":5},{"value":"elevationDomain (Array, optional)","depth":5},{"value":"elevationRange (Array, optional)","depth":5},{"value":"elevationScale (Number, optional) transition-enabled","depth":5},{"value":"extruded (Boolean, optional)","depth":5},{"value":"upperPercentile (Number, optional) transition-enabled","depth":5},{"value":"lowerPercentile (Number, optional) transition-enabled","depth":5},{"value":"elevationUpperPercentile (Number, optional) transition-enabled","depth":5},{"value":"elevationLowerPercentile (Number, optional) transition-enabled","depth":5},{"value":"colorScaleType (String, optional)","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"colorAggregation (String, optional)","depth":5},{"value":"Example 1 : Using count of data elements that fall into a cell to encode the its color","depth":6},{"value":"Example 2 : Using mean value of 'SPACES' field of data elements to encode the color of the cell","depth":6},{"value":"elevationAggregation (String, optional)","depth":5},{"value":"Example 1 : Using count of data elements that fall into a cell to encode the its elevation","depth":6},{"value":"Example 2 : Using maximum value of 'SPACES' field of data elements to encode the elevation of the cell","depth":6},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional)","depth":5},{"value":"getColorWeight (Function, optional) transition-enabled","depth":5},{"value":"getColorValue (Function, optional) transition-enabled","depth":5},{"value":"getElevationWeight (Function, optional) transition-enabled","depth":5},{"value":"getElevationValue (Function, optional) transition-enabled","depth":5},{"value":"Callbacks","depth":3},{"value":"onSetColorDomain (Function, optional)","depth":5},{"value":"onSetElevationDomain (Function, optional)","depth":5},{"value":"Sub Layers","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/aggregation-layers/cpu-grid-layer","title":"CPUGridLayer"},{"excerpt":"GPUGridLayer (WebGL2) The  GPUGridLayer  aggregates data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. This layer performs aggregation on GPU hence not supported in non WebGL2 browsers. GPUGridLayer  is one of the sublayers for  GridLayer  and is only supported when using  WebGL2  enabled browsers. It is provided to customize GPU Aggregation for advanced use cases. For any regular use case,  GridLayer  is recommended. GPUGridLayer  is a  CompositeLayer . Note:  The  GPUGridLayer  at the moment only works with  COORDINATE_SYSTEM.LNGLAT . Note:  GPU Aggregation is faster only when using large data sets (data size is more than 500K), for smaller data sets GPU Aggregation could be potentially slower than CPU Aggregation. Note:  This layer is similar to  CPUGridLayer  but performs aggregation on GPU. Check below for more detailed differences of this layer compared to  CPUGridLayer . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  and  CompositeLayer  properties. Render Options cellSize  (Number, optional)  Default:  1000 Size of each cell in meters. Must be greater than  0 . colorDomain  (Array, optional) Default:  [min(colorWeight), max(colorWeight)] Color scale domain, default is set to the extent of aggregated weights in each cell.\nYou can control how the colors of cells are mapped to weights by passing in an arbitrary color domain.\nThis is useful when you want to render different data input with the same color mapping for comparison. colorRange  (Array, optional) Default:  colorbrewer   6-class YlOrRd   Specified as an array of colors  color1, color2, ... . Each color is an array of 3 or 4 values  R, G, B  or  R, G, B, A , representing intensities of Red, Green, Blue and Alpha channels.  Each intensity is a value between 0 and 255. When Alpha not provided a value of 255 is used. colorDomain  is divided into  colorRange.length  equal segments, each mapped to one color in  colorRange . coverage  (Number, optional)  Default:  1 Cell size multiplier, clamped between 0 - 1. The displayed size of cell is calculated by  coverage * cellSize .\nNote: coverage does not affect how objects are binned. elevationDomain  (Array, optional) Default:  [0, max(elevationWeight)] Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\nYou can control how the elevations of cells are mapped to weights by passing in an arbitrary elevation domain.\nThis is useful when you want to render different data input with the same elevation scale for comparison. elevationRange  (Array, optional) Default:  [0, 1000] Elevation scale output range elevationScale  (Number, optional)  Default:  1 Cell elevation multiplier.\nThis is a handy property to scale the height of all cells without updating the data. extruded  (Boolean, optional) Default:  true Whether to enable cell elevation. If set to false, all cell will be flat. material  (Object, optional) Default:  true This is an object that contains material props for  lighting effect  applied on extruded polygons.\nCheck  the lighting guide  for configurable settings. colorAggregation  (String, optional) Default: 'SUM' Defines the operation used to aggregate all data object weights to calculate a cell's color value. Valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'. 'SUM' is used when an invalid value is provided. getColorWeight  and  colorAggregation  together determine the elevation value of each cell. elevationAggregation  (String, optional) Default: 'SUM' Defines the operation used to aggregate all data object weights to calculate a cell's elevation value. Valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'. 'SUM' is used when an invalid value is provided. getElevationWeight  and  elevationAggregation  together determine the elevation value of each cell. Data Accessors getPosition  ( Function , optional) Default:  object => object.position Method called to retrieve the position of each object. getColorWeight  (Function, optional)  Default:  1 The weight of a data object used to calculate the color value for a cell. If a number is provided, it is used as the weight for all objects. If a function is provided, it is called on each object to retrieve its weight. getElevationWeight  (Function, optional)  Default:  1 The weight of a data object used to calculate the elevation value for a cell. If a number is provided, it is used as the weight for all objects. If a function is provided, it is called on each object to retrieve its weight. Differences compared to CPUGridLayer Unsupported props Due to the nature of GPU Aggregation implementation following CPUGridLayer props are not supported by this layer. upperPercentile   lowerPercentile   elevationUpperPercentile ,  elevationLowerPercentile ,  getColorValue ,  getElevationValue ,  onSetColorDomain  and  onSetElevationDomain Instead of  getColorValue ,  getColorWeight  and  colorAggregation  should be used. Instead of  getElevationValue ,  getElevationWeight  and  elevationAggregation  should be used. There is no alternate for all other unsupported props, if they are needed  CPUGridLayer  should be used instead of this layer. Picking When picking mode is  hover , only the elevation value, color value of selected cell are included in picking result. Array of all objects that aggregated into that cell is not provided. For all other modes, picking results match with  CPUGridLayer , for these cases data is aggregated on CPU to provide array of all objects that aggregated to the cell. Source modules/aggregation-layers/src/gpu-grid-layer","headings":[{"value":"GPUGridLayer (WebGL2)","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"cellSize (Number, optional) transition-enabled","depth":5},{"value":"colorDomain (Array, optional)","depth":5},{"value":"colorRange (Array, optional)","depth":5},{"value":"coverage (Number, optional) transition-enabled","depth":5},{"value":"elevationDomain (Array, optional)","depth":5},{"value":"elevationRange (Array, optional)","depth":5},{"value":"elevationScale (Number, optional) transition-enabled","depth":5},{"value":"extruded (Boolean, optional)","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"colorAggregation (String, optional)","depth":5},{"value":"elevationAggregation (String, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional)","depth":5},{"value":"getColorWeight (Function, optional) transition-enabled","depth":5},{"value":"getElevationWeight (Function, optional) transition-enabled","depth":5},{"value":"Differences compared to CPUGridLayer","depth":2},{"value":"Unsupported props","depth":3},{"value":"Picking","depth":3},{"value":"Source","depth":2}],"slug":"docs/api-reference/aggregation-layers/gpu-grid-layer","title":"GPUGridLayer (WebGL2)"},{"excerpt":"GridLayer The  GridLayer  aggregates data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. This layer renders either a  GPUGridLayer  or a  CPUGridLayer , depending on its props and whether GPU aggregation is supported. For more details check the  GPU Aggregation  section below. GridLayer  is a  CompositeLayer . Note:  The  GridLayer  at the moment only works with  COORDINATE_SYSTEM.LNGLAT . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  and  CompositeLayer  properties. Render Options cellSize  (Number, optional) Default:  1000 Size of each cell in meters colorDomain  (Array, optional) Default:  [min(colorWeight), max(colorWeight)] Color scale domain, default is set to the extent of aggregated weights in each cell.\nYou can control how the colors of cells are mapped to weights by passing in an arbitrary color domain.\nThis is useful when you want to render different data input with the same color mapping for comparison. colorRange  (Array, optional) Default:  colorbrewer   6-class YlOrRd   Specified as an array of colors  color1, color2, ... . Each color is an array of 3 or 4 values  R, G, B  or  R, G, B, A , representing intensities of Red, Green, Blue and Alpha channels.  Each intensity is a value between 0 and 255. When Alpha not provided a value of 255 is used. colorDomain  is divided into  colorRange.length  equal segments, each mapped to one color in  colorRange . coverage  (Number, optional)  Default:  1 Cell size multiplier, clamped between 0 - 1. The displayed size of cell is calculated by  coverage * cellSize .\nNote: coverage does not affect how objects are binned. elevationDomain  (Array, optional) Default:  [0, max(elevationWeight)] Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\nYou can control how the elevations of cells are mapped to weights by passing in an arbitrary elevation domain.\nThis is useful when you want to render different data input with the same elevation scale for comparison. elevationRange  (Array, optional) Default:  [0, 1000] Elevation scale output range elevationScale  (Number, optional)  Default:  1 Cell elevation multiplier.\nThis is a handy property to scale all cells without updating the data. extruded  (Boolean, optional) Default:  true Whether to enable cell elevation.If set to false, all cell will be flat. upperPercentile  (Number, optional)  Default:  100 Filter cells and re-calculate color by  upperPercentile . Cells with value\nlarger than the upperPercentile will be hidden. lowerPercentile  (Number, optional)  Default:  0 Filter cells and re-calculate color by  lowerPercentile . Cells with value\nsmaller than the lowerPercentile will be hidden. elevationUpperPercentile  (Number, optional)  Default:  100 Filter cells and re-calculate elevation by  elevationUpperPercentile . Cells with elevation value\nlarger than the elevationUpperPercentile will be hidden. elevationLowerPercentile  (Number, optional)  Default:  0 Filter cells and re-calculate elevation by  elevationLowerPercentile . Cells with elevation value\nsmaller than the elevationLowerPercentile will be hidden. colorScaleType  (String, optional) Default: 'quantize' Scaling function used to determine the color of the grid cell, default value is 'quantize'. Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'. fp64  (Boolean, optional) Default:  false Whether the aggregation should be performed in high-precision 64-bit mode. Note that since deck.gl v6.1, the default 32-bit projection uses a hybrid mode that matches 64-bit precision with significantly better performance. gpuAggregation  (bool, optional) Default:  false When set to true, aggregation is performed on GPU, provided other conditions are met, for more details check the  GPU Aggregation  section below. GPU aggregation can be a lot faster than CPU depending upon the number of objects and number of cells. Note:  GPU Aggregation is faster only when using large data sets. For smaller data sets GPU Aggregation could be potentially slower than CPU Aggregation. material  (Object, optional) Default:  true This is an object that contains material props for  lighting effect  applied on extruded polygons.\nCheck  the lighting guide  for configurable settings. colorAggregation  (String, optional) Default: 'SUM' Defines the operation used to aggregate all data object weights to calculate a cell's color value. Valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'. 'SUM' is used when an invalid value is provided. getColorWeight  and  colorAggregation  together determine the elevation value of each cell. If the  getColorValue  prop is supplied, they will be ignored. Note that supplying  getColorValue  disables GPU aggregation. Example 1 : Using count of data elements that fall into a cell to encode the its color Using  getColorValue Using  getColorWeight  and  colorAggregation Example 2 : Using mean value of 'SPACES' field of data elements to encode the color of the cell Using  getColorValue Using  getColorWeight  and  colorAggregation If your use case requires aggregating using an operation that is not one of 'SUM', 'MEAN', 'MAX' and 'MIN',  getColorValue  should be used to define such custom aggregation function. In those cases GPU aggregation is not supported. elevationAggregation  (String, optional) Default: 'SUM' Defines the operation used to aggregate all data object weights to calculate a cell's elevation value. Valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'. 'SUM' is used when an invalid value is provided. getElevationWeight  and  elevationAggregation  together determine the elevation value of each cell. If the  getElevationValue  prop is supplied, they will be ignored. Note that supplying  getElevationValue  disables GPU aggregation. Example 1 : Using count of data elements that fall into a cell to encode the its elevation Using  getElevationValue Using  getElevationWeight  and  elevationAggregation Example 2 : Using maximum value of 'SPACES' field of data elements to encode the elevation of the cell Using  getElevationValue Using  getElevationWeight  and  elevationAggregation If your use case requires aggregating using an operation that is not one of 'SUM', 'MEAN', 'MAX' and 'MIN',  getElevationValue  should be used to define such custom aggregation function. In those cases GPU aggregation is not supported. getElevationValue  (Function, optional)  Default:  null After data objects are aggregated into cells, this accessor is called on each cell to get the value that its elevation is based on. If supplied, this will override the effect of  getElevationWeight  and  elevationAggregation  props. Note that supplying this prop disables GPU aggregation. Arguments: objects  (Array) - a list of objects whose positions fall inside this cell. objectInfo  (Object) - contains the following fields: indices  (Array) - the indices of  objects  in the original data data  - the value of the  data  prop. Data Accessors getPosition  ( Function , optional) Default:  object => object.position Method called to retrieve the position of each object. getColorWeight  (Function, optional)  Default:  1 The weight of a data object used to calculate the color value for a cell. If a number is provided, it is used as the weight for all objects. If a function is provided, it is called on each object to retrieve its weight. getColorValue  (Function, optional)  Default:  null After data objects are aggregated into cells, this accessor is called on each cell to get the value that its color is based on. If supplied, this will override the effect of  getColorWeight  and  colorAggregation  props. Note that supplying this prop disables GPU aggregation. Arguments: objects  (Array) - a list of objects whose positions fall inside this cell. objectInfo  (Object) - contains the following fields: indices  (Array) - the indices of  objects  in the original data data  - the value of the  data  prop. getElevationWeight  (Function, optional)  Default:  1 The weight of a data object used to calculate the elevation value for a cell. If a number is provided, it is used as the weight for all objects. If a function is provided, it is called on each object to retrieve its weight. Callbacks onSetColorDomain  (Function, optional) Default:  ([min, max]) => {} This callback will be called when cell color domain has been calculated. onSetElevationDomain  (Function, optional) Default:  ([min, max]) => {} This callback will be called when cell elevation domain has been calculated. GPU Aggregation Performance Metrics The following table compares the performance between CPU and GPU aggregations using random data: #objects CPU #iterations/sec GPU #iterations/sec Notes 25K 535 359 GPU is  33%  slower 100K 119 437 GPU is  267%  faster 1M 12.7 158 GPU is  1144%  faster Numbers are collected on a 2016 15-inch Macbook Pro (CPU: 2.8 GHz Intel Core i7 and GPU: AMD Radeon R9 M370X 2 GB) Fallback Cases This layer performs aggregation on GPU when the browser is using  WebGL2  and the  gpuAggregation  prop is set to  true , but will fallback to CPU in the following cases: Percentile Props When following percentile props are set, it requires sorting of aggregated values, which cannot be supported when aggregating on GPU. lowerPercentile ,  upperPercentile ,  elevationLowerPercentile  and  elevationUpperPercentile . Color and Elevation Props When  colorScaleType  props is set to a 'quantile' or 'ordinal', aggregation will fallback to CPU. For GPU Aggregation, use 'quantize', 'linear'. Color Scale Type Props When following percentile props are set, it requires sorting of aggregated values, which cannot be supported when aggregating on GPU. lowerPercentile ,  upperPercentile ,  elevationLowerPercentile  and  elevationUpperPercentile . Domain setting callbacks When using GPU Aggregation,  onSetColorDomain  and  onSetElevationDomain  are not fired. Sub Layers The GridLayer renders the following sublayers: CPU  - a  CPUGridLayer  when using CPU aggregation. GPU  - a  GPUGridLayer  when using GPU aggregation. Source modules/aggregation-layers/src/grid-layer","headings":[{"value":"GridLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"cellSize (Number, optional)","depth":5},{"value":"colorDomain (Array, optional)","depth":5},{"value":"colorRange (Array, optional)","depth":5},{"value":"coverage (Number, optional) transition-enabled","depth":5},{"value":"elevationDomain (Array, optional)","depth":5},{"value":"elevationRange (Array, optional)","depth":5},{"value":"elevationScale (Number, optional) transition-enabled","depth":5},{"value":"extruded (Boolean, optional)","depth":5},{"value":"upperPercentile (Number, optional) transition-enabled","depth":5},{"value":"lowerPercentile (Number, optional) transition-enabled","depth":5},{"value":"elevationUpperPercentile (Number, optional) transition-enabled","depth":5},{"value":"elevationLowerPercentile (Number, optional) transition-enabled","depth":5},{"value":"colorScaleType (String, optional)","depth":5},{"value":"fp64 (Boolean, optional)","depth":5},{"value":"gpuAggregation (bool, optional)","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"colorAggregation (String, optional)","depth":5},{"value":"Example 1 : Using count of data elements that fall into a cell to encode the its color","depth":6},{"value":"Example 2 : Using mean value of 'SPACES' field of data elements to encode the color of the cell","depth":6},{"value":"elevationAggregation (String, optional)","depth":5},{"value":"Example 1 : Using count of data elements that fall into a cell to encode the its elevation","depth":6},{"value":"Example 2 : Using maximum value of 'SPACES' field of data elements to encode the elevation of the cell","depth":6},{"value":"getElevationValue (Function, optional) transition-enabled","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional)","depth":5},{"value":"getColorWeight (Function, optional) transition-enabled","depth":5},{"value":"getColorValue (Function, optional) transition-enabled","depth":5},{"value":"getElevationWeight (Function, optional) transition-enabled","depth":5},{"value":"Callbacks","depth":3},{"value":"onSetColorDomain (Function, optional)","depth":5},{"value":"onSetElevationDomain (Function, optional)","depth":5},{"value":"GPU Aggregation","depth":2},{"value":"Performance Metrics","depth":3},{"value":"Fallback Cases","depth":3},{"value":"Percentile Props","depth":4},{"value":"Color and Elevation Props","depth":4},{"value":"Color Scale Type Props","depth":4},{"value":"Domain setting callbacks","depth":3},{"value":"Sub Layers","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/aggregation-layers/grid-layer","title":"GridLayer"},{"excerpt":"HeatmapLayer HeatmapLayer  can be used to visualize spatial distribution of data. It internally implements  Gaussian Kernel Density Estimation  to render heatmaps. Note that this layer does not support all platforms; see \"limitations\" section below. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  and  CompositeLayer  properties. Render Options radiusPixels  (Number, optional)  Default:  30 Radius of the circle in pixels, to which the weight of an object is distributed. colorRange  (Array, optional) Default:  colorbrewer   6-class YlOrRd   The color palette used in the heatmap, as an array of colors  color1, color2, ... . Each color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. See the  colorDomain  section below for how weight values are mapped to colors in  colorRange . intensity  (Number, optional)  Default:  1 Value that is multiplied with the total weight at a pixel to obtain the final weight. A value larger than  1  biases the output color towards the higher end of the spectrum, and a value less than  1  biases the output color towards the lower end of the spectrum. threshold  (Number, optional)  Default:  0.05 The  HeatmapLayer  reduces the opacity of the pixels with relatively low weight to create a fading effect at the edge. A larger  threshold  smoothens the boundaries of color blobs, while making pixels with low relative weight harder to spot (due to low alpha value). threshold  is defined as the ratio of the fading weight to the max weight, between  0  and  1 . For example,  0.1  affects all pixels with weight under 10% of the max. threshold  is ignored when  colorDomain  is specified. colorDomain  (Array, optional)  Default:  null Controls how weight values are mapped to the  colorRange , as an array of two numbers  minValue ,  maxValue . When  colorDomain  is specified, a pixel with  minValue  is assigned the first color in  colorRange , a pixel with  maxValue  is assigned the last color in  colorRange , and any value in between is linearly interpolated. Pixels with weight less than  minValue  gradually fade out by reducing alpha, until 100% transparency representing  0 . Pixels with weight more than  maxValue  are capped to the last color in  colorRange . If using  aggregation: 'SUM' , values in  colorDomain  are interpreted as weight per square meter. If using  aggregation: 'MEAN' , values in  colorDomain  are interpreted as weight. When this prop is not specified, the maximum value is automatically determined from the current viewport, and the domain is set to  maxValue * threshold ,  maxValue . This default behavior ensures that the colors are distributed somewhat reasonably regardless of the data in display. However, as a result, the color at a specific location is dependent on the current viewport and any other data points within view. To obtain a stable color mapping (e.g. for displaying a legend), you need to provide a custom  colorDomain . aggregation  (String, optional) Default:  'SUM' Operation used to aggregate all data point weights to calculate a pixel's color value. One of  'SUM'  or  'MEAN' .  'SUM'  is used when an invalid value is provided. The weight of each data object is distributed to all the pixels in a circle centered at the object position. The weight that a pixel receives is inversely proportional to its distance from the center. In  'SUM'  mode, pixels that fall into multiple circles will have the sum of all weights. In  'MEAN'  mode, pixels that fall into multiple circles will have their weight calculated as the weighted average from all the neighboring data points. And the weight of the pixel determines its color.  weightsTextureSize  (Number, optional) Default:  2048 weightsTextureSize  specifies the size of weight texture. Smaller texture sizes can improve rendering performance. Heatmap aggregation calculates the maximum weight value in the texture and the process can take 50-100 ms for 2048x2048 texture, but only 5-7ms for 512x512 texture. Smaller texture sizes lead to visible pixelation. debounceTimeout  (Number, optional) Default:  500 debounceTimeout  is an interval in milliseconds during which changes to the viewport don't trigger aggregation. Large datasets combined with a large  radiusPixels  can cause freezes during user interactions due to aggregation updates. Setting positive debounceTimeout delays aggregation updates and prevents freezes during the interaction. As a side effect, the user has to wait to see updated results after the end of the interaction.  Data Accessors getPosition  ( Function , optional) Default:  object => object.position Method called to retrieve the position of each point. getWeight  ( Function , optional) Default:  1 Method called to retrieve weight of each point. By default each point will use a weight of  1 . Limitations The  HeatmapLayer  performs aggregation on the GPU. This feature is fully supported in evergreen desktop browsers, but limited in the following platforms due to partial WebGL support: iOS Safari: WebGL context does not support rendering to a float texture. The layer therefore falls back to an 8-bit low-precision mode, where weights must be integers and the accumulated weights in any pixel cannot exceed 255. Source modules/aggregation-layers/src/heatmap-layer","headings":[{"value":"HeatmapLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"radiusPixels (Number, optional) transition-enabled","depth":5},{"value":"colorRange (Array, optional)","depth":5},{"value":"intensity (Number, optional) transition-enabled","depth":5},{"value":"threshold (Number, optional) transition-enabled","depth":5},{"value":"colorDomain (Array, optional) transition-enabled","depth":5},{"value":"aggregation (String, optional)","depth":5},{"value":"weightsTextureSize (Number, optional)","depth":5},{"value":"debounceTimeout (Number, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional)","depth":5},{"value":"getWeight (Function, optional)","depth":5},{"value":"Limitations","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/aggregation-layers/heatmap-layer","title":"HeatmapLayer"},{"excerpt":"HexagonLayer The  HexagonLayer  aggregates data into a hexagon-based heatmap. The color and height of a hexagon are determined based on the objects it contains. HexagonLayer is a  CompositeLayer  and at the moment only works with  COORDINATE_SYSTEM.LNGLAT . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  and  CompositeLayer  properties. Render Options radius  (Number, optional)  Default:  1000 Radius of hexagon bin in meters. The hexagons are pointy-topped (rather than flat-topped). hexagonAggregator  (Function, optional) Default:  d3-hexbin hexagonAggregator  is a function to aggregate data into hexagonal bins.\nThe  hexagonAggregator  takes props of the layer and current viewport as arguments.\nThe output should be  {hexagons: [], hexagonVertices: []} .  hexagons  is\nan array of  {centroid: [], points: []} , where  centroid  is the\ncenter of the hexagon, and  points  is an array of points that contained by it.   hexagonVertices \n(optional) is an array of points define the primitive hexagon geometry. By default, the  HexagonLayer  uses\n d3-hexbin  as  hexagonAggregator ,\nsee  modules/layers/src/point-density-hexagon-layer/hexagon-aggregator colorDomain  (Array, optional) Default:  [min(colorWeight), max(colorWeight)] Color scale input domain. The color scale maps continues numeric domain into\ndiscrete color range. If not provided, the layer will set  colorDomain  to the\nextent of aggregated weights in each hexagon.\nYou can control how the colors of hexagons are mapped to weights by passing in an arbitrary color domain.\nThis is useful when you want to render different data input with the same color mapping for comparison. colorRange  (Array, optional) Default:  colorbrewer   6-class YlOrRd   Specified as an array of colors  color1, color2, ... . Each color is an array of 3 or 4 values  R, G, B  or  R, G, B, A , representing intensities of Red, Green, Blue and Alpha channels.  Each intensity is a value between 0 and 255. When Alpha not provided a value of 255 is used. colorDomain  is divided into  colorRange.length  equal segments, each mapped to one color in  colorRange . coverage  (Number, optional)  Default:  1 Hexagon radius multiplier, clamped between 0 - 1. The displayed radius of hexagon is calculated by  coverage * radius .\nNote: coverage does not affect how objects are binned. elevationDomain  (Array, optional) Default:  [0, max(elevationWeight)] Elevation scale input domain. The elevation scale is a linear scale that\nmaps number of counts to elevation. By default it is set to between\n0 and the max of aggregated weights in each hexagon.\nYou can control how the elevations of hexagons are mapped to weights by passing in an arbitrary elevation domain.\nThis property is useful when you want to render different data input\nwith the same elevation scale for comparison. elevationRange  (Array, optional) Default:  [0, 1000] Elevation scale output range elevationScale  (Number, optional)  Default:  1 Hexagon elevation multiplier. The actual elevation is calculated by\n   elevationScale * getElevationValue(d) .  elevationScale  is a handy property to scale\nall hexagons without updating the data. extruded  (Boolean, optional) Default:  false Whether to enable cell elevation. If set to false, all cells will be flat. upperPercentile  (Number, optional)  Default:  100 Filter bins and re-calculate color by  upperPercentile . Hexagons with color value\nlarger than the upperPercentile will be hidden. lowerPercentile  (Number, optional)  Default:  0 Filter bins and re-calculate color by  lowerPercentile . Hexagons with color value\nsmaller than the lowerPercentile will be hidden. elevationUpperPercentile  (Number, optional)  Default:  100 Filter bins and re-calculate elevation by  elevationUpperPercentile . Hexagons with elevation value\nlarger than the elevationUpperPercentile will be hidden. elevationLowerPercentile  (Number, optional)  Default:  0 Filter bins and re-calculate elevation by  elevationLowerPercentile . Hexagons with elevation value\nsmaller than the elevationLowerPercentile will be hidden. colorScaleType  (String, optional) Default: 'quantize' Scaling function used to determine the color of the grid cell, default value is 'quantize'. Supported Values are 'quantize', 'quantile' and 'ordinal'. material  (Object, optional) Default:  true This is an object that contains material props for  lighting effect  applied on extruded polygons.\nCheck  the lighting guide  for configurable settings. colorAggregation  (String, optional) Default: 'SUM' Defines the operation used to aggregate all data object weights to calculate a bin's color value. Valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'. 'SUM' is used when an invalid value is provided. getColorWeight  and  colorAggregation  together determine the elevation value of each bin. If the  getColorValue  prop is supplied, they will be ignored. Example 1 : Using count of data elements that fall into a bin to encode the its color Using  getColorValue Using  getColorWeight  and  colorAggregation Example 2 : Using mean value of 'SPACES' field of data elements to encode the color of the bin Using  getColorValue Using  getColorWeight  and  colorAggregation If your use case requires aggregating using an operation that is not one of 'SUM', 'MEAN', 'MAX' and 'MIN',  getColorValue  should be used to define such custom aggregation function. elevationAggregation  (String, optional) Default: 'SUM' Defines the operation used to aggregate all data object weights to calculate a bin's elevation value. Valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'. 'SUM' is used when an invalid value is provided. getElevationWeight  and  elevationAggregation  together determine the elevation value of each bin. If the  getElevationValue  prop is supplied, they will be ignored. Example 1 : Using count of data elements that fall into a bin to encode the its elevation Using  getElevationValue Using  getElevationWeight  and  elevationAggregation Example 2 : Using maximum value of 'SPACES' field of data elements to encode the elevation of the bin Using  getElevationValue Using  getElevationWeight  and  elevationAggregation If your use case requires aggregating using an operation that is not one of 'SUM', 'MEAN', 'MAX' and 'MIN',  getElevationValue  should be used to define such custom aggregation function. Data Accessors getPosition  ( Function , optional) Default:  object => object.position Method called to retrieve the position of each object. getColorWeight  (Function, optional)  Default:  1 The weight of a data object used to calculate the color value for a bin. If a number is provided, it is used as the weight for all objects. If a function is provided, it is called on each object to retrieve its weight. getColorValue  (Function, optional)  Default:  null After data objects are aggregated into bins, this accessor is called on each bin to get the value that its color is based on. If supplied, this will override the effect of  getColorWeight  and  colorAggregation  props. Arguments: objects  (Array) - a list of objects whose positions fall inside this cell. objectInfo  (Object) - contains the following fields: indices  (Array) - the indices of  objects  in the original data data  - the value of the  data  prop. getElevationWeight  (Function, optional)  Default:  1 The weight of a data object used to calculate the elevation value for a bin. If a number is provided, it is used as the weight for all objects. If a function is provided, it is called on each object to retrieve its weight. getElevationValue  (Function, optional)  Default:  null After data objects are aggregated into bins, this accessor is called on each bin to get the value that its elevation is based on. If supplied, this will override the effect of  getElevationWeight  and  elevationAggregation  props. Arguments: objects  (Array) - a list of objects whose positions fall inside this cell. objectInfo  (Object) - contains the following fields: indices  (Array) - the indices of  objects  in the original data data  - the value of the  data  prop. Callbacks onSetColorDomain  (Function, optional) Default:  ([min, max]) => {} This callback will be called when bin color domain has been calculated. onSetElevationDomain  (Function, optional) Default:  ([min, max]) => {} This callback will be called when bin elevation domain has been calculated. Sub Layers The HexagonLayer renders the following sublayers: hexagon-cell  - a  ColumnLayer  rendering the aggregated columns. Source modules/aggregation-layers/src/hexagon-layer","headings":[{"value":"HexagonLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"radius (Number, optional) transition-enabled","depth":5},{"value":"hexagonAggregator (Function, optional)","depth":5},{"value":"colorDomain (Array, optional)","depth":5},{"value":"colorRange (Array, optional)","depth":5},{"value":"coverage (Number, optional) transition-enabled","depth":5},{"value":"elevationDomain (Array, optional)","depth":5},{"value":"elevationRange (Array, optional)","depth":5},{"value":"elevationScale (Number, optional) transition-enabled","depth":5},{"value":"extruded (Boolean, optional)","depth":5},{"value":"upperPercentile (Number, optional) transition-enabled","depth":5},{"value":"lowerPercentile (Number, optional) transition-enabled","depth":5},{"value":"elevationUpperPercentile (Number, optional) transition-enabled","depth":5},{"value":"elevationLowerPercentile (Number, optional) transition-enabled","depth":5},{"value":"colorScaleType (String, optional)","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"colorAggregation (String, optional)","depth":5},{"value":"Example 1 : Using count of data elements that fall into a bin to encode the its color","depth":6},{"value":"Example 2 : Using mean value of 'SPACES' field of data elements to encode the color of the bin","depth":6},{"value":"elevationAggregation (String, optional)","depth":5},{"value":"Example 1 : Using count of data elements that fall into a bin to encode the its elevation","depth":6},{"value":"Example 2 : Using maximum value of 'SPACES' field of data elements to encode the elevation of the bin","depth":6},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional)","depth":5},{"value":"getColorWeight (Function, optional) transition-enabled","depth":5},{"value":"getColorValue (Function, optional) transition-enabled","depth":5},{"value":"getElevationWeight (Function, optional) transition-enabled","depth":5},{"value":"getElevationValue (Function, optional) transition-enabled","depth":5},{"value":"Callbacks","depth":3},{"value":"onSetColorDomain (Function, optional)","depth":5},{"value":"onSetElevationDomain (Function, optional)","depth":5},{"value":"Sub Layers","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/aggregation-layers/hexagon-layer","title":"HexagonLayer"},{"excerpt":"ScreenGridLayer The  ScreenGridLayer  aggregates data into histogram bins and renders them as a grid. By default aggregation happens on GPU, aggregation falls back to CPU when browser doesn't support GPU Aggregation or when  gpuAggregation  prop is set to 1. Note:  The aggregation is done in screen space, so the data prop\nneeds to be reaggregated by the layer whenever the map is zoomed or panned.\nThis means that this layer is best used with small data set, however the\nvisuals when used with the right data set can be quite effective. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Render Options cellSizePixels  (Number, optional)  Default:  100 Unit width/height of the bins. cellMarginPixels  (Number, optional)  Default:  2 , gets clamped to  0, 5 Cell margin size in pixels. minColor  (Number 4 , optional)  DEPRECATED Default:  [0, 0, 0, 255] Expressed as an rgba array, minimal color that could be rendered by a tile. This prop is deprecated in version 5.2.0, use  colorRange  and  colorDomain  instead. maxColor  (Number 4 , optional)  DEPRECATED Default:  [0, 255, 0, 255] Expressed as an rgba array, maximal color that could be rendered by a tile.  This prop is deprecated in version 5.2.0, use  colorRange  and  colorDomain  instead. colorDomain  (Array, optional) Default:  [1, max(weight)] Color scale input domain. The color scale maps continues numeric domain into\ndiscrete color range. If not provided, the layer will set  colorDomain  to  1, max-of-all-cell-weights , You can control how the color of cells mapped\nto value of its weight by passing in an arbitrary color domain. This property is extremely handy when you want to render different data input with the same color mapping for comparison. colorRange  (Array, optional) Default:  Specified as an array of 6 colors  color1, color2, ... color6 . Each color is an array of 3 or 4 values  R, G, B  or  R, G, B, A , representing intensities of Red, Green, Blue and Alpha channels.  Each intensity is a value between 0 and 255. When Alpha not provided a value of 255 is used. By default  colorRange  is set to\n colorbrewer   6-class YlOrRd . NOTE:  minColor  and  maxColor  take precedence over  colorDomain  and  colorRange , to use  colorDomain  and  colorRange  do not provide  minColor  and  maxColor . gpuAggregation  (bool, optional) Default: true When set to true and browser supports GPU aggregation, aggregation is performed on GPU. GPU aggregation can be 10 to 20 times faster depending upon number of points and number of cells. NOTE: GPU Aggregation requires WebGL2 support by the browser. When  gpuAggregation  is set to true and browser doesn't support WebGL2, aggregation falls back to CPU. aggregation  (String, optional) Default: 'SUM' Defines the type of aggregation operation, valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'. When no value or an invalid value is set, 'SUM' is used as aggregation. SUM : Grid cell contains sum of all weights that fall into it. MEAN : Grid cell contains mean of all weights that fall into it. MIN : Grid cell contains minimum of all weights that fall into it. MAX : Grid cell contains maximum of all weights that fall into it. Data Accessors getPosition  ( Function , optional) Default:  object => object.position Method called to retrieve the position of each object. getWeight  ( Function , optional) Default:  1 The weight of each object. If a number is provided, it is used as the weight for all objects. If a function is provided, it is called on each object to retrieve its weight. Source modules/aggregation-layers/src/screen-grid-layer","headings":[{"value":"ScreenGridLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"cellSizePixels (Number, optional) transition-enabled","depth":5},{"value":"cellMarginPixels (Number, optional) transition-enabled","depth":5},{"value":"minColor (Number4, optional) DEPRECATED","depth":5},{"value":"maxColor (Number4, optional) DEPRECATED","depth":5},{"value":"colorDomain (Array, optional)","depth":5},{"value":"colorRange (Array, optional)","depth":5},{"value":"gpuAggregation (bool, optional)","depth":5},{"value":"aggregation (String, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional)","depth":5},{"value":"getWeight (Function, optional)","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/aggregation-layers/screen-grid-layer","title":"ScreenGridLayer"},{"excerpt":"DeckLayer This class inherits from the ArcGIS  Layer  class and can be added to maps created with the ArcGIS API for JavaScript. At the moment,  DeckLayer  only supports 2D integration. Usage Constructor Inherits all properties from the base  Layer  class. Property names that start with  deck.  are forwarded to a  Deck  instance. The following  Deck  props are supported: deck.layers deck.layerFilter deck.parameters deck.effects deck.pickingRadius deck.onBeforeRender deck.onAfterRender deck.onClick deck.onHover deck.onDragStart deck.onDrag deck.onDragEnd deck.onError deck.debug deck.drawPickingColors deck.getCursor deck.getTooltip Members deck An ArcGIS  Accessor  that stores Deck props. The props can be updated after the layer construction:","headings":[{"value":"DeckLayer","depth":1},{"value":"Usage","depth":2},{"value":"Constructor","depth":2},{"value":"Members","depth":2},{"value":"deck","depth":5}],"slug":"docs/api-reference/arcgis/deck-layer","title":"DeckLayer"},{"excerpt":"DeckRenderer This class is an experimental implementation of the ArcGIS  ExternalRenderer  interface and can be added to 3D views of maps created with the ArcGIS\nAPI for JavaScript. Usage Constructor sceneView  ( SceneView ) - the view to use this renderer with.  viewingMode  must be set to  'local' . props  (Object) - forwarded to a  Deck  instance. The following  Deck  props are supported: layers layerFilter parameters effects pickingRadius onBeforeRender onAfterRender onClick onHover onDragStart onDrag onDragEnd onError debug drawPickingColors getCursor getTooltip Members deck An ArcGIS  Accessor  that stores Deck props. The props can be updated after the layer construction:","headings":[{"value":"DeckRenderer","depth":1},{"value":"Usage","depth":2},{"value":"Constructor","depth":2},{"value":"Members","depth":2},{"value":"deck","depth":5}],"slug":"docs/api-reference/arcgis/deck-renderer","title":"DeckRenderer"},{"excerpt":"@deck.gl/arcgis Use deck.gl layers with the ArcGIS API for JavaScript. The functionality exported by this module must be loaded asynchronously using the loader function  loadArcGISModules .\nThis function can be used to load any module that ships with the ArcGIS API for JavaScript, plus an additional  arcGIS  module\nthat acts as an interface between deck.gl and ArcGIS. 2D integration with  MapView  is supported by the  DeckLayer  class. 3D integration with  SceneView  is experimental: see the  DeckRenderer  class. Installation Include the Standalone Bundle Note that only  loadArcGISModules  is expoted by the standalone bundle.  DeckLayer  and  DeckRenderer  are avalaible when  loadArcGISModule()  is resolved. Install from NPM The integration classes ( DeckLayer  and  DeckRenderer ) extend ArcGIS core classes, therefore they are only available when ArcGIS is available. To load ArcGIS, applications have  two options : from AMD modules on CDN or from locally installed ES modules. It is important that the Deck classes are imported in the same way as the ArcGIS dependency. If the application is importing the ArcGIS Map via AMD modules ( esri-loader ), then the Deck classes should be accessed by calling  loadArcGISModules . This is the case if you are using  @esri/react-arcgis , which utilizes  esri-loader  under the hood. If the application is importing the ArcGIS Map from locally installed ES modules ( @arcgis/core ), then the Deck classes should be imported directly from  @deck.gl/arcgis . Supported Features and Limitations Supported deck.gl features: Layers Effects Attribute transitions Auto-highlighting onHover  and  onClick  callbacks Not supported features: Multiple views Controller React integration","headings":[{"value":"@deck.gl/arcgis","depth":1},{"value":"Installation","depth":2},{"value":"Include the Standalone Bundle","depth":3},{"value":"Install from NPM","depth":3},{"value":"Supported Features and Limitations","depth":2}],"slug":"docs/api-reference/arcgis/overview","title":"@deck.gl/arcgis"},{"excerpt":"loadArcGISModules This utility function initializes the classes in this module by loading ArcGIS dependencies. Optionally, it can also load additional dependencies from the  esri  namespace. Usage Arguments: modules  (Array, optional) - Array of esri modules to load, passed to  esri-loader 's  loadModules loadScriptOptions  (Object, optional) -  esri-loader options Returns: a promise that resolves to an object with the following fields: DeckLayer DeckRenderer modules  (Array) - if the  modules  argument was specified, will represent an array of the resolved objects","headings":[{"value":"loadArcGISModules","depth":1},{"value":"Usage","depth":2}],"slug":"docs/api-reference/arcgis/load-arcgis-modules","title":"loadArcGISModules"},{"excerpt":"BASEMAP CARTO basemaps  are available and they can be used without a token. Ensure you follow the  Terms and Conditions  when using them. Usage React Important Note:  Mapbox-GL-JS v2.0 changed to a license that requires an API key for loading the library, which will prevent you from using  react-map-gl  ( a higher level library). They have an in-depth guide about it  here . In short, if you want to use the library without a Mapbox token, then you have two options: use a  react-map-gl  version less than 6.0 ( npm i react-map-gl@5 ), or  substitute  mapbox-gl  with a fork . To install the dependencies from NPM: Standalone To use pre-bundled scripts: Supported basemaps There are several basemaps available today: POSITRON DARK_MATTER VOYAGER POSITRON_NOLABELS DARK_MATTER_NOLABELS VOYAGER_NOLABELS NAME PREVIEW STYLE URL POSITRON https://basemaps.cartocdn.com/gl/positron-gl-style/style.json DARK_MATTER https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json VOYAGER https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json POSITRON_NOLABELS https://basemaps.cartocdn.com/gl/positron-nolabels-gl-style/style.json DARK_MATTER_NOLABELS https://basemaps.cartocdn.com/gl/dark-matter-nolabels-gl-style/style.json VOYAGER_NOLABELS https://basemaps.cartocdn.com/gl/voyager-nolabels-gl-style/style.json","headings":[{"value":"BASEMAP","depth":1},{"value":"Usage","depth":2},{"value":"React","depth":3},{"value":"Standalone","depth":3},{"value":"Supported basemaps","depth":2}],"slug":"docs/api-reference/carto/basemap","title":"BASEMAP"},{"excerpt":"CartoLayer CartoLayer  is the layer to visualize data using the CARTO Maps API. Usage Geometry data By default the  CartoLayer  expects the data to be described using longitude & latitude. Tiled data will be used, with the format depending on  formatTiles .\nA  MVTLayer  will be created and all properties will be inherited. Spatial index data The CARTO platform supports storing data using a spatial index. The  geoColumn  prop is used to specify a database column that contains geographic data. When  geoColumn  has one of the following values, the data will be interpreted as a spatial index: h3   H3  indexing system will be used quadbin   Quadbin  indexing system will be used Tiled data will be used, with the layer created depending on the spatial index used: h3   H3HexagonLayer  will be created and all properties will be inherited. quadbin   QuadkeyLayer  will be created and all properties will be inherited.  Note the  getQuadkey  accessor is replaced with  getQuadbin . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties In all cases the properties of  TileLayer  will be inherited. Depending on the datasource, additional properties will be inherited from the created sublayer: For the  h3  spatial index:  H3HexagonLayer . For the  quadbin  spatial index:  QuadkeyLayer .  Note the  getQuadkey  accessor is replaced with  getQuadbin . Otherwise (longitude/latitude):  MVTLayer . data  (String) Required. Either a SQL query or a name of dataset/tileset. type  (String) Required. Data type. Possible values are: MAP_TYPES.QUERY , if  data  is a SQL query. MAP_TYPES.TILESET , if  data  is a tileset name. MAP_TYPES.TABLE , if  data  is a dataset name. Only supported with API v3. connection  (String, optional) Required when  apiVersion  is  API_VERSIONS.V3 . Name of the connection registered in the CARTO workspace. formatTiles  (String, optional) Only supported when  apiVersion  is  API_VERSIONS.V3  and  format  is  FORMATS.TILEJSON . Use to override the default tile data format. Possible values are:  TILE_FORMATS.BINARY ,  TILE_FORMATS.GEOJSON  and  TILE_FORMATS.MVT . geoColumn  (String, optional) Only supported when  type  is  MAP_TYPES.TABLE . Name of the  geo_column  in the CARTO platform. Use this override the default column ('geom'), from which the geometry information should be fetched. columns  (Array, optional) Only supported when  type  is  MAP_TYPES.TABLE . Names of columns to fetch. By default, all columns are fetched. uniqueIdProperty  (String) Default:  cartodb_id Optional. A string pointing to a unique attribute at the result of the query. A unique attribute is needed for highlighting with vector tiles when a feature is split across two or more tiles. credentials  (Object) Optional. Overrides the configuration to connect with CARTO. Check the parameters  here . aggregationExp  (String, optional) Optional. Aggregation SQL expression. Only used for spatial index datasets. aggregationResLevel  (Number, optional) Optional. Aggregation resolution level. Only used for spatial index datasets, defaults to 6 for quadbins, 4 for h3. Callbacks onDataLoad  (Function, optional) onDataLoad  is called when the request to the CARTO Maps API was completed successfully. Default:  data => {} Receives arguments: data  (Object) - Data received from CARTO Maps API onDataError  (Function, optional) onDataError  is called when the request to the CARTO Maps API failed. By default the Error is thrown. Default:  null Receives arguments: error  ( Error ) Source modules/carto/src/layers/carto-layer.js","headings":[{"value":"CartoLayer","depth":1},{"value":"Usage","depth":2},{"value":"Geometry data","depth":3},{"value":"Spatial index data","depth":3},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"data (String)","depth":5},{"value":"type (String)","depth":5},{"value":"connection (String, optional)","depth":5},{"value":"formatTiles (String, optional)","depth":5},{"value":"geoColumn (String, optional)","depth":5},{"value":"columns (Array, optional)","depth":5},{"value":"uniqueIdProperty (String)","depth":5},{"value":"credentials (Object)","depth":5},{"value":"aggregationExp (String, optional)","depth":5},{"value":"aggregationResLevel (Number, optional)","depth":5},{"value":"Callbacks","depth":3},{"value":"onDataLoad (Function, optional)","depth":4},{"value":"onDataError (Function, optional)","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/carto/carto-layer","title":"CartoLayer"},{"excerpt":"Styles Helper functions to create data-driven map visualizations. These helpers take advantage of  CARTOColors , custom color schemes built on top of well-known standards for color use on maps, with next generation enhancements for the web and CARTO basemaps. colorBins Helper function for quickly creating a color bins style based on  d3 scaleThreshold . Data values of each attribute are rounded down to the nearest value in the domain and are then styled with the corresponding color. In this example, using  Teal  of length  domain.length + 1 , the range/color equivalence is: Arguments attr  (String) Attribute or column to symbolize by. domain  (Array) Assign manual class break values. colors  (String | Array, optional) Color assigned to each domain value. String: A valid named  CARTOColors  palette. Array: Array of colors in RGBA  [ [r, g, b, [a]] ] .  Default:  PurpOr nullColor  (Array, optional) Color for null values. Default:  [204, 204, 204] colorCategories Helper function for quickly creating a color category style. Data values of each attribute listed in the domain are mapped one to one with corresponding colors in the range. Arguments attr  (String) Attribute or column to symbolize by. domain  (Array) Category list. Must be a valid list of categories. colors  (String | Array, optional) Color assigned to each domain value. String: A valid named  CARTOColors  palette. Array: Array of colors in RGBA  [ [r, g, b, [a]] ] .  Default:  PurpOr nullColor  (Array, optional) Color for null values. Default:  [204, 204, 204] othersColor  (Array, optional) Fallback color for a category not correctly assigned. Default:  [119, 119, 119] Color Continuous Helper function for quickly creating a color continuous style. Data values of each field are interpolated linearly across values in the domain and are then styled with a blend of the corresponding color in the range. Arguments attr  (String) Attribute or column to symbolize by. domain  (Array) Attribute domain to define the data range. colors  (String | Array, optional) Color assigned to each domain value. String: A valid named  CARTOColors  palette. Array: Array of colors in RGBA  [ [r, g, b, [a]] ] .  Default:  PurpOr nullColor  (Array, optional) Color for null values. Default:  [204, 204, 204]","headings":[{"value":"Styles","depth":1},{"value":"colorBins","depth":2},{"value":"Arguments","depth":3},{"value":"attr (String)","depth":4},{"value":"domain (Array)","depth":4},{"value":"colors (String | Array, optional)","depth":4},{"value":"nullColor (Array, optional)","depth":4},{"value":"colorCategories","depth":2},{"value":"Arguments","depth":3},{"value":"attr (String)","depth":4},{"value":"domain (Array)","depth":4},{"value":"colors (String | Array, optional)","depth":4},{"value":"nullColor (Array, optional)","depth":4},{"value":"othersColor (Array, optional)","depth":4},{"value":"Color Continuous","depth":2},{"value":"Arguments","depth":3},{"value":"attr (String)","depth":4},{"value":"domain (Array)","depth":4},{"value":"colors (String | Array, optional)","depth":4},{"value":"nullColor (Array, optional)","depth":4}],"slug":"docs/api-reference/carto/styles","title":"Styles"},{"excerpt":"fetchMap CARTO  Builder  is a powerful tool for designing map visualizations. With the  fetchMap  function, you can easily instantiate layers configured in Builder for use with deck.gl. It is available starting with CARTO Maps API version v3 and deck.gl 8.7. Usage Static display of a CARTO map Integration with CARTO basemaps Parameters cartoMapId  (String) Required. Identifier of map created in CARTO Builder.  credentials  (Object, optional) CARTO Credentials  to use in API requests. autoRefresh  (Number, optional) Interval in seconds at which to autoRefresh the data. If provided,  onNewData  must also be provided. onNewData  (Function, Optional) Callback function that will be invoked whenever data in layers is changed. If provided,  autoRefresh  must also be provided. Return value When invoked with a given  cartoMapId ,  fetchMap  will retrieve the information about the map from CARTO, generate appropriate layers and populate them with data. The properties of the  map  are as follows: id  (String) The  cartoMapId . title  (String) The title given to the map in CARTO Builder. description  (String) The description given to the map in CARTO Builder. createdAt  (String) When the map was created. updatedAt  (String) When the map was last updated. initialViewState  (String) The  view state . mapStyle  (String) An identifier describing the  basemap  configured in CARTO Builder. layers  (Array) A collection of deck.gl  layers . stopAutoRefresh  (Function) A function to invoke to stop auto-refreshing. Only present if  autoRefresh  option was provided to  fetchMap . Auto-refreshing With dynamic data sources, the  autoRefresh  option to  fetchMap  makes it simple to create an live-updating map.","headings":[{"value":"fetchMap","depth":1},{"value":"Usage","depth":2},{"value":"Static display of a CARTO map","depth":3},{"value":"Integration with CARTO basemaps","depth":3},{"value":"Parameters","depth":2},{"value":"cartoMapId (String)","depth":5},{"value":"credentials (Object, optional)","depth":5},{"value":"autoRefresh (Number, optional)","depth":5},{"value":"onNewData (Function, Optional)","depth":5},{"value":"Return value","depth":2},{"value":"id (String)","depth":5},{"value":"title (String)","depth":5},{"value":"description (String)","depth":5},{"value":"createdAt (String)","depth":5},{"value":"updatedAt (String)","depth":5},{"value":"initialViewState (String)","depth":5},{"value":"mapStyle (String)","depth":5},{"value":"layers (Array)","depth":5},{"value":"stopAutoRefresh (Function)","depth":5},{"value":"Auto-refreshing","depth":2}],"slug":"docs/api-reference/carto/fetch-map","title":"fetchMap"},{"excerpt":"@deck.gl/carto Deck.gl is the preferred and official solution for creating modern geospatial web applications using  CARTO Location Intelligence platform . With deck.gl and the all-new  CARTO 3 platform  you can directly access spatial datasets and tilesets that are hosted in your current cloud data warehouse. CARTO 3 provides seamless integrations with Google BigQuery, Amazon Redshift, Snowflake, Databricks and PostgreSQL-compatible databases, eliminating the need to move your data into CARTO. The platform integrates with the CARTO Maps API to: Provide a geospatial backend storage for your geospatial data. Visualize large datasets overcoming browser memory limitations. Provide an SQL spatial interface to work directly with your data. Install package Usage Automatically create layers configured in CARTO Builder Custom layers connected to CARTO datasource Examples You can see working examples for the following: Scripting : Quick scripting examples to play with the module without NPM or Webpack. If you're not a web developer, this is probably what you're looking for. React : Integrate in a React application. Pure JS : Integrate in a pure js application, using webpack. CARTO credentials This is an object to define the connection to CARTO, including the credentials (and optionally the parameters to point to specific API endpoints). These are the available properties: apiBaseUrl  (optional): base URL for requests to the API (can be obtained in the CARTO 3 Workspace). Default:  https://gcp-us-east1.api.carto.com . accessToken  (optional): token to authenticate/authorize requests to the Maps API (private datasets) mapsUrl  (optional): Maps API URL Template. By default it is derived from  apiBaseUrl : https://{apiBaseUrl}/v3/maps Support for other deck.gl layers The CARTO submodule includes the CartoLayer that simplifies the interaction with the CARTO platform. If you want to use other deck.gl layers (i.e. ArcLayer, H3HexagonLayer...), there are two possibilities depending on the API version you are using: You can directly retrieve the data in the format expected by the layer using the  fetchLayerData  function: The formats available are JSON, GEOJSON, TILEJSON, and NDJSON.  NDJSON  (Newline Delimited JSON) allows to handle incremental data loading  https://deck.gl/docs/developer-guide/performance#handle-incremental-data-loading . Constants To make it easier to work with the CARTO module the following constants are provided: ENUMERATION VALUES API_VERSIONS V1 V2 V3 MAP_TYPES QUERY TABLE TILESET FORMATS GEOJSON JSON TILEJSON NDJSON TILE_FORMATS BINARY JSON GEOJSON MVT","headings":[{"value":"@deck.gl/carto","depth":1},{"value":"Install package","depth":2},{"value":"Usage","depth":2},{"value":"Automatically create layers configured in CARTO Builder","depth":3},{"value":"Custom layers connected to CARTO datasource","depth":3},{"value":"Examples","depth":3},{"value":"CARTO credentials","depth":3},{"value":"Support for other deck.gl layers","depth":3},{"value":"Constants","depth":3}],"slug":"docs/api-reference/carto/overview","title":"@deck.gl/carto"},{"excerpt":"AttributeManager The  AttributeManager  is used internally by deck.gl layers. Unless you are writing custom deck.gl layers, or you are working with some very narrow advanced performance optimization use cases, you do not need to use this class. The  AttributeManager  class provides automated attribute allocations and updates. Summary: keeps track of valid state for each attribute auto reallocates attributes when needed auto updates attributes with registered updater functions allows overriding with application supplied buffers For more information consult the  Attribute Management  article. Static Methods setDefaultLogFunctions Sets log functions to help trace or time attribute updates.\nDefault logging uses the deck.gl logger. Note that the app may not be in control of when update is called,\nso hooks are provided for update start and end. Parameters: opts.onUpdateStart  (Function) - callback, called before an attribute starts updating opts.onUpdate  (Function) - callback, called when update is performed. Receives an argument  message  detailing the update operation. opts.onUpdateEnd  (Function) - callback, called after an attribute is updated. Receives an argument  message  detailing the update operation. Constructor Parameters: id  (String, optional) - identifier (for debugging) Methods add Adds attribute descriptions to the AttributeManager that describe\nthe attributes that should be auto-calculated. Takes a single parameter as a map of attribute descriptor objects: keys are attribute names values are objects with attribute definitions: luma.gl  accessor parameters : type  (Enum, optional) - data type of the attribute, see \"Remarks\" section below. size  (Number) - number of elements per vertex normalized  (Boolean) - default  false integer  (Boolean) - WebGL2 only, default  false divisor  (Boolean, optional) -  1  if this is an instanced attribute\n(a.k.a. divisor). Default to  0 . deck.gl attribute configurations: isIndexed  (Boolean, optional) - if this is an index attribute\n(a.k.a. indices). Default to  false . accessor  (String | Array of strings | Function) - accessor name(s) that will\ntrigger an update of this attribute when changed. Used with\n updateTriggers . transform  (Function, optional) - callback to process the result returned by  accessor . update  (Function, optional) - the function to be called when data changes. If not supplied, the attribute will be auto-filled with  accessor . defaultValue  (Number | Array of numbers, optional) - Default  [0, 0, 0, 0] . noAlloc  (Boolean, optional) - if this attribute should not be\nautomatically allocated. Default to  false . shaderAttributes  (Object, optional) - If this attribute maps to multiple\nattributes in the vertex shader, that mapping can be defined here. All\n shaderAttributes  will share a single buffer created based on the  size \nparameter. This can be used to interleave attributes. Each shader attribute object may contain any of the following: size  (Number) - number of elements per vertex vertexOffset  (Number) - offset of the attribute by vertex (stride). Default  0 . elementOffset  (Number) - offset of the attribute by element. default  0 . divisor  (Boolean, optional) -  1  if this is an instanced attribute\n(a.k.a. divisor). Default to  0 . addInstanced Shorthand for  add()  in which all attributes  instanced  field are set to  true . remove Removes defined attributes. Parameters: attributeNames  (Array) - Array of attribute names to be removed invalidate Mark an attribute as need update. Parameters: name  (String) - Either the name of the attribute, or the name of an accessor. If an name of accessor is provided, all attributes with that accessor are invalidated. dataRange  (Object, optional) - A partial range of the attribute to invalidate, in the shape of  {startRow, endRow} . Start (included) and end (excluded) are indices into the data array. If not provided, recalculate the  attribute for all data. invalidateAll Mark all attributes as need update. Parameters: dataRange  (Object, optional) - A partial range of the attributes to invalidate, in the shape of  {startRow, endRow} . Start (included) and end (excluded) are indices into the data array. If not provided, recalculate the  attributes for all data. update Ensure all attribute buffers are updated from props or data. Parameters: data  (Object) - data (iterable object) numInstances  (Number) - count of data buffers  (Object) - pre-allocated buffers props  (Object) - passed to updaters context  (Object) - Used as \"this\" context for updaters Notes: Any preallocated buffers in \"buffers\" matching registered attribute names will be used. No update will happen in this case. Calls onUpdateStart and onUpdateEnd log callbacks before and after. Remarks Attribute Type The following  type  values are supported for attribute definitions: type value array type notes GL.FLOAT Float32Array GL.DOUBLE Float64Array Because 64-bit floats are not supported by WebGL, the value is converted to an interleaved  Float32Array  before uploading to the GPU. It is exposed to the vertex shader as two attributes,  <attribute_name>  and  <attribute_name>64Low , the sum of which is the 64-bit value. GL.BYTE Int8Array GL.SHORT Int16Array GL.INT Int32Array GL.UNSIGNED_BYTE Uint8ClampedArray GL.UNSIGNED_SHORT Uint16Array GL.UNSIGNED_INT Uint32Array Source modules/core/src/lib/attribute-manager.js","headings":[{"value":"AttributeManager","depth":1},{"value":"Static Methods","depth":2},{"value":"setDefaultLogFunctions","depth":5},{"value":"Constructor","depth":2},{"value":"Methods","depth":2},{"value":"add","depth":5},{"value":"addInstanced","depth":5},{"value":"remove","depth":5},{"value":"invalidate","depth":5},{"value":"invalidateAll","depth":5},{"value":"update","depth":5},{"value":"Remarks","depth":2},{"value":"Attribute Type","depth":3},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/attribute-manager","title":"AttributeManager"},{"excerpt":"AmbientLight Create an ambient light source which illuminates all the objects equally. Ambient light comes from all directions, adding ambient light ensures that object colors are rendered but does not show structure in 3D objects like directional and point lights do. Only one ambient light is supported. Usage Create an ambient light source with color and intensity. Methods constructor The constructor for the  AmbientLight  class. Use this to create a new  AmbientLight . color  - ( array ,)  RGB color of ambient light source, default value is  [255, 255, 255] . intensity  - ( number ) Strength of ambient light source, default value is  1.0 .","headings":[{"value":"AmbientLight","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"constructor","depth":3}],"slug":"docs/api-reference/core/ambient-light","title":"AmbientLight"},{"excerpt":"Attribute (Internal) This class is a target for refactor. This class helps deck.gl manage attributes. It integrates into the luma.gl  Model.setAttributes()  method by implementing the  Attribute.getValue()  method. luma.gl checks for the presence of this method on any attribute passed in. Usage Create model object by passing shaders, uniforms, geometry and render it by passing updated uniforms. Methods constructor The constructor for the Attribute class. Use this to create a new Attribute. new Attribute(gl, options); gl  - WebGL context. size  ( number ) - The number of components in each element the buffer (1-4). id  ( string , optional) - Identifier of the attribute. Cannot be updated. type  ( GLenum , optional) - Type of the attribute. If not supplied will be inferred from  value . Cannot be updated. isIndexed  ( bool , optional) - If the attribute is element index. Default  false . Cannot be updated. constant  ( bool , optional) - If the attribute is a constant. Default  false . isInstanced  ( bool , optional) - Whether buffer contains instance data. Default  false . normalized  ( boolean , optional) - Default  false integer  ( boolean , optional) - Default  false offset  ( number , optional) - where the data starts in the buffer. Default  0 . stride  ( number , optional) - an additional offset between each element in the buffer. Default  0 . value  ( TypedArray ) - value of the attribute. If  constant  is  true , the length of  value  should match  size If  constant  is  false , the length of  value  should be  size  multiplies the number of vertices. buffer  ( Buffer ) - an external buffer for the attribute. delete Free WebGL resources associated with this attribute. update Update attribute options. See  constructor  for possible options. getBuffer Returns a  Buffer  object associated with this attribute, if any.","headings":[{"value":"Attribute (Internal)","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"constructor","depth":3},{"value":"delete","depth":3},{"value":"update","depth":3},{"value":"getBuffer","depth":3}],"slug":"docs/api-reference/core/attribute","title":"Attribute (Internal)"},{"excerpt":"CameraLight (Experimental) CameraLight is a special  point light  source which always emits from the camera position. Usage Create an camera light source. constructor The constructor for the  CameraLight  class. Use this to create a new  CameraLight . color  - ( array )  RGB color of camera light source, default value is  [255, 255, 255] . intensity  - ( number ) Strength of camera light source, default value is  1.0 . Source /modules/core/src/effects/lighting/camera-light.js","headings":[{"value":"CameraLight (Experimental)","depth":1},{"value":"Usage","depth":2},{"value":"constructor","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/camera-light","title":"CameraLight (Experimental)"},{"excerpt":"Controller The base class for all viewport controllers. A controller class can be passed to either the  Deck  class's  controller  prop or a  View  class's  controller  prop to specify viewport interactivity. Options The base Controller class supports the following options: scrollZoom  (Boolean|Object) - enable zooming with mouse wheel. Default  true . If an object is supplied, it may contain the following fields to customize the zooming behavior: speed  (Number) - scaler that translates wheel delta to the change of viewport scale. Default  0.01 . smooth  (Boolean) - smoothly transition to the new zoom. If enabled, will provide a slightly lagged but smoother experience. Default  false . dragPan  (Boolean) - enable panning with pointer drag. Default  true dragRotate  (Boolean) - enable rotating with pointer drag. Default  true doubleClickZoom  (Boolean) - enable zooming with double click. Default  true touchZoom  (Boolean) - enable zooming with multi-touch. Default  true touchRotate  (Boolean) - enable rotating with multi-touch. Use two-finger rotating gesture for horizontal and three-finger swiping gesture for vertical rotation. Default  false keyboard  (Boolean|Object) - enable interaction with keyboard. Default  true . If an object is supplied, it may contain the following fields to customize the keyboard behavior: zoomSpeed  (Number) - speed of zoom using +/- keys. Default  2 . moveSpeed  (Number) - speed of movement using arrow keys, in pixels. rotateSpeedX  (Number) - speed of rotation using shift + left/right arrow keys, in degrees. Default  15 . rotateSpeedY  (Number) - speed of rotation using shift + up/down arrow keys, in degrees. Default  10 . dragMode  (String) - drag behavior without pressing function keys, one of  pan  and  rotate . inertia  (Boolean|Number) - Enable inertia after panning/pinching. If a number is provided, indicates the duration of time over which the velocity reduces to zero, in milliseconds. Default  false . Methods A controller is not meant to be instantiated by the application. The following methods are documented for creating custom controllers that extend the base Controller class. constructor The constructor takes two arguments: ViewState  - a class that implements the following methods: getViewportProps()  - returns an object that describes the view state getInteractiveState()  - returns an object that contains the internal state of the ongoing interaction shortestPathFrom(viewState)  - returns an object that describes another view state that is closest to this view state. This is used by viewport transition when there are multiple equivalent ways to define a view state (e.g.  bearing: 240  and  bearing: -120 ) methods that return a new ViewState with updated props: panStart pan panEnd rotateStart rotate rotateEnd zoomStart zoom zoomEnd zoomIn zoomOut moveLeft moveRight moveUp moveDown rotateLeft rotateRight rotateUp rotateDown options  (Object) - options and view state props handleEvent(event) Called by the event manager to handle pointer events. This method delegate to the following methods to handle the default events: _onPanStart(event) _onPan(event) _onPanEnd(event) _onPinchStart(event) _onPinch(event) _onPinchEnd(event) _onTriplePanStart(event) _onTriplePan(event) _onTriplePanEnd(event) _onDoubleTap(event) _onWheel(event) _onKeyDown(event) See  Event object documentation . setProps(props) Called by the view when the view state updates. This method handles adding/removing event listeners based on user options. updateViewport(newMapState, extraProps, interactionState) Called by the event handlers, this method updates internal state, and invokes  onViewStateChange  callback with a new map state. getCenter(event) Utility used by the event handlers, returns pointer position  [x, y]  from any event. isFunctionKeyPressed(event) Utility used by the event handlers, returns  true  if ctrl/alt/meta key is pressed during any event. isPointInBounds(pos, [event]) Utility used by the event handlers, returns  true  if a pointer position  [x, y]  is inside the current view. If  event  is provided, returns  false  if the event is already handled, and mark the event as handled if the point is in bounds. This can be used to make sure that certain events are only handled by one controller, when there are overlapping viewports. isDragging() Returns  true  if the user is dragging the view. Example: Implementing A Custom Controller In its constructor, a controller class can optionally specify a list of event names that it subscribes to with the  events  field. A full list of supported events can be found  here . Note that the following events are always toggled on/off by user options: scrollZoom  -  ['wheel'] dragPan  and  dragRotate  -  ['pan'] touchZoom  -  ['pinch'] touchRotate  -  ['pinch', 'tripan] doubleClickZoom  -  ['doubletap'] keyboard  -  ['keydown'] Source modules/core/src/controllers/controller.js","headings":[{"value":"Controller","depth":1},{"value":"Options","depth":2},{"value":"Methods","depth":2},{"value":"constructor","depth":5},{"value":"handleEvent(event)","depth":5},{"value":"setProps(props)","depth":5},{"value":"updateViewport(newMapState, extraProps, interactionState)","depth":5},{"value":"getCenter(event)","depth":5},{"value":"isFunctionKeyPressed(event)","depth":5},{"value":"isPointInBounds(pos, [event])","depth":5},{"value":"isDragging()","depth":5},{"value":"Example: Implementing A Custom Controller","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/controller","title":"Controller"},{"excerpt":"CompositeLayer Class The  CompositeLayer  class is a subclass of the  Layer Class , that customizes various  layer lifecycle methods  to help create sublayers and handle events from those layers. If you intend to implement a layer that generates other layers, you should extend this class. For more information consult the  Composite Layers  article. Usage Define a composite layer that renders a set of sublayers, one of them conditionally Constructor Parameters: props  (Object) -  Layer  properties. Properties Inherits from all  Base Layer  properties. _subLayerProps  (Object)  EXPERIMENTAL Key is the id of a sublayer and value is an object used to override the props of the sublayer. For a list of ids rendered by each composite layer, consult the  Sub Layers  section in each layer's documentation. Example: make only the point features in a GeoJsonLayer respond to hover and click Example: use IconLayer instead of ScatterplotLayer to render the point features in a GeoJsonLayer Members isComposite Always  true . isLoaded true  if all asynchronous assets are loaded, and all sublayers are also loaded. parent A  Layer  instance if this layer is rendered by a  CompositeLayer Methods draw A composite layer does not render directly into the WebGL context. The  draw  method inherited from the base class is therefore never called. renderLayers Allows a layer to \"render\" or insert one or more deck.gl layers after itself.\nCalled after a layer has been updated. Returns: null , a single  Layer  instance, or a (nested) array of layers. The default implementation of  renderLayers  returns  null . renderLayers  can return a nested arrays with  null  values. deck.gl will automatically flatten and filter the array. See usage above. filterSubLayer Allows a layer to dynamically show/hide sub layers based on the render context. Receives arguments: layer  (Layer) - the sub layer to be drawn viewport  (Viewport) - the current viewport isPicking  (Boolean) - whether this is a picking pass renderPass  (String) - the name of the current render pass. See  layerFilter  for possible values. Returns: true  if the layer should be drawn. This method achieves the same result as toggling sub layers'  visible  prop in  renderLayers . The difference is that,  renderLayers  is only called when the layer is updated due to props or state change, and will recursively create new instances of all decendant layers, therefore is more expensive to invoke.  filterSubLayer  is evaluated before every redraw, and is intended to be a more performant solution to setting  visible  props dynamically during continuous viewport updates. Generally speaking,  filterSubLayer  is favorable if the visibilities of sub layers change frequently, and the logic to determine visibility is very cheap to compute. An example of leveraging this method is to switch sub layers on viewport change: getPickingInfo Called when a sublayer is being hovered or clicked, after the  getPickingInfo \nof the sublayer has been called.\nThe composite layer can override or add additional fields to the  info  object\nthat will be passed to the callbacks. Parameters: pickParams  (Object) pickParams.info  (Object) - The current  info  object. By default it contains the\nfollowing fields: x  (Number) - Mouse position x relative to the viewport. y  (Number) - Mouse position y relative to the viewport. coordinate  ( Number, Number ) - Mouse position in world coordinates. Only applies if the\n coordinateSystem \nprop is set to  COORDINATE_SYSTEM.LNGLAT . color  (Number 4 ) - The color of the pixel that is being picked. It represents a\n\"picking color\" that is encoded by\n layer.encodePickingColor() . index  (Number) - The index of the object that is being picked. It is the returned\nvalue of\n layer.decodePickingColor() . picked  (Boolean) -  true  if  index  is not  -1 . pickParams.mode  (String) - One of  hover  and  click pickParams.sourceLayer  (Layer) - the sublayer instance where this event originates from. Returns: An  info  object with optional fields about what was picked. This object will be passed to the layer's  onHover  or  onClick  callbacks. null , if the corresponding event should be cancelled with no callback functions called. The default implementation returns  pickParams.info  without any change. getSubLayerProps This utility method helps create sublayers that properly inherit a composite layer's basic props. For example, it creates a unique id for the sublayer, and makes sure the sublayer's  coordinateSystem  is set to be the same as the parent. Parameters: subLayerProps  (Object) id  (String, required) - an id that is unique among all the sublayers generated by this composite layer. updateTriggers  (Object) - the sublayer's update triggers. Any additional props are optional. Returns a properties object used to generate a sublayer, with the following keys: id  - a unique id for the sublayer, by prepending the parent layer id to the sublayer id. updateTriggers  - merged object of the parent layer update triggers and the sublayer update triggers. Base layer props that are directly forwarded from the base layer: opacity pickable visible parameters getPolygonOffset highlightedObjectIndex autoHighlight highlightColor coordinateSystem coordinateOrigin wrapLongitude positionFormat modelMatrix Any other additional props from the input parameter are directly forwarded. Any overriding props specified in  _subLayerProps . shouldRenderSubLayer Called to determine if a sublayer should be rendered.\nA composite layer can override this method to change the default behavior. Parameters: id  (String) - the sublayer id data  (Array) - the sublayer data Returns  true  if the sublayer should be rendered. The base class implementation returns  true  if  data  is not empty. getSubLayerClass Called to retrieve the constructor of a sublayer.\nA composite layer can override this method to change the default behavior. Parameters: id  (String) - the sublayer id DefaultLayerClass  - the default constructor used for this sublayer. Returns: Constructor for this sublayer. The base class implementation checks if  type  is specified for the sublayer in  _subLayerProps , otherwise returns the default. getSubLayerRow Used by  adapter layers ) to decorate transformed data with a reference to the original object. Parameters: row  (Object) - a custom data object to pass to a sublayer. sourceObject  (Object) - the original data object provided by the user sourceObjectIndex  (Object) - the index of the original data object provided by the user Returns: The  row  object, decorated with a reference. getSubLayerAccessor Used by  adapter layers ) to allow user-provided accessors to read the original objects from transformed data. Parameters: accessor  (Function|Any) - the accessor provided to the current layer. Returns: If  accessor  is a function, returns a new accessor function. If  accessor  is a constant value, returns it as is. Source modules/core/src/lib/composite-layer.js","headings":[{"value":"CompositeLayer Class","depth":1},{"value":"Usage","depth":2},{"value":"Constructor","depth":2},{"value":"Properties","depth":2},{"value":"_subLayerProps (Object) EXPERIMENTAL","depth":5},{"value":"Members","depth":2},{"value":"isComposite","depth":5},{"value":"isLoaded","depth":5},{"value":"parent","depth":5},{"value":"Methods","depth":2},{"value":"draw","depth":5},{"value":"renderLayers","depth":5},{"value":"filterSubLayer","depth":5},{"value":"getPickingInfo","depth":5},{"value":"getSubLayerProps","depth":5},{"value":"shouldRenderSubLayer","depth":5},{"value":"getSubLayerClass","depth":5},{"value":"getSubLayerRow","depth":5},{"value":"getSubLayerAccessor","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/composite-layer","title":"CompositeLayer Class"},{"excerpt":"DeckGL (Scripting Interface) DeckGL  extends the core  Deck  class with some additional features such as Mapbox integration. It offers a convenient way to use deck.gl in prototype environments such as  Codepen ,  JSFiddle  and  Observable .  Make sure to read the  Using deck.gl Scripting API  article. Usage Properties All  Deck  class properties, with these additional props that can be passed to the constructor: container  (DOMElement | String, optional) Default:  document.body The container in which deck.gl should append its canvas. Can be either a HTMLDivElement or the element id. The deck.gl canvas is resized to fill the container. map  (Object, optional) Default:  window.mapboxgl The scripting API offers out-of-the-box integration with Mapbox. To add a base map to your visualization, you need to include the Mapbox library and stylesheet: The above script adds  mapboxgl  to the global scope, which will be picked up by default.  To disable the base map, simply exclude the mapbox script or set  map  to false. In some environments such as Observable, libraries cannot be imported into the global scope, in which case you need to manually pass the mapboxgl object to  map : And To use a mapbox-gl fork such as  MapLibre GL JS , pass the corresponding library entry point to  map : And  mapStyle  (Object | String) The style JSON or URL for the Mapbox map. mapboxApiAccessToken  (String) The API access token to use Mapbox tiles. See  Mapbox GL JS  documentation for how to use Mapbox. Methods All  Deck  class methods, with these additional methods: getMapboxMap Returns the mapbox-gl  Map  instance if a base map is present. Source modules/main/bundle.js","headings":[{"value":"DeckGL (Scripting Interface)","depth":1},{"value":"Usage","depth":2},{"value":"Properties","depth":2},{"value":"container (DOMElement | String, optional)","depth":5},{"value":"map (Object, optional)","depth":5},{"value":"mapStyle (Object | String)","depth":5},{"value":"mapboxApiAccessToken (String)","depth":5},{"value":"Methods","depth":2},{"value":"getMapboxMap","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/deckgl","title":"DeckGL (Scripting Interface)"},{"excerpt":"Deck Deck  is a class that takes deck.gl layer instances and viewport parameters, renders those layers as a transparent overlay, and handles events. If you are using React, you should not use this class directly. Instead you should be rendering the  DeckGL  React component. Usage Constructor Creates a new Deck instance. Parameters: See the  Properties  section. Properties Initialization Settings The following properties are used to initialize a  Deck  instance. Any custom value should always be provided to the  Deck  constructor. Changing them with  setProps  afterwards will have no effect. canvas  (HTMLCanvasElement | String, optional) The canvas to render into. Can be either a HTMLCanvasElement or the element id. Will be auto-created if not supplied. gl  (WebGLContext) WebGL context. Will be auto-created if not supplied. glOptions  (Object) Additional options used when creating the WebGLContext. See  WebGL context attributes . id  (String) Default:  'deckgl-overlay' ID assigned to the canvas that is created by this  Deck  instance, to allow style customization in CSS. parent  (HTMLElement) Default:  document.body The container to append the auto-created canvas to. debug  (Boolean) Default:  false Flag to enable WebGL debug mode. Also requires an extra luma.gl import: Notes: Debug mode is slower as it will use synchronous operations to keep track of GPU state. _typedArrayManagerProps  (Object) Default: {} (Experimental) May contain the following fields: overAlloc  (Number) - Default  2 . By default, attributes are allocated twice the memory than they actually need (on both CPU and GPU). Must be larger than  1 . poolSize  (Number) - Default  100 . When memory reallocation is needed, old chunks are held on to and recycled. Smaller number uses less CPU memory. Can be any number  >=0 . The above default settings make data updates faster, at the price of using more memory. If the app does not anticipate frequent data changes, they may be aggressively reduced: Rendering Configuration width  (Number|String) Default:  '100%' Width of the canvas, a number in pixels or a valid CSS string. height  (Number|String) Default:  '100%' Height of the canvas, a number in pixels or a valid CSS string. style  (Object) Additional CSS styles for the canvas. useDevicePixels  (Boolean|Number) Default:  true Controls the resolution of drawing buffer used for rendering. true :  Device (physical) pixels  resolution is used for rendering, this resolution is defined by  window.devicePixelRatio . On Retina/HD systems this resolution is usually twice as big as  CSS pixels  resolution. false :  CSS pixels  resolution (equal to the canvas size) is used for rendering. Number  (Experimental): Specified Number is used as a custom ratio (drawing buffer resolution to  CSS pixel  resolution) to determine drawing buffer size, a value less than  one  uses resolution smaller than  CSS pixels , gives better performance but produces blurry images, a value greater than  one  uses resolution bigger than CSS pixels resolution (canvas size), produces sharp images but at a lower performance. Note: Consider setting to  false  or to a number <=1 if better rendering performance is needed. When it is set to a high Number (like, 4 or more), it is possible to hit the system limit for allocating drawing buffer, such cases will log a warning and fallback to system allowed resolution. parameters  (Object) Expects an object with WebGL settings. Before each frame is rendered, this object will be passed to luma.gl's  setParameters  function to reset the WebGL context parameters, e.g. to disable depth testing, change blending modes etc. The default parameters set by  Deck  on initialization are the following: Refer to the luma.gl  setParameters  API for documentation on supported parameters and values. Notes: Any WebGL  parameters  prop supplied to individual layers will still override the global  parameters  when that layer is rendered. An alternative way to set  parameters   is to instead define the  onWebGLInitialized  callback (it receives the  gl  context as parameter) and call the luma.gl  setParameters  method inside it. layers  (Array) Default:  [] The array of  Layer  instances to be rendered. Nested arrays are accepted, as well as falsy values ( null ,  false ,  undefined ). This allows applications to do something like: layerFilter  (Function) Default:  null If supplied, will be called before a layer is drawn to determine whether it should be rendered. This gives the application an opportunity to filter out layers from the layer list during either rendering or picking. Filtering can be done per viewport or per layer or both. This enables techniques like adding helper layers that work as masks during picking but do not show up during rendering. Receives arguments: layer  (Layer) - the layer to be drawn viewport  (Viewport) - the current viewport isPicking  (Boolean) - whether this is a picking pass cullRect  (Object) - if defined, indicates that only the content rendered to the given rectangle is needed. renderPass  (String) - the name of the current render pass. Some standard passes are: 'screen'  - drawing to screen 'picking:hover'  - drawing to offscreen picking buffer due to pointer move 'picking:query'  - drawing to offscreen picking buffer due to user-initiated query, e.g. calling  deck.pickObject . 'shadow'  - drawing to shadow map Returns: true  if the layer should be drawn. Notes: layerFilter  does not override the visibility if the layer is disabled via  visible: false  or  pickable: false  props. All the lifecycle methods other than  draw  are still triggered even a if a layer is filtered out using this method. views  (Object|Array) Default:  new MapView() A single  View  instance, or an array of  View  instances. View s represent the \"camera(s)\" (essentially viewport dimensions and projection matrices) that you look at your data with. deck.gl offers multiple view types for both geospatial and non-geospatial use cases. Read the  Views and Projections  guide for the concept and examples. viewState  (Object) An object that describes the  view state  for each view in the  views  prop. For example, the default view's view state is described  here : When using multiple views, the  viewState  is a map from each view id to its respective view state object. See  example . Transitions between two viewState objects can also be achieved by providing set of fields to  viewState  prop, for more details check  ViewState Transitions ). Notes: If you supply this prop, you are responsible of managing the changes to the view state upon user interaction. This prop is therefore usually used together with the  onViewStateChange  callback ( example ). For  Deck  to update view states automatically, use the  initialViewState  prop instead. initialViewState  (Object) If  initialViewState  is provided, the  Deck  component will track view state changes from any attached  controller  using internal state, with  initialViewState  as its initial view state. This is the easiest way to  control the camera . If the  initialViewState  prop changes, the internally tracked view state will be updated to match the new \"initial\" view state. Notes: The  onViewStateChange  callback will still be called, if provided. If the  viewState  prop is supplied by the application, the supplied  viewState  will always be used, overriding the  Deck  component's internal view state. In simple applications, use of the  initialViewState  prop can avoid the need to track the view state in the application. One drawback of using  initialViewState  for reactive/functional applications is that the  Deck  component becomes more stateful. effects  (Array) The array of effects to be rendered. A lighting effect will be added if an empty array is supplied. Refer to effect's documentation to see details: LightingEffect PostProcessEffect _framebuffer  (Object) (Experimental) Render to a custom frame buffer other than to screen. _animate  (Boolean) Default:  false (Experimental) Forces deck.gl to redraw layers every animation frame. Normally deck.gl layers are only redrawn if any change is detected. Interaction Settings controller  (Function | Boolean | Object) Default:  null Options for viewport interactivity, e.g. pan, rotate and zoom with mouse, touch and keyboard. This is a shorthand for defining interaction with the  views  prop if you are using the default view (i.e. a single  MapView ). is equivalent to: controller  can be one of the following types: null  or  false : the viewport is not interactive. true : initiates the default controller of the default view - e.g. a  MapController  if  MapView  is used. Controller  class (not instance): initiates the provided controller with default options. Must be a subclass of  Controller . Object : controller options. This will be merged with the default controller options. controller.type : the controller class, must be a subclass of  Controller . Other options supported by the controller type. Consult the documentation of  Controller . getCursor  (Function) Default:  ({isDragging}) => isDragging ? 'grabbing' : 'grab' A custom callback to retrieve the cursor type. Receives arguments: interactiveState  (Object) isDragging  (Boolean) - whether the pointer is down and moving isHovering  (Boolean) - whether the pointer is over a pickable object Returns: A valid  CSS cursor  string. Remarks: It is worth noting that when supplying a custom image for the cursor icon, Chrome requires a fallback option to be supplied, otherwise the custom image will not be loaded; e.g.  getCursor={() => 'url(images/custom.png), auto'} getTooltip  (Function) Callback that takes a hovered-over point and renders a tooltip. If the prop is not specified, the tooltip is always hidden. Receives arguments: info  - the  picking info  describing the object being hovered. Returns one of the following: null  - the tooltip is hidden, with the CSS  display  property set to  none . A string - the string is rendered in a tooltip with the default CSS styling described below. An object with the following fields: text  (String, optional) - Specifies the  innerText  attribute of the tooltip. html  (String, optional) - Specifies the  innerHTML  attribute of the tooltip. Note that this will override the specified  innerText . className  (String, optional) - Class name to attach to the tooltip element. The element has the default class name of  deck-tooltip . style  (Object, optional) - An object of CSS styles to apply to the tooltip element, which can override the default styling. By default, the tooltip has the following CSS style: pickingRadius  (Number) Extra pixels around the pointer to include while picking. This is helpful when rendered objects are difficult to target, for example irregularly shaped icons, small moving circles or interaction by touch. Default  0 . touchAction  (String) Default:  none . Allow browser default touch actions. See  hammer.js documentation . By default, the deck canvas captures all touch interactions. This prop is useful for mobile applications to unblock default scrolling behavior. For example, use the combination  controller: {dragPan: false}  and  touchAction: 'pan-y'  to allow vertical page scroll when dragging over the canvas. eventRecognizerOptions  (Object) default:  {} Set options for gesture recognition. May contain the following fields: pan  - an object that is  Hammer.Pan  options. This gesture is used for drag events. pinch  - an object that is  Hammer.Pinch  options This gesture is used for two-finger touch events. tripan  - an object that is  Hammer.Pan  options.  This gesture is used for three-finger touch events. tap  - an object that is  Hammer.Tap  options. This gesture is used for the  onClick  callback. doubletap  - an object that is  Hammer.Tap  options. This gesture is used for double click events. For example, the following setting makes panning less sensitive and clicking easier on mobile: _pickable  (Boolean) Default:  true (Experimental) If set to  false , force disables all picking features, disregarding the  pickable  prop set in any layer. Event Callbacks onWebGLInitialized  (Function) Called once the WebGL context has been initiated. Receives arguments: gl  - the WebGL context. onViewStateChange  (Function) Called when the user has interacted with the deck.gl canvas, e.g. using mouse, touch or keyboard. onViewStateChange({viewState, interactionState, oldViewState}) Receives arguments: viewState  - An updated  view state  object. interactionState  - Describes the interaction that invoked the view state change. May include the following fields: inTransition  (Boolean) isDragging  (Boolean) isPanning  (Boolean) isRotating  (Boolean) isZooming  (Boolean) oldViewState  - The previous  view state  object. Returns: A view state object that is used to update  Deck 's internally tracked view state (see  initialViewState ). This can be used to intercept and modify the view state before the camera updates, see  add constraints to view state example . If no value is returned, it's equivalent to  (viewState) => viewState . onInteractionStateChange  (Function) Called when the user has interacted with the deck.gl canvas, e.g. using mouse, touch or keyboard. onInteractionStateChange(interactionState) Receives arguments: interactionState  - Describes the current interaction. May include the following fields: inTransition  (Boolean) isDragging  (Boolean) isPanning  (Boolean) isRotating  (Boolean) isZooming  (Boolean) Note: onInteractionStateChange  may be fired without  onViewStateChange . For example, when the pointer is released at the end of a drag-pan,  isDragging  is reset to  false , without the viewport's  longitude  and  latitude  changing. onHover  (Function) Called when the pointer moves over the canvas. Receives arguments: info  - the  picking info  describing the object being hovered. event  - the original gesture event onClick  (Function) Called when clicking on the canvas. Receives arguments: info  - the  picking info  describing the object being clicked. event  - the original gesture event onDragStart  (Function) Called when the user starts dragging on the canvas. Receives arguments: info  - the  picking info  describing the object being dragged. event  - the original gesture event onDrag  (Function) Called when dragging the canvas. Receives arguments: info  - the  picking info  describing the object being dragged. event  - the original gesture event onDragEnd  (Function) Called when the user releases from dragging the canvas. Receives arguments: info  - the  picking info  describing the object being dragged. event  - the original gesture event onLoad  (Function) Called once after gl context and Deck components ( ViewManager ,  LayerManager , etc) are created. It is safe to trigger viewport transitions after this event. onResize  (Function) Called when the canvas resizes. Receives arguments: size width  (Number) - the new width of the deck canvas, in client pixels height  (Number) - the new height of the deck canvas, in client pixels onBeforeRender  (Function) Called just before the canvas rerenders. Receives arguments: gl  - the WebGL context. onAfterRender  (Function) Called right after the canvas rerenders. Receives arguments: gl  - the WebGL context. onError  (Function) Default:  console.error Called if deck.gl encounters an error. By default, deck logs the error to console and attempt to continue rendering the rest of the scene. If this callback is set to  null , errors are silently ignored. Receives arguments: error  ( Error ) layer  (Layer?) - the layer where the error is originated, if applicable _onMetrics  (Function) (Experimental) Called once every second with performance metrics. Receives arguments: metrics  - an object with fields specified  here . Methods finalize Frees all resources associated with this  Deck  instance. deck.finalize() setProps Updates (partial) properties. Parameters: One or more properties to update, as described in the \"Properties\" section on this page. redraw Attempt to draw immediately, rather than waiting for the next draw cycle. By default, deck flushes all changes to the canvas on each animation frame. This behavior might cause the deck canvas to fall out of sync with other components if synchronous updates are required. Redrawing frequently outside of rAF may cause performance problems. Only use this method if the render cycle must be managed manually. Parameters: force  (Boolean) - if  false , only redraw if necessary (e.g. changes have been made to views or layers). If  true , skip the check. Default  false . pickObject Get the closest pickable and visible object at the given screen coordinate. Parameters: x  (Number) - x position in pixels y  (Number) - y position in pixels radius  (Number, optional) - radius of tolerance in pixels. Default  0 . layerIds  (Array, optional) - a list of layer ids to query from. If not specified, then all pickable and visible layers are queried. unproject3D  (Boolean, optional) - if  true ,  info.coordinate  will be a 3D point by unprojecting the  x, y  screen coordinates onto the picked geometry. Default  false . Returns: a single  info  object, or  null  if nothing is found. pickMultipleObjects Performs deep picking. Finds all close pickable and visible object at the given screen coordinate, even if those objects are occluded by other objects. Parameters: x  (Number) - x position in pixels y  (Number) - y position in pixels radius  (Number, optional) - radius of tolerance in pixels. Default  0 . layerIds  (Array, optional) - a list of layer ids to query from. If not specified, then all pickable and visible layers are queried. depth  - Specifies the max number of objects to return. Default  10 . unproject3D  (Boolean, optional) - if  true ,  info.coordinate  will be a 3D point by unprojecting the  x, y  screen coordinates onto the picked geometry. Default  false . Returns: An array of  info  objects. The array will be empty if no object was picked. Notes: Deep picking is implemented as a sequence of simpler picking operations and can have a performance impact. Should this become a concern, you can use the  depth  parameter to limit the number of matches that can be returned, and thus the maximum number of picking operations. pickObjects Get all pickable and visible objects within a bounding box. Parameters: x  (Number) - left of the bounding box in pixels y  (Number) - top of the bouding box in pixels width  (Number, optional) - width of the bouding box in pixels. Default  1 . height  (Number, optional) - height of the bouding box in pixels. Default  1 . layerIds  (Array, optional) - a list of layer ids to query from. If not specified, then all pickable and visible layers are queried. maxObjects  (Number, optional) - if specified, limits the number of objects that can be returned. Returns: an array of unique  info  objects Notes: The query methods are designed to quickly find objects by utilizing the picking buffer. The query methods offer more flexibility for developers to handle events compared to the built-in hover and click callbacks. Member Variables isInitialized Flag indicating that the Deck instance has initialized its resources. It is safe to call public methods when  isInitialized  is  true . metrics A map of various performance statistics for the last 60 frames of rendering. Metrics gathered in deck.gl are the following: fps  - average number of frames rendered per second updateAttributesTime  - time spent updating layer attributes setPropsTime  - time spent setting deck properties framesRedrawn  - number of times the scene was rendered pickTime  - total time spent on picking operations pickCount  - number of times a pick operation was performed gpuTime  - total time spent on GPU processing gpuTimePerFrame  - average time spent on GPU processing per frame cpuTime  - total time spent on CPU processing cpuTimePerFrame  - average time spent on CPU processing per frame bufferMemory  - total GPU memory allocated for buffers textureMemory  - total GPU memory allocated for textures renderbufferMemory  - total GPU memory allocated for renderbuffers gpuMemory  - total allocated GPU memory Source modules/core/src/lib/deck.js","headings":[{"value":"Deck","depth":1},{"value":"Usage","depth":2},{"value":"Constructor","depth":2},{"value":"Properties","depth":2},{"value":"Initialization Settings","depth":3},{"value":"canvas (HTMLCanvasElement | String, optional)","depth":5},{"value":"gl (WebGLContext)","depth":5},{"value":"glOptions (Object)","depth":5},{"value":"id (String)","depth":5},{"value":"parent (HTMLElement)","depth":5},{"value":"debug (Boolean)","depth":5},{"value":"_typedArrayManagerProps (Object)","depth":5},{"value":"Rendering Configuration","depth":3},{"value":"width (Number|String)","depth":5},{"value":"height (Number|String)","depth":5},{"value":"style (Object)","depth":5},{"value":"useDevicePixels (Boolean|Number)","depth":5},{"value":"parameters (Object)","depth":5},{"value":"layers (Array)","depth":5},{"value":"layerFilter (Function)","depth":5},{"value":"views (Object|Array)","depth":5},{"value":"viewState (Object)","depth":5},{"value":"initialViewState (Object)","depth":5},{"value":"effects (Array)","depth":5},{"value":"_framebuffer (Object)","depth":5},{"value":"_animate (Boolean)","depth":5},{"value":"Interaction Settings","depth":3},{"value":"controller (Function | Boolean | Object)","depth":5},{"value":"getCursor (Function)","depth":5},{"value":"getTooltip (Function)","depth":5},{"value":"pickingRadius (Number)","depth":5},{"value":"touchAction (String)","depth":5},{"value":"eventRecognizerOptions (Object)","depth":5},{"value":"_pickable (Boolean)","depth":5},{"value":"Event Callbacks","depth":3},{"value":"onWebGLInitialized (Function)","depth":5},{"value":"onViewStateChange (Function)","depth":5},{"value":"onInteractionStateChange (Function)","depth":5},{"value":"onHover (Function)","depth":5},{"value":"onClick (Function)","depth":5},{"value":"onDragStart (Function)","depth":5},{"value":"onDrag (Function)","depth":5},{"value":"onDragEnd (Function)","depth":5},{"value":"onLoad (Function)","depth":5},{"value":"onResize (Function)","depth":5},{"value":"onBeforeRender (Function)","depth":5},{"value":"onAfterRender (Function)","depth":5},{"value":"onError (Function)","depth":5},{"value":"_onMetrics (Function)","depth":5},{"value":"Methods","depth":2},{"value":"finalize","depth":5},{"value":"setProps","depth":5},{"value":"redraw","depth":5},{"value":"pickObject","depth":5},{"value":"pickMultipleObjects","depth":5},{"value":"pickObjects","depth":5},{"value":"Member Variables","depth":2},{"value":"isInitialized","depth":5},{"value":"metrics","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/deck","title":"Deck"},{"excerpt":"DirectionalLight Create a directional light source which emits from a specific direction.A directional light can be considered \"infinitely\" far away (like the Sun) and does not attenuate with distance. At most 5 directional lights can be supported. Usage Create a directional light source with color, intensity and direction. Methods constructor The constructor for the  DirectionalLight  class. Use this to create a new  DirectionalLight . color  - ( array ,)  RGB color of directional light source, default value is  [255, 255, 255] . intensity  - ( number ) Strength of directional light source, default value is  1.0 . direction  - ( array ,)  3D vector specifies the direction the light comes from, default value is  [0, 0, -1] . _shadow  - ( boolean , optional) Enable experimental shadow effect, default value is  false . Source /modules/core/src/effects/lighting/directional-light.js","headings":[{"value":"DirectionalLight","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"constructor","depth":3},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/directional-light","title":"DirectionalLight"},{"excerpt":"FirstPersonController Inherits from  Base Controller . The  FirstPersonController  class can be passed to either the  Deck  class's  controller  prop or a  View  class's  controller  prop to specify that viewport interaction should be enabled. FirstPersonController  is the default controller for  FirstPersonView . Usage Use with the default view: is equivalent to: Options Supports all  Controller options  with the following default behavior: dragMode : default  'rotate'  (drag to rotate) dragPan : not effective, this view does not support panning keyboard : arrow keys to move camera, arrow keys with shift/ctrl down to rotate, +/- to zoom Custom FirstPersonController You can further customize the  FirstPersonController 's behavior by extending the class: See the  Controller  class  documentation  for the methods that you can use and/or override. Source modules/core/src/controllers/first-person-controller.js","headings":[{"value":"FirstPersonController","depth":1},{"value":"Usage","depth":2},{"value":"Options","depth":2},{"value":"Custom FirstPersonController","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/first-person-controller","title":"FirstPersonController"},{"excerpt":"FirstPersonView The  FirstPersonView  class is a subclass of  View  that describes a camera placed at a provided location, looking  towards  the direction and orientation specified by  viewState . The behavior is similar to that of a  first-person game . It's recommended that you read the  Views and Projections guide  before using this class. Constructor FirstPersonView  takes the same parameters as the  View  superclass constructor, plus the following: projectionMatrix  (Array 16 , optional) Projection matrix. If  projectionMatrix  is not supplied, the  View  class will build a projection matrix from the following parameters: fovy  (Number, optional) Field of view covered by camera, in the perspective case. In degrees. Default  75 . near  (Number, optional) Distance of near clipping plane. Default  0.1 . far  (Number, optional) Distance of far clipping plane. Default  1000 . focalDistance  (Number, optional) Modifier of viewport scale. Corresponds to the number of pixels per meter. Default  1 . View State To render, a  FirstPersonView  needs to be combined with a  viewState  object with the following parameters: longitude  (Number, optional) - longitude of the camera latitude  (Number, optional) - latitude of the camera position  (Number 3 , optional) - meter offsets of the camera from the lng-lat anchor point. Default  [0, 0, 0] . bearing  (Number, optional) - bearing angle in degrees. Default  0  (north). pitch  (Number, optional) - pitch angle in degrees. Default  0  (horizontal). maxPitch  (Number, optional) - max pitch angle. Default  90  (down). minPitch  (Number, optional) - min pitch angle. Default  -90  (up). Controller By default,  FirstPersonView  uses the  FirstPersonController  to handle interactivity. To enable the controller, use: Visit the  FirstPersonController  documentation for a full list of supported options. Source modules/core/src/views/first-person-view.js","headings":[{"value":"FirstPersonView","depth":1},{"value":"Constructor","depth":2},{"value":"projectionMatrix (Array16, optional)","depth":5},{"value":"fovy (Number, optional)","depth":5},{"value":"near (Number, optional)","depth":5},{"value":"far (Number, optional)","depth":5},{"value":"focalDistance (Number, optional)","depth":5},{"value":"View State","depth":2},{"value":"Controller","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/first-person-view","title":"FirstPersonView"},{"excerpt":"FlyToInterpolator Performs \"fly to\" style interpolation between two geospatial view states. Implements  TransitionInterpolator . See  View State Transitions  for usage examples. Constructor Parameters: options (Object) curve  (Number, optional) - The zooming \"curve\" that will occur along the flight path. Default  1.414 . speed  (Number, optional) - The average speed of the animation defined in relation to  options.curve , it linearly affects the duration, higher speed returns smaller durations and vice versa. Default  1.2 . screenSpeed  (Number, optional) - The average speed of the animation measured in screenfuls per second. Similar to  speed  it linearly affects the duration,  when specified  speed  is ignored. maxDuration  (Number, optional) - Maximum duration in milliseconds, if calculated duration exceeds this value,  0  is returned. Source modules/core/src/transitions/viewport-fly-to-interpolator.js","headings":[{"value":"FlyToInterpolator","depth":1},{"value":"Constructor","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/fly-to-interpolator","title":"FlyToInterpolator"},{"excerpt":"GlobeView (Experimental) This class is experimental, which means it does not provide the compatibility and stability that one would typically expect from other  View  classes. Use with caution and report any issues that you find on GitHub. The  GlobeView  class is a subclass of  View . This view projects the earth into a 3D globe. It's recommended that you read the  Views and Projections guide  before using this class. Limitations The goal of  GlobeView  is to provide a generic solution to rendering and navigating data in the 3D space.\nIn the initial release, this class mainly addresses the need to render an overview of the entire globe. The following limitations apply, as features are still under development:  No support for rotation ( pitch  or  bearing ). The camera always points towards the center of the earth, with north up. No high-precision rendering at high zoom levels (> 12). Features at the city-block scale may not be rendered accurately. Only supports  COORDINATE_SYSTEM.LNGLAT  (default of the  coordinateSystem  prop). Known rendering issues when using multiple views mixing  GlobeView  and  MapView , or switching between the two. Support for  TileLayer  and  MVTLayer  is experimental. These layers currently do not work in this view: Aggregation layers:  HeatmapLayer ,  ContourLayer TerrainLayer When GeoJson paths and polygons are rendered with this view, the straight lines and flat surfaces are warped to the surface of the globe. Note that the warped edges still correspond to straight lines in the Mercator projection. To draw lines along the shortest distance on the globe, use the  GreatCircleLayer . Constructor GlobeView  takes the same parameters as the  View  superclass constructor, plus the following: resolution  (Number, optional) The resolution at which to turn flat features into 3D meshes, in degrees. Smaller numbers will generate more detailed mesh. Default  10 . nearZMultiplier  (Number, optional) Scaler for the near plane, 1 unit equals to the height of the viewport. Default to  0.1 . Overwrites the  near  parameter. farZMultiplier  (Number, optional) Scaler for the far plane, 1 unit equals to the distance from the camera to the edge of the screen. Default to  2 . Overwrites the  far  parameter. View State To render,  GlobeView  needs to be used together with a  viewState  with the following parameters: longitude  (Number) - longitude at the viewport center latitude  (Number) - latitude at the viewport center zoom  (Number) - zoom level maxZoom  (Number, optional) - max zoom level. Default  20 . minZoom  (Number, optional) - min zoom level. Default  0 . Controller By default,  GlobeView  uses the  GlobeController  to handle interactivity. To enable the controller, use: Visit the  GlobeController  documentation for a full list of supported options. Remarks Occlusion In the MapView, it is often sufficient to provide a solid background color where there is no geometry. In the GlobeView, the user can \"see through\" to the other side of the earth. There are two ways to fix this: Render a polygon that represents the surface of the earth: Discard all surfaces that face away from the camera by passing the following prop to  Deck : Source modules/core/src/views/globe-view.js","headings":[{"value":"GlobeView (Experimental)","depth":1},{"value":"Limitations","depth":2},{"value":"Constructor","depth":2},{"value":"resolution (Number, optional)","depth":5},{"value":"nearZMultiplier (Number, optional)","depth":5},{"value":"farZMultiplier (Number, optional)","depth":5},{"value":"View State","depth":2},{"value":"Controller","depth":2},{"value":"Remarks","depth":1},{"value":"Occlusion","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/globe-view","title":"GlobeView (Experimental)"},{"excerpt":"GlobeController (Experimental) Inherits from  Base Controller . The  GlobeController  class can be passed to either the  Deck  class's  controller  prop or a  View  class's  controller  prop to specify that viewport interaction should be enabled. GlobeController  is the default controller for  GlobeView . Usage Use with the default view: is equivalent to: Options Supports all  Controller options  with the following default behavior: dragPan : default  'pan'  (drag to pan) dragRotate : not effective, this view does not currently support rotation touchRotate : not effective, this view does not currently support rotation keyboard : arrow keys to pan, +/- to zoom Custom GlobeController You can further customize the  GlobeController 's behavior by extending the class: See the  Controller  class  documentation  for the methods that you can use and/or override. Source modules/core/src/controllers/globe-controller.js","headings":[{"value":"GlobeController (Experimental)","depth":1},{"value":"Usage","depth":2},{"value":"Options","depth":2},{"value":"Custom GlobeController","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/globe-controller","title":"GlobeController (Experimental)"},{"excerpt":"GlobeViewport (Experimental) The  GlobeViewport  class takes globe view states ( latitude ,  longitude , and  zoom ), and performs projections between world and screen coordinates. It is a helper class for visualizing the earth as a 3D globe. Usage A  GlobeViewport  instance is created under the hood by a  GlobeView . Constructor Parameters: opts  (Object) - Globe viewport options width  (Number) - Width of the viewport. height  (Number) - Height of the viewport. geospatial arguments: latitude  (Number, optional) - Latitude of the viewport center on map. Default to  0 . longitude  (Number, optional) - Longitude of the viewport center on map. Default to  0 . zoom  (Number, optional) - Map zoom (scale is calculated as  2^zoom ). Default to  11 . altitude  (Number, optional) - Altitude of camera, 1 unit equals to the height of the viewport. Default to  1.5 . projection matrix arguments: nearZMultiplier  (Number, optional) - Scaler for the near plane, 1 unit equals to the height of the viewport. Default to  0.1 . farZMultiplier  (Number, optional) - Scaler for the far plane, 1 unit equals to the distance from the camera to the top edge of the screen. Default to  1 . Remarks: width  and  height  are forced to 1 if supplied as 0, to avoid division by zero. This is intended to reduce the burden of apps to check values before instantiating a  Viewport . Per cartographic tradition, longitudes and latitudes are specified as degrees. Inherits all  Viewport methods . Methods Inherits all methods from  Viewport . project Projects world coordinates to pixel coordinates on screen. Parameters: coordinates  (Array) -  [longitude, latitude, altitude] .  altitude  is in meters and default to  0  if not supplied. opts  (Object) topLeft  (Boolean, optional) - Whether projected coords are top left. Default to  true . Returns: [x, y]  or  [x, y, z]  in pixels coordinates.  z  is pixel depth. If input is  [longitude, latitude] : returns  [x, y] . If input is  [longitude, latitude: altitude] : returns  [x, y, z] . unproject Unproject pixel coordinates on screen into world coordinates. Parameters: pixels  (Array) -  [x, y, z]  in pixel coordinates. Passing a  z  is optional. opts  (Object) topLeft  (Boolean, optional) - Whether projected coords are top left. Default to  true . targetZ  (Number, optional) - If pixel depth  z  is not specified in  pixels , this is used as the elevation plane to unproject onto. Default  0 . Returns: [longitude, latitude]  or  [longitude, latitude, altitude]  in world coordinates.  altitude  is in meters. If input is  [x, y]  without specifying  opts.targetZ : returns  [longitude, latitude] . If input is  [x, y]  with  opts.targetZ : returns  [longitude, latitude, targetZ] . If input is  [x, y, z] : returns  [longitude, latitude, altitude] . Source modules/core/src/viewports/globe-viewport.js","headings":[{"value":"GlobeViewport (Experimental)","depth":1},{"value":"Usage","depth":2},{"value":"Constructor","depth":2},{"value":"Methods","depth":2},{"value":"project","depth":5},{"value":"unproject","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/globe-viewport","title":"GlobeViewport (Experimental)"},{"excerpt":"LayerManager Class (Internal) The  LayerManager  class is gradually being refactor into a  ComponentManager  class and will be made part of the  lifecycle  directory. It is now an internal class, use the  Deck  class (or the  DeckGL  React Component) which creates a  LayerManager  under the hood. The  LayerManager  class manages a set of layers' lifecycle. For more information consult the  Using Standalone  article. Constructor Creates a new  LayerManager  instance. Parameters: gl  ( WebGLRenderingContext ) Methods needsRedraw Checks if layers need to be redrawn. Parameters: clearRedrawFlags  (Bool) - Reset the needs redraw status Returns: true  if redraw is needed. getLayers Returns an list of layers, optionally be filtered by a list of layer ids. Parameters: layerIds  (String[], optional) - A list of layer id strings. If supplied, the returned list will only contain layers whose  id  property matches (see note) one of the strings in the list. Returns: Layer[]  - array of layer instances. Notes: The returned list of layers is \"expanded\" in the sense that composite layers will have been recursively rendered and the list will thus only contain primitive layers. When supplying the layer id of a composite layer, all the sub layers rendered by that layer will be included. layer id matching checks that a layer id  starts with  one of the supplied strings. This ensures that sublayers rendered by a composite layer with the given id will also be included in the matched list. setLayers Provide a new list of layers. Layers will be matched against old layers, and any composite layers will be recursively expanded into primitive layers. newLayers  (Layer[]) - Array of layers updateLayers Updates the current list of layers. Source modules/core/src/lib/layer-manager.js","headings":[{"value":"LayerManager Class (Internal)","depth":1},{"value":"Constructor","depth":2},{"value":"Methods","depth":2},{"value":"needsRedraw","depth":5},{"value":"getLayers","depth":5},{"value":"setLayers","depth":5},{"value":"updateLayers","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/layer-manager","title":"LayerManager Class (Internal)"},{"excerpt":"Layer Class The  Layer  class is the base class of all deck.gl layers, and it provides a number of  base properties  available in all layers. Static Members layerName  (String, required) This static property should contain the name of the layer, typically the name of layer's class (it cannot reliably be autodeduced in minified code). It is used as the default Layer id as well as for debugging and profiling. defaultProps  (Object, optional) All deck.gl layers define a  defaultProps  static member listing their props and default values. Using  defaultProps  improves both the code readability and performance during layer instance construction. Constructor Parameters: props  (Object) -  Layer  properties. Notes: More than one property object can be supplied. Property objects will be merged with the same semantics as  Object.assign , i.e. props in later objects will overwrite props earlier object. Every layer specifies default values for all its props, and these values will be used internally if that prop is not specified by the application in the Layer constructor. Properties Basic Properties id  (String, optional) Default: the layer class's  layerName  static property. The  id  must be unique among all your layers at a given time. The default value of  id  is the  Layer 's \"name\". If more than one instance of a specific type of layer exist at the same time, they must possess different  id  strings for deck.gl to properly distinguish them. Remarks: id  is used to match layers between rendering calls. deck.gl requires each layer to have a unique  id . A default  id  is assigned based on layer type, which means if you are using more than one layer of the same type (e.g. two  ScatterplotLayer s) you need to provide a custom  id  for at least one of them. A layer's name is defined by the  Layer.layerName  static member, or inferred from the constructor name (which is not robust in minified code). For sublayers (automatically generated by composite layers), a unique \"composite layer id\" is automatically generated by appending the sub layer's id to the parent layer's  id , so there is no risk of  id  collisions for sublayers, as long as the application's layer names are unique. data  (Iterable | String | Promise | AsyncIterable | Object, optional) Default:  [] deck.gl layers typically expect  data  to be one of the following types: Array : a JavaScript array of data objects. An object that implements the  iterable protocol , for example  Map  and  Set . Represents a collection of data objects. Any non-iterable object that contains a  length  field. deck.gl will not attempt to interpret its format, but simply call each accessor  length  times. (See remark below) String : an URL pointing to the data source. deck.gl will attempt to fetch the remote content and parse it as JSON. The resulting object is then used as the value of the  data  prop. Promise : the resolved value will be used as the value of the  data  prop. AsyncIterable : an  async iterable  object that yields data in batches. The default implementation expects each batch to be an array of data objects; one may change this behavior by supplying a custom  dataTransform  callback. data.attributes When using a non-iterable  data  object, the object may optionally contain a field  attributes , if the application wishes to supply binary buffers directly to the layer. This use case is discussed in detail in the  performance developer guide . The keys in  data.attributes  correspond to the  accessor  name that the binary should replace, for example  getPosition ,  getColor . See each layer's documentation for available accessor props. Each value in  data.attributes  may be one of the following formats: luma.gl  Buffer  instance A typed array, which will be used to create a  Buffer An object containing the following optional fields. For more information, see  WebGL vertex attribute API . buffer  ( Buffer ) value  (TypedArray) type  (GLenum) - A WebGL data type, see  vertexAttribPointer . size  (Number) - the number of elements per vertex attribute. offset  (Number) - offset of the first vertex attribute into the buffer, in bytes stride  (Number) - the offset between the beginning of consecutive vertex attributes, in bytes normalized  (Boolean) - whether data values should be normalized. Note that all color attributes in deck.gl layers are normalized by default. Remarks Some layers may accept alternative data formats. For example, the  GeoJsonLayer  supports any valid GeoJSON object as  data . These exceptions, if any, are documented in each layer's documentation. When an iterable value is passed to  data , every accessor function receives the current element as the first argument. When a non-iterable value (any object with a  length  field) is passed to  data , the accessor functions are responsible of interpreting the data format. The latter is often used with binary inputs. Read about this in  accessors . The automatic URL loading support is intended as a convenience for simple use cases. There are many limitations, including control over request parameters and headers, ability to parse non-JSON data, control of post-processing, CORS support etc. In such cases, it is always possible to load data using traditional JavaScript techniques and rerender the layer with the resulting data array. For  Layer  writers: Even though applications can pass in url string as  data  props, deck.gl makes sure that the layers never see  data  props containing  String  values. Layers will only see the default empty array value for the  data  prop until the data is loaded, at which point it will be updated with the loaded array. visible  (Boolean, optional) Default:  true Whether the layer is visible. Under most circumstances, using  visible  prop to control the visibility of layers are recommended over doing conditional rendering. Compare: with In the second example (conditional rendering) the layer state will be destroyed and regenerated every time the  showMyLayer  flag changes. opacity  (Number, optional) Default:  1 The opacity of the layer. Remarks: deck.gl automatically applies gamma to the opacity in an attempt to make opacity changes appear linear (i.e. the perceived opacity is visually proportional to the value of the prop). While it is a recommended convention that all deck.gl layers should support the  opacity  prop, it is up to each layer's fragment shader to properly implement support for opacity. extensions  (Array, optional) Add additional functionalities to this layer. See the  list of available extensions . onError  (Function, optional) Called when this layer encounters an error, with the following arguments: error  - a JavaScript  Error  object. If this callback is supplied and returns  true , the error is marked as handled and will not bubble up to the  onError  callback of the  Deck  instance. Interaction Properties Layers can be interacted with using these properties. pickable  (Boolean, optional) Default:  false Whether the layer responds to mouse pointer picking events. onHover  (Function, optional) This callback will be called when the mouse enters/leaves an object of this deck.gl layer with the following parameters: info event  - the source event If this callback returns a truthy value, the  hover  event is marked as handled and will not bubble up to the  onHover  callback of the  DeckGL  canvas. Requires  pickable  to be true. onClick  (Function, optional) This callback will be called when the mouse clicks over an object of this deck.gl layer with the following parameters: info event  - the source event If this callback returns a truthy value, the  click  event is marked as handled and will not bubble up to the  onClick  callback of the  DeckGL  canvas. Requires  pickable  to be true. onDragStart  (Function, optional) This callback will be called when the mouse starts dragging an object of this deck.gl layer with the following parameters: info event  - the source event If this callback returns a truthy value, the  dragstart  event is marked as handled and will not bubble up to the  onDragStart  callback of the  DeckGL  canvas. Requires  pickable  to be true. onDrag  (Function, optional) This callback will be called when the mouse drags an object of this deck.gl layer with the following parameters: info event  - the source event If this callback returns a truthy value, the  drag  event is marked as handled and will not bubble up to the  onDrag  callback of the  DeckGL  canvas. Requires  pickable  to be true. onDragEnd  (Function, optional) This callback will be called when the mouse releases an object of this deck.gl layer with the following parameters: info event  - the source event If this callback returns a truthy value, the  dragend  event is marked as handled and will not bubble up to the  onDragEnd  callback of the  DeckGL  canvas. Requires  pickable  to be true. highlightColor  (Array|Function, optional) Default:  [0, 0, 128, 128] RGBA color to blend with the highlighted object (either the hovered over object if  autoHighlight: true , or the object at the index specified by  highlightedObjectIndex ). When the value is a 3 component (RGB) array, a default alpha of 255 is applied. If an array is supplied, it is used for the object that is currently highlighted. If a function is supplied, it is called with a  pickingInfo  object when the hovered object changes. The return value is used as the highlight color for the picked object. Only works with  autoHighlight: true . highlightedObjectIndex  (Number|null, optional) Default:  null The index of the object in  data  to highlight. If specified, overrides the effect of  autoHighlight . When set to an integer that corresponds to an object, the object will be highlighted with  highlightColor . When set to an integer that does not correspond to an object (e.g.  -1 ), nothing is highlighted. autoHighlight  (Boolean, optional) Default:  false When true, current object pointed by mouse pointer (when hovered over) is highlighted with  highlightColor . Requires  pickable  to be true. Coordinate System Properties Normally only used when the application wants to work with coordinates that are not Web Mercator projected longitudes/latitudes. coordinateSystem  (Number, optional) Default:  COORDINATE_SYSTEM.DEFAULT Specifies how layer positions and offsets should be geographically interpreted. One of: COORDINATE_SYSTEM.CARTESIAN COORDINATE_SYSTEM.LNGLAT COORDINATE_SYSTEM.METER_OFFSETS COORDINATE_SYSTEM.LNGLAT_OFFSETS The default is to interpret positions as latitude and longitude, however it is also possible to interpret positions as meter offsets added to projection center specified by the  coordinateOrigin  prop. See the article on  Coordinate Systems  for details. coordinateOrigin  ( Number, Number, Number , optional) Default:  [0, 0, 0] Specifies a reference point for coordinates that are expressed as offsets. Used when the  coordinateSystem  is set to one of the following modes: COORDINATE_SYSTEM.CARTESIAN  (optional) COORDINATE_SYSTEM.METER_OFFSETS  (required) COORDINATE_SYSTEM.LNGLAT_OFFSETS  (required) See the article on  Coordinate Systems  for details. wrapLongitude  (Boolean, optional) Default:  false Normalizes geometry longitudes. Only works with the  LNGLAT  coordinate system. When enabled on  PathLayer ,  PolygonLayer  and  GeoJsonLayer , the paths/polygons are interpretted such that the connection between any two neighboring vertices is drawn on the shorter side of the world, and split into two if it crosses the 180th meridian. Note that this introduces CPU overhead at runtime. When working with static data, it is recommend that you preprocess the features offline instead of using this option. When enabled on layers with position pairs, such as  LineLayer  and  ArcLayer , they will draw the shortest path between source and target positions. If the shortest path crosses the 180th meridian, it is split into two segments. When enabled on other layers, the effect is applied by moving the anchor point into the  [-180, 180]  range. modelMatrix  (Number 16 , optional) An optional 4x4 matrix that is multiplied into the affine projection matrices used by shader  project  GLSL function and the Viewport's  project  and  unproject  JavaScript function. Allows local coordinate system transformations to be applied to a layer, which is useful when composing data from multiple sources that use different coordinate systems. Note that the matrix projection is applied after the non-linear mercator projection calculations are resolved, so be careful when using model matrices with longitude/latitude encoded coordinates. They normally work best with non-mercator viewports or meter offset based mercator layers. Data Properties There are a number of additional properties that provide extra control over data iteration, comparison and update. dataComparator  (Function, optional) This prop causes the  data  prop to be compared using a custom comparison function. The comparison function is called with the old data and the new data objects, and is expected to return true if they compare equally. Used to override the default shallow comparison of the  data  object. As an illustration, the app could set this to e.g. 'lodash.isequal', enabling deep comparison of the data structure. This particular examples would obviously have considerable performance impact and should only be used as a temporary solution for small data sets until the application can be refactored to avoid the need. The function receives two arguments: newData  - the new data prop oldData  - the data prop before the update And should return  true  if the two values are considered equal (no update needed), or  false  if the data has changed. dataTransform  (Function, optional) Executed to manipulate remote data when it's fetched. This callback applies when  data  is assigned a value that is either string (URL), Promise or an async iterable. The function receives two arguments: data  - the newly fetched data previousData  - (only available when  data  is an async iterable) the previously loaded data. If  dataTransform  is not supplied, the new data chunk is appended to the previous data array. And must return a valid  data  object: an array, an iterable or a non-iterable object that contains a  length  field. See documentation of the  data  prop for details. _dataDiff  (Function, optional)  Experimental This function is called when the data changes, either shallowly when  dataComparator  is not supplied or because  dataComparator  returns  false , to retrieve the indices of the changed objects. By default, when data changes, the attributes of all objects are recalculated. If this prop is supplied, only the attributes of the specified objects will be updated. This can lead to significant performance improvement if a few rows in a large data table need to change frequently: The function receives two arguments: newData  - the new data prop oldData  - the data prop before the update And is expected to return an array of \"ranges\", in the form of  {startRow, endRow} : startRow  (Number) - the beginning index of a changed chunk in the new data. endRow  (Number) - the end index of a changed chunk in the new data (excluded). This feature is experimental and intended for advanced use cases.  Note that it only rewrites part of a buffer, not remove or insert, therefore the user of this prop is responsible of making sure that all the unchanged objects remain at the same indices between  oldData  and  newData . This becomes trickier when dealing with data of dynamic lengths, for example  PathLayer ,  PolygonLayer  and  GeoJsonLayer . Generally speaking, it is not recommended to use this feature when the count of vertices in the paths/polygons may change. positionFormat  (String, optional) One of  'XYZ' ,  'XY' . This prop is currently only effective in  PathLayer ,  SolidPolygonLayer  and  PolygonLayer . Default  'XYZ' . colorFormat  (String, optional) One of  'RGBA' ,  'RGB' . Setting it to  'RGB'  will make the layer ignore the alpha channel of the colors returned by accessors, and instead assume all objects to be opaque.\nThe layer's overall transparency controlled by  opacity  is still applied. Default  'RGBA' . numInstances  (Number, optional) deck.gl automatically derives the number of drawing instances from the  data  prop by counting the number of objects in  data . However, the developer might want to manually override it using this prop. updateTriggers  (Object, optional) Accessors such as  getColor  and  getPosition  are called to retrieve colors and positions when a layer is first added. From then on, to maximize performance, deck.gl does not recalculate colors or positions unless the  data  prop changes by shallow comparison. Sometimes  data  remains the same, but the outcome of an accessor has changed. In the following example, this is caused by changes in the external values  maleColor  and  femaleColor : In this case, you need to explicitly inform deck.gl to re-evaluate  getFillColor  for all data items. You do so by defining  updateTriggers : updateTriggers  expect an object whose keys are names of accessor props of this layer, and values are one or more variables that affect the output of the accessors. For example,  updateTriggers.getFillColor  is a list of variables that affect the output of\n  getFillColor . If either value in the array changes, all attributes that depend on\n  getFillColor  will be updated.\nThe variables may be numbers, strings, objects or functions. During each rendering cycle, deck.gl shallow-compares them with the previous values. Note: change of the  data  prop has higher priority than the  updateTriggers . If the app supplies a new  data  object, then all attributes will be automatically updated, even if the updateTriggers have not changed. To block excessive attribute updates, set the  dataComparator  prop. loaders  (Array, optional) Default:  [] An array of  loaders.gl loaders . Out of the box, deck.gl supports loading JSON and image files (with  ImageLoader ), and specific layer implementation such as  MVTLayer ,  TerrainLayer  and  ScenegraphLayer  also include loaders for their targeted formats. Support for addtional formats can be added by adding loaders to the  loaders  prop. For example, to load data from CSV files: loadOptions  (Object, optional) Default:  null Layers use  loaders.gl  to load data and other resources.  loadOptions  is an object to customize the behavior of any loader used during fetching and parsing. The object may contain any of the  top-level options , as well as loader-specific options targeting a particular format. Layers may also include specialized loaders for their own use case, such as images, 3d-tiles, etc. See the documentation of each layer for additional load options that are available. Find usage examples in the  data loading guide . fetch  (Function, optional) Called to fetch and parse content from URLs. The function receives the following arguments: url  (String) - the URL to fetch context  (Object) layer  (Layer) - the current layer propName  (String) - the name of the prop that is making the request loaders  (Array?) - an array of  loaders.gl loaders  to parse this request with, default to  props.loaders . loadOptions  (Object?) - loader options for this request, default to  props.loadOptions . signal  ( AbortSignal ?) - the signal to abort the request The function is expected to return a Promise that resolves to loaded data. Default:  load(url, loaders, loadOptions) onDataLoad  (Function, optional) Called when remote data is fully loaded. This callback applies when  data  is assigned a value that is either string (URL), Promise or an async iterable. The function receives two arguments: value  - the loaded data context  (Object) layer  - the current layer Render Properties parameters  (Object, optional) The  parameters  allows applications to specify values for WebGL parameters such as blending mode, depth testing etc. Any  parameters  will be applied temporarily while rendering this layer only. To get access to static parameter values, applications can  import GL from 'luma.gl' . Please refer to the luma.gl  setParameters  API for documentation on supported parameters and values. getPolygonOffset  (Function, optional) Default:  ({layerIndex}) => [0, -layerIndex * 100] When multiple layers are rendered on the same plane,  z-fighting  may create undesirable artifacts. To improve the visual quality of composition, deck.gl allows layers to use  gl.polygonOffset  to apply an offset to its depth. By default, each layer is offset a small amount by its index so that layers are cleanly stacked from bottom to top. This accessor takes a single parameter  uniform  - an object that contains the current render uniforms, and returns an array of two numbers  factor  and  units . Negative values pull layer towards the camera, and positive values push layer away from the camera. For more information, refer to the  documentation  and  FAQ . If the accessor is assigned a falsy value, polygon offset will be set to  [0, 0] . Remarks: While this feature helps mitigate z-fighting, at close up zoom levels the issue might return because of the precision error of 32-bit projection matrices. Try set the  fp64  prop to  true  in this case. transitions  (Object, optional) Default:  {} When creating layers, animation can be enabled by supplying an  transitions  prop. Animation parameters are defined per attribute by using attribute names or accessor names as keys: Each accessor name is mapped to an object that is the transition setting. The object may contain the following fields: Key Type Default Description type String 'interpolation' Type of the transition (either  'interpolation'  or  'spring' ) enter Function APPEARANCE ( value => value ) Callback to get the value that the entering vertices are transitioning from. See notes below onStart Function null Callback when the transition is started onEnd Function null Callback when the transition is done onInterrupt Function null Callback when the transition is interrupted Additional fields for  type: 'interpolation' : Key Type Default Description duration Number 0 Duration of the transition animation, in milliseconds easing Function LINEAR ( t => t ) Easing function that maps a value from  0, 1  to  0, 1 , see  http://easings.net/ Additional fields for  type: 'spring' : Key Type Default Description stiffness Number 0.05 \"Tension\" factor for the spring damping Number 0.5 \"Friction\" factor that counteracts the spring's acceleration Notes: As a shorthand, if an accessor key maps to a number rather than an object, then the number is assigned to the  duration  parameter, and an  interpolation  transition is used. Attribute transition is performed between the values at the same index. If the new data is larger,  enter  callback is called for each new vertex to backfill the values to transition from. enter  should return the value to transition from. for the current vertex. It receives two arguments: toValue  (TypedArray) - the new value to transition to, for the current vertex fromChunk  (Array | TypedArray) - the existing value to transition from, for the chunk that the current vertex belongs to. A \"chunk\" is a group of vertices that help the callback determine the context of this transition. For most layers, all objects are in one chunk. For PathLayer and PolygonLayer, each path/polygon is a chunk. Members Layer members are designed to support the creation of new layers or layer sub-classing and are NOT intended to be used by applications. context  (Object) The context object stores information that are shared by all layers. gl  ( WebGLRenderingContext ) - WebGL context of the current canvas. viewport  ( Viewport ) - The current viewport deck  ( Deck ) - The current deck.gl instance state  (Object) The state object allows a layer to store persistent information cross rendering cycles. attributeManager  ( AttributeManager ) - The attribute manager of this layer. props  (Object) Properties  of this layer. isLoaded true  if all asynchronous assets are loaded. parent A  Layer  instance if this layer is rendered by a  CompositeLayer Methods Layer methods are designed to support the creation of new layers or layer sub-classing and are NOT intended to be called by applications. General Methods clone Create a copy of this layer, optionally change some prop values. Arguments: overrideProps  (Object, optional) - layer props to update. setState Used to update the layers  state  object. Calling this method will also cause the layer to rerender. setModuleParameters Used to update the settings of shader modules. raiseError Used to propagate errors thrown in layers to the deck.gl error handling system. This prevents rendering from being interrupted by exceptions in layers. raiseError(error, message) error  (Error) - a JavaScript Error object message  (String, optional) - additional contextual description to amend the error message with Layer Lifecycle Methods For more information about when these methods are called, see  layer lifecycle . initializeState This method is called only once for each layer to set up the initial state. initializeState(context) context  - The layer context is supplied as a parameter context.gl  ( WebGLRenderingContext ) - gl context ... deck.gl will already have created the  state  object at this time, and added the  gl  context and the  attributeManager  state. shouldUpdateState Called during each rendering cycle when layer  properties  or  context  has been updated and before layers are drawn. shouldUpdateState({props, oldProps, context, changeFlags}) Parameters: props  (Object) - Layer properties from the current rendering cycle. oldProps  (Object) - Layer properties from the previous rendering cycle. context  (Object) - Layer context from the current rendering cycle. changeFlags : an object that contains the following boolean flags: dataChanged ,  propsChanged ,  viewportChanged ,  somethingChanged ,  propsOrDataChanged ,  stateChanged ,  updateTriggersChanged ,  viewportChanged Returns: true  this layer needs to be updated. Remarks: Prop change is determined by shallow comparison. Data change is determined by shallow comparison of  props.data  unless  dataComparator  is supplied. The default implementation returns  true  if any change has been detected in data or props, but  ignores viewport changes . updateState Called when a layer needs to be updated. updateState({props, oldProps, context, changeFlags}) Parameters: props  (Object) - Layer properties from the current rendering cycle. oldProps  (Object) - Layer properties from the previous rendering cycle. context  (Object) - Layer context from the current rendering cycle. changeFlags : an object that contains the following boolean flags: dataChanged ,  propsChanged ,  viewportChanged ,  somethingChanged ,  propsOrDataChanged ,  stateChanged ,  updateTriggersChanged ,  viewportChanged The default implementation will invalidate all attributeManager attributes if the  data  prop has changed. draw Called on a layer to render to the WebGL canvas. draw({moduleParameters, uniforms, ..., context}) Parameters: uniforms : an object that contains all the  default unforms  to be passed to the shaders. context  - The layer context is supplied as a parameter context.gl  ( WebGLRenderingContext ) - gl context ... The default implementation looks for a variable  model  in the layer's state (which is expected to be an instance of the luma.gl  Model  class) and calls  draw  on that model with the parameters. getPickingInfo Called when a layer is being hovered or clicked, before any user callbacks are called. The layer can override or add additional fields to the  info  object that will be passed to the callbacks. Parameters: pickParams  (Object) pickParams.info  (Object) - The current  info  object. By default it contains the\nfollowing fields: x  (Number) - Mouse position x relative to the viewport. y  (Number) - Mouse position y relative to the viewport. coordinate  ( Number, Number ) - Mouse position in world coordinates. Only applies if  coordinateSystem  is  COORDINATE_SYSTEM.LNGLAT . color  (Number 4 ) - The color of the pixel that is being picked. It represents a \"picking color\" that is encoded by  layer.encodePickingColor() . index  (Number) - The index of the object that is being picked. It is the returned value of  layer.decodePickingColor() . picked  (Boolean) -  true  if  index  is not  -1 . pickParams.mode  (String) - One of  hover  and  click Returns: An  info  object with optional fields about what was picked. This object will be passed to the layer's  onHover  or  onClick  callbacks. null , if the corresponding event should cancelled with no callback functions called. The default implementation populates the  info.object  field with the  info.index  element from the layer's  data  prop. finalizeState This method is called before the layer is being removed. A layer should release all resources created during its life span. Layer Projection Methods While most projection is handled \"automatically\" in the layers vertex shader, it is occasionally useful to be able to work in the projected coordinates in JavaScript while calculating uniforms etc. project Projects a map coordinate to screen coordinate, using the current viewport settings and the current coordinate system. Parameters: coordinates  (Array) -  [x, y, z]  in this layer's coordinate system. Returns: A screen coordinates array  [x, y]  or  [x, y, z]  if an altitude was given. unproject Unprojects a screen coordinate using the current viewport settings. Parameters: pixels  (Array) -  [x, y, z]  Passing a  z  is optional. Returns: A map coordinates array  [lng, lat]  or  [lng, lat, altitude]  if a  z  was given. projectPosition Projects a map coordinate to world coordinate using the current viewport settings and the current coordinate system. Can be useful to calculate world space angle and distances. Parameters: coordinates  (Array) -  [x, y, z]  in this layer's coordinate system. params  (Object, optional) - Projection parameters override. It accepts the following fields: viewport  (Viewport) - defaults to  this.context.viewport . modelMatrix  (Matrix4) - defaults to  this.props.modelMatrix . coordinateOrigin  ( Number, Number, Number ) - defaults to  this.props.coordinateOrigin . coordinateSystem  (Number) - defaults to  this.props.coordinateSystem . fromCoordinateOrigin  ( Number, Number, Number ) - defaults to passed  coordinateOrigin . fromCoordinateSystem  (Number) - defaults to passed  coordinateSystem . Returns: World coordinates in  [x, y] . Layer Picking Methods For the usage of these methods, see  how picking works . decodePickingColor Converts a color to a \"sub-feature index\" number.\nThis color is encoded by the  layer.encodePickingColor()  method. Parameters: color  (Array) - The color to be decoded in  [r, g, b] . Returns: A number representing the index of the feature. The null picking color (See  Layer.nullPickingColor ) will be decoded as -1. Note: The null picking color is returned when a pixel is picked that is not covered by the layer, or when the layer has selected to render a pixel using the null picking color to make it unpickable. encodePickingColor Converts a \"sub-feature index\" number to a color. This color can later be decoded by the  layer.decodePickingColor()  method. Parameters: index  (Integer) - The index to be encoded. Returns: An array of  [r, g, b] . To get a color that does not correspond to any sub-feature, use  layer.nullPickingColor() . Notes: indices to be encoded must be integers larger than or equal to 0. Picking colors are 24 bit values and can thus encode up to 16 million indices. nullPickingColor Returns: a \"null\" picking color which is equal the color of pixels not covered by the layer. This color is guaranteed not to match any index value greater than or equal to zero. Source modules/core/src/lib/layer.js","headings":[{"value":"Layer Class","depth":1},{"value":"Static Members","depth":2},{"value":"layerName (String, required)","depth":5},{"value":"defaultProps (Object, optional)","depth":5},{"value":"Constructor","depth":2},{"value":"Properties","depth":2},{"value":"Basic Properties","depth":3},{"value":"id (String, optional)","depth":5},{"value":"data (Iterable | String | Promise | AsyncIterable | Object, optional)","depth":5},{"value":"visible (Boolean, optional)","depth":5},{"value":"opacity (Number, optional)","depth":5},{"value":"extensions (Array, optional)","depth":5},{"value":"onError (Function, optional)","depth":5},{"value":"Interaction Properties","depth":3},{"value":"pickable (Boolean, optional)","depth":5},{"value":"onHover (Function, optional)","depth":5},{"value":"onClick (Function, optional)","depth":5},{"value":"onDragStart (Function, optional)","depth":5},{"value":"onDrag (Function, optional)","depth":5},{"value":"onDragEnd (Function, optional)","depth":5},{"value":"highlightColor (Array|Function, optional)","depth":5},{"value":"highlightedObjectIndex (Number|null, optional)","depth":5},{"value":"autoHighlight (Boolean, optional)","depth":5},{"value":"Coordinate System Properties","depth":3},{"value":"coordinateSystem (Number, optional)","depth":5},{"value":"coordinateOrigin (Number, Number, Number, optional)","depth":5},{"value":"wrapLongitude (Boolean, optional)","depth":5},{"value":"modelMatrix (Number16, optional)","depth":5},{"value":"Data Properties","depth":3},{"value":"dataComparator (Function, optional)","depth":5},{"value":"dataTransform (Function, optional)","depth":5},{"value":"_dataDiff (Function, optional) Experimental","depth":5},{"value":"positionFormat (String, optional)","depth":5},{"value":"colorFormat (String, optional)","depth":5},{"value":"numInstances (Number, optional)","depth":5},{"value":"updateTriggers (Object, optional)","depth":5},{"value":"loaders (Array, optional)","depth":5},{"value":"loadOptions (Object, optional)","depth":5},{"value":"fetch (Function, optional)","depth":5},{"value":"onDataLoad (Function, optional)","depth":5},{"value":"Render Properties","depth":3},{"value":"parameters (Object, optional)","depth":5},{"value":"getPolygonOffset (Function, optional)","depth":5},{"value":"transitions (Object, optional)","depth":5},{"value":"Members","depth":2},{"value":"context (Object)","depth":5},{"value":"state (Object)","depth":5},{"value":"props (Object)","depth":5},{"value":"isLoaded","depth":5},{"value":"parent","depth":5},{"value":"Methods","depth":2},{"value":"General Methods","depth":3},{"value":"clone","depth":5},{"value":"setState","depth":5},{"value":"setModuleParameters","depth":5},{"value":"raiseError","depth":5},{"value":"Layer Lifecycle Methods","depth":3},{"value":"initializeState","depth":5},{"value":"shouldUpdateState","depth":5},{"value":"updateState","depth":5},{"value":"draw","depth":5},{"value":"getPickingInfo","depth":5},{"value":"finalizeState","depth":5},{"value":"Layer Projection Methods","depth":3},{"value":"project","depth":5},{"value":"unproject","depth":5},{"value":"projectPosition","depth":5},{"value":"Layer Picking Methods","depth":3},{"value":"decodePickingColor","depth":5},{"value":"encodePickingColor","depth":5},{"value":"nullPickingColor","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/layer","title":"Layer Class"},{"excerpt":"LinearInterpolator Performs simple linear interpolation between two view states. Implements  TransitionInterpolator . See  View State Transitions  for usage examples. Constructor Parameters: options (Object) transitionProps  (Array, optional) - Array of prop names that should be linearly interpolated. Default  ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'] . around  (Array, optional) - A point to zoom/rotate around,  [x, y]  in screen pixels. If provided, the location at this point will not move during the transition. makeViewport  (Function, optional) - Called to construct a  viewport , e.g.  props => new WebMercatorViewport(props) . Must be provided if  around  is used. Source modules/core/src/transitions/linear-interpolator.js","headings":[{"value":"LinearInterpolator","depth":1},{"value":"Constructor","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/linear-interpolator","title":"LinearInterpolator"},{"excerpt":"MapController Inherits from  Base Controller . The  MapController  class can be passed to either the  Deck  class's  controller  prop or a  View  class's  controller  prop to specify that map interaction should be enabled. MapController  is the default controller for  MapView .. Usage Use with the default view: is equivalent to: Options Supports all  Controller options  with the following default behavior: dragMode  - default  'pan'  (drag to pan, shift/ctrl + drag to rotate) keyboard  - arrow keys to pan, arrow keys with shift/ctrl down to rotate, +/- to zoom normalize  - normalize viewport props to fit map height into viewport. Default  true Custom MapController You can further customize the  MapController 's behavior by extending the class: See the  Controller  class  documentation  for the methods that you can use and/or override. Source modules/core/src/controllers/map-controller.js","headings":[{"value":"MapController","depth":1},{"value":"Usage","depth":2},{"value":"Options","depth":2},{"value":"Custom MapController","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/map-controller","title":"MapController"},{"excerpt":"LightingEffect The  LightingEffect  applies ambient, point and directional lighting to layers which support material property. Constructor Parameters: lights (Object) - a collection of light sources. Keys can be any arbitrary name and values. Members Light Sources ambientLight  (Object, optional) An  AmbientLight  source which illuminates all the objects equally. Default: ambient light source with color =  [255, 255, 255]  and intensity =  1.0 directionalLights  (Array, optional) Array of  DirectionalLight  source which emits from a specific directions. Default: two directional light sources Light Source Color Intensity Direction _shadow 1 255, 255, 255 1.0 -1, -3, -1 false 2 255, 255, 255 0.9 1, 8, -2.5 false For rendering experimental shadow effect,  _shadow  prop of  DirectionalLight  must be set to  true . The effect can be toggled on and off for a layer by setting layer's  shadowEnabled  prop. pointLights  (Array, optional) Array of  PointLight  source which emits from a point in all directions. Default:  [] Remarks Only one ambient light is supported. Point light position uses the same coordinate system as view state. Source /modules/core/src/effects/lighting/lighting-effect.js","headings":[{"value":"LightingEffect","depth":1},{"value":"Constructor","depth":2},{"value":"Members","depth":2},{"value":"Light Sources","depth":3},{"value":"ambientLight (Object, optional)","depth":5},{"value":"directionalLights (Array, optional)","depth":5},{"value":"pointLights (Array, optional)","depth":5},{"value":"Remarks","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/lighting-effect","title":"LightingEffect"},{"excerpt":"OrthographicController Inherits from  Base Controller . The  OrthographicController  class can be passed to either the  Deck  class's  controller  prop or a  View  class's  controller  prop to specify that viewport interaction should be enabled. OrthographicController  is the default controller for  OrthographicView . Usage Use with the default view: is equivalent to: Options Supports all  Controller options  with the following default behavior: dragPan : default  'pan'  (drag to pan) dragRotate : not effective, this view cannot be rotated touchRotate : not effective, this view cannot be rotated keyboard : arrow keys to pan, +/- to zoom Also accepts additional options: zoomAxis  (String) - which axes to apply zoom to. Affects scroll, keyboard +/- and double tap. One of  X  (zoom along the X axis only),  Y  (zoom along the Y axis only),  all . Default  all . If this option is set to  X  or  Y ,  viewState.zoom  must be an array to enable independent zoom for each axis. Custom OrthographicController You can further customize the  OrthographicController 's behavior by extending the class: See the  Controller  class  documentation  for the methods that you can use and/or override. Source modules/core/src/controllers/orthographic-controller.js","headings":[{"value":"OrthographicController","depth":1},{"value":"Usage","depth":2},{"value":"Options","depth":2},{"value":"Custom OrthographicController","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/orthographic-controller","title":"OrthographicController"},{"excerpt":"MapView The  MapView  class is a subclass of  View . This viewport creates a camera that looks at a geospatial location on a map from a certain direction. The behavior of  MapView  is generally modeled after that of Mapbox GL JS. It's recommended that you read the  Views and Projections guide  before using this class. Constructor MapView  takes the same parameters as the  View  superclass constructor, plus the following: repeat  (Boolean, optional) Whether to render multiple copies of the map at low zoom levels. Default  false . nearZMultiplier  (Number, optional) Scaler for the near plane, 1 unit equals to the height of the viewport. Default to  0.1 . Overwrites the  near  parameter. farZMultiplier  (Number, optional) Scaler for the far plane, 1 unit equals to the distance from the camera to the top edge of the screen. Default to  1.01 . Overwrites the  far  parameter. projectionMatrix  (Array 16 , optional) Projection matrix. If  projectionMatrix  is not supplied, the  View  class will build a projection matrix from the following parameters: fovy  (Number, optional) Field of view covered by the camera, in the perspective case. In degrees. If not supplied, will be calculated from  altitude . altitude  (Number, optional) Distance of the camera relative to viewport height. Default  1.5 . orthographic  (Boolean) Whether to create an orthographic or perspective projection matrix. Default is  false  (perspective projection). View State To render,  MapView  needs to be used together with a  viewState  with the following parameters: longitude  (Number) - longitude at the map center latitude  (Number) - latitude at the map center zoom  (Number) - zoom level pitch  (Number, optional) - pitch angle in degrees. Default  0  (top-down). bearing  (Number, optional) - bearing angle in degrees. Default  0  (north). maxZoom  (Number, optional) - max zoom level. Default  20 . minZoom  (Number, optional) - min zoom level. Default  0 . maxPitch  (Number, optional) - max pitch angle. Default  60 . minPitch  (Number, optional) - min pitch angle. Default  0 . Controller By default,  MapView  uses the  MapController  to handle interactivity. To enable the controller, use: Visit the  MapController  documentation for a full list of supported options. Source modules/core/src/views/map-view.js","headings":[{"value":"MapView","depth":1},{"value":"Constructor","depth":2},{"value":"repeat (Boolean, optional)","depth":5},{"value":"nearZMultiplier (Number, optional)","depth":5},{"value":"farZMultiplier (Number, optional)","depth":5},{"value":"projectionMatrix (Array16, optional)","depth":5},{"value":"fovy (Number, optional)","depth":5},{"value":"altitude (Number, optional)","depth":5},{"value":"orthographic (Boolean)","depth":5},{"value":"View State","depth":2},{"value":"Controller","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/map-view","title":"MapView"},{"excerpt":"OrbitController Inherits from  Base Controller . The  OrbitController  class can be passed to either the  Deck  class's  controller  prop or a  View  class's  controller  prop to specify that viewport interaction should be enabled. OrbitController  is the default controller for  OrbitView . Usage Use with the default view: is equivalent to: Options Supports all  Controller options  with the following default behavior: dragMode : default  'rotate'  (drag to rotate, shift/ctrl + drag to pan) keyboard : arrow keys to pan, arrow keys with shift/ctrl down to rotate, +/- to zoom Custom OrbitController You can further customize the  OrbitController 's behavior by extending the class: See the  Controller  class  documentation  for the methods that you can use and/or override. Source modules/core/src/controllers/orbit-controller.js","headings":[{"value":"OrbitController","depth":1},{"value":"Usage","depth":2},{"value":"Options","depth":2},{"value":"Custom OrbitController","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/orbit-controller","title":"OrbitController"},{"excerpt":"OrbitView The  OrbitView  class is a subclass of  View  that creates a 3D camera that rotates around a target position. It is usually used for the examination of a 3D scene in non-geospatial use cases. It's recommended that you read the  Views and Projections guide  before using this class. Constructor OrbitView  takes the same parameters as the  View  superclass constructor, plus the following: orbitAxis  (String, optional) Axis with 360 degrees rotating freedom, either  'Y'  or  'Z' , default to  'Z' . projectionMatrix  (Array 16 , optional) Projection matrix. If  projectionMatrix  is not supplied, the  View  class will build a projection matrix from the following parameters: fovy  (Number, optional) Field of view covered by camera, in the perspective case. In degrees. Default  50 . near  (Number, optional) Distance of near clipping plane. Default  0.1 . far  (Number, optional) Distance of far clipping plane. Default  1000 . orthographic  (Boolean) Whether to create an orthographic or perspective projection matrix. Default is  false  (perspective projection). View State To render,  OrbitView  needs to be used together with a  viewState  with the following parameters: target  (Number 3 , optional) - The world position at the center of the viewport. Default  [0, 0, 0] . rotationOrbit  (Number, optional) - Rotating angle around orbit axis. Default  0 . rotationX  (Number, optional) - Rotating angle around X axis. Default  0 . zoom  (Number, optional) - The zoom level of the viewport.  zoom: 0  maps one unit distance to one pixel on screen, and increasing  zoom  by  1  scales the same object to twice as large. Default  0 . minZoom  (Number, optional) - The min zoom level of the viewport. Default  -Infinity . maxZoom  (Number, optional) - The max zoom level of the viewport. Default  Infinity . minRotationX  (Number, optional) - The min rotating angle around X axis. Default  -90 . maxRotationX  (Number, optional) - The max rotating angle around X axis. Default  90 . Controller By default,  OrbitView  uses the  OrbitController  to handle interactivity. To enable the controller, use: Visit the  OrbitController  documentation for a full list of supported options. Source modules/core/src/views/orbit-view.js","headings":[{"value":"OrbitView","depth":1},{"value":"Constructor","depth":2},{"value":"orbitAxis (String, optional)","depth":5},{"value":"projectionMatrix (Array16, optional)","depth":5},{"value":"fovy (Number, optional)","depth":5},{"value":"near (Number, optional)","depth":5},{"value":"far (Number, optional)","depth":5},{"value":"orthographic (Boolean)","depth":5},{"value":"View State","depth":2},{"value":"Controller","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/orbit-view","title":"OrbitView"},{"excerpt":"OrthographicView The  OrthographicView  class is a subclass of  View  that creates a top-down view of the XY plane. It is usually used for rendering 2D charts in non-geospatial use cases. It's recommended that you read the  Views and Projections guide  before using this class. Constructor OrthographicView  takes the same parameters as the  View  superclass constructor, plus the following: flipY  (Boolean) Whether to use top-left coordinates ( true ) or bottom-left coordinates ( false ). Default  true . near  (Number, optional) Distance of near clipping plane. Default  0.1 . far  (Number, optional) Distance of far clipping plane. Default  1000 . View State To render,  OrthographicView  needs to be used together with a  viewState  with the following parameters: target  (Number 3 , optional) - The world position at the center of the viewport. Default  [0, 0, 0] . zoom  (Number|Number 2 , optional) - The zoom level of the viewport.  zoom: 0  maps one unit distance to one pixel on screen, and increasing  zoom  by  1  scales the same object to twice as large. To apply independent zoom levels to the X and Y axes, supply an array  [zoomX, zoomY] . Default  0 . minZoom  (Number, optional) - The min zoom level of the viewport. Default  -Infinity . maxZoom  (Number, optional) - The max zoom level of the viewport. Default  Infinity . Controller By default,  OrthographicView  uses the  OrthographicController  to handle interactivity. To enable the controller, use: Visit the  OrthographicController  documentation for a full list of supported options. Source modules/core/src/views/orthographic-view.js","headings":[{"value":"OrthographicView","depth":1},{"value":"Constructor","depth":2},{"value":"flipY (Boolean)","depth":5},{"value":"near (Number, optional)","depth":5},{"value":"far (Number, optional)","depth":5},{"value":"View State","depth":2},{"value":"Controller","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/orthographic-view","title":"OrthographicView"},{"excerpt":"PostProcessEffect The  PostProcessEffect  applies screen space pixel manipulation effects to deck.gl layers. Constructor Parameters: shaderModule (Object) - a shader module wraps a screen space effect. For supported effects see  luma.gl shader modules . props (Object) - parameters to replace the default values in shader module. Example Source /modules/core/src/effects/post-process-effect.js","headings":[{"value":"PostProcessEffect","depth":1},{"value":"Constructor","depth":2},{"value":"Example","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/post-process-effect","title":"PostProcessEffect"},{"excerpt":"project (Shader Module) The  project  shader module is part of the core of deck.gl. It makes it easy to write shaders that support all of deck.gl's projection modes and it supports some advanced rendering techniques such as pixel space rendering etc. The  project  module has two extensions: project32  shorthand functions for projecting directly from worldspace to clipspace. project64  counterpart of  project32  that enables 64 bit projections, providing an increase in precision, at the cost of performance. Usage Projects worldspace coordinates to clipspace coordinates. getUniforms The JavaScript uniforms are extracted from both contextual and per-layer props. The following information are used: viewport devicePixelRatio coordinateSystem coordinateOrigin modelMatrix GLSL Uniforms Uniforms are considered private to each shader module. They may change in between patch releases. Always use documented functions instead of accessing module uniforms directly. The uniforms of the  project  shader module are prefixed with  project_  in their names. GLSL Functions The projection module enables you to write vertex shaders that support deck.gl's coordinate systems and projection methods. Using the projection module ensures that you layer will be able accept position coordinates in the various formats supported by deck.gl, such as  [longitude, latitude, altitude]  or  [metersX, metersY, metersZ] . To support the basic features expected of a deck.gl layer, such as various viewport types and coordinate systems, your own shaders should always use the built-in projection functions. The functions converts positions/vectors between 4 coordinate spaces: Name Short Name Description World space world The  coordinate system  defined by the layer, not necessarily linear or uniform. Common space common A normalized intermediate 3D space that deck.gl uses for consistent processing of geometries, guaranteed to be linear and uniform. Therefore, it is safe to add/rotate/scale positions and vectors in this space. Screen space pixel Top-left coordinate system runs from  [0, 0]  to  [viewportWidth, viewportHeight]  (see remarks below). Clip space clipspace Output of the vertex shader. More detailed explanation of each coordinate space can be found in the  coordinate systems guide . The GLSL functions of the  project  shader module uses the following naming convention: source_space : the short name of the coordinate space of the input. If not specified, the input is always in the  world  space. object_type : one of the following position : absolute position of a point offset : the delta between two positions normal : the normal vector of a surface size : the measurement of a geometry. This is different from  offset  in that  size  is uniform on all axes (e.g.  x, y, z  in meters in  LNGLAT  world space) and  offset  may not be (e.g.  dLon, dLat, dAlt  in degrees, degrees, and meters respectively in  LNGLAT  world space). target_space : the short name of the coordinate space of the output. If not specified, the output is always in the  common  space. project_position Converts the coordinates of a point from the world space to the common space. The coordinates are interpreted according to  coordinateSystem  and  modelMatrix  is applied. project_size Converts the size of a geometry from the world space (meters if geospatial, and absolute units otherwise) to the common space. project_size_to_pixel Converts the size of a geometry from the given units in the world space to the common space. If unspecified, units is meters. The result corresponds to the number of screen pixels when the given size is viewed with a top-down camera. project_pixel_size Converts the size of a geometry from the screen space to the common space. project_pixel_size_to_clipspace Converts the size of a geometry from the screen space to the clip space. project_normal Converts position deltas from the world space to normalized vector in the common space. project_common_position_to_clipspace Converts the coordinates of a point from the common space to the clip space, which can be assigned to  gl_Position  as the \"return value\" from the vertex shader. project_get_orientation_matrix Returns a matrix that rotates any vector defined in the default common space to a new orientation, such that  vec3(0, 0, 1)  is aligned with  up .  up  is a normal in common space. Remarks For consistent results, the screen space pixels are logical pixels, not device pixels, i.e. functions in the project module multiply  pixels  with  project_uDevicePixelRatio . The pixels offsets will be divided by the  w  coordinate of  gl_Position . This is simply the GPUs standard treatment of any coordinate. This means that there will be more pixels closer to the camera and less pixels further away from the camer. Setting the  focalDistance  uniform controls this. To avoid pixel sizes scaling with distance from camera, simply set  focalDistance  to 1 and multiply clipspace offset with  gl_Position.w","headings":[{"value":"project (Shader Module)","depth":1},{"value":"Usage","depth":2},{"value":"getUniforms","depth":2},{"value":"GLSL Uniforms","depth":2},{"value":"GLSL Functions","depth":2},{"value":"project_position","depth":3},{"value":"project_size","depth":3},{"value":"project_size_to_pixel","depth":3},{"value":"project_pixel_size","depth":3},{"value":"project_pixel_size_to_clipspace","depth":3},{"value":"project_normal","depth":3},{"value":"project_common_position_to_clipspace","depth":3},{"value":"project_get_orientation_matrix","depth":3},{"value":"Remarks","depth":2}],"slug":"docs/api-reference/core/project","title":"project (Shader Module)"},{"excerpt":"PointLight Create a point light source which emits from a point in all directions.Point lights attenuation is not available. At most 5 directional lights can be supported. Usage Create a point light source with color, intensity and position. Methods constructor The constructor for the  PointLight  class. Use this to create a new  PointLight . Parameters color  - ( array ,)  RGB color of point light source, default value is  [255, 255, 255] . intensity  - ( number ) Strength of point light source, default value is  1.0 . position  - ( array ,)  Location of point light source, default value is  [0, 0, 1] .The coordinate system of the position depends on the current  view :  [longitude, latitude, altitude]  in geospatial views and world position in non-geospatial views. Source /modules/core/src/effects/lighting/point-light.js","headings":[{"value":"PointLight","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"constructor","depth":3},{"value":"Parameters","depth":4},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/point-light","title":"PointLight"},{"excerpt":"project32 (Shader Module) The  project32  shader module is an extension of the  project  shader module that adds some projection utilities. GLSL Functions project_position_to_clipspace 32 bit implementation of the  project_position_to_clipspace  interface. Parameters: position  - vertex position in the layer's coordinate system. position64Low  - lower part of the vertex position, calculated as  aLow = a - Math.fround(a) . offset  - offset from the coordinate, in common space commonPosition  - projected position in the common space Returns:\nProjected position in the clipspace.","headings":[{"value":"project32 (Shader Module)","depth":1},{"value":"GLSL Functions","depth":2},{"value":"project_position_to_clipspace","depth":3}],"slug":"docs/api-reference/core/project32","title":"project32 (Shader Module)"},{"excerpt":"project64 (Shader Module) The  project64  shader module is an extension of the  project  shader module that does projection using 64 bit floating point. It provides an increase in precision, at the cost of performance. Note that starting with deck.gl v6.1, the improved default 32 bit projection mode provides sufficient precision for most use cases. getUniforms The uniforms needed by  project64  are extracted from the  project  module uniforms  project_uViewProjectionMatrix  and  project_uScale . GLSL Uniforms Uniforms are considered private to each shader module. They may change in between patch releases. Always use documented functions instead of accessing module uniforms directly. The uniforms of the  project64  shader module are prefixed with  project64_  in their names. GLSL Functions project_position_to_clipspace 64 bit implementation of the  project_position_to_clipspace  interface. Parameters: position  - vertex position in the layer's coordinate system. position64Low  - low part of the vertex position, calculated as  aLow = a - Math.fround(a) . offset  - offset from the coordinate, in common space commonPosition  - projected position in the common space Returns:\nProjected position in the clipspace. project_position_fp64 64 bit counterpart of the  project  modules  project_position project_common_position_to_clipspace_fp64 64 bit counterpart of the  project  modules  project_common_position_to_clipspace Remarks project64  depends on luma.gl's  fp64  module which is a big and complex shader module, which means that  project64  is a big dependency for your shader.","headings":[{"value":"project64 (Shader Module)","depth":1},{"value":"getUniforms","depth":2},{"value":"GLSL Uniforms","depth":2},{"value":"GLSL Functions","depth":2},{"value":"project_position_to_clipspace","depth":3},{"value":"project_position_fp64","depth":3},{"value":"project_common_position_to_clipspace_fp64","depth":3},{"value":"Remarks","depth":2}],"slug":"docs/api-reference/core/project64","title":"project64 (Shader Module)"},{"excerpt":"TransitionInterpolator Base interpolator class that provides common functionality required to interpolate between two  View States . This class is not intended to be used directly. See  View State Transitions  for backgrounds. Example Constructor Parameters: opts  (Object | Array) If an object is provided, it should contain the following fields: compare  (Array) - prop names used in equality check. Transition is triggered if some of the  compare  props are not deeply equal. extract  (Array) - prop names needed for interpolation. See  initializeProps  below. required  (Array) - prop names that must be supplied. See  initializeProps  below. If an array is provided, the same list of prop names is used for all three above. Interface getDuration This method can be optionally implemented by a subclass. If implemented, the user can specify  transitionDuration: 'auto'  when using this interpolator, and the duration will be dynamically computed using this method. Receives the following arguments: startViewState  (Object) - the view state that is transitioning from. endViewState  (Object) - the view state that is transitioning to. Returns: A number in milliseconds representing the target duration of the transition. If  0 , transition is disabled. initializeProps Called when a transition is about to be triggered. This can be used to preprocess values for use in every transition frame by  interpolateProps . Receives the following arguments: startViewState  (Object) - the view state that is transitioning from. endViewState  (Object) - the view state that is transitioning to. Returns: An object in the shape of  {start, end}  that will be passed to  interpolateProps . The default implementation takes all values of the  extract  prop names from the start and end view states. If some  required  prop names are missing from the view state, an error will be thrown. interpolateProps This method must be implemented by a subclasses. Receives the following arguments: start  (Object) - descriptor of the state that is transitioning from, generated by  initializeProps . end  (Object) - descriptor of the state that is transitioning to, generated by  initializeProps . t  (Number) - current time into the transition, between  0  and  1 . Returns: An object that contains the interpolated view state fields. Source modules/core/src/transitions/transition-interpolator.js","headings":[{"value":"TransitionInterpolator","depth":1},{"value":"Example","depth":2},{"value":"Constructor","depth":2},{"value":"Interface","depth":2},{"value":"getDuration","depth":5},{"value":"initializeProps","depth":5},{"value":"interpolateProps","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/transition-interpolator","title":"TransitionInterpolator"},{"excerpt":"SunLight (Experimental) SunLight is a directional light source simulating the sun. Sun position calculations are based on  article  and inspired by  SunCalc .  Usage Create a sun light source. constructor The constructor for the  SunLight  class. Use this to create a new  SunLight . timestamp  - ( number ) - Unix timestamp in milliseconds. color  - ( array )  RGB color of sun light source, default value is  [255, 255, 255] . intensity  - ( number ) Strength of sun light source, default value is  1.0 . Source /modules/core/src/effects/lighting/sun-light.js","headings":[{"value":"SunLight (Experimental)","depth":1},{"value":"Usage","depth":2},{"value":"constructor","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/sun-light","title":"SunLight (Experimental)"},{"excerpt":"View Class For detailed explanations and code examples about deck.gl's views system, visit the  Views and Projections  article. The  View  class and its subclasses are used to specify where and how your deck.gl layers should be rendered. Applications typically instantiate at least one  View  subclass. Views allow you to specify: A unique  id . The position and extent of the view on the canvas:  x ,  y ,  width , and  height . Certain camera parameters specifying how your data should be projected into this view, e.g. field of view, near/far planes, perspective vs. orthographic, etc. The  controller  to be used for this view. A controller listens to pointer events and touch gestures, and translates user input into changes in the view state. If enabled, the camera becomes interactive. deck.gl offers a set of  View  classes that package the camera and controller logic that you need to visualize and interact with your data. You may choose one or multiple  View  classes based on the type of data (e.g. geospatial, 2D chart) and the desired perspective (top down, first-person, etc). Constructor Parameters: id  (String, optional) A unique id of the view. In a multi-view use case, this is important for matching view states and place contents into this view. x  (String|Number, optional) A relative (e.g.  '50%' ) or absolute position. Default  0 . y  (String|Number, optional) A relative (e.g.  '50%' ) or absolute position. Default  0 . width  (String|Number, optional) A relative (e.g.  '50%' ) or absolute extent. Default  '100%' . height  (String|Number, optional) A relative (e.g.  '50%' ) or absolute extent. Default  '100%' . padding  (Object, optional) Padding around the viewport, in the shape of  {left, right, top, bottom}  where each value is either a relative (e.g.  '50%' ) or absolute pixels. This can be used to move the \"look at\"/target/vanishing point away from the center of the viewport rectangle. controller  (Function|Boolean|Object, optional) Options for viewport interactivity. null  or  false : this view is not interactive. true : initiates the default controller with default options. Controller  class (not instance): initiates the provided controller with default options. Object : controller options. This will be merged with the default controller options. controller.type : the controller class For other options, consult the documentation of  Controller . Default  null . viewState  (String|Object, optional) The optional  viewState  property enables a  View  to specify, select or select-and-modify its view state. viewState  is an overloaded property that can take either just a view state id string, or an object specifying view state parameters and optionally a view state id string: null  (default): Will select a view state based on  view.id , falling back to using the first view state. String : Will attempt to match the indicated \tview state. Object  (with  id  field): if the object contains an  id  field which matches a dynamic view state, the remaining fields in  View.viewState  will extend (be merged into a copy of) the selected dynamic view state. Object  (with no  id  field): If no  id  is provided, the  View.viewState  object will be used directly as the view state, essentially representing a fixed or constant view state. Note that specifying  viewState  as an object with an  id  field effectively allows the View to modify a dynamic view state by overriding some of its fields. This is useful in multiview situations where it enables having one view that fixes some parameters (eg. zoom, pitch and bearing to show an overview map). The  viewState  property is intended to support a number of use cases: Sharing view states between multiple views - If a  View  id is different from the designed view state's id. specify a complete, constant (fixed) view state directly in the view Overriding a partial set of view state properties from a selected view state. clear  (Boolean|Object, optional) Clears the contents (pixels) of the viewport. The value of the  clear  prop is passed as an argument to luma.gl's  clear  function. If  true  clears color and depth buffers. If an object, behaviour is controlled by the following fields: color  (Boolean or Array) - if not  false , clears all active color buffers with either the provided color or the currently set clear color. depth  (Boolean)  - if  true , clears the depth buffer. stencil  (Boolean) - if  true  clears the stencil buffer. Note that deck.gl always clears the screen before each render, and clearing, while cheap, is not totally free. This means that viewports should only specify the  clear  property if they need additional clearing, e.g. because they are rendering on top of another viewport, or want to have a different background color etc. Default  false . Methods Note: most applications just create Views with the appropriate props and do not need to call the following View methods directly. equals Returns  true  if deck.gl can determine that the supplied  View  instance is identical (equivalent) with this view. view.equals(otherView) otherView  ( View ) - Another view instance to compare with. Returns: true  - the given view is identical to the current one. Note: For speed, deck.gl uses shallow equality. This means that a value of  false  does not guarantee that the views are not equivalent. makeViewport Parameters: width  ( Number ) - Dimension in pixels of the target viewport. height  ( Number ) - Dimension in pixels of the target viewport. viewState  ( Object ) -  view state  compatible with the current  View  subclass in use. Note that any prop provided to the  View  constructor will override that inside the  viewState . Returns a  Viewport  using the viewport type, props in the  View  and provided dimensions and view state. getDimensions Returns the actual pixel position and size that this  View  will occupy in a given \"canvas\" size. Parameters: width  ( Number ) - Dimension in CSS pixels of the deck.gl \"canvas\". height  ( Number ) - Dimension in CSS pixels of the deck.gl \"canvas\". Returns an object containing the following fields: x  ( Number ) - x position in CSS pixels y  ( Number ) - y position in CSS pixels width  ( Number ) - width in CSS pixels height  ( Number ) - height in CSS pixels Remarks The  View  class and its subclasses are perhaps best thought of as geospatially enabled counterparts of the typical  Camera  classes found in most 3D libraries. Source modules/core/src/views/view.js","headings":[{"value":"View Class","depth":1},{"value":"Constructor","depth":2},{"value":"id (String, optional)","depth":5},{"value":"x (String|Number, optional)","depth":5},{"value":"y (String|Number, optional)","depth":5},{"value":"width (String|Number, optional)","depth":5},{"value":"height (String|Number, optional)","depth":5},{"value":"padding (Object, optional)","depth":5},{"value":"controller (Function|Boolean|Object, optional)","depth":5},{"value":"viewState (String|Object, optional)","depth":5},{"value":"clear (Boolean|Object, optional)","depth":5},{"value":"Methods","depth":2},{"value":"equals","depth":5},{"value":"makeViewport","depth":5},{"value":"getDimensions","depth":5},{"value":"Remarks","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/view","title":"View Class"},{"excerpt":"Viewport Read the article detailing deck.gl's  Views and Projections  system. A deck.gl  Viewport  is essentially a geospatially enabled camera, and combines a number of responsibilities, which can project and unproject 3D coordinates to the screen. Viewport  classes are focused on mathematical operations such as coordinate projection/unprojection, and calculation of  view  and  projection  matrices and other uniforms needed by the WebGL vertex shaders. The basic  Viewport  class is a generic geospatially enabled version of the typical 3D \"camera\" class you would find in most 3D/WebGL/OpenGL library. While the  Viewport  class can certainly be used directly if you need and are able to calculate your own projection matrices, you typically do not directly create  Viewport  instances. Instead,  Viewport  classes are created using the  View  class descriptors and the current  viewState . Overview of Viewport Classes Viewport Class Description Viewport The base viewport has to be supplied view and projection matrices. It is typically only instantiated directly if the application needs to work with viewports that have been supplied from external sources, such as the  WebVR  API. WebMercatorViewport While all  Viewport  subclasses are geospatially enabled, this class renders from a perspective that matches a typical top-down map and is designed to synchronize perfectly with a mapbox-gl base map (even in 3D enabled perspective mode). Usage The  Viewport  class is normally not instantiated directly. The  View  class is more commonly used by applications. deck.gl automatically creates  Viewport s from  View s and  viewState  when needed, using the  View.makeViewport  method. Constructor General Parameters x  ( Number , optional) - x position of viewport top-left corner. Default  0 . y  ( Number , optional) - y position of viewport top-left corner. Default  0 . width  ( Number ) - Width of viewport. Default  1 . height  ( Number ) - Height of viewport. Default  1 . View Matrix Parameters viewMatrix  ( Array[16] , optional) - 4x4 view matrix. Defaults to the identity matrix. Position and Geospatial Anchor Options (Optional) latitude  ( Number , optional) - Center of viewport on map (alternative to center). Must be provided if constructing a geospatial viewport. longitude  ( Number , optional) - Center of viewport on map (alternative to center). Must be provided if constructing a geospatial viewport. zoom  ( Number , optional) -  zoom level  . focalDistance  ( Number , optional) - modifier of viewport scale if  zoom  is not supplied. Corresponds to the number of pixels per meter. Default to  1 . position  ( Array[3] , optional) - Position of viewport camera. Default  [0, 0, 0] . modelMatrix  ( Array[16] , optional) - Optional 4x4 model matrix applied to position. Projection Matrix Parameters. projectionMatrix  ( Array[16] , optional) - 4x4 projection matrix. If  projectionMatrix  is not supplied, an attempt is made to build from the remaining parameters. Otherwise the remaining parameters will be ignored. fovy  ( Number , optional) - Field of view covered by camera, in the perspective case. In degrees. Default  75 . near  ( Number , optional) - Distance of near clipping plane. Default  0.1 . (Note that in geospatial viewports, this actual distance used is scaled by the height of the screen). far  ( Number , optional) - Distance of far clipping plane. Default  1000 . (Note that in geospatial viewports, this actual distance used is scaled by the height of the screen). orthographic  ( Boolean , optional) - whether to create an orthographic or perspective projection matrix. Default  false  (perspective projection). Methods equals Parameters: viewport  (Viewport) - The viewport to compare with. Returns: true  if the given viewport is identical to the current one. project Projects world coordinates to pixel coordinates on screen. Parameters: coordinates  (Array) -  [X, Y, Z]  in world units.  Z  is default to  0  if not supplied. opts  (Object) topLeft  (Boolean, optional) - Whether projected coords are top left. Default to  true . Returns: [x, y]  or  [x, y, z]  in pixels coordinates.  z  is pixel depth. If input is  [X, Y] : returns  [x, y] . If input is  [X, Y, Z] : returns  [x, y, z] . unproject Unproject pixel coordinates on screen into world coordinates. Parameters: pixels  (Array) -  [x, y, z]  in pixel coordinates. Passing a  z  is optional. opts  (Object) topLeft  (Boolean, optional) - Whether projected coords are top left. Default to  true . targetZ  (Number, optional) - If pixel depth  z  is not specified in  pixels , this is used as the elevation plane to unproject onto. Default  0 . Returns: [X, Y]  or  [X, Y, Z]  in world coordinates. If input is  [x, y]  without specifying  opts.targetZ : returns  [X, Y] . If input is  [x, y]  with  opts.targetZ : returns  [X, Y, targetZ] . If input is  [x, y, z] : returns  [X, Y, Z] . projectPosition Projects latitude, longitude (and altitude) to coordinates in the  common space . Parameters: coordinates  (Array) -  [lng, lat, altitude]  Passing an altitude is optional. Returns: [x, y, z]  in WebMercator coordinates. unprojectPosition Projects a coordinate from the  common space  to latitude, longitude and altitude. Parameters: coordinates  (Array) -  [x, y, z]  in the WebMercator world.  z  is optional. Returns: [longitude, latitude, altitude] getBounds Extracts the axis-aligned bounding box of the current visible area. options  (Object, optional) options.z  (Number, optional) - To calculate a bounding volume for fetching 3D data, this option can be used to get the bounding box at a specific elevation. Default  0 . Returns: [minX, minY, maxX, maxY]  that defines the smallest orthogonal bounds that encompasses the visible region. getFrustumPlanes Extract view frustum planes of the current camera. Each plane is defined by its normal  normal  and distance from\nthe origin  distance  (such that point  x  is on the plane if  dot(normal, x) === distance ) in the  common space . Returns: {near: {normal, distance}, far: {normal, distance}, left: {normal, distance}, right: {normal, distance}, top: {normal, distance}, bottom: {normal, distance}} Remarks The  Viewport  class and its subclasses are perhaps best thought of as geospatially enabled counterparts of the typical  Camera  classes found in most 3D libraries. The  Viewport  class works together with the  project  shader module and generates the uniforms that module needs to project correctly in GLSL code. Accordingly, a main function of viewports is to generate WebGL compatible view and projection matrices (column-major format). Functions (including projection and unprojection of coordinates) are available both in JavaScript and in GLSL, so that layers can do consistent projection calculations in both GLSL and JavaScript. To support pixel project/unproject functions (in addition to the clipspace projection that Camera classes typically manage), the  Viewport  is also aware of the viewport extents. In geospatial setups, Viewports can contain geospatial anchors. Source modules/core/src/viewports/viewport.js","headings":[{"value":"Viewport","depth":1},{"value":"Overview of Viewport Classes","depth":2},{"value":"Usage","depth":2},{"value":"Constructor","depth":2},{"value":"Methods","depth":2},{"value":"equals","depth":5},{"value":"project","depth":5},{"value":"unproject","depth":5},{"value":"projectPosition","depth":5},{"value":"unprojectPosition","depth":5},{"value":"getBounds","depth":5},{"value":"getFrustumPlanes","depth":5},{"value":"Remarks","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/viewport","title":"Viewport"},{"excerpt":"BrushingExtension The  BrushingExtension  adds GPU-based data brushing functionalities to layers. It allows the layer to show/hide objects based on the current pointer position. Installation To install the dependencies from NPM: To use pre-bundled scripts: Constructor Layer Properties When added to a layer via the  extensions  prop, the  BrushingExtension  adds the following properties to the layer: brushingRadius  (Number) The brushing radius centered at the pointer, in meters. If a data object is within this circle, it is rendered; otherwise it is hidden. brushingEnabled  (Boolean, optional) Default:  true Enable/disable brushing. If brushing is disabled, all objects are rendered. Brushing is always disabled when the pointer leaves the current viewport. brushingTarget  (Enum, optional) Default:  source The position used to filter each object by. One of the following: 'source' : Use the primary position for each object. This can mean different things depending on the layer. It usually refers to the coordinates returned by  getPosition  or  getSourcePosition  accessors. 'target' : Use the secondary position for each object. This may not be available in some layers. It usually refers to the coordinates returned by  getTargetPosition  accessors. 'source_target' : Use both the primary position and secondary position for each object. Show objet if either is in brushing range. 'custom' : Some layers may not describe their data objects with one or two coordinates, for example  PathLayer  and  PolygonLayer . Use this option with the  getBrushingTarget  prop to provide a custom position that each object should be filtered by. getBrushingTarget  ( Function , optional) Default:  null Called to retrieve an arbitrary position for each object that it will be filtered by. Returns an array  [x, y] . Only effective if  brushingTarget  is set to  custom . Source modules/extensions/src/brushing","headings":[{"value":"BrushingExtension","depth":1},{"value":"Installation","depth":2},{"value":"Constructor","depth":2},{"value":"Layer Properties","depth":2},{"value":"brushingRadius (Number)","depth":5},{"value":"brushingEnabled (Boolean, optional)","depth":5},{"value":"brushingTarget (Enum, optional)","depth":5},{"value":"getBrushingTarget (Function, optional)","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/extensions/brushing-extension","title":"BrushingExtension"},{"excerpt":"ClipExtension The  ClipExtension  adds support for clipping rendered layers by rectangular bounds. Installation To install the dependencies from NPM: To use pre-bundled scripts: Constructor Layer Properties When added to a layer via the  extensions  prop, the  ClipExtension  adds the following properties to the layer: clipBounds  (Array) Rectangular bounds to be used for clipping the rendered region. Supported format:  [left, bottom, right, top] clipByInstance  (Boolean, optional) clipByInstance  controls whether an object is clipped by its anchor (e.g. icon, point) or by its geometry (e.g. path, polygon). If not specified, it is deduced from whether there is an attribute called  instancePositions . This behavior can be overridden if: the anchor attribute goes by some other name to clip an anchored layer by geometry, like the text layer Source modules/extensions/src/clip","headings":[{"value":"ClipExtension","depth":1},{"value":"Installation","depth":2},{"value":"Constructor","depth":2},{"value":"Layer Properties","depth":2},{"value":"clipBounds (Array)","depth":5},{"value":"clipByInstance (Boolean, optional)","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/extensions/clip-extension","title":"ClipExtension"},{"excerpt":"WebMercatorViewport The  WebMercatorViewport  class takes map view states ( latitude ,  longitude ,  zoom ,  pitch ,  bearing  etc.), and performs projections between world and screen coordinates. It is tuned to work in synchronization with  mapbox-gl 's projection matrix. Usage The  WebMercatorViewport  is the default viewport for deck.gl, created under the hood by a  MapView . Constructor Parameters: opts  (Object) - Web Mercator viewport options width  (Number) - Width of the viewport. height  (Number) - Height of the viewport. web mercator style arguments: latitude  (Number, optional) - Latitude of the viewport center on map. Default to  0 . longitude  (Number, optional) - Longitude of the viewport center on map. Default to  0 . zoom  (Number, optional) - Map zoom (scale is calculated as  2^zoom ). Default to  11 . pitch  (Number, optional) - The pitch (tilt) of the map from the screen, in degrees (0 is straight down). Default to  0 . bearing  (Number, optional) - The bearing (rotation) of the map from north, in degrees counter-clockwise (0 means north is up). Default to  0 . altitude  (Number, optional) - Altitude of camera in screen units. Default to  1.5 . projection matrix arguments: nearZMultiplier  (Number, optional) - Scaler for the near plane, 1 unit equals to the height of the viewport. Default to  0.1 . farZMultiplier  (Number, optional) - Scaler for the far plane, 1 unit equals to the distance from the camera to the top edge of the screen. Default to  1.01 . orthographic  (Boolean, optional) - Default  false . projectionMatrix  (Array, optional) - Optional 16-element 4x4 projection matrix, that overrides the matrix created from the parameters above. Remarks: altitude  has a default value that matches assumptions in mapbox-gl width  and  height  are forced to 1 if supplied as 0, to avoid division by zero. This is intended to reduce the burden of apps to check values before instantiating a  Viewport . When using Mercator projection, per cartographic tradition, longitudes and latitudes are specified as degrees. latitude  of  90  or  -90  are projected to infinity in  Web Mercator projection . Using pole locations with this viewport may result in  NaN s. Many base map providers cut off at  85.051129  at which the full world becomes a square. When constructing the viewport, a field of view is not specified, but rather is calculated from the  altitude  or (if present) the  projectionMatrix . The value can be obtained from  this.fovy  (in degrees). Inherits all  Viewport methods . Methods Inherits all methods from  Viewport . project Projects world coordinates to pixel coordinates on screen. Parameters: coordinates  (Array) -  [longitude, latitude, altitude] .  altitude  is in meters and default to  0  if not supplied. opts  (Object) topLeft  (Boolean, optional) - Whether projected coords are top left. Default to  true . Returns: [x, y]  or  [x, y, z]  in pixels coordinates.  z  is pixel depth. If input is  [longitude, latitude] : returns  [x, y] . If input is  [longitude, latitude: altitude] : returns  [x, y, z] . unproject Unproject pixel coordinates on screen into world coordinates. Parameters: pixels  (Array) -  [x, y, z]  in pixel coordinates. Passing a  z  is optional. opts  (Object) topLeft  (Boolean, optional) - Whether projected coords are top left. Default to  true . targetZ  (Number, optional) - If pixel depth  z  is not specified in  pixels , this is used as the elevation plane to unproject onto. Default  0 . Returns: [longitude, latitude]  or  [longitude, latitude, altitude]  in world coordinates.  altitude  is in meters. If input is  [x, y]  without specifying  opts.targetZ : returns  [longitude, latitude] . If input is  [x, y]  with  opts.targetZ : returns  [longitude, latitude, targetZ] . If input is  [x, y, z] : returns  [longitude, latitude, altitude] . getDistanceScales Returns an object with scale values supporting first order (linear) and second order (quadratic) approximations of the local Web Mercator projection scale around the viewport center. Error increases with distance from viewport center (very roughly 1% per 100km in linear mode, quadratic approximation does significantly better). Returns: An object with precalculated distance scales allowing conversion between lnglat deltas, meters and pixels. addMetersToLngLat Add a meter delta to a base lnglat coordinate using linear approximation. For information on numerical precision, see remarks on  getDistanceScales . Parameters: lngLatZ  (Array) - Base coordinate in  [longitude, latitude, altitude] . Passing a  altitude  is optional. xyz  (Array) - Array of  [x, y, z]  in meter deltas. Passing a  z  is optional. Returns: New coordinate array in  [longitude, latitude]  or  [longitude, latitude, altitude]  if  z  is provided. fitBounds Returns a new viewport that fit around the given bounding box. Only supports non-perspective mode. Parameters: bounds  (Array) - Bounding box in  [[longitude, latitude], [longitude, latitude]] . opts  (Object) padding  (Number) - The amount of padding in pixels to add to the given bounds. offset  (Array) - The center in  [x, y]  of the given bounds relative to the map's center measured in pixels. Returns:  New  WebMercatorViewport  fit around the given bounding box. Remarks Because  WebMercatorViewport  a subclass of  Viewport , an application can implement support for generic 3D  Viewport s and automatically get the ability to accept web mercator style map coordinates. A limitation at the moment is that there is no way to extract web mercator parameters from a \"generic\" viewport, so for map synchronization applications (rendering on top of a typical map component that only accepts web mercator parameters) the  WebMercatorViewport  is necessary. Facilitates the necessary mercator projections by breaking them into a minimal non-linear piece followed by a standard projection chain. Making deck.gl work with non-mapbox map systems  in perspective mode  might require subclassing  WebMercatorViewport  and adjust the projection so it matches the map's projection. Source modules/core/src/viewports/web-mercator-viewport.js","headings":[{"value":"WebMercatorViewport","depth":1},{"value":"Usage","depth":2},{"value":"Constructor","depth":2},{"value":"Methods","depth":2},{"value":"project","depth":5},{"value":"unproject","depth":5},{"value":"getDistanceScales","depth":5},{"value":"addMetersToLngLat","depth":5},{"value":"fitBounds","depth":5},{"value":"Remarks","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/core/web-mercator-viewport","title":"WebMercatorViewport"},{"excerpt":"DataFilterExtension The  DataFilterExtension  adds GPU-based data filtering functionalities to layers. It allows the layer to show/hide objects based on user-defined properties. This extension provides a significantly more performant alternative to filtering the data array on the CPU. Note: This extension does not work with all deck.gl layers. See \"limitations\" below. Installation To install the dependencies from NPM: To use pre-bundled scripts: Constructor filterSize  (Number) - the size of the filter (number of columns to filter by). The data filter can show/hide data based on 1-4 numeric properties of each object. Default  1 . fp64  (Boolean) - if  true , use 64-bit precision instead of 32-bit. Default  false . See the \"remarks\" section below for use cases and limitations. countItems  (Boolean) - if  true , reports the number of filtered objects with the  onFilteredItemsChange  callback. Default  false . Layer Properties When added to a layer via the  extensions  prop, the  DataFilterExtension  adds the following properties to the layer: getFilterValue  ( Function ) Called to retrieve the value for each object that it will be filtered by. Returns either a number (if  filterSize: 1 ) or an array. For example, consider data in the following format: To filter by timestamp: To filter by both timestamp and speed: Note that all filtered values are uploaded as 32-bit floating numbers, so certain values e.g. raw unix epoch time may not be accurately represented. You may test the validity of a timestamp by calling  Math.fround(t)  to check if there would be any loss of precision. filterRange  (Array) The bounds which defines whether an object should be rendered. If an object's filtered value is within the bounds, the object will be rendered; otherwise it will be hidden. This prop can be updated on user input or animation with very little cost. Format: If  filterSize  is  1 :  [min, max] If  filterSize  is  2  to  4 :  [[min0, max0], [min1, max1], ...]  for each filtered property, respectively. filterSoftRange  (Array, optional) Default:  null If specified, objects will be faded in/out instead of abruptly shown/hidden. When the filtered value is outside of the bounds defined by  filterSoftRange  but still within the bounds defined by  filterRange , the object will be rendered as \"faded.\" See  filterTransformSize  and  filterTransformColor  for additional control over this behavior. Format: If  filterSize  is  1 :  [softMin, softMax] If  filterSize  is  2  to  4 :  [[softMin0, softMax0], [softMin1, softMax1], ...]  for each filtered property, respectively. filterTransformSize  (Boolean, optional) Default:  true When an object is \"faded\", manipulate its size so that it appears smaller or thinner. Only works if  filterSoftRange  is specified. filterTransformColor  (Boolean, optional) Default:  true When an object is \"faded\", manipulate its opacity so that it appears more translucent. Only works if  filterSoftRange  is specified. filterEnabled  (Boolean, optional) Default:  true Enable/disable the data filter. If the data filter is disabled, all objects are rendered. onFilteredItemsChange  (Function, optional) Only used if the  countItems  option is enabled. Called with the following arguments when the filter changes: event  (Object) id  (String) - the id of the source layer. Note when this prop is specified on a  CompositeLayer , such as  GeoJsonLayer , the callback is called once by each sub layer. count  (Number) - the number of data objects that pass the filter. Remarks Filter precision By default, both the filter values and the filter range are uploaded to the GPU as 32-bit floats. When using very large filter values, most commonly Epoch timestamps, 32-bit float representation could lead to an error margin of >1 minute. Enabling 64-bit precision by setting  fp64: true  would allow the filter range to be evaluated more accurately. However, 64-bit support requires one extra attribute slot, which increases the risk of exceeding the hardware limit on vertex attributes. Depending on the layer that the  DataFilterExtension  is used with, it may interfere with the layer's ability to use other extensions. If this becomes an issue, an alternative technique is to transform each filter value by subtracting a fixed \"origin\" value, thus making the numbers smaller: 32-bit floats can accurately represent each second within ~190 days ( 2^24 ). Unless the filter values require both a large span and fine granularity, 32-bit floats should be sufficient. Limitations Given data filtering happens on GPU, not all layers of  @deck.gl/aggregation-layers  module, support this feature. Always supported: HeatMapLayer GPUGridLayer Supported only when aggregation is performed on GPU: ScreenGridlayer ContourLayer GridLayer Not supported: CPUGridLayer HexagonLayer Source modules/extensions/src/data-filter","headings":[{"value":"DataFilterExtension","depth":1},{"value":"Installation","depth":2},{"value":"Constructor","depth":2},{"value":"Layer Properties","depth":2},{"value":"getFilterValue (Function)","depth":5},{"value":"filterRange (Array)","depth":5},{"value":"filterSoftRange (Array, optional)","depth":5},{"value":"filterTransformSize (Boolean, optional)","depth":5},{"value":"filterTransformColor (Boolean, optional)","depth":5},{"value":"filterEnabled (Boolean, optional)","depth":5},{"value":"onFilteredItemsChange (Function, optional)","depth":5},{"value":"Remarks","depth":2},{"value":"Filter precision","depth":3},{"value":"Limitations","depth":2},{"value":"Always supported:","depth":3},{"value":"Supported only when aggregation is performed on GPU:","depth":3},{"value":"Not supported:","depth":3},{"value":"Source","depth":2}],"slug":"docs/api-reference/extensions/data-filter-extension","title":"DataFilterExtension"},{"excerpt":"FillStyleExtension The  FillStyleExtension  adds selected features to layers that render a \"fill\", such as the  PolygonLayer  and  ScatterplotLayer . Installation To install the dependencies from NPM: To use pre-bundled scripts: Constructor pattern  (Boolean) - if  true , adds the ability to tile the filled area with a pattern. Layer Properties When added to a layer via the  extensions  prop, the  FillStyleExtension  adds the following properties to the layer: Fill Pattern The following properties are available if the  pattern  option is enabled. fillPatternAtlas  (Texture2D | String) Sprite image url or texture that packs all your patterns into one layout.\nYou can create sprite images with tools such as  TexturePacker . fillPatternEnabled  (Boolean) Default:  true Whether to use pattern fill. If  false , then the extension has no effect. fillPatternMapping  (Object | String) Pattern names mapped to pattern definitions. Each pattern is defined with the following values: x  (Number, required): x position of pattern on the atlas image y  (Number, required): y position of pattern on the atlas image width  (Number, required): width of pattern on the atlas image height  (Number, required): height of pattern on the atlas image fillPatternMask  (Boolean) Default:  true Whether to treat the patterns as transparency masks. If  true , user defined color (e.g. from  getFillColor ) is applied. If  false , pixel color from the image is applied. getFillPattern  ( Function ) Called to retrieve the name of the pattern. Returns a string key from the  fillPatternMapping  object. getFillPatternScale  ( Function |Number) Default:  1 The scale of the pattern, relative to the original size. If the pattern is 24 x 24 pixels, scale  1  roughly yields 24 meters. If a number is provided, it is used as the pattern scale for all objects. If a function is provided, it is called on each object to retrieve its pattern scale. getFillPatternOffset  ( Function |Array) Default:  [0, 0] The offset of the pattern, relative to the original size. Offset  [0.5, 0.5]  shifts the pattern alignment by half. If an array is provided, it is used as the pattern offset for all objects. If a function is provided, it is called on each object to retrieve its pattern offset. Source modules/extensions/src/fill-style","headings":[{"value":"FillStyleExtension","depth":1},{"value":"Installation","depth":2},{"value":"Constructor","depth":2},{"value":"Layer Properties","depth":2},{"value":"Fill Pattern","depth":3},{"value":"fillPatternAtlas (Texture2D | String)","depth":5},{"value":"fillPatternEnabled (Boolean)","depth":5},{"value":"fillPatternMapping (Object | String)","depth":5},{"value":"fillPatternMask (Boolean)","depth":5},{"value":"getFillPattern (Function)","depth":5},{"value":"getFillPatternScale (Function|Number)","depth":5},{"value":"getFillPatternOffset (Function|Array)","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/extensions/fill-style-extension","title":"FillStyleExtension"},{"excerpt":"Fp64Extension The  Fp64Extension  adds 64-bit precision to geospatial layers. Note: This extension is the equivalent of the  fp64  prop from older deck.gl versions. As of v6.3, the fp64 mode was deprecated in favor of the new default 32-bit projection mode that is comparable in precision but considerably more performant. Installation To install the dependencies from NPM: To use pre-bundled scripts: Constructor Layer Properties When added to a layer via the  extensions  prop, the  Fp64Extension  requires the  coordinateSystem  prop of the layer to be  COORDINATE_SYSTEM.LNGLAT_DEPRECATED . Source modules/extensions/src/fp64","headings":[{"value":"Fp64Extension","depth":1},{"value":"Installation","depth":2},{"value":"Constructor","depth":2},{"value":"Layer Properties","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/extensions/fp64-extension","title":"Fp64Extension"},{"excerpt":"MaskExtension The  MaskExtension  allows layers to show/hide objects by a geofence. For example, a map may filter a list of user locations by the boundaries of a given country, or highlight part of a base map that is inside a user-drawn circle or lasso area. This extension provides a significantly more performant alternative to testing the data array against a bounding geometry on the CPU. To use this extension, first define a mask layer with the prop  operation: 'mask' . A mask layer is not rendered to screen; it defines the geometry of the mask. If the layer renders 3D objects, its footprint on the XY plane is used. For each layer that should be masked, add the  MaskExtension  to its  extensions  prop, and set the  maskId  prop to the id of the mask layer. A masked layer only renders data objects that fall inside the mask. Note: This extension does not work with all deck.gl layers. See \"limitations\" below. Installation To install the dependencies from NPM: To use pre-bundled scripts: Constructor Layer Properties When added to a layer via the  extensions  prop, the  MaskExtension  adds the following properties to the layer: maskId  (String) Id of the layer that defines the mask. The mask layer must use the prop  operation: 'mask' . Masking is disabled if  maskId  is empty or no valid mask layer with the specified id is found. maskByInstance  (Boolean, optional) maskByInstance  controls whether an object is clipped by its anchor (usually defined by an accessor called  getPosition , e.g. icon, scatterplot) or by its geometry (e.g. path, polygon). If not specified, it is automatically deduced from the layer type. Limitations The current implementation supports up to 4 masks at the same time. Given that masking is performed on the GPU, the layers of  @deck.gl/aggregation-layers  module that does aggregation on the CPU, for example  CPUGridLayer  and  HexagonLayer , are not supported. Source modules/extensions/src/mask","headings":[{"value":"MaskExtension","depth":1},{"value":"Installation","depth":2},{"value":"Constructor","depth":2},{"value":"Layer Properties","depth":2},{"value":"maskId (String)","depth":5},{"value":"maskByInstance (Boolean, optional)","depth":5},{"value":"Limitations","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/extensions/mask-extension","title":"MaskExtension"},{"excerpt":"@deck.gl/extensions Layer extensions are bonus features that you can optionally add to the core deck.gl layers. These features are not included in the layers by default because one or more of the following reasons: They do not work consistently for all layers, but still valuable for some; While they optimize for specific use cases, there is an unnecessary performance overhead for users who don't need them; Once separated from the core layer code, they can be tree shaken. Applications can have smaller bundle sizes by only including the features they need. This module contains the following extensions: BrushingExtension ClipExtension DataFilterExtension FillStyleExtension Fp64Extension MaskExtension PathStyleExtension For instructions on authoring your own layer extensions, visit  developer guide . Installation Install from NPM Include the Standalone Bundle","headings":[{"value":"@deck.gl/extensions","depth":1},{"value":"Installation","depth":2},{"value":"Install from NPM","depth":3},{"value":"Include the Standalone Bundle","depth":3}],"slug":"docs/api-reference/extensions/overview","title":"@deck.gl/extensions"},{"excerpt":"PathStyleExtension The  PathStyleExtension  adds selected features to the  PathLayer  and composite layers that render the  PathLayer , e.g.  PolygonLayer  and  GeoJsonLayer . Note: In v8.0, the  getDashArray  and  dashJustified  props are removed from the  PathLayer  and moved into this extension. Installation To install the dependencies from NPM: To use pre-bundled scripts: Constructor dash  (Boolean) - add capability to render dashed lines. Default  false . highPrecisionDash  (Boolean) - improve dash rendering quality in certain circumstances. Note that this option introduces additional performance overhead, see \"Remarks\" below. Default  false . offset  (Boolean) - add capability to offset lines. Default  false . Layer Properties When added to a layer via the  extensions  prop, the  PathStyleExtension  adds the following properties to the layer: getDashArray  ( Function |Array) Must be specified if the  dash  option is enabled. The dash array to draw each path with:  [dashSize, gapSize]  relative to the width of the path. If an array is provided, it is used as the dash array for all paths. If a function is provided, it is called on each path to retrieve its dash array. Return  [0, 0]  to draw the path in solid line. If this accessor is not specified, all paths are drawn as solid lines. dashJustified  (Boolean, optional) Default:  false Only effective if  getDashArray  is specified. If  true , adjust gaps for the dashes to align at both ends. Overrides the effect of  highPrecisionDash . getOffset  ( Function |Number) Must be specified if the  offset  option is enabled. The offset to draw each path with, relative to the width of the path. Negative offset is to the left hand side, and positive offset is to the right hand side.  0  extrudes the path so that it is centered at the specified coordinates. If a number is provided, it is used as the offset for all paths. If a function is provided, it is called on each path to retrieve its offset. dashGapPickable  (Boolean, optional) Default  false Only effective if  getDashArray  is specified. If  true , gaps between solid strokes are pickable. If  false , only the solid strokes are pickable.  Remarks Limitations WebGL has guaranteed support for up to 16 attributes per shader. The current implementation of  PathLayer  uses 13 attributes. Each one of the options of this extension adds one more attribute. In other words, if all options are enabled, the layer will not be able to use other extensions. Tips on Rendering Dash Lines There are three modes to render dash lines with this extension: Default: dash starts from the beginning of each line segment Justified: dash is stretched to center on each line segment High precision: dash is evaluated continuously from the beginning of a path The above table illustrates the visual behavior of the three modes. The default mode works best if the data consists of long, disjoint paths. It renders dashes at exactly the defined lengths. The justified mode is guaranteed to render sharp, well-defined corners. This is great for rendering polyline shapes. However, the gap size may look inconsistent across line segments due to stretching. The high precision mode pre-calculates path length on the CPU, so it may be slower and use more resources for large datasets. When a path contains a lot of short segments, this mode yields the best result. Source modules/extensions/src/path-style","headings":[{"value":"PathStyleExtension","depth":1},{"value":"Installation","depth":2},{"value":"Constructor","depth":2},{"value":"Layer Properties","depth":2},{"value":"getDashArray (Function|Array)","depth":5},{"value":"dashJustified (Boolean, optional)","depth":5},{"value":"getOffset (Function|Number)","depth":5},{"value":"dashGapPickable (Boolean, optional)","depth":5},{"value":"Remarks","depth":2},{"value":"Limitations","depth":3},{"value":"Tips on Rendering Dash Lines","depth":3},{"value":"Source","depth":2}],"slug":"docs/api-reference/extensions/path-style-extension","title":"PathStyleExtension"},{"excerpt":"GeohashLayer The  GeohashLayer  renders filled and/or stroked polygons based on the  Geohash  geospatial indexing system. GeohashLayer  is a  CompositeLayer . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer ,  CompositeLayer , and  PolygonLayer  properties, plus the following: Data Accessors getGeohash  ( Function , optional) Called for each data object to retrieve the geohash string identifier. default:  object => object.geohash Sub Layers The  GeohashLayer  renders the following sublayers: cell  - a  PolygonLayer  rendering all geohash cells. Source modules/geo-layers/src/geohash-layer","headings":[{"value":"GeohashLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Data Accessors","depth":3},{"value":"getGeohash (Function, optional)","depth":5},{"value":"Sub Layers","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/geo-layers/geohash-layer","title":"GeohashLayer"},{"excerpt":"GreatCircleLayer The  GreatCircleLayer  is a variation of the  ArcLayer . It renders flat arcs along the great circle joining pairs of source and target points,\nspecified as latitude/longitude coordinates. Starting v8.2, using this layer is identical to using the  ArcLayer  with props  greatCircle: true  and  getHeight: 0 . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  and  ArcLayer  properties. Source great-circle-layer","headings":[{"value":"GreatCircleLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/geo-layers/great-circle-layer","title":"GreatCircleLayer"},{"excerpt":"H3ClusterLayer The  H3ClusterLayer  renders regions represented by hexagon sets from the  H3  geospatial indexing system. H3ClusterLayer  is a  CompositeLayer . Installation To install the dependencies from NPM: To use pre-bundled scripts: Note that  h3-js  must be included before  deck.gl . Properties Inherits from all  Base Layer ,  CompositeLayer , and  PolygonLayer  properties, plus the following: Data Accessors getHexagons  ( Function , optional) Method called to retrieve the hexagon cluster from each object, as an array of  H3  hexagon indices. These hexagons are joined into polygons that represent the geospatial outline of the cluster. Sub Layers The  H3ClusterLayer  renders the following sublayers: cell  - a  PolygonLayer  rendering all clusters. Source modules/geo-layers/src/h3-layers/h3-cluster-layer","headings":[{"value":"H3ClusterLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Data Accessors","depth":3},{"value":"getHexagons (Function, optional)","depth":5},{"value":"Sub Layers","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/geo-layers/h3-cluster-layer","title":"H3ClusterLayer"},{"excerpt":"H3HexagonLayer The  H3HexagonLayer  renders hexagons from the  H3  geospatial indexing system. H3HexagonLayer  is a  CompositeLayer . Installation To install the dependencies from NPM: To use pre-bundled scripts: Note that  h3-js  must be included before  deck.gl . Properties Inherits from all  Base Layer ,  CompositeLayer , and  PolygonLayer  properties, plus the following: Render Options highPrecision  (Boolean, optional) Default:  'auto' Each hexagon in the H3 indexing system is  slightly different in shape . To draw a large number of hexagons efficiently, the  H3HexagonLayer  may choose to use instanced drawing by assuming that all hexagons within the current viewport have the same shape as the one at the center of the current viewport. The discrepancy is usually too small to be visible. There are several cases in which high-precision mode is required. In these cases,  H3HexagonLayer  may choose to switch to high-precision mode, where it trades performance for accuracy: The input set contains a pentagon. There are 12 pentagons world wide at each resolution, and these cells and their immediate neighbors have significant differences in shape. The input set is at a coarse resolution (res  0  through res  5 ). These cells have larger differences in shape, particularly when using a Mercator projection. The input set contains hexagons with different resolutions. Possible values: 'auto' : The layer chooses the mode automatically. High-precision rendering is only used if an edge case is encountered in the data. true : Always use high-precision rendering. false : Always use instanced rendering, regardless of the characteristics of the data. coverage  (Number, optional)  Default:  1 Hexagon radius multiplier, between 0 - 1. When  coverage  = 1, hexagon is rendered with actual size, by specifying a different value (between 0 and 1) hexagon can be scaled down. Data Accessors getHexagon  ( Function , optional) Default:  object => object.hexagon Method called to retrieve the  H3  hexagon index of each object. Note that all hexagons within one  H3HexagonLayer  must use the same  resolution . Sub Layers The  H3HexagonLayer  renders the following sublayers: hexagon-cell-hifi  - On  highPrecision  mode, rendered by  SolidPolygonLayer hexagon-cell  - On non  highPrecision  mode, rendered by  ColumnLayer Source modules/geo-layers/src/h3-layers/h3-hexagon-layer","headings":[{"value":"H3HexagonLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"highPrecision (Boolean, optional)","depth":5},{"value":"coverage (Number, optional) transition-enabled","depth":5},{"value":"Data Accessors","depth":3},{"value":"getHexagon (Function, optional)","depth":5},{"value":"Sub Layers","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/geo-layers/h3-hexagon-layer","title":"H3HexagonLayer"},{"excerpt":"S2Layer The  S2Layer  renders filled and/or stroked polygons based on the  S2  geospatial indexing system. S2Layer  is a  CompositeLayer . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer ,  CompositeLayer , and  PolygonLayer  properties, plus the following: Data Accessors getS2Token  ( Function , optional)  Called for each data object to retrieve the identifier of the S2 cell. May return one of the following: A string that is the cell's hex token A string that is the Hilbert quad key (containing  / ) A  Long  object that is the cell's id Check  S2 Cell  for more details. default:  object => object.token Sub Layers The  S2Layer  renders the following sublayers: cell  - a  PolygonLayer  rendering all S2 cells. Source modules/geo-layers/src/s2-layer","headings":[{"value":"S2Layer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Data Accessors","depth":3},{"value":"getS2Token (Function, optional) transition-enabled","depth":5},{"value":"Sub Layers","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/geo-layers/s2-layer","title":"S2Layer"},{"excerpt":"MVTLayer The  MVTLayer  is a derived  TileLayer  that makes it possible to visualize very large datasets through MVTs ( Mapbox Vector Tiles ). Behaving like  TileLayer , it will only load, decode and render MVTs containing features that are visible within the current viewport. Data is loaded from URL templates in the  data  property. This layer also handles feature clipping so that there are no features divided by tile divisions. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits all properties from  TileLayer  and  base  Layer , with exceptions indicated below. If using the default  renderSubLayers , supports all  GeoJSONLayer  properties to style features. data  (String | Array | JSON) Required. It defines the remote data for the MVT layer. String: Either a URL template or a  TileJSON  URL.  Array: an array of URL templates. It allows to balance the requests across different tile endpoints. For example, if you define an array with 4 urls and 16 tiles need to be loaded, each endpoint is responsible to server 16/4 tiles. JSON: A valid  TileJSON object . See  TileLayer 's  data  prop documentation for the URL template syntax. The  getTileData  prop from the  TileLayer  class will not be called. uniqueIdProperty  (String) Optional. Needed for highlighting a feature split across two or more tiles if no  feature id  is provided. An string pointing to a tile attribute containing a unique identifier for features across tiles. highlightedFeatureId  (Number | String) Default:  null Optional. When provided, a feature with ID corresponding to the supplied value will be highlighted with  highlightColor . If  uniqueIdProperty  is provided, value within that feature property will be used for ID comparison. If not,  feature id  will be used. loadOptions  (Object, optional) On top of the  default options , also accepts options for the following loaders: MVTLoader Note that by default, the  MVTLoader  parses data using web workers, with code loaded from a  CDN . To change this behavior, see  loaders and workers . binary  (Boolean, optional) Default:  true Use tile data in  binary format  to improve performance (2-3x faster on large datasets). It removes the need for serialization and deserialization of data transferred by the worker back to the main process.  Remarks:  It requires using  GeoJsonLayer  in the  renderSubLayers  callback. Callbacks onDataLoad  (Function, optional) Called if  data  is a TileJSON URL when it is successfully fetched Receives arguments: tileJSON  (Object) - the loaded TileJSON Methods getRenderedFeatures  (Function) Get the rendered features in the current viewport. If a  uniqueIdProperty  is provided only unique properties are returned. Requires  pickable  prop to be true. Parameters: maxFeatures  (Number, optional): Max number of features to retrieve when getRenderedFeatures is called. Default to  null . Returns: An array with geometries in GeoJSON format. Remarks: As it's an expensive operation, it's not recommended to call  getRenderedFeatures  every time  onViewStateChange  is executed, use a debounce function instead.  In most of the cases you probably want to use it attached to  onViewStateChange  and  onViewportLoad . Tile Aside from all members of the  Tile  class, tile instances from the  MVTLayer  also include the following fields: dataInWGS84  (Array) A list of features in world coordinates (WGS84). Usage example: Source modules/geo-layers/src/mvt-layer/mvt-layer.js","headings":[{"value":"MVTLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"data (String | Array | JSON)","depth":5},{"value":"uniqueIdProperty (String)","depth":5},{"value":"highlightedFeatureId (Number | String)","depth":5},{"value":"loadOptions (Object, optional)","depth":5},{"value":"binary (Boolean, optional)","depth":5},{"value":"Callbacks","depth":3},{"value":"onDataLoad (Function, optional)","depth":5},{"value":"Methods","depth":2},{"value":"getRenderedFeatures (Function)","depth":5},{"value":"Tile","depth":2},{"value":"dataInWGS84 (Array)","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/geo-layers/mvt-layer","title":"MVTLayer"},{"excerpt":"QuadkeyLayer The  QuadkeyLayer  renders filled and/or stroked polygons based on the  Quadkey  geospatial indexing system. QuadkeyLayer  is a  CompositeLayer . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer ,  CompositeLayer , and  PolygonLayer  properties, plus the following: Data Accessors getQuadkey  ( Function , optional) Called for each data object to retrieve the quadkey string identifier. default:  object => object.quadkey Sub Layers The  QuadkeyLayer  renders the following sublayers: cell  - a  PolygonLayer  rendering all quadkey cells. Source modules/geo-layers/src/quadkey-layer","headings":[{"value":"QuadkeyLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Data Accessors","depth":3},{"value":"getQuadkey (Function, optional)","depth":5},{"value":"Sub Layers","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/geo-layers/quadkey-layer","title":"QuadkeyLayer"},{"excerpt":"TerrainLayer The  TerrainLayer  reconstructs mesh surfaces from height map images, e.g.  Mapzen Terrain Tiles , which encodes elevation into R,G,B values. When  elevationData  is supplied with a URL template, i.e. a string containing  '{x}'  and  '{y}' , it loads terrain tiles on demand using a  TileLayer  and renders a mesh for each tile. If  elevationData  is an absolute URL, a single mesh is used, and the  bounds  prop is required to position it into the world space. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties When in Tiled Mode, inherits from all  TileLayer  properties. Forwards  wireframe  property to  SimpleMeshLayer . Data Options elevationData  (String|Array, required) Image URL that encodes height data. If the value is a valid URL, this layer will render a single mesh. If the value is a string, and contains substrings  {x}  and  {y} , it is considered a URL template. This layer will render a  TileLayer  of meshes.  {x}   {y}  and  {z}  will be replaced with a tile's actual index when it is requested. If the value is an array: multiple URL templates. See  TileLayer 's  data  prop documentation for use cases. texture  (String|Null, optional) Image URL to use as the surface texture. Same schema as  elevationData . Default:  null meshMaxError  (Number, optional) Martini error tolerance in meters, smaller number results in more detailed mesh.. Default:  4.0 elevationDecoder  (Object) Parameters used to convert a pixel to elevation in meters.\nAn object containing the following fields: rScaler : Multiplier of the red channel. gScaler : Multiplier of the green channel. bScaler : Multiplier of the blue channel. offset : Translation of the sum. Each color channel (r, g, and b) is a number between  [0, 255] . For example, the Mapbox terrain service's elevation is  encoded as follows : The corresponding  elevationDecoder  is: The default value of  elevationDecoder  decodes a grayscale image: bounds  (Array, optional) Bounds of the image to fit x,y coordinates into. In  [left, bottom, right, top] .\n left  and  right  refers to the world longitude/x at the corresponding side of the image.\n top  and  bottom  refers to the world latitude/y at the corresponding side of the image. Must be supplied when using non-tiled elevation data. Default:  null loadOptions  (Object, optional) On top of the  default options , also accepts options for the following loaders: TerrainLoader ImageLoader  if the  texture  prop is supplied Note that by default, the  TerrainLoader  parses data using web workers, with code loaded from a  CDN . To change this behavior, see  loaders and workers . Render Options color  (Color, optional) Color to use if  texture  is unavailable. Forwarded to  SimpleMeshLayer 's  getColor  prop. Default:  [255, 255, 255] wireframe  (Boolean, optional) Forwarded to  SimpleMeshLayer 's  wireframe  prop. Default:  false material  (Object, optional) Forwarded to  SimpleMeshLayer 's  material  prop. Default:  true Sub Layers The  TerrainLayer  renders the following sublayers: tiles  - a  TileLayer . Only rendered if  elevationData  is a URL template. mesh  - a  SimpleMeshLayer  rendering the terrain mesh. Source modules/geo-layers/src/terrain-layer","headings":[{"value":"TerrainLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Data Options","depth":3},{"value":"elevationData (String|Array, required)","depth":5},{"value":"texture (String|Null, optional)","depth":5},{"value":"meshMaxError (Number, optional)","depth":5},{"value":"elevationDecoder (Object)","depth":5},{"value":"bounds (Array, optional)","depth":5},{"value":"loadOptions (Object, optional)","depth":5},{"value":"Render Options","depth":3},{"value":"color (Color, optional)","depth":5},{"value":"wireframe (Boolean, optional)","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"Sub Layers","depth":2},{"value":"Source","depth":1}],"slug":"docs/api-reference/geo-layers/terrain-layer","title":"TerrainLayer"},{"excerpt":"Trips Layer The  TripsLayer  renders animated paths that represent vehicle trips. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  and  PathLayer  properties, plus the following: Render Options currentTime  (Number, optional)  Default:  0 The current time of the frame, i.e. the playhead of the animation. This value should be in the same units as the timestamps from  getPath . fadeTrail  (Boolean, optional) Default:  true Whether or not the path fades out. If  false ,  trailLength  has no effect. trailLength  (Number, optional)  Default:  120 How long it takes for a path to completely fade out. This value should be in the same units as the timestamps from  getPath . Data Accessors getPath  ( Function , optional) Default:  d => d.path Called for each data object to retrieve paths.\nReturns an array of navigation points on a single path. See  PathLayer  documentation for supported path formats. getTimestamps  ( Function , optional) Default:  d => d.timestamps Returns an array of timestamps, one for each navigation point in the geometry returned by  getPath , representing the time that the point is visited. Because timestamps are stored as 32-bit floating numbers, raw unix epoch time can not be used. You may test the validity of a timestamp by calling  Math.fround(t)  to check if there would be any loss of precision. Legacy API, removing in a future major release: If  getTimestamps  is not supplied, each navigation point in the path is interpreted as  [longitude, latitude, timestamp] , and the paths will always be rendered flat against the ground. Source modules/geo-layers/src/trips-layer","headings":[{"value":"Trips Layer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"currentTime (Number, optional) transition-enabled","depth":5},{"value":"fadeTrail (Boolean, optional)","depth":5},{"value":"trailLength (Number, optional) transition-enabled","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPath (Function, optional)","depth":5},{"value":"getTimestamps (Function, optional)","depth":5},{"value":"Source","depth":1}],"slug":"docs/api-reference/geo-layers/trips-layer","title":"Trips Layer"},{"excerpt":"Tile3DLayer (Experimental) The  Tile3DLayer  renders 3d tiles data formatted according to the  3D Tiles Specification  and  ESRI I3S  ,\nwhich is supported by the  Tiles3DLoader . Tile3DLayer is a  CompositeLayer . Base on each tile type, it uses a  PointCloudLayer , a  ScenegraphLayer  or  SimpleMeshLayer  to render. References 3D Tiles . ESRI I3S Load a 3D tiles dataset from ION server.  Set up Ion account ; Load I3S Tiles Installation To install the dependencies: To use pre-bundled scripts: Properties Inherits from all  Base Layer  and  CompositeLayer  properties. Along with other options as below, Render Options opacity  (Number, Optional) Default  1.0 The opacity of the layer. The same as defined in  layer . pointSize  (Number, Optional) Default  1.0 Global radius of all points in pixels.\nThis value is only applied when  tile format  is  pnts . Data Properties data  (String) A URL to fetch tiles entry point of  3D Tiles   Tileset JSON  file or  Indexed 3D Scene Layer  file  I3S . loader  (Object) Default  Tiles3DLoader A loader which is used to decode the fetched tiles. Available options are  CesiumIonLoader , Tiles3DLoader ,  I3SLoader . loadOptions  (Object, Optional) On top of the  default options , also support the following keys: [loader.id]  passing options to the loader defined by the  loader  prop. tileset : Forward parameters to the  Tileset3D  instance after fetching the tileset metadata. pickable  (Boolean, Optional) Default: false When  picking  is enabled,  info.object  will be a  Tile3DHeader  object. Data Accessors getPointColor  (Function|Array, Optional) Default  [0, 0, 0, 255] The rgba color at the target, in  r, g, b, [a] . Each component is in the 0-255 range.\nThis value is only applied when  tile format  is  pnts  and no  color properties  are defined in point cloud tile file. Callbacks onTilesetLoad  (Function, optional) onTilesetLoad  is a function that is called when Tileset JSON file is loaded.  Tileset  object is passed in the callback. Default:  onTilesetLoad: (tileset) => {} onTileLoad  (Function, optional) onTileLoad  is a function that is called when a tile in the tileset hierarchy is loaded.  Tile3D  object is passed in the callback. Default:  onTileLoad: (tileHeader) => {} onTileUnload  (Function, optional) onTileUnload  is a function that is called when a tile is unloaded.  Tile3D  object is passed in the callback. Default:  onTileUnload: (tileHeader) => {} onTileError  (Function, optional) onTileError  is a function that is called when a tile failed to load. Default:  onTileError: (tileHeader, url, message) => {} url : the url of the failed tile. message : the error message. _getMeshColor  (Function, optional) _getMeshColor  is a function which allows to change color of mesh based on properties of  tileHeader  object.\nIt recieves  tileHeader  object as argument and return type is array of  r, g, b  values in the 0-255 range.\nThis value is only applied when tile format is  mesh .\nCan be used only for I3S debugging purposes. Default:  _getMeshColor: (tileHeader) => [255, 255, 255] Sub Layers The Tile3DLayer renders the following sublayers based on tile  format : scenegraph  - a  ScenegraphLayer  rendering all the tiles with Batched 3D Model format ( b3dm ) or Instanced 3D Model format ( i3dm ). _lighting  is default to  pbr . pointcloud  - a  PointCloudLayer  rendering all the tiles with Point Cloud format ( pnts ). mesh  - a  SimpleMeshLayer  rendering all the tiles ESRI  MeshPyramids  data. Follow  CompositeLayer  and example in this layer doc to see how to override sub layer props. Remarks The  Tile3DLayer  can be rendered in multiple views. A tile is loaded if it is required by any of the viewports, and shared across all views via a single cache system. Source modules/geo-layers/src/tile-3d-layer","headings":[{"value":"Tile3DLayer (Experimental)","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"opacity (Number, Optional)","depth":5},{"value":"pointSize (Number, Optional)","depth":5},{"value":"Data Properties","depth":3},{"value":"data (String)","depth":5},{"value":"loader (Object)","depth":5},{"value":"loadOptions (Object, Optional)","depth":5},{"value":"pickable (Boolean, Optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPointColor (Function|Array, Optional)","depth":5},{"value":"Callbacks","depth":3},{"value":"onTilesetLoad (Function, optional)","depth":5},{"value":"onTileLoad (Function, optional)","depth":5},{"value":"onTileUnload (Function, optional)","depth":5},{"value":"onTileError (Function, optional)","depth":5},{"value":"_getMeshColor (Function, optional)","depth":5},{"value":"Sub Layers","depth":2},{"value":"Remarks","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/geo-layers/tile-3d-layer","title":"Tile3DLayer (Experimental)"},{"excerpt":"TileLayer The  TileLayer  is a composite layer that makes it possible to visualize very large datasets. Instead of fetching the entire dataset, it only loads and renders what's visible in the current viewport. To use this layer, the data must be sliced into \"tiles\". Each tile has a pre-defined bounding box and level of detail.\nUsers have the option to load each tile from a unique URL, defined by a template in the  data  property.\nThe layer can also supply a callback  getTileData  that does custom fetching when a tile is requested.\nThe loaded tile data is then rendered with the layer(s) returned by  renderSubLayers . Installation To install the dependencies from NPM: To use pre-bundled scripts: Indexing System At each integer zoom level ( z ), the XY plane in the view space is divided into square tiles of the same size, each uniquely identified by their  x  and  y  index. When  z  increases by 1, the view space is scaled by 2, meaning that one tile at  z  covers the same area as four tiles at  z+1 . When the  TileLayer  is used with a geospatial view such as the  MapView , x, y, and z are determined from  the OSM tile index . When the  TileLayer  is used used with a non-geospatial view such as the  OrthographicView  or the  OrbitView ,  x  and  y  increment from the world origin, and each tile's width and height match that defined by the  tileSize  prop. For example, the tile  x: 0, y: 0  occupies the square between  [0, 0]  and  [tileSize, tileSize] . If you need to offset the  z  level at which the tiles are fetched in order to fetch tiles at a higher resolution in order to produce a \"crisper\" picture, there is a  zoomOffset  prop. Properties Inherits all properties from  base  Layer . If using the default  renderSubLayers , supports all  GeoJSONLayer  properties to style features. Data Options data  (String|Array, optional) Default:  [] Either a URL template or an array of URL templates from which the tile data should be loaded. If the value is a string: a URL template. Substrings  {x}   {y}  and  {z} , if present, will be replaced with a tile's actual index when it is requested. If the value is an array: multiple URL templates. Each endpoint must return the same content for the same tile index. This can be used to work around  domain sharding , allowing browsers to download more resources simultaneously. Requests made are balanced among the endpoints, based on the tile index. getTileData  (Function, optional) Default:  tile => load(tile.url) If supplied,  getTileData  is called to retrieve the data of each tile. It receives one argument  tile  which contains the following fields: index  (Object) - index of the tile.  index  is in the shape of  {x, y, z} , corresponding to the integer values specifying the tile. id  (String) - unique string representation of index. url  (String) - resolved url of the tile if the  data  prop is provided, otherwise  null bbox  (Object) - bounding box of the tile. When used with a geospatial view,  bbox  is in the shape of  {west: <longitude>, north: <latitude>, east: <longitude>, south: <latitude>} . When used with a non-geospatial view,  bbox  is in the shape of  {left, top, right, bottom} . signal  (Object) - an  AbortSignal  that may be signalled if there are too many queued requests. Note: only tiles that aren't visible will be aborted. It should return either the tile data or a Promise that resolves to the tile data. This prop is not required if  data  points to a supported format (JSON or image by default). Additional formats may be added by registering  loaders.gl  modules. It is recommended to pass  signal  to any  fetch  calls and check its  aborted  property before doing any expensive computation. If  signal  is aborted, then throw or return falsy from  getTileData  so the data is not cached; do not return incomplete data. If  signal  is aborted, but  getTileData  still returns a truthy response, then its data will be cached. TilesetClass  (class, optional) Default:  Tileset2D Tileset class that  TileLayer  uses for tile indexing. Extend  Tileset2D  to implement a custom indexing scheme. tileSize  (Number, optional) The pixel dimension of the tiles, usually a power of 2. For geospatial viewports, tile size represents the target pixel width and height of each tile when rendered. Smaller tile sizes display the content at higher resolution, while the layer needs to load more tiles to fill the same viewport. For non-geospatial viewports, the tile size should correspond to the true pixel size of the tiles. Default:  512 zoomOffset  (Number, optional) This offset changes the zoom level at which the tiles are fetched.  Needs to be an integer. Default:  0 maxZoom  (Number|Null, optional) The max zoom level of the layer's data. When overzoomed (i.e.  zoom > maxZoom ), tiles from this level will be displayed. Default:  null minZoom  (Number, optional) The min zoom level of the layer's data. When underzoomed (i.e.  zoom < minZoom ), the layer will not display any tiles unless  extent  is defined, to avoid issuing too many tile requests. Default: 0 extent  (Array, optional) The bounding box of the layer's data, in the form of  [minX, minY, maxX, maxY] . If provided, the layer will only load and render the tiles that are needed to fill this box.  Default:  null maxCacheSize  (Number, optional) The maximum number of tiles that can be cached. The tile cache keeps loaded tiles in memory even if they are no longer visible. It reduces the need to re-download the same data over and over again when the user pan/zooms around the map, providing a smoother experience. If not supplied, the  maxCacheSize  is calculated as  5  times the number of tiles in the current viewport. Default:  null maxCacheByteSize  (Number, optional) The maximum memory used for caching tiles. If this limit is supplied,  getTileData  must return an object that contains a  byteLength  field. Default:  null refinementStrategy  (String|Function, optional) How the tile layer refines the visibility of tiles. When zooming in and out, if the layer only shows tiles from the current zoom level, then the user may observe undesirable flashing while new data is loading. By setting  refinementStrategy  the layer can attempt to maintain visual continuity by displaying cached data from a different zoom level before data is available. This prop accepts one of the following: 'best-available' : If a tile in the current viewport is waiting for its data to load, use cached content from the closest zoom level to fill the empty space. This approach minimizes the visual flashing due to missing content. 'no-overlap' : Avoid showing overlapping tiles when backfilling with cached content. This is usually favorable when tiles do not have opaque backgrounds. 'never' : Do not display any tile that is not selected. A custom function. See \"custom strategy\" below. Default:  'best-available' custom strategy Apps may define a custom  refinementStrategy  by supplying its own callback function. The function will be called frequently on every viewport update and every tile loaded event. When called, the function receives an array of  Tile  instances representing every tile that is currently in the cache. It is an opportunity to manipulate  tile.isVisible  before sub layers are rendered.  isVisible  is initially set to the value of  isSelected  (equivalent to  refinementStrategy: 'never' ). maxRequests  (Number, optional) The maximum number of concurrent  getTileData  calls. If  <= 0 , no throttling will occur, and  getTileData  may be called an unlimited number of times concurrently regardless of how long that tile is or was visible. If  > 0 , a maximum of  maxRequests  instances of  getTileData  will be called concurrently. Requests may never be called if the tile wasn't visible long enough to be scheduled and started. Requests may also be aborted (through the  signal  passed to  getTileData ) if there are more than  maxRequests  ongoing requests and some of those are for tiles that are no longer visible. If  getTileData  makes  fetch  requests against an HTTP 1 web server, then  maxRequests  should correlate to the browser's maximum number of concurrent  fetch  requests. For Chrome, the max is 6 per domain. If you use the  data  prop and specify multiple domains, you can increase this limit. For example, with Chrome and 3 domains specified, you can set  maxRequests=18 . If the web server supports HTTP/2 (Open Chrome dev tools and look for \"h2\" in the Protocol column), then you can make an unlimited number of concurrent requests (and can set  maxRequests=-1 ). Note that this will request data for every tile, no matter how long the tile was visible, and may increase server load. Default:  6 Render Options renderSubLayers  (Function, optional) Renders one or an array of Layer instances with all the  TileLayer  props and the following props: id : An unique id for this sublayer data : Resolved from  getTileData . As of deck.gl 8.2, this prop is always the data resolved from the Promise and is never a Promise itself. tile : An object containing  index ,  bbox , and  id  of the tile. Default:  props => new GeoJsonLayer(props) Note that the following sub layer props are overridden by  TileLayer  internally: visible  (toggled based on tile visibility) highlightedObjectIndex  (set based on the parent layer's highlight state) zRange  (Array, optional) An array representing the range of minimum and maximum heights in the tile. This is designed to support extruded layers, such as the TerrainLayer, ensuring the right tiles are loaded and rendered. This prop currently only has effect when used with a geospatial view. Default:  null  (interpreted as  [0, 0] ) modelMatrix  (Matrix4, optional) Affects both rendering and tile fetching to produce a transformed tile layer.  Note that this can result in tiles being fetched outside the  extent  prop, for example if the  modelMatrix  defines a rotation. Default:  null Callbacks onViewportLoad  (Function, optional) onViewportLoad  is a function that is called when all tiles in the current viewport are loaded. An array of loaded  Tile  instances are passed as argument to this function Default:  data => null onTileLoad  (Function, optional) onTileLoad  called when a tile successfully loads. Default:  () => {} Receives arguments: tile  (Object) - the  tile  that has been loaded. onTileError  (Function, optional) onTileError  called when a tile failed to load. Default:  console.error Receives arguments: error  ( Error ) onTileUnload  (Function, optional) onTileUnload  called when a tile is cleared from cache. Default:  () => {} Receives arguments: tile  (Object) - the  tile  that has been cleared from cache. Tile Class to hold the reading of a single tile Properties: index  (Object) - index of the tile.  index  is in the shape of  {x, y, z} , corresponding to the integer values specifying the tile. id  (String) - unique string representation of index, as 'x-y-z', e.g. '0-2-3'. bbox  (Object) - bounding box of the tile. When used with a geospatial view,  bbox  is in the shape of  {west: <longitude>, north: <latitude>, east: <longitude>, south: <latitude>} . When used with a non-geospatial view,  bbox  is in the shape of  {left, top, right, bottom} . content  (Object) - the tile's cached content.  null  if the tile's initial load is pending, cancelled, or encountered an error. data  (Object|Promise) - the tile's requested content. If the tile is loading, returns a Promise that resolves to the loaded content when loading is completed. parent  (Tile) - the nearest ancestor tile (a tile on a lower  z  that contains this tile), if present in the cache children  (Tile[]) - the nearest sub tiles (tiles on higher  z  that are contained by this tile), if present in the cache isSelected  (Boolean) - if the tile is expected to show up in the current viewport isVisible  (Boolean) - if the tile should be rendered isLoaded  (Boolean) - if the content of the tile has been loaded Tileset2D Class that manages loading and purging of tile data. This class caches recently visited tiles and only creates new tiles if they are present. To implement a custom indexing scheme, extend  Tileset2D  and implement the following interface: getTileIndices({viewport, maxZoom, minZoom, zRange, modelMatrix, modelMatrixInverse})  - returns an array of indices in the given viewport. The indices should have the shape of Objects, like:  {q: '0123'}  to allow referencing in the URL template supplied to the  data  prop. getTileId(index)  - returns unique string key for a tile index. getParentIndex(index)  - returns index of the parent tile. getTileZoom(index)  - returns a zoom level for a tile index. `getTileMetadata(index) - returns additional metadata to add to tile (optional). For example, to index using  quadkeys : Source modules/geo-layers/src/tile-layer","headings":[{"value":"TileLayer","depth":1},{"value":"Installation","depth":2},{"value":"Indexing System","depth":2},{"value":"Properties","depth":2},{"value":"Data Options","depth":3},{"value":"data (String|Array, optional)","depth":5},{"value":"getTileData (Function, optional)","depth":5},{"value":"TilesetClass (class, optional)","depth":5},{"value":"tileSize (Number, optional)","depth":5},{"value":"zoomOffset (Number, optional)","depth":5},{"value":"maxZoom (Number|Null, optional)","depth":5},{"value":"minZoom (Number, optional)","depth":5},{"value":"extent (Array, optional)","depth":5},{"value":"maxCacheSize (Number, optional)","depth":5},{"value":"maxCacheByteSize (Number, optional)","depth":5},{"value":"refinementStrategy (String|Function, optional)","depth":5},{"value":"custom strategy","depth":5},{"value":"maxRequests (Number, optional)","depth":5},{"value":"Render Options","depth":3},{"value":"renderSubLayers (Function, optional)","depth":5},{"value":"zRange (Array, optional)","depth":5},{"value":"modelMatrix (Matrix4, optional)","depth":5},{"value":"Callbacks","depth":3},{"value":"onViewportLoad (Function, optional)","depth":5},{"value":"onTileLoad (Function, optional)","depth":5},{"value":"onTileError (Function, optional)","depth":5},{"value":"onTileUnload (Function, optional)","depth":5},{"value":"Tile","depth":2},{"value":"Tileset2D","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/geo-layers/tile-layer","title":"TileLayer"},{"excerpt":"@deck.gl/google-maps Use deck.gl layers as a custom Google Maps overlay. Installation Include the Standalone Bundle Install from NPM Vector/Raster maps Starting with Google Maps v3.45 there are two modes of rendering  Vector and Raster . To control which rendering mode is used, you need to configure the Google Map using the  Google Cloud Platform . From v8.6, the  GoogleMapsOverlay  class automatically detects at runtime which rendering type is used. The Vector rendering mode is in general more performant, and the  GoogleMapsOverlay  class offers several features not available when using Raster rendering: Shared 3D space: objects drawn by the  GoogleMapsOverlay  class appear inside the Google Maps scene, correctly intersecting with 3D buildings and behind the contextual labels drawn by Google Maps Tilting and rotating the view is supported Rendering uses the same WebGL context as Google Maps, improving performance Supported Features and Limitations Supported deck.gl features: Layers Effects Auto-highlighting Attribute transitions onHover  and  onClick  callbacks Tooltip Tilting & Rotation (Vector maps only) Not supported features: Views Controller React integration Gesture event callbacks (e.g.  onDrag* )","headings":[{"value":"@deck.gl/google-maps","depth":1},{"value":"Installation","depth":2},{"value":"Include the Standalone Bundle","depth":3},{"value":"Install from NPM","depth":3},{"value":"Vector/Raster maps","depth":2},{"value":"Supported Features and Limitations","depth":2}],"slug":"docs/api-reference/google-maps/overview","title":"@deck.gl/google-maps"},{"excerpt":"GoogleMapsOverlay This class implements the  OverlayView / WebGLOverlayView  (depending on map rendering type) interface and can be used as any other Google Maps overlay. Vector/Raster maps As detailed in the  overview , the overlay supports both Vector and Raster Google map rendering. Depending on the Google Map configuration, the correct deck.gl overlay rendering method will be chosen at runtime. Usage Constructor props  are forwarded to a  Deck  instance. The following  Deck  props are supported: style layers effects parameters pickingRadius useDevicePixels onWebGLInitialized onBeforeRender onAfterRender onLoad Methods setMap Add/remove the overlay from a map. An overlay can be temporarily hidden from a map by calling  setMap(null) . Removing an overlay does not destroy the WebGL context; use  finalize()  if the overlay should be permanently removed. setProps Update (partial) props. pickObject Equivalent of  deck.pickObject . pickObjects Equivalent of  deck.pickObjects . pickMultipleObjects Equivalent of  deck.pickMultipleObjects . finalize Remove the overlay and release all underlying resources.","headings":[{"value":"GoogleMapsOverlay","depth":1},{"value":"Vector/Raster maps","depth":2},{"value":"Usage","depth":2},{"value":"Constructor","depth":2},{"value":"Methods","depth":2},{"value":"setMap","depth":5},{"value":"setProps","depth":5},{"value":"pickObject","depth":5},{"value":"pickObjects","depth":5},{"value":"pickMultipleObjects","depth":5},{"value":"finalize","depth":5}],"slug":"docs/api-reference/google-maps/google-maps-overlay","title":"GoogleMapsOverlay"},{"excerpt":"JSONConfiguration Object with the following fields. classes  - a map of general classes that should be made available to the JSON class resolver. (In the case of deck.gl, this would typically be  Layer  and  View  classes). functions  - a map of functions that should be made available to the JSON function resolver. enumerations  - a map of enumerations that should be made available to the JSON string resolver. constants  - A map of constants that should be made available to the JSON string resolver. reactComponents  - a map of general react components that should be made available to the JSON class resolver.\nReact support is experimental. The React dependency has to be injected via the configuration See more details in the  Configuration Reference  section.","headings":[{"value":"JSONConfiguration","depth":1}],"slug":"docs/api-reference/json/json-configuration","title":"JSONConfiguration"},{"excerpt":"Conversion Reference Prefix Description Example usage @@type Interpret a string as a JavaScript class or React component, resolving in the JSONConfiguration. \"@@type\": \"ScatterplotLayer\" @@function Interpret a string as a JavaScript function, resolving in the JSONConfiguration. \"@@function\": \"calculateRadius\" @@= Interpret the rest of the string as a function, parsing unquoted character strings as identifiers \"@@=[lng, lat]\" @@# Interpret the rest of the string as a constant, resolving in the JSON configuration \"@@#MapController\" @@#<enum-name>.<enum-value> Interpret the rest of the string as a enumeration, resolving in the JSON configuration \"@@#GL.ONE\" The @deck.g/json framework inspects the \"raw\" parsed JSON data structure before supplying it to deck.gl as props. This conversion process replaces certain objects in the structure with instances of objects. Classes and using  @@type Conversion happens by default for classes. For example, when this configuration of classes is passed to a\n  JSONConverter – and used to resolve this JSON object– it will replace the layers descriptor with A warning will be raised if the named layer is not registered. Whenever the  JSONConverter  component finds the  @@type  field, it looks into the \"class catalog\"\nlike that in the configuration object above. These classes can be layers, views, or other objects,\n provided the classes have been registered. Functions and using  @@function Any JavaScript function can be passed. For example, when this configuration of functions is passed to a\n JSONConverter – and used to resolve this JSON object– it will replace the layers descriptor with A warning will be raised if the function is not registered. Whenever the  JSONConverter  component finds the  @@function  field, it looks into the \"function catalog\"\nlike that in the configuration object above. Constants and using the  @@#  prefix A map of constants that should be made available to the JSON string resolver. This is also helpful to evaluate a prop that does not need to be instantiated. The  @@#  prefix on an constant triggers this lookup. For example, when this configuration is passed to  JSONConverter : and used to resolve in this JSON object: will replace the constants' value with the value provided in configuration declaration: Whenever the  JSONConverter  component finds a string prefixed with  @@# , it looks into a \"constants catalog\" first and then the \"enumerations catalog\". Enumerations and using the  @@#  prefix Often deck.gl visualizations require access to particular enumerations. For this reason, a configuration\n object can also contain a map of enumerations that should be made available to the @deck.gl/json string\nresolver. The  @@#  prefix on an enumeration triggers this lookup. For example, when this configuration is passed to the  JSONConverter – and used to resolve this JSON object– the  @@#<enum-name>.<enum-value>  will be resolved to values in the  enumerations  config: Functions and using the  @@=  prefix Functions are parsed from value strings with a  @@=  prefix. In this case, a function is generated of the format  (datum) => [datum[\"lng\"], datum[\"lng\"]] , reading\nfrom the JSON data rows. Passing  @@=-  will simply return a function of the format  (datum) => (datum) . For example, if data were\nan array of coordinates (e.g.,  [[0, 1], [0, 5]] ), passing  @@=-  would return those values. Additionally,  @@=  provides access to a small Javascript expression parser. You can apply basic Boolean,\ninline conditionals, and arithmetic operations via this parser.\nFor example, the following are all valid functions– Each would be evaluated to an expression equivalent to–","headings":[{"value":"Conversion Reference","depth":1},{"value":"Classes and using @@type","depth":2},{"value":"Functions and using @@function","depth":2},{"value":"Constants and using the @@# prefix","depth":3},{"value":"Enumerations and using the @@# prefix","depth":3},{"value":"Functions and using the @@= prefix","depth":2}],"slug":"docs/api-reference/json/conversion-reference","title":"Conversion Reference"},{"excerpt":"JSONConverter NOTE: This component is only intended to support  official deck.gl API props  via JSON. In particular, it is not intended to evolve an implementation of alternate JSON schemas. Support for such schemas should be developed independently, perhaps using the source code of this component as a base. See the  JSON Layers RFC  for more on this. Converts a JSON description of a deck.gl visualization into properties that can be passed to the  Deck  component. Requirements on the JSON description: Expected to contain at minimum \"layers\" and \"initialViewState\" fields. The JSON for each layer should be formatted as in described in JSONLayer. Usage Properties json  (Object|String) A JSON string or a parsed JSON structure.\nAll properties in this object, after processing, are passed to a  Deck  instance as props. Configuration See more details in the  Configuration Reference  section.","headings":[{"value":"JSONConverter","depth":1},{"value":"Usage","depth":2},{"value":"Properties","depth":2},{"value":"json (Object|String)","depth":5},{"value":"Configuration","depth":2}],"slug":"docs/api-reference/json/json-converter","title":"JSONConverter"},{"excerpt":"@deck.gl/json The deck.gl JSON module provides a  JSONConverter  class that converts textual JSON specifications into JavaScript objects, and functions. Through a set of conventions, the JSON module allows the specification of  JavaScript class instances ,  React elements ,  enumerations  and  functions  (in addition to the basic types created during the JSON parsing process (i.e. arrays, objects, strings, numbers and booleans). The set of classes, React components, functions, constants and enumerations that should be available to the JSONConverter must be provided via an application-provided configuration object. Use Cases Especially in the infovis space, there is a growing need to be able to generate powerful visualizations directly from the backend. Being able to describe a visualization in abstract terms and send it to the front-end for display without modifying JavaScript code can be valuable. deck.gl Integration deck.gl supports a declarative system for describing layers and their props, and this declarative API can be trivially exposed via the JSON API. See our  live demo . The module was created to enable specifying deck.gl visualizations using  JSON formatted  text files and strings, but is completely generic and Installation Include the Standalone Bundle Install from NPM Schema The valid combinations are defined by the  documented API . Error Handling Error detection is currently limited and error messages may not be very helpful.","headings":[{"value":"@deck.gl/json","depth":1},{"value":"Use Cases","depth":2},{"value":"deck.gl Integration","depth":2},{"value":"Installation","depth":2},{"value":"Include the Standalone Bundle","depth":3},{"value":"Install from NPM","depth":3},{"value":"Schema","depth":2},{"value":"Error Handling","depth":2}],"slug":"docs/api-reference/json/overview","title":"@deck.gl/json"},{"excerpt":"Layer Catalog Overview For first-time deck.gl developers, it is helpful to read the following pages before jumping into the layer catalog: Guide to using deck.gl layers : general concepts and frequently asked questions All deck.gl layers inherit from either the  Layer  or the  CompositeLayer  base classes, and the props of those layers are available to all layers unless otherwise documented. The base class props are not repeated in individual layer documentation. Core Layers The  Core Layers  are a group of generic-purpose layers, intended to represent the building blocks for all data visualizations. The core layers are the most stable and supported deck.gl layers. ArcLayer BitmapLayer ColumnLayer GeoJsonLayer GridCellLayer IconLayer LineLayer PathLayer PointCloudLayer PolygonLayer ScatterplotLayer SolidPolygonLayer TextLayer Aggregation Layers The  Aggregation Layers  are layers that aggregate the input data and visualize them in alternative representations, such as grid and hexagon binning, contour, and heatmap. ContourLayer GridLayer GPUGridLayer CPUGridLayer HexagonLayer ScreenGridLayer HeatmapLayer   Experimental Geo Layers The  Geo Layers  collects layers that specifically target geospatial visualization use cases, including support for map tiles, popular geospatial indexing systems, GIS formats, etc. GreatCircleLayer H3ClusterLayer H3HexagonLayer GeohashLayer QuadkeyLayer S2Layer TileLayer TripsLayer TerrainLayer MVTLayer Mesh Layers The  Mesh Layers  visualize 3D models, with experimental support for scenegraph in the glTF format. SimpleMeshLayer ScenegraphLayer","headings":[{"value":"Layer Catalog Overview","depth":1},{"value":"Core Layers","depth":2},{"value":"Aggregation Layers","depth":2},{"value":"Geo Layers","depth":2},{"value":"Mesh Layers","depth":2}],"slug":"docs/api-reference/layers","title":"Layer Catalog Overview"},{"excerpt":"BitmapLayer The  BitmapLayer  renders a bitmap at specified boundaries. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Data image  (String|Texture2D|Image|ImageData|HTMLCanvasElement|HTMLVideoElement|ImageBitmap|Promise|Object) Default  null . The image to display. If a string is supplied, it is interpreted as a URL or a  Data URL . One of the following, or a Promise that resolves to one of the following: One of the valid  pixel sources for WebGL texture A luma.gl  Texture2D  instance A plain object that can be passed to the  Texture2D  constructor, e.g.  {width: <number>, height: <number>, data: <Uint8Array>} . Note that whenever this object shallowly changes, a new texture will be created. The image data will be converted to a  Texture2D  object. See  textureParameters  prop for advanced customization. bounds  (Array) Supported formats: Coordinates of the bounding box of the bitmap  [left, bottom, right, top] Coordinates of four corners of the bitmap, should follow the sequence of  [[left, bottom], [left, top], [right, top], [right, bottom]] . Each position could optionally contain a third component  z . left  and  right  refers to the world longitude/x at the corresponding side of the image.\n top  and  bottom  refers to the world latitude/y at the corresponding side of the image. loadOptions  (Object, optional) On top of the  default options , also accepts options for the following loaders: ImageLoader  if the  image  prop is an URL textureParameters  (Object) Customize the  texture parameters . If not specified, the layer uses the following defaults to create a linearly smoothed texture from  image : For example, to remove smoothing and achieve a pixelated appearance: This prop is only used when  image  initially loads or changes. _imageCoordinateSystem  (Number, optional) Note: this prop is experimental. Specifies how image coordinates should be geographically interpreted. By default, the image is uniformly stretched to fill the geometry defined by  bounds . This might not be desirable if the image is encoded in a different coordinate system from the projection that the layer is using. For example, a  satellite image encoded in longitude/latitude  should not be interpreted linearly when placed in a Web Mercator visualization. This prop allows you to explicitly inform the layer of the coordinate system of the image: COORDINATE_SYSTEM.LNGLAT  if x-axis maps to longitude and y-axis maps to latitude COORDINATE_SYSTEM.CARTESIAN  if the image is pre-projected into the Web Mercator plane. This option only works with geospatial views and  bounds  that is orthogonal ( [left, bottom, right, top] ). See the article on  Coordinate Systems  for more information. Render Options desaturate  (Number)  Default  0 The desaturation of the bitmap. Between  [0, 1] .  0  being the original color and  1  being grayscale. transparentColor  (Array)  Default  [0, 0, 0, 0] The color to use for transparent pixels, in  [r, g, b, a] . Each component is in the  [0, 255]  range. tintColor  (Array)  Default  [255, 255, 255] The color to tint the bitmap by, in  [r, g, b] . Each component is in the  [0, 255]  range. Pixel Picking (From v8.4) The  picking info  passed to callbacks ( onHover ,  onClick , etc.) provides information on which pixel was picked. It contains an additional  bitmap  field if applicable: bitmap pixel  ( number, number )  Integer coordinates into the bitmap size  ({width: number; height: number})  Size of bitmap in pixels uv  ( number, number ) Normalized (0-1) floating point coordinates Note that the  bitmap  field can be  null  if on mouse leave or if the bitmap has not yet loaded. The following code reads the picked pixel color from the bitmap when the layer is clicked: Source modules/layers/src/bitmap-layer","headings":[{"value":"BitmapLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Data","depth":3},{"value":"image (String|Texture2D|Image|ImageData|HTMLCanvasElement|HTMLVideoElement|ImageBitmap|Promise|Object)","depth":5},{"value":"bounds (Array)","depth":5},{"value":"loadOptions (Object, optional)","depth":5},{"value":"textureParameters (Object)","depth":5},{"value":"_imageCoordinateSystem (Number, optional)","depth":5},{"value":"Render Options","depth":3},{"value":"desaturate (Number) transition-enabled","depth":5},{"value":"transparentColor (Array) transition-enabled","depth":5},{"value":"tintColor (Array) transition-enabled","depth":5},{"value":"Pixel Picking","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/bitmap-layer","title":"BitmapLayer"},{"excerpt":"ArcLayer The  ArcLayer  renders raised arcs joining pairs of source and target coordinates. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Render Options greatCircle  (Boolean, optional) Default:  false If  true , create the arc along the shortest path on the earth surface. This option is only effective with data in the  LNGLAT  coordinate system. widthUnits  (String, optional) Default:  'pixels' The units of the line width, one of  'meters' ,  'common' , and  'pixels' . See  unit system . widthScale  (Number, optional)  Default:  1 The scaling multiplier for the width of each line. This prop is a very efficient way to change the width of all objects, comparing to recalculating the width for each object with  getWidth . widthMinPixels  (Number, optional)  Default:  0 The minimum line width in pixels. This prop can be used to prevent the line from getting too thin when zoomed out. widthMaxPixels  (Number, optional)  Default:  Number.MAX_SAFE_INTEGER The maximum line width in pixels. This prop can be used to prevent the line from getting too thick when zoomed in. Data Accessors getSourcePosition  ( Function , optional)  Default:  object => object.sourcePosition Method called to retrieve the source position of each object. getTargetPosition  ( Function , optional)  Default:  object => object.targetPosition Method called to retrieve the target position of each object. getSourceColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the source color for all objects. If a function is provided, it is called on each object to retrieve its source color. getTargetColor  ( Function |Array, optional)  Default  [0, 0, 0, 255] The rgba color at the target, in  r, g, b, [a] . Each component is in the 0-255 range. If an array is provided, it is used as the target color for all objects. If a function is provided, it is called on each object to retrieve its target color. getWidth  ( Function |Number, optional)  Default:  1 The line width of each object, in units specified by  widthUnits  (default pixels). If a number is provided, it is used as the line width for all objects. If a function is provided, it is called on each object to retrieve its line width. getHeight  ( Function |Number, optional)  Default:  1 Multiplier of layer height.  0  will make the layer flat. getTilt  ( Function |Number, optional)  Default:  0 Use to tilt the arc to the side if you have multiple arcs with the same source and target positions.\nIn degrees, can be positive or negative ( -90 to +90 ). Source modules/layers/src/arc-layer","headings":[{"value":"ArcLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"greatCircle (Boolean, optional)","depth":5},{"value":"widthUnits (String, optional)","depth":5},{"value":"widthScale (Number, optional) transition-enabled","depth":5},{"value":"widthMinPixels (Number, optional) transition-enabled","depth":5},{"value":"widthMaxPixels (Number, optional) transition-enabled","depth":5},{"value":"Data Accessors","depth":3},{"value":"getSourcePosition (Function, optional) transition-enabled","depth":5},{"value":"getTargetPosition (Function, optional) transition-enabled","depth":5},{"value":"getSourceColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getTargetColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getWidth (Function|Number, optional) transition-enabled","depth":5},{"value":"getHeight (Function|Number, optional) transition-enabled","depth":5},{"value":"getTilt (Function|Number, optional) transition-enabled","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/arc-layer","title":"ArcLayer"},{"excerpt":"ColumnLayer This is the primitive layer rendered by  HexagonLayer  after aggregation. Unlike the HexagonLayer, it renders one column for each data object. The  ColumnLayer  renders extruded cylinders (tessellated regular polygons) at given coordinates. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Render Options diskResolution  (Number, optional) Default:  20 The number of sides to render the disk as. The disk is a regular polygon that fits inside the given radius. A higher resolution will yield a smoother look close-up, but also need more resources to render. radius  (Number, optional)  Default:  1000 Disk size in units specified by  radiusUnits  (default meters). angle  (Number, optional)  Default:  0 Disk rotation, counter-clockwise in degrees. vertices  (Array, optional) Replace the default geometry (regular polygon that fits inside the unit circle) with a custom one. The length of the array must be at least  diskResolution . Each vertex is a point  [x, y]  that is the offset from the instance position, relative to the radius. offset  ( Number, Number , optional)  Default:  [0, 0] Disk offset from the position, relative to the radius. By default, the disk is centered at each position. coverage  (Number, optional)  Default:  1 Radius multiplier, between 0 - 1. The radius of the disk is calculated by\n coverage * radius elevationScale  (Number, optional)  Default:  1 Column elevation multiplier. The elevation of column is calculated by\n elevationScale * getElevation(d) .  elevationScale  is a handy property\nto scale all column elevations without updating the data. filled  (Boolean, optional) Default:  true Whether to draw a filled column (solid fill). stroked  (Boolean, optional) Default:  false Whether to draw an outline around the disks. Only applies if  extruded: false . extruded  (Boolean, optional) Default:  true Whether to extrude the columns. If set to  false , all columns will be rendered as flat polygons. wireframe  (Boolean, optional) Default:  false Whether to generate a line wireframe of the column. The outline will have\n\"horizontal\" lines closing the top and bottom polygons and a vertical line\n(a \"strut\") for each vertex around the disk. Only applies if  extruded: true . flatShading  (Boolean, optional) Default:  false If  true , the vertical surfaces of the columns use  flat shading .\nIf  false , use smooth shading. Only effective if  extruded  is  true . radiusUnits  (String, optional) Default:  'meters' The units of the radius, one of  'meters' ,  'common' , and  'pixels' . See  unit system . lineWidthUnits  (String, optional) Default:  'meters' The units of the line width, one of  'meters' ,  'common' , and  'pixels' . See  unit system . lineWidthScale  (Boolean, optional)  Default:  1 The line width multiplier that multiplied to all outlines if the  stroked  attribute is  true . lineWidthMinPixels  (Number, optional)  Default:  0 The minimum outline width in pixels. lineWidthMaxPixels  (Number, optional)  Default: Number.MAX_SAFE_INTEGER The maximum outline width in pixels. material  (Object, optional) Default:  true This is an object that contains material props for  lighting effect  applied on extruded polygons. Check  the lighting guide  for configurable settings. Data Accessors getPosition  ( Function , optional)  Default:  object => object.position Method called to retrieve the position of each column, in  [x, y] . An optional third component can be used to set the elevation of the bottom. getFillColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the color for all objects. If a function is provided, it is called on each object to retrieve its color. If not provided, it falls back to  getColor . getLineColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the outline color for all columns. If a function is provided, it is called on each object to retrieve its outline color. If not provided, it falls back to  getColor . getElevation  ( Function |Number, optional)  Default:  1000 The elevation of each cell in meters. If a number is provided, it is used as the elevation for all objects. If a function is provided, it is called on each object to retrieve its elevation. getLineWidth  ( Function |Number, optional)  Default:  1 The width of the outline of the column, in units specified by  lineWidthUnits  (default meters). Only applies if  extruded: false  and  stroked: true . If a number is provided, it is used as the outline width for all columns. If a function is provided, it is called on each object to retrieve its outline width. Source modules/layers/src/column-layer","headings":[{"value":"ColumnLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"diskResolution (Number, optional)","depth":5},{"value":"radius (Number, optional) transition-enabled","depth":5},{"value":"angle (Number, optional) transition-enabled","depth":5},{"value":"vertices (Array, optional)","depth":5},{"value":"offset (Number, Number, optional) transition-enabled","depth":5},{"value":"coverage (Number, optional) transition-enabled","depth":5},{"value":"elevationScale (Number, optional) transition-enabled","depth":5},{"value":"filled (Boolean, optional)","depth":5},{"value":"stroked (Boolean, optional)","depth":5},{"value":"extruded (Boolean, optional)","depth":5},{"value":"wireframe (Boolean, optional)","depth":5},{"value":"flatShading (Boolean, optional)","depth":5},{"value":"radiusUnits (String, optional)","depth":5},{"value":"lineWidthUnits (String, optional)","depth":5},{"value":"lineWidthScale (Boolean, optional) transition-enabled","depth":5},{"value":"lineWidthMinPixels (Number, optional) transition-enabled","depth":5},{"value":"lineWidthMaxPixels (Number, optional) transition-enabled","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional) transition-enabled","depth":5},{"value":"getFillColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getLineColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getElevation (Function|Number, optional) transition-enabled","depth":5},{"value":"getLineWidth (Function|Number, optional) transition-enabled","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/column-layer","title":"ColumnLayer"},{"excerpt":"GridCellLayer This is the primitive layer rendered by  CPUGridLayer  after aggregation. Unlike the CPUGridLayer, it renders one column for each data object. The  GridCellLayer  can render a grid-based heatmap.\nIt is a variation of the  ColumnLayer .\nIt takes the constant width / height of all cells and bottom-left coordinate of\neach cell. The grid cells can be given a height using the  getElevation  accessor. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Render Options cellSize  (Number, optional)  Default:  1000 Size of each grid cell in meters coverage  (Number, optional)  Default:  1 Cell size scale factor. The size of cell is calculated by\n cellSize * coverage . elevationScale  (Number, optional)  Default:  1 Elevation multiplier. The elevation of cell is calculated by\n elevationScale * getElevation(d) .  elevationScale  is a handy property\nto scale all cell elevations without updating the data. extruded  (Boolean, optional) Default:  true Whether to enable grid elevation. If set to false, all grid will be flat. material  (Object, optional) Default:  true This is an object that contains material props for  lighting effect  applied on extruded polygons.\nCheck  the lighting guide  for configurable settings. Data Accessors getPosition  ( Function , optional)  Default:  x => x.position Method called to retrieve the bottom-left corner ( [minX, minY] ) of each cell. getColor  ( Function |Array, optional)  Default:  [255, 0, 255, 255] The rgba color of each object, in  r, g, b, [a] . Each component is in the 0-255 range. If an array is provided, it is used as the color for all objects. If a function is provided, it is called on each object to retrieve its color. getElevation  ( Function |Number, optional)  Default:  1000 The elevation of each cell in meters. If a number is provided, it is used as the elevation for all objects. If a function is provided, it is called on each object to retrieve its elevation. Source modules/layers/src/grid-cell-layer","headings":[{"value":"GridCellLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"cellSize (Number, optional) transition-enabled","depth":5},{"value":"coverage (Number, optional) transition-enabled","depth":5},{"value":"elevationScale (Number, optional) transition-enabled","depth":5},{"value":"extruded (Boolean, optional)","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional) transition-enabled","depth":5},{"value":"getColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getElevation (Function|Number, optional) transition-enabled","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/grid-cell-layer","title":"GridCellLayer"},{"excerpt":"IconLayer The  IconLayer  renders raster icons at given coordinates. There are two approaches to load icons. You can pre-generated a sprite image ( iconAtlas ), which packs all your icons\ninto one layout, and a JSON descriptor ( iconMapping ), which describes the position and size of each icon in the  iconAtlas .\nYou can create sprite images with tools such as  TexturePacker . This is the\nmost efficient way to load icons. It is also possible to ask  IconLayer  to generate  iconAtlas  dynamically. This is slower but might be useful in certain\nuse cases. Example: pre-packed iconAtlas Example: auto packing iconAtlas In some use cases, it is not possible to know the icons that will be used. Instead, each icon needs to be fetched from\na programmatically generated URL at runtime. For example, if you want to visualize avatars of github contributors for\na project on a map, it is not convenient for you to generate the  iconAtlas  with all the contributors' avatars.\nIn this case, you can follow the example. Auto packing icons is less efficient than pre-packed. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. iconAtlas  (String|Texture2D|Image|ImageData|HTMLCanvasElement|HTMLVideoElement|ImageBitmap|Promise|Object, optional) A pre-packed image that contains all icons. If a string is supplied, it is interpreted as a URL or a  Data URL . One of the following, or a Promise that resolves to one of the following: One of the valid  pixel sources for WebGL texture A luma.gl  Texture2D  instance A plain object that can be passed to the  Texture2D  constructor, e.g.  {width: <number>, height: <number>, data: <Uint8Array>} . Note that whenever this object shallowly changes, a new texture will be created. The image data will be converted to a  Texture2D  object. See  textureParameters  prop for advanced customization. If you go with pre-packed strategy, this prop is required. If you choose to use auto packing, this prop should be left empty. iconMapping  (Object|String, optional) Icon names mapped to icon definitions, or a URL to load such mapping from a JSON file. Each icon is defined with the following values: x  (Number, required): x position of icon on the atlas image y  (Number, required): y position of icon on the atlas image width  (Number, required): width of icon on the atlas image height  (Number, required): height of icon on the atlas image anchorX  (Number, optional): horizontal position of icon anchor. Default: half width. anchorY  (Number, optional): vertical position of icon anchor. Default: half height. mask  (Boolean, optional): whether icon is treated as a transparency mask.\nIf  true , user defined color is applied.\nIf  false , pixel color from the image is applied. User still can specify the opacity through getColor.\nDefault:  false If you go with pre-packed strategy, this prop is required. If you choose to use auto packing, this prop should be left empty. sizeScale  (Number, optional)  Default:  1 Icon size multiplier. sizeUnits  (String, optional) Default:  pixels The units of the size, one of  'meters' ,  'common' , and  'pixels' . See  unit system . sizeMinPixels  (Number, optional)  Default:  0 The minimum size in pixels. When using non-pixel  sizeUnits , this prop can be used to prevent the icon from getting too small when zoomed out. sizeMaxPixels  (Number, optional)  Default:  Number.MAX_SAFE_INTEGER The maximum size in pixels. When using non-pixel  sizeUnits , this prop can be used to prevent the icon from getting too big when zoomed in. billboard  (Boolean, optional) Default:  true If  true , the icon always faces camera. Otherwise the icon faces up (z). alphaCutoff  (Number, optional) Default:  0.05 Discard pixels whose opacity is below this threshold. A discarded pixel would create a \"hole\" in the icon that is not considered part of the object. This is useful for customizing picking behavior, e.g. setting  alphaCutoff: 0, autoHighlight  will highlight an object whenever the cursor moves into its bounding box, instead of over the visible pixels. loadOptions  (Object, optional) On top of the  default options , also accepts options for the following loaders: ImageLoader  if the  iconAtlas  prop is an URL, or if  getIcon  returns URLs for auto-packing textureParameters  (Object) Customize the  texture parameters . If not specified, the layer uses the following defaults to create a linearly smoothed texture from  iconAtlas : Data Accessors getIcon  ( Function , optional) Default:  d => d.icon Method called to retrieve the icon name of each object, returns string or object. If you go with pre-packed strategy, then  getIcon  should return a string representing name of the icon,\nused to retrieve icon definition from given  iconMapping . If you choose to use auto packing, then  getIcon  should return an object which contains\nthe following properties. url  (String, required): url to fetch the icon height  (Number, required): height of icon width  (Number, required): width of icon id : (String, optional): unique identifier of the icon, fall back to  url  if not specified anchorX ,  anchorY ,  mask  are the same as mentioned in  iconMapping IconLayer  use  id  (fallback to  url ) to dedupe icons. If for the same icon identifier,  getIcon  returns different  width  or  height ,  IconLayer  will only apply the first occurrence and ignore the rest of them. getPosition  ( Function , optional)  Default:  d => d.position Method called to retrieve the position of each object, returns  [lng, lat, z] . getSize  ( Function |Number, optional)  Default:  1 The height of each object, in units specified by  sizeUnits  (default pixels). If a number is provided, it is used as the size for all objects. If a function is provided, it is called on each object to retrieve its size. getColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the color for all objects. If a function is provided, it is called on each object to retrieve its color. If  mask  = false, only the alpha component will be used to control the opacity of the icon. getAngle  ( Function |Number, optional)  Default:  0 The rotating angle  of each object, in degrees. If a number is provided, it is used as the angle for all objects. If a function is provided, it is called on each object to retrieve its angle. getPixelOffset  ( Function |Array, optional)  Default:  [0, 0] Screen space offset relative to the  coordinates  in pixel unit. If an array is provided, it is used as the offset for all objects. If a function is provided, it is called on each object to retrieve its offset. Callbacks onIconError  (Function) Default:  null Only used when using auto-packing. If the attempt to fetch an icon returned by  getIcon  fails, this callback is called with the following arguments: event  (Object) url  (String) - the URL that was trying to fetch loadOptions  (Object) - the load options used for the fetch source  (Object) - the original data object that requested this icon sourceIndex  (Object) - the index of the original data object that requested this icon error  (Error) Use binary attributes This section is about the special requirements when  supplying attributes directly  to an  IconLayer . If  data.attributes.getIcon  is supplied, since its value can only be a typed array,  iconMapping  can only use integers as keys. Source modules/layers/src/icon-layer","headings":[{"value":"IconLayer","depth":1},{"value":"Example: pre-packed iconAtlas","depth":2},{"value":"Example: auto packing iconAtlas","depth":2},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"iconAtlas (String|Texture2D|Image|ImageData|HTMLCanvasElement|HTMLVideoElement|ImageBitmap|Promise|Object, optional)","depth":5},{"value":"iconMapping (Object|String, optional)","depth":5},{"value":"sizeScale (Number, optional) transition-enabled","depth":5},{"value":"sizeUnits (String, optional)","depth":5},{"value":"sizeMinPixels (Number, optional) transition-enabled","depth":5},{"value":"sizeMaxPixels (Number, optional) transition-enabled","depth":5},{"value":"billboard (Boolean, optional)","depth":5},{"value":"alphaCutoff (Number, optional)","depth":5},{"value":"loadOptions (Object, optional)","depth":5},{"value":"textureParameters (Object)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getIcon (Function, optional)","depth":5},{"value":"getPosition (Function, optional) transition-enabled","depth":5},{"value":"getSize (Function|Number, optional) transition-enabled","depth":5},{"value":"getColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getAngle (Function|Number, optional) transition-enabled","depth":5},{"value":"getPixelOffset (Function|Array, optional) transition-enabled","depth":5},{"value":"Callbacks","depth":3},{"value":"onIconError (Function)","depth":5},{"value":"Use binary attributes","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/icon-layer","title":"IconLayer"},{"excerpt":"GeoJsonLayer The  GeoJsonLayer  renders  GeoJSON  formatted data as polygons, lines and points (circles, icons and/or texts). GeoJsonLayer  is a  CompositeLayer . See the  sub layers  that it renders. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  and  CompositeLayer  properties. data The  GeoJSONLayer  accepts any of the following formats passed to the  data  prop: A valid GeoJSON  FeatureCollection ,  Feature ,  Geometry  or  GeometryCollection  object. An array of GeoJSON  Feature  objects. An URL or Promise that resolves to the above formats. loaders.gl's  flat GeoJSON format . pointType  (String, optional) Default:  'circle' How to render  Point  and  MultiPoint  features in the data. Supported types are: circle icon text To use more than one type, join the names with  + , for example  pointType: 'icon+text' . Fill Options The following props control the solid fill of  Polygon  and  MultiPolygon \nfeatures, and the  Point  and  MultiPoint  features if  pointType  is  'circle' . filled  (Boolean, optional) Default:  true Whether to draw filled polygons (solid fill) and points (circles). Note that for each polygon,\nonly the area between the outer polygon and any holes will be filled. This\nprop is effective only when the polygon is NOT extruded. getFillColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The solid color of the polygon and points (circles).\nFormat is  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the fill color for all features. If a function is provided, it is called on each feature to retrieve its fill color. Stroke Options The following props control the  LineString  and  MultiLineString  features,\nthe outline for  Polygon  and  MultiPolygon  features, and the outline for  Point  and  MultiPoint  features if  pointType  is  'circle' . stroked  (Boolean, optional) Default:  true Whether to draw an outline around polygons and points (circles). Note that\nfor complex polygons, both the outer polygon as well the outlines of\nany holes will be drawn. getLineColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color of a line is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the line color for all features. If a function is provided, it is called on each feature to retrieve its line color. getLineWidth  ( Function |Number, optional)  Default:  1 The width of a line, in units specified by  lineWidthUnits  (default meters). If a number is provided, it is used as the line width for all features. If a function is provided, it is called on each feature to retrieve its line width. lineWidthUnits  (String, optional) Default:  'meters' The units of the line width, one of  'meters' ,  'common' , and  'pixels' . See  unit system . lineWidthScale  (Number, optional)  Default:  1 A multiplier that is applied to all line widths. lineWidthMinPixels  (Number, optional)  Default:  0 The minimum line width in pixels. This prop can be used to prevent the line from getting too thin when zoomed out. lineWidthMaxPixels  (Number, optional)  Default: Number.MAX_SAFE_INTEGER The maximum line width in pixels. This prop can be used to prevent the line from getting too thick when zoomed in. lineCapRounded  (Boolean, optional) Default:  false Type of line caps. If  true , draw round caps. Otherwise draw square caps. lineJointRounded  (Boolean, optional) Default:  false Type of line joint. If  true , draw round joints. Otherwise draw miter joints. lineMiterLimit  (Number, optional)  Default:  4 The maximum extent of a joint in ratio to the stroke width.\nOnly works if  lineJointRounded  is  false . lineBillboard  (Boolean, optional) Default:  false If  true , extrude the line in screen space (width always faces the camera).\nIf  false , the width always faces up. 3D Options The following props control the extrusion of  Polygon  and  MultiPolygon  features. extruded  (Boolean, optional) Extrude Polygon and MultiPolygon features along the z-axis if set to\ntrue. The height of the drawn features is obtained using the  getElevation  accessor. Default:  false wireframe  (Boolean, optional) Default:  false Whether to generate a line wireframe of the hexagon. The outline will have\n\"horizontal\" lines closing the top and bottom polygons and a vertical line\n(a \"strut\") for each vertex on the polygon. Remarks: These lines are rendered with  GL.LINE  and will thus always be 1 pixel wide. Wireframe and solid extrusions are exclusive, you'll need to create two layers\nwith the same data if you want a combined rendering effect. This is only effective if the  extruded  prop is set to true. getElevation  ( Function |Number, optional)  Default:  1000 The elevation of a polygon feature (when  extruded  is true). If a cartographic projection mode is used, height will be interpreted as meters,\notherwise will be in unit coordinates. If a number is provided, it is used as the elevation for all polygon features. If a function is provided, it is called on each polygon feature to retrieve its elevation. elevationScale  (Number, optional)  Default:  1 Elevation multiplier. The final elevation is calculated by\n   elevationScale * getElevation(d) .  elevationScale  is a handy property to scale\nall polygon elevation without updating the data. material  (Object, optional) Default:  true This is an object that contains material props for  lighting effect  applied on extruded polygons.\nCheck  the lighting guide  for configurable settings. pointType:circle Options The following props are forwarded to a  ScatterplotLayer  if  pointType  is  'circle' . Prop name Default value ScatterplotLayer equivalent getPointRadius 1 getRadius pointRadiusUnits 'meters' radiusUnits pointRadiusScale 1 radiusScale pointRadiusMinPixels 0 radiusMinPixels pointRadiusMaxPixels Number.MAX_SAFE_INTEGER radiusMaxPixels pointAntialiasing true antialiasing pointBillboard false billboard pointType:icon Options The following props are forwarded to an  IconLayer  if  pointType  is  'icon' . Prop name Default value IconLayer equivalent iconAtlas null iconAtlas iconMapping {} iconMapping getIcon f => f.properties.icon getIcon getIconSize 1 getSize getIconColor [0, 0, 0, 255] getColor getIconAngle 0 getAngle getIconPixelOffset [0, 0] getPixelOffset iconSizeUnits 'pixels' sizeUnits iconSizeScale 1 sizeScale iconSizeMinPixels 0 sizeMinPixels iconSizeMaxPixels Number.MAX_SAFE_INTEGER sizeMaxPixels iconBillboard true billboard iconAlphaCutoff 0.05 alphaCutoff pointType:text Options The following props are forwarded to a  TextLayer  if  pointType  is  'text' . Prop name Default value TextLayer equivalent getText f => f.properties.text getText getTextColor [0, 0, 0, 255] getColor getTextAngle 0 getAngle getTextSize 32 getSize getTextAnchor 'middle' getTextAnchor getTextAlignmentBaseline 'center' getAlignmentBaseline getTextPixelOffset [0, 0] getPixelOffset getTextBackgroundColor [255, 255, 255, 255] getBackgroundColor getTextBorderColor [0, 0, 0, 255] getBorderColor getTextBorderWidth 0 getBorderWidth textSizeUnits 'pixels' sizeUnits textSizeScale 1 sizeScale textSizeMinPixels 0 sizeMinPixels textSizeMaxPixels Number.MAX_SAFE_INTEGER sizeMaxPixels textCharacterSet ASCII chars 32-128 characterSet textFontFamily 'Monaco, monospace' fontFamily textFontWeight 'normal' fontWeight textLineHeight 1 lineHeight textMaxWidth -1 maxWidth textWordBreak 'break-word' wordBreak textBackground false background textBackgroundPadding [0, 0] backgroundPadding textOutlineColor [0, 0, 0, 255] outlineColor textOutlineWidth 0 outlineWidth textBillboard true billboard textFontSettings {} fontSettings Sub Layers The GeoJsonLayer renders the following sublayers: polygons-fill  - a  SolidPolygonLayer  rendering all the  Polygon  and  MultiPolygon  features. polygons-stroke  - a  PathLayer  rendering the outline of all the  Polygon  and  MultiPolygon  features. Only rendered if  stroked: true  and  extruded: false . linestrings  - a  PathLayer  rendering all the  LineString  and  MultiLineString  features. points-circle  - a  ScatterplotLayer  rendering all the  Point  and  MultiPoint  features if  pointType  is  'circle' . points-icon  - an  IconLayer  rendering all the  Point  and  MultiPoint  features if  pointType  is  'icon' . points-text  - a  TextLayer  rendering all the  Point  and  MultiPoint  features if  pointType  is  'text' . Remarks Geometry transition can be enabled with  props.transitions: {geometry: <transition_settings>} . Input data must adhere to the  GeoJSON specification . Most GIS software support exporting to GeoJSON format. You may validate your data with free tools such as  this . The GeoJsonLayer renders 3D geometries if each feature's  coordinates  contain 3D points. Source modules/layers/src/geojson-layer","headings":[{"value":"GeoJsonLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"data","depth":5},{"value":"pointType (String, optional)","depth":5},{"value":"Fill Options","depth":3},{"value":"filled (Boolean, optional)","depth":5},{"value":"getFillColor (Function|Array, optional) transition-enabled","depth":5},{"value":"Stroke Options","depth":3},{"value":"stroked (Boolean, optional)","depth":5},{"value":"getLineColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getLineWidth (Function|Number, optional) transition-enabled","depth":5},{"value":"lineWidthUnits (String, optional)","depth":5},{"value":"lineWidthScale (Number, optional) transition-enabled","depth":5},{"value":"lineWidthMinPixels (Number, optional) transition-enabled","depth":5},{"value":"lineWidthMaxPixels (Number, optional) transition-enabled","depth":5},{"value":"lineCapRounded (Boolean, optional)","depth":5},{"value":"lineJointRounded (Boolean, optional)","depth":5},{"value":"lineMiterLimit (Number, optional) transition-enabled","depth":5},{"value":"lineBillboard (Boolean, optional)","depth":5},{"value":"3D Options","depth":3},{"value":"extruded (Boolean, optional)","depth":5},{"value":"wireframe (Boolean, optional)","depth":5},{"value":"getElevation (Function|Number, optional) transition-enabled","depth":5},{"value":"elevationScale (Number, optional) transition-enabled","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"pointType:circle Options","depth":3},{"value":"pointType:icon Options","depth":3},{"value":"pointType:text Options","depth":3},{"value":"Sub Layers","depth":2},{"value":"Remarks","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/geojson-layer","title":"GeoJsonLayer"},{"excerpt":"LineLayer The  LineLayer  renders straight lines joining pairs of source and target coordinates. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Render Options The width used to draw each line. Unit is pixels. widthUnits  (String, optional) Default:  'pixels' The units of the line width, one of  'meters' ,  'common' , and  'pixels' . See  unit system . widthScale  (Number, optional)  Default:  1 The scaling multiplier for the width of each line. This prop is a very efficient way to change the width of all objects, comparing to recalculating the width for each object with  getWidth . widthMinPixels  (Number, optional)  Default:  0 The minimum line width in pixels. This prop can be used to prevent the line from getting to thin when zoomed out. widthMaxPixels  (Number, optional)  Default:  Number.MAX_SAFE_INTEGER The maximum line width in pixels. This prop can be used to prevent the line from getting to thick when zoomed in. Data Accessors getSourcePosition  ( Function , optional)  Default:  object => object.sourcePosition Method called to retrieve the source position of each object. getTargetPosition  ( Function , optional)  Default:  object => object.targetPosition Method called to retrieve the target position of each object. getColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the color for all objects. If a function is provided, it is called on each object to retrieve its color. getWidth  ( Function |Number, optional)  Default:  1 The line width of each object, in units specified by  widthUnits  (default pixels). If a number is provided, it is used as the line width for all objects. If a function is provided, it is called on each object to retrieve its line width. Source modules/layers/src/line-layer","headings":[{"value":"LineLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"widthUnits (String, optional)","depth":5},{"value":"widthScale (Number, optional) transition-enabled","depth":5},{"value":"widthMinPixels (Number, optional) transition-enabled","depth":5},{"value":"widthMaxPixels (Number, optional) transition-enabled","depth":5},{"value":"Data Accessors","depth":3},{"value":"getSourcePosition (Function, optional) transition-enabled","depth":5},{"value":"getTargetPosition (Function, optional) transition-enabled","depth":5},{"value":"getColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getWidth (Function|Number, optional) transition-enabled","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/line-layer","title":"LineLayer"},{"excerpt":"PathLayer The  PathLayer  renders lists of coordinate points as extruded polylines with mitering. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Render Options widthUnits  (String, optional) Default:  'meters' The units of the line width, one of  'meters' ,  'common' , and  'pixels' . See  unit system . widthScale  (Number, optional)  Default:  1 The path width multiplier that multiplied to all paths. widthMinPixels  (Number, optional)  Default:  0 The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out. widthMaxPixels  (Number, optional)  Default: Number.MAX_SAFE_INTEGER The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in. capRounded  (Boolean, optional) Default:  false Type of caps. If  true , draw round caps. Otherwise draw square caps. jointRounded  (Boolean, optional) Default:  false Type of joint. If  true , draw round joints. Otherwise draw miter joints. billboard  (Boolean, optional) Default:  false If  true , extrude the path in screen space (width always faces the camera).\nIf  false , the width always faces up. miterLimit  (Number, optional)  Default:  4 The maximum extent of a joint in ratio to the stroke width.\nOnly works if  jointRounded  is  false . _pathType  (Object, optional) Default:  null Note: This prop is experimental One of  null ,  'loop'  or  'open' . If  'loop'  or  'open' , will skip normalizing the coordinates returned by  getPath  and instead assume all paths are to be loops or open paths. Disabling normalization improves performance during data update, but makes the layer prone to error in case the data is malformed. It is only recommended when you use this layer with preprocessed static data or validation on the backend. When normalization is disabled, paths must be specified in the format of flat array. Open paths must contain at least 2 vertices and closed paths must contain at least 3 vertices. See  getPath  below for details. Data Accessors getPath  ( Function , optional)  Default:  object => object.path Called on each object in the  data  stream to retrieve its corresponding path. A path can be one of the following formats: An array of points ( [x, y, z] ). Compatible with the GeoJSON  LineString  specification. A flat array or  TypedArray  of numbers, in the shape of  [x0, y0, z0, x1, y1, z1, ...] . By default, each coordinate is assumed to contain 3 consecutive numbers. If each coordinate contains only two numbers (x, y), set the  positionFormat  prop of the layer to  XY : getColor  ( Function |Array, optional)  Default  [0, 0, 0, 255] The rgba color of each object, in  r, g, b, [a] . Each component is in the 0-255 range. If an array is provided, it is used as the color for all objects. If a function is provided, it is called on each object to retrieve its color. getWidth  ( Function |Number, optional)  Default:  1 The width of each path, in units specified by  widthUnits  (default meters). If a number is provided, it is used as the width for all paths. If a function is provided, it is called on each path to retrieve its width. Use binary attributes This section is about the special requirements when  supplying attributes directly  to a  PathLayer . Because each path has a different number of vertices, when  data.attributes.getPath  is supplied, the layer also requires an array  data.startIndices  that describes the vertex index at the start of each path. For example, if there are 3 paths of 2, 3, and 4 vertices each,  startIndices  should be  [0, 2, 5, 9] . Additionally, all other attributes ( getColor ,  getWidth , etc.), if supplied, must contain the same layout (number of vertices) as the  getPath  buffer. To truly realize the performance gain from using binary data, the app likely wants to skip all data processing in this layer. Specify the  _pathType  prop to skip normalization. Example use case: Convert to using binary attributes: Source modules/layers/src/path-layer","headings":[{"value":"PathLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"widthUnits (String, optional)","depth":5},{"value":"widthScale (Number, optional) transition-enabled","depth":5},{"value":"widthMinPixels (Number, optional) transition-enabled","depth":5},{"value":"widthMaxPixels (Number, optional) transition-enabled","depth":5},{"value":"capRounded (Boolean, optional)","depth":5},{"value":"jointRounded (Boolean, optional)","depth":5},{"value":"billboard (Boolean, optional)","depth":5},{"value":"miterLimit (Number, optional) transition-enabled","depth":5},{"value":"_pathType (Object, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPath (Function, optional) transition-enabled","depth":5},{"value":"getColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getWidth (Function|Number, optional) transition-enabled","depth":5},{"value":"Use binary attributes","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/path-layer","title":"PathLayer"},{"excerpt":"PointCloudLayer The  PointCloudLayer  renders a point cloud with 3D positions, normals and colors. loaders.gl  offers a  category  of loaders for loading point clouds from standard formats. For example, the following code adds support for LAS/LAZ files: Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Render Options sizeUnits  (String, optional) Default:  'pixels' The units of the point size, one of  'meters' ,  'common' , and  'pixels' . See  unit system . pointSize  (Number, optional)  Default:  10 Global radius of all points, in units specified by  sizeUnits  (default pixels). material  (Object, optional) Default:  true This is an object that contains material props for  lighting effect  applied on extruded polygons.\nCheck  the lighting guide  for configurable settings. Data Accessors getPosition  ( Function , optional)  Default:  object => object.position Method called to retrieve the position of each object. getNormal  ( Function |Array, optional)  Default:  [0, 0, 1] The normal of each object, in  [nx, ny, nz] . If an array is provided, it is used as the normal for all objects. If a function is provided, it is called on each object to retrieve its normal. getColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the color for all objects. If a function is provided, it is called on each object to retrieve its color. Source modules/layers/src/point-cloud-layer","headings":[{"value":"PointCloudLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"sizeUnits (String, optional)","depth":5},{"value":"pointSize (Number, optional) transition-enabled","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional) transition-enabled","depth":5},{"value":"getNormal (Function|Array, optional) transition-enabled","depth":5},{"value":"getColor (Function|Array, optional) transition-enabled","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/point-cloud-layer","title":"PointCloudLayer"},{"excerpt":"ScatterplotLayer The  ScatterplotLayer  renders circles at given coordinates. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Render Options radiusUnits  (String, optional)  Default:  'meters' The units of the radius, one of  'meters' ,  'common' , and  'pixels' . See  unit system . radiusScale  (Number, optional)  Default:  1 A global radius multiplier for all points. lineWidthUnits  (String, optional)  Default:  'meters' The units of the line width, one of  'meters' ,  'common' , and  'pixels' . See  unit system . lineWidthScale  (Number, optional)  Default:  1 A global line width multiplier for all points. stroked  (Boolean, optional) Default:  false Draw the outline of points. filled  (Boolean, optional) Default:  true Draw the filled area of points. radiusMinPixels  (Number, optional)  Default:  0 The minimum radius in pixels. This prop can be used to prevent the circle from getting too small when zoomed out. radiusMaxPixels  (Number, optional)  Default:  Number.MAX_SAFE_INTEGER The maximum radius in pixels. This prop can be used to prevent the circle from getting too big when zoomed in. lineWidthMinPixels  (Number, optional)  Default:  0 The minimum line width in pixels. This prop can be used to prevent the stroke from getting too thin when zoomed out. lineWidthMaxPixels  (Number, optional)  Default:  Number.MAX_SAFE_INTEGER The maximum line width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in. billboard  (Boolean, optional) Default:  false If  true , rendered circles always face the camera. If  false  circles face up (i.e. are parallel with the ground plane). antialiasing  (Boolean, optional) Default:  true If  true , circles are rendered with smoothed edges. If  false , circles are rendered with rough edges. Antialiasing can cause artifacts on edges of overlapping circles. Also, antialiasing isn't supported in FirstPersonView.  Data Accessors getPosition  ( Function , optional)  Default:  object => object.position Method called to retrieve the position of each object. getRadius  ( Function |Number, optional)  Default:  1 The radius of each object, in units specified by  radiusUnits  (default meters). If a number is provided, it is used as the radius for all objects. If a function is provided, it is called on each object to retrieve its radius. getColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the color for all objects. If a function is provided, it is called on each object to retrieve its color. It will be overridden by  getLineColor  and  getFillColor  if these new accessors are specified. getFillColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the filled color for all objects. If a function is provided, it is called on each object to retrieve its color. If not provided, it falls back to  getColor . getLineColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the outline color for all objects. If a function is provided, it is called on each object to retrieve its color. If not provided, it falls back to  getColor . getLineWidth  ( Function |Number, optional)  Default:  1 The width of the outline of each object, in units specified by  lineWidthUnits  (default meters). If a number is provided, it is used as the outline width for all objects. If a function is provided, it is called on each object to retrieve its outline width. If not provided, it falls back to  strokeWidth . Source modules/layers/src/scatterplot-layer","headings":[{"value":"ScatterplotLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"radiusUnits (String, optional) transition-enabled","depth":5},{"value":"radiusScale (Number, optional) transition-enabled","depth":5},{"value":"lineWidthUnits (String, optional) transition-enabled","depth":5},{"value":"lineWidthScale (Number, optional) transition-enabled","depth":5},{"value":"stroked (Boolean, optional)","depth":5},{"value":"filled (Boolean, optional)","depth":5},{"value":"radiusMinPixels (Number, optional) transition-enabled","depth":5},{"value":"radiusMaxPixels (Number, optional) transition-enabled","depth":5},{"value":"lineWidthMinPixels (Number, optional) transition-enabled","depth":5},{"value":"lineWidthMaxPixels (Number, optional) transition-enabled","depth":5},{"value":"billboard (Boolean, optional)","depth":5},{"value":"antialiasing (Boolean, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional) transition-enabled","depth":5},{"value":"getRadius (Function|Number, optional) transition-enabled","depth":5},{"value":"getColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getFillColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getLineColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getLineWidth (Function|Number, optional) transition-enabled","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/scatterplot-layer","title":"ScatterplotLayer"},{"excerpt":"PolygonLayer The  PolygonLayer  renders filled, stroked and/or extruded polygons. PolygonLayer is a  CompositeLayer  that wraps around the  SolidPolygonLayer  and the  PathLayer . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  and  CompositeLayer  properties. Render Options filled  (Boolean, optional) Default:  true Whether to draw a filled polygon (solid fill). Note that only\nthe area between the outer polygon and any holes will be filled. stroked  (Boolean, optional) Default:  true Whether to draw an outline around the polygon (solid fill). Note that\nboth the outer polygon as well the outlines of any holes will be drawn. extruded  (Boolean, optional) Default:  false Whether to extrude the polygons (based on the elevations provided by the\n getElevation  accessor. If set to false, all polygons will be flat, this\ngenerates less geometry and is faster than simply returning  0  from  getElevation . wireframe  (Boolean, optional) Default:  false Whether to generate a line wireframe of the hexagon. The outline will have\n\"horizontal\" lines closing the top and bottom polygons and a vertical line\n(a \"strut\") for each vertex on the polygon. Requires the  extruded  prop to be true. elevationScale  (Number, optional)  Default:  1 Elevation multiplier. The final elevation is calculated by\n   elevationScale * getElevation(d) .  elevationScale  is a handy property to scale\nall elevation without updating the data. lineWidthUnits  (String, optional) Default:  'meters' The units of the line width, one of  'meters' ,  'common' , and  'pixels' . See  unit system . lineWidthScale  (Boolean, optional)  Default:  1 The line width multiplier that multiplied to all outlines of  Polygon  and  MultiPolygon \nfeatures if the  stroked  attribute is true. lineWidthMinPixels  (Number, optional)  Default:  0 The minimum line width in pixels. lineWidthMaxPixels  (Number, optional)  Default: Number.MAX_SAFE_INTEGER The maximum line width in pixels. lineJointRounded  (Boolean, optional) Default:  false Type of joint. If  true , draw round joints. Otherwise draw miter joints. lineMiterLimit  (Number, optional)  Default:  4 The maximum extent of a joint in ratio to the stroke width.\nOnly works if  lineJointRounded  is  false . material  (Object, optional) Default:  true This is an object that contains material props for  lighting effect  applied on extruded polygons.\nCheck  the lighting guide  for configurable settings. _normalize  (Object, optional) Default:  true Note: This prop is experimental If  false , will skip normalizing the coordinates returned by  getPolygon . Disabling normalization improves performance during data update, but makes the layer prone to error in case the data is malformed. It is only recommended when you use this layer with preprocessed static data or validation on the backend. When normalization is disabled, polygons must be specified in the format of flat array or  {positions, holeIndices} . Rings must be closed (i.e. the first and last vertices must be identical). The winding order of rings must be consistent with that defined by  _windingOrder . See  getPolygon  below for details. _windingOrder  (String, optional) Default:  'CW' Note: This prop is experimental This prop is only effective with  _normalize: false . It specifies the winding order of rings in the polygon data, one of: 'CW' : outer-ring is clockwise, and holes are counter-clockwise 'CCW' : outer-ring is counter-clockwise, and holes are clockwise The proper value depends on the source of your data. Most geometry formats  enforce a specific winding order . Incorrectly set winding order will cause  an extruded polygon's surfaces to be flipped, affecting culling and the lighting effect. Data Accessors getPolygon  ( Function , optional)  default:  object => object.polygon Called on each object in the  data  stream to retrieve its corresponding polygon. A polygon can be one of the following formats: An array of points ( [x, y, z] ) - a.k.a. a \"ring\". An array of rings. The first ring is the exterior boundary and the successive rings are the holes. Compatible with the GeoJSON  Polygon  specification. A flat array or  TypedArray  of coordinates, in the shape of  [x0, y0, z0, x1, y1, z1, ...] , is equivalent to a single ring. By default, each coordinate is assumed to contain 3 consecutive numbers. If each coordinate contains only two numbers (x, y), set the  positionFormat  prop of the layer to  XY . An object of shape  {positions, holeIndices} . positions  (Array|TypedArray) - a flat array of coordinates. By default, each coordinate is assumed to contain 3 consecutive numbers. If each coordinate contains only two numbers (x, y), set the  positionFormat  prop of the layer to  XY . holeIndices  (Array) - the starting index of each hole in the  positions  array. The first ring is the exterior boundary and the successive rings are the holes. If the optional third component  z  is supplied for a position, it specifies the altitude of the vertex: getFillColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the fill color for all polygons. If a function is provided, it is called on each polygon to retrieve its fill color. getLineColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the outline color for all polygons. If a function is provided, it is called on each polygon to retrieve its outline color. getLineWidth  ( Function |Number, optional)  Default:  1 The width of the outline of the polygon, in units specified by  lineWidthUnits  (default meters). Only applies if  extruded: false . If a number is provided, it is used as the outline width for all polygons. If a function is provided, it is called on each polygon to retrieve its outline width. getElevation  ( Function |Number, optional)  Default:  1000 The elevation to extrude each polygon with.\nIf a cartographic projection mode is used, height will be interpreted as meters,\notherwise will be in unit coordinates.\nOnly applies if  extruded: true . If a number is provided, it is used as the elevation for all polygons. If a function is provided, it is called on each polygon to retrieve its elevation. Note:  If 3D positions are returned by  getPolygon , the extrusion returned by  getElevation  is added to the base altitude of each vertex. Sub Layers The PolygonLayer renders the following sublayers: fill  - a  SolidPolygonLayer  rendering the surface of all polygons. stroke  - a  PathLayer  rendering the outline of all polygons. Only rendered if  stroked: true  and  extruded: false . Remarks Polygons are always closed, i.e. there is an implicit line segment between\nthe first and last vertices, when those vertices are not equal. The specification of complex polygons intentionally follows the GeoJson\nconventions for representing polygons with holes. Wireframe lines are rendered with  GL.LINE  and thus will always be 1 pixel wide. Wireframe and solid extrusions are exclusive, you'll need to create two layers\nwith the same data if you want a combined rendering effect. Source modules/layers/src/polygon-layer","headings":[{"value":"PolygonLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"filled (Boolean, optional)","depth":5},{"value":"stroked (Boolean, optional)","depth":5},{"value":"extruded (Boolean, optional)","depth":5},{"value":"wireframe (Boolean, optional)","depth":5},{"value":"elevationScale (Number, optional) transition-enabled","depth":5},{"value":"lineWidthUnits (String, optional)","depth":5},{"value":"lineWidthScale (Boolean, optional) transition-enabled","depth":5},{"value":"lineWidthMinPixels (Number, optional) transition-enabled","depth":5},{"value":"lineWidthMaxPixels (Number, optional) transition-enabled","depth":5},{"value":"lineJointRounded (Boolean, optional)","depth":5},{"value":"lineMiterLimit (Number, optional) transition-enabled","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"_normalize (Object, optional)","depth":5},{"value":"_windingOrder (String, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPolygon (Function, optional) transition-enabled","depth":5},{"value":"getFillColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getLineColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getLineWidth (Function|Number, optional) transition-enabled","depth":5},{"value":"getElevation (Function|Number, optional) transition-enabled","depth":5},{"value":"Sub Layers","depth":2},{"value":"Remarks","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/polygon-layer","title":"PolygonLayer"},{"excerpt":"TextLayer The  TextLayer  renders text labels at given coordinates. TextLayer is a  CompositeLayer  that wraps around the  IconLayer . It automatically creates an atlas texture from the specified font settings and  characterSet . Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  and  CompositeLayer  properties. Rendering Options sizeScale  (Number, optional)  Default: 1 Text size multiplier. sizeUnits  (String, optional) Default:  pixels The units of the size, one of  'meters' ,  'common' , and  'pixels' . See  unit system . sizeMinPixels  (Number, optional)  Default:  0 The minimum size in pixels. When using non-pixel  sizeUnits , this prop can be used to prevent the icon from getting too small when zoomed out. sizeMaxPixels  (Number, optional)  Default:  Number.MAX_SAFE_INTEGER The maximum size in pixels. When using non-pixel  sizeUnits , this prop can be used to prevent the icon from getting too big when zoomed in. billboard  (Boolean, optional) Default:  true If  true , the text always faces camera. Otherwise the text faces up (z). background  (Boolean, optional) Default  false Whether to render background for the text blocks. backgroundPadding  (Array, optional) Default  [0, 0, 0, 0] The padding of the background, an array of either 2 or 4 numbers. If an array of 2 is supplied, it is interpreted as  [padding_x, padding_y]  in pixels. If an array of 4 is supplied, it is interpreted as  [padding_left, padding_top, padding_right, padding_bottom]  in pixels. fontFamily  (String, optional) Default:  'Monaco, monospace' Specifies a prioritized list of one or more font family names and/or generic family names. Follow the specs for CSS  font-family . See the  remarks  section below for tips on using web fonts. characterSet  (Array | Set | String, optional) Default: ASCII characters 32-128 Specifies a list of characters to include in the font. If set to  'auto' , automatically detects the characters used in the data. This option has a performance overhead and may cause the layer to take longer to load if the data is very large. If set to an array or set of characters, the generated font will be limited to these characters. If you already know all the characters that are needed (e.g. numbers, latin alphabet), using this option provides better performance. If a character outside of the specified range is referenced by  getText , a warning will be logged to the JavaScript console. Note that there is a limit to the number of unique characters supported by a single layer. The maximum number subjects to  fontSettings.fontSize  and the  MAX_TEXTURE_SIZE  of the device/browser. fontWeight  (Number | String, optional) Default:  normal . css  font-weight . lineHeight  (Number, optional) Default:  1.0 . A unitless number that will be multiplied with the current font size to set the line height. fontSettings  (Object, optional) Advance options for fine tuning the appearance and performance of the generated shared  fontAtlas . Options: fontSize  (Number): Font size in pixels. Default is  64 . This option is only applied for generating  fontAtlas , it does not impact the size of displayed text labels. Larger  fontSize  will give you a sharper look when rendering text labels with very large font sizes. But larger  fontSize  requires more time and space to generate the  fontAtlas . buffer  (Number): Whitespace buffer around each side of the character. Default is  4 . In general, bigger  fontSize  requires bigger  buffer . Increase  buffer  will add more space between each character when layout  characterSet  in  fontAtlas . This option could be tuned to provide sufficient space for drawing each character and avoiding overlapping of neighboring characters. sdf  (Boolean): Flag to enable / disable  sdf . Default is  false .  sdf  (Signed Distance Fields)  will provide a sharper look when rendering with very large or small font sizes.  TextLayer  integrates with  TinySDF  which implements the  sdf  algorithm. radius  (Number): How many pixels around the glyph shape to use for encoding distance. Default is  12 . Bigger radius yields higher quality outcome. Only applies when  sdf: true . cutoff  (Number): How much of the radius (relative) is used for the inside part the glyph. Default is  0.25 . Bigger  cutoff  makes character thinner. Smaller  cutoff  makes character look thicker. Only applies when  sdf: true . smoothing  (Number): How much smoothing to apply to the text edges. Default  0.1 . Only applies when  sdf: true . wordBreak  (String, optional) Default:  break-word Available options are  break-all  and  break-word . A valid  maxWidth  has to be provided to use  wordBreak . maxWidth  (Number, optional) Default:  -1 maxWidth  is used together with  break-word  for wrapping text. The value of  maxWidth  specifies the width limit to break the text into multiple lines. outlineWidth  (Number, optional) Default:  0 Width of outline around the text, relative to the font size. Only effective if  fontSettings.sdf  is  true . outlineColor  (Array, optional) Default:  [0, 0, 0, 255] Color of outline around the text, in  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. Data Accessors getText  ( Function , optional) Default:  x => x.text Method called to retrieve the content of each text label. getPosition  ( Function , optional)  Default:  x => x.position Method called to retrieve the location of each text label. getSize  ( Function |Number, optional)  Default:  32 The font size of each text label, in units specified by  sizeUnits  (default pixels). If a number is provided, it is used as the size for all objects. If a function is provided, it is called on each object to retrieve its size. getColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the color for all objects. If a function is provided, it is called on each object to retrieve its color. getAngle  ( Function |Number, optional)  Default:  0 The rotating angle of each text label, in degrees. If a number is provided, it is used as the angle for all objects. If a function is provided, it is called on each object to retrieve its angle. getTextAnchor  ( Function |String, optional) Default:  'middle' The text anchor. Available options include  'start' ,  'middle'  and  'end' . If a string is provided, it is used as the text anchor for all objects. If a function is provided, it is called on each object to retrieve its text anchor. getAlignmentBaseline  ( Function |String, optional) Default:  'center' The alignment baseline. Available options include  'top' ,  'center'  and  'bottom' . If a string is provided, it is used as the alignment baseline for all objects. If a function is provided, it is called on each object to retrieve its alignment baseline. getPixelOffset  ( Function |Array, optional)  Default:  [0, 0] Screen space offset relative to the  coordinates  in pixel unit. If an array is provided, it is used as the offset for all objects. If a function is provided, it is called on each object to retrieve its offset. getBackgroundColor  ( Function |Array, optional)  Default:  [255, 255, 255, 255] The background color. Only effective if  background: true . The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the background color for all objects. If a function is provided, it is called on each object to retrieve its background color. getBorderColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The border color of the background. Only effective if  background: true . The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the border color for all objects. If a function is provided, it is called on each object to retrieve its border color. getBorderWidth  ( Function |Number, optional)  Default:  0 The border thickness of each text label, in pixels. Only effective if  background: true . If a number is provided, it is used as the border thickness for all objects. If a function is provided, it is called on each object to retrieve its border thickness. Sub Layers The TextLayer renders the following sublayers: characters  - an  IconLayer  rendering all the characters. background  - the background for each text block, if  background: true . Use binary attributes This section is about the special requirements when  supplying attributes directly  to a  TextLayer . Because each text string has a different number of characters, when  data.attributes.getText  is supplied, the layer also requires an array  data.startIndices  that describes the character index at the start of each text object. For example, if there are 3 text objects of 2, 3, and 4 characters each,  startIndices  should be  [0, 2, 5, 9] . Additionally, all other attributes ( getColor ,  getWidth , etc.), if supplied, must contain the same layout (number of characters) as the  getText  buffer. Example use case: Convert to using binary attributes: Use binary attributes with background To use  background: true  with binary data, the background attributes must be supplied separately via  data.attributes.background . Each attribute is packed with  one vertex  per object. data.attributes.background  may contain the following keys: getPosition : corresponds to the  getPosition  accessor getAngle : corresponds to the  getAngle  accessor getSize : corresponds to the  getSize  accessor getPixelOffset : corresponds to the  getPixelOffset  accessor getFillColor : corresponds to the  getBackgroundColor  accessor getLineColor : corresponds to the  getBorderColor  accessor getLineWidth : corresponds to the  getBorderWidth  accessor Following the above example, additional attributes are required to render the background: Remarks Use web fonts The  TextLayer  creates a font texture when it is first added with the  fillText  API. If the font specified by  fontFamily  is not loaded at this point, it will fall back to using the default font just like regular CSS behavior. The loading sequence may become an issue when a web font is used, due to  lazy loading . One way to force a web font to load before the script execution is to preload the font resource: Another way is to use the  FontFace  API to load a web font before adding the  TextLayer : Unicode support The TextLayer has full support for Unicode characters. To reference a Unicode character in JavaScript you can either use a string literal ( '日本語' ,  '©' ) or  escaped code point  ( '\\u{1F436}' ). At the moment this layer doesn't render multi-color emojis. Font Atlas Cache Limit To conserve memory, DeckGL caches the most 3 used  fontAtlas  by default. Creating a  fontAtlas  is a CPU intesive operation specially if  fontSettings.sdf  is set to  true . \nIf you are using much more than 3 fonts, you might experience perforamnce hits because DeckGL constantly tries to evict the least most used  fontAtlas  from cache and recreate them when needed. To mitigate the potential performance degradation, you can override the  fontAtlas  default cache limit by setting  TextLayer.fontAtlasCacheLimit  value: It is recommended to set  fontAtlasCacheLimit  once in your application since it recreates the cache which removes existing cached  fontAtals . Source modules/layers/src/text-layer","headings":[{"value":"TextLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Rendering Options","depth":3},{"value":"sizeScale (Number, optional) transition-enabled","depth":5},{"value":"sizeUnits (String, optional)","depth":5},{"value":"sizeMinPixels (Number, optional) transition-enabled","depth":5},{"value":"sizeMaxPixels (Number, optional) transition-enabled","depth":5},{"value":"billboard (Boolean, optional)","depth":5},{"value":"background (Boolean, optional)","depth":5},{"value":"backgroundPadding (Array, optional)","depth":5},{"value":"fontFamily (String, optional)","depth":5},{"value":"characterSet (Array | Set | String, optional)","depth":5},{"value":"fontWeight (Number | String, optional)","depth":5},{"value":"lineHeight (Number, optional)","depth":5},{"value":"fontSettings (Object, optional)","depth":5},{"value":"wordBreak (String, optional)","depth":5},{"value":"maxWidth (Number, optional)","depth":5},{"value":"outlineWidth (Number, optional)","depth":5},{"value":"outlineColor (Array, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getText (Function, optional)","depth":5},{"value":"getPosition (Function, optional) transition-enabled","depth":5},{"value":"getSize (Function|Number, optional) transition-enabled","depth":5},{"value":"getColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getAngle (Function|Number, optional) transition-enabled","depth":5},{"value":"getTextAnchor (Function|String, optional)","depth":5},{"value":"getAlignmentBaseline (Function|String, optional)","depth":5},{"value":"getPixelOffset (Function|Array, optional) transition-enabled","depth":5},{"value":"getBackgroundColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getBorderColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getBorderWidth (Function|Number, optional) transition-enabled","depth":5},{"value":"Sub Layers","depth":2},{"value":"Use binary attributes","depth":2},{"value":"Use binary attributes with background","depth":3},{"value":"Remarks","depth":2},{"value":"Use web fonts","depth":3},{"value":"Unicode support","depth":3},{"value":"Font Atlas Cache Limit","depth":3},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/text-layer","title":"TextLayer"},{"excerpt":"SolidPolygonLayer The  SolidPolygonLayer  renders filled and/or extruded polygons. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Render Options filled  (Boolean, optional) Default:  true Whether to fill the polygons (based on the color provided by the\n getFillColor  accessor. extruded  (Boolean, optional) Default:  false Whether to extrude the polygons (based on the elevations provided by the\n getElevation  accessor. If set to false, all polygons will be flat, this\ngenerates less geometry and is faster than simply returning  0  from  getElevation . wireframe  (Boolean, optional) Default:  false Whether to generate a line wireframe of the polygon. The outline will have\n\"horizontal\" lines closing the top and bottom polygons and a vertical line\n(a \"strut\") for each vertex on the polygon. elevationScale  (Number, optional)  Default:  1 Elevation multiplier. The final elevation is calculated by\n   elevationScale * getElevation(d) .  elevationScale  is a handy property to scale\nall elevation without updating the data. Remarks: These lines are rendered with  GL.LINE  and will thus always be 1 pixel wide. Wireframe and solid extrusions are exclusive, you'll need to create two layers\nwith the same data if you want a combined rendering effect. material  (Object, optional) Default:  true This is an object that contains material props for  lighting effect  applied on extruded polygons.\nCheck  the lighting guide  for configurable settings. _normalize  (Object, optional) Default:  true Note: This prop is experimental If  false , will skip normalizing the coordinates returned by  getPolygon . Disabling normalization improves performance during data update, but makes the layer prone to error in case the data is malformed. It is only recommended when you use this layer with preprocessed static data or validation on the backend. When normalization is disabled, polygons must be specified in the format of flat array or  {positions, holeIndices} . Rings must be closed (i.e. the first and last vertices must be identical). The winding order of rings must be consistent with that defined by  _windingOrder . See  getPolygon  below for details. _windingOrder  (String, optional) Default:  'CW' Note: This prop is experimental This prop is only effective with  _normalize: false . It specifies the winding order of rings in the polygon data, one of: 'CW' : outer-ring is clockwise, and holes are counter-clockwise 'CCW' : outer-ring is counter-clockwise, and holes are clockwise The proper value depends on the source of your data. Most geometry formats  enforce a specific winding order . Incorrectly set winding order will cause an extruded polygon's surfaces to be flipped, affecting culling and the lighting effect. Data Accessors getPolygon  ( Function , optional)  Default:  object => object.polygon This accessor returns the polygon corresponding to an object in the  data  stream. A polygon can be one of the following formats: An array of points ( [x, y, z] ) - a.k.a. a \"ring\". An array of rings. The first ring is the exterior boundary and the following rings are the holes. Compatible with the GeoJSON  Polygon  specification. A flat array or  TypedArray  of numbers, in the shape of  [x0, y0, z0, x1, y1, z1, ...] , is equivalent to a single ring. By default, each coordinate is assumed to contain 3 consecutive numbers. If each coordinate contains only two numbers (x, y), set the  positionFormat  prop of the layer to  XY . An object of shape  {positions, holeIndices} . positions  (Array|TypedArray) - a flat array of coordinates. By default, each coordinate is assumed to contain 3 consecutive numbers. If each coordinate contains only two numbers (x, y), set the  positionFormat  prop of the layer to  XY . holeIndices  (Array) - the starting index of each hole in the  positions  array. The first ring is the exterior boundary and the successive rings are the holes. getFillColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the fill color for all polygons. If a function is provided, it is called on each polygon to retrieve its fill color. getLineColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied.\nOnly applies if  extruded: true . If an array is provided, it is used as the stroke color for all polygons. If a function is provided, it is called on each object to retrieve its stroke color. getElevation  ( Function |Number, optional)  Default:  1000 The elevation to extrude each polygon with.\nIf a cartographic projection mode is used, height will be interpreted as meters,\notherwise will be in unit coordinates.\nOnly applies if  extruded: true . If a number is provided, it is used as the elevation for all polygons. If a function is provided, it is called on each object to retrieve its elevation. Use binary attributes This section is about the special requirements when  supplying attributes directly  to a  SolidPolygonLayer . Because each polygon has a different number of vertices, when  data.attributes.getPolygon  is supplied, the layer also requires an array  data.startIndices  that describes the vertex index at the start of each polygon. For example, if there are 3 polygons of 3, 4, and 5 vertices each (including the end vertex that overlaps with the first vertex to close the loop),  startIndices  should be  [0, 3, 7, 12] .  Polygons with holes are not supported when using precalculated attributes. Additionally, all other attributes ( getFillColor ,  getElevation , etc.), if supplied, must contain the same layout (number of vertices) as the  getPolygon  buffer. To truly realize the performance gain from using binary data, the app likely wants to skip all data processing in this layer. Specify the  _normalize  prop to skip normalization. Example use case: Convert to using binary attributes: Remarks This layer only renders filled polygons. If you need to render polygon\noutlines, use the  PathLayer Polygons are always closed, i.e. there is an implicit line segment between\nthe first and last vertices, when those vertices are not equal. The specification of complex polygons intentionally follows the GeoJson\nconventions for representing polygons with holes. Source modules/layers/src/solid-polygon-layer","headings":[{"value":"SolidPolygonLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Render Options","depth":3},{"value":"filled (Boolean, optional)","depth":5},{"value":"extruded (Boolean, optional)","depth":5},{"value":"wireframe (Boolean, optional)","depth":5},{"value":"elevationScale (Number, optional) transition-enabled","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"_normalize (Object, optional)","depth":5},{"value":"_windingOrder (String, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPolygon (Function, optional) transition-enabled","depth":5},{"value":"getFillColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getLineColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getElevation (Function|Number, optional) transition-enabled","depth":5},{"value":"Use binary attributes","depth":2},{"value":"Remarks","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/layers/solid-polygon-layer","title":"SolidPolygonLayer"},{"excerpt":"MapboxOverlay MapboxOverlay  is an implementation of  Mapbox GL JS 's  IControl  API. When adding a  MapboxOverlay  control to an mapbox map, deck.gl layers are rendered in synchronization with the base map layers. This control supports both  overlaid and interleaved  rendering modes. Example Overlaid Interleaved Using with react-map-gl The following code demonstrates how to create a React component from  MapboxOverlay  with  react-map-gl@7.x : See react-map-gl's  useControl  hook. Constructor MapboxOverlay  accepts the same props as the  Deck  class, with the following exceptions: views  - multi-view support is limited. There is only one  MapView  that can synchronize with the base map. See the  using with multi-views  section for details. parent  /  canvas  /  gl  - context creation is managed internally. viewState  /  initialViewState  - camera state is managed internally. controller  - always disabled (to use Mapbox's interaction handlers). The constructor additionally accepts the following option: interleaved  (Boolean) - If  false , a dedicated deck.gl canvas is added on top of the base map. If  true , deck.gl layers are inserted into mapbox-gl's layer stack, and share the same WebGLRenderingContext as the base map. Default is  false . When using  interleaved: true , you may optionally add a  beforeId  prop to a layer to specify its position in the Mapbox layer stack. If multiple deck.gl layers have the same  beforeId , they are rendered in the order that is passed into the  layers  array. Methods setProps Updates (partial) props of the underlying  Deck  instance. See  Deck.setProps . pickObject See  Deck.pickObject . pickObjects See  Deck.pickObjects . pickMultipleObjects See  Deck.pickMultipleObjects . finalize Removes the control and deletes all resources. Remarks Multi-view usage When using  MapboxOverlay  with multiple views passed to the  views  prop, only one of the views can match the base map and receive interaction. With that said, it is still possible to take advantage of deck's multi-view system and render a mapbox base map onto any one MapView of your choice by setting the  views  array and a  layerFilter  callback. To use multiple views, define a  MapView  with the id  “mapbox” . This view will receive the state that matches the base map at each render. If views are provided but the array does not contain this id, then a  MapView({id: 'mapbox'})  will be inserted at the bottom of the stack.","headings":[{"value":"MapboxOverlay","depth":1},{"value":"Example","depth":2},{"value":"Overlaid","depth":3},{"value":"Interleaved","depth":3},{"value":"Using with react-map-gl","depth":3},{"value":"Constructor","depth":2},{"value":"Methods","depth":2},{"value":"setProps","depth":5},{"value":"pickObject","depth":5},{"value":"pickObjects","depth":5},{"value":"pickMultipleObjects","depth":5},{"value":"finalize","depth":5},{"value":"Remarks","depth":2},{"value":"Multi-view usage","depth":3}],"slug":"docs/api-reference/mapbox/mapbox-overlay","title":"MapboxOverlay"},{"excerpt":"MapboxLayer MapboxLayer  is an implementation of  Mapbox GL JS 's  CustomLayerInterface  API. By adding a  MapboxLayer  instance to an mapbox map, one can render any deck.gl layer inside the mapbox canvas / WebGL context. This is in contrast to the traditional deck.gl/mapbox integration where the deck.gl layers are rendered into a separate canvas over the base map. See the Mapbox  map.addLayer(layer, before?)  API for how to add a layer to an existing layer stack. Example Constructor Parameters: props  (Object) props.id  (String) - an unique id is required for each layer. props.type  ( Layer , optional) - a class that extends deck.gl's base  Layer  class. Required if  deck  is not provided. props.deck  ( Deck , optional) - a  Deck  instance that controls the rendering of this layer. If provided, the layer will be looked up from its layer stack by  id  at render time, and all other props are ignored. It's recommended that you use the  MapboxOverlay  class where a  Deck  instance is automatically managed. Optional: any other prop needed by this type of layer. See deck.gl's  layer catalog  for documentation and examples on how to create layers. Methods setProps(props) Update a layer after it's added. Has no effect if  props.deck  is provided.","headings":[{"value":"MapboxLayer","depth":1},{"value":"Example","depth":2},{"value":"Constructor","depth":2},{"value":"Methods","depth":2},{"value":"setProps(props)","depth":5}],"slug":"docs/api-reference/mapbox/mapbox-layer","title":"MapboxLayer"},{"excerpt":"@deck.gl/mapbox This module makes it easy to use deck.gl as native layers and controls in the Mapbox GL JS ecosystem.  It allows deck.gl to be used with other mapbox-gl controls such as  NavigationControl ,  GeolocateControl  and  mapbox-gl-geocoder . You may choose to interleave deck.gl layers with the base map layers, such as drawing behind map labels, z-occlusion between deck.gl 3D objects and Mapbox buildings, etc. Installation Include the Standalone Bundle Install from NPM Use Cases One should note that this module is  not required  to use mapbox-gl as a base map for deck.gl. When you use this module, Mapbox is the root element and deck.gl is the child, with Mapbox handling all user inputs. Some of deck.gl's features are therefore unavailable due to limitations of mapbox-gl's API, see  limitations  below. If you just want the base map as a back drop, and do not need mapbox-gl's UI controls or mixing deck and Mapbox layers, it is recommended that you use deck.gl as the root element. Visit the  mapbox base map developer guide  for examples of each option. It may be easier to understand the concepts of the module if you are already a mapbox-gl developer. Mixing deck.gl layers and Mapbox layers One major use case for interleaving deck.gl and Mapbox is that some important information in the Mapbox map could be hidden by a deck.gl visualization layer, and controlling opacity is not enough. A typical example of this is labels and roads, where it is desirable to have a deck.gl visualization layer render on top of the Mapbox geography, but where one might still want to see e.g. labels and/or roads. Alternatively, the deck.gl visualization should cover the ground, but not the roads and labels. To inject a deck layer into the Mapbox stack, either: Create a  MapboxLayer  and call the  map.addLayer(layer, before?)  API. Add a  beforeId  prop to any layer passed to the  MapboxOverlay  control. Mapbox provides an example of  finding the first label layer . For more sophisticated injection point lookups, refer to Mapbox' documentation on the format of Mapbox style layers, see  Mapbox Style Spec . In some cases, the application wants to add a deck.gl 3D layer (e.g. ArcLayer, HexagonLayer, GeoJsonLayer) on top of a Mapbox basemap, while seamlessly blend into the z-buffer. This will interleave the useful visualization layers from both the deck.gl and Mapbox layer catalogs. In this case, a  beforeId  is not needed. Using mapbox-gl controls with deck.gl The Mapbox ecosystem offers many well-designed controls, from the basic functionalities of  NavigationControl ,  Popup  and  GeolocateControl , to vendor-service-bound UI implementations such as  mapbox-gl-geocoder  and  mapbox-gl-directions . These libraries require that the Mapbox Map holds the source of truth of the camera state, instead of the normal  state management  by  Deck . When you use the  MapboxLayer  or  MapboxOverlay  classes from this module, deck.gl plays nice with all the mapbox-gl peripherals. Limitations When using deck.gl's multi-view system, only one of the views can match the base map and receive interaction. See  using MapboxOverlay with multi-views  for details. When using deck.gl as Mapbox layers or controls,  Deck  only receives a subset of user inputs delegated by  Map . Therefore, certain interactive callbacks like  onDrag ,  onInteractionStateChange  are not available. WebGL2 based deck.gl features, such as attribute transitions and GPU accelerated aggregation layers cannot be used. Mapbox 2.0's terrain feature is currently not supported.","headings":[{"value":"@deck.gl/mapbox","depth":1},{"value":"Installation","depth":2},{"value":"Include the Standalone Bundle","depth":3},{"value":"Install from NPM","depth":3},{"value":"Use Cases","depth":2},{"value":"Mixing deck.gl layers and Mapbox layers","depth":3},{"value":"Using mapbox-gl controls with deck.gl","depth":3},{"value":"Limitations","depth":2}],"slug":"docs/api-reference/mapbox/overview","title":"@deck.gl/mapbox"},{"excerpt":"ScenegraphLayer The  ScenegraphLayer  renders a number of instances of a complete glTF scenegraph. Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Mesh scenegraph  (URL|Object|Promise) The geometry to render for each data object.\nCan be a URL of an object. You need to provide the  fetch  function to load the object.\nCan also be a luma.gl  ScenegraphNode , or a  Promise  that resolves to one.\nThe layer calls  delete()  on  scenegraph  when a new one is provided or the layer is finalized. loadOptions  (Object, optional) On top of the  default options , also accepts options for the following loaders: GLTFLoader  if the  scenegraph  prop is an URL Render Options sizeScale  (Number, optional)  Default  1 . Multiplier to scale each geometry by. _animations  (Object, optional) Default  undefined . (No animations are running). An object used to configure animations playing.  keys  can be one of the following: number  for index number name  for animation name *  to affect all animations\nEach value is an object with: playing  (Boolean) default  true speed  (Number) speed multiplier, default  1 . startTime  (Number) start time, default  0 .\nAnimations are parsed automatically from  glTF  files. getScene  (Function, optional) Default:  scenegraph => (scenegraph && scenegraph.scenes ? scenegraph.scenes[0] : scenegraph) If you have multiple scenes you can select the scene you want to use.\nOnly triggers when scenegraph property changes. getAnimator  (Function, optional) Default:  scenegraph => scenegraph && scenegraph.animator Return  null  to disable animation or provide your custom animator.\nOnly triggers when scenegraph property changes. _lighting  (String, optional) Default:  flat Experimental  lighting support, can be: flat : No light calculation. Works well with any textured object. pbr  Uses  glTF  PBR model. Works well with  glTF  models. Only read when scenegraph property changes.\nUses  global light configuration  from deck. _imageBasedLightingEnvironment  (Function or GLTFEnvironment, optional) Default:  null Experimental  Can be: A  GLTFEnvironment  object. A function that takes  {gl, layer}  as first argument and returns a  GLTFEnvironment . Only read when scenegraph property changes. Data Accessors getPosition  ( Function , optional)  Default:  object => object.position Method called to retrieve the center position for each object in the  data  stream. getColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] The rgba color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. Only used if  texture  is empty. If an array is provided, it is used as the color for all objects. If a function is provided, it is called on each object to retrieve its color. getOrientation  ( Function |Array, optional) Default:  [0, 0, 0] Object orientation defined as a vec3 of Euler angles,  [pitch, yaw, roll]  in degrees. This will be composed with layer's  modelMatrix . If an array is provided, it is used as the orientation for all objects. If a function is provided, it is called on each object to retrieve its orientation. getScale  ( Function |Array, optional) Default:  [1, 1, 1] Scaling factor on the mesh along each axis. If an array is provided, it is used as the scale for all objects. If a function is provided, it is called on each object to retrieve its scale. getTranslation  ( Function |Array, optional) Default:  [0, 0, 0] Translation of the mesh along each axis. Offset from the center position given by  getPosition .  [x, y, z]  in meters. If an array is provided, it is used as the offset for all objects. If a function is provided, it is called on each object to retrieve its offset. getTransformMatrix  ( Function |Array, optional) Default:  null Explicitly define a 4x4 column-major model matrix for the mesh. If provided, will override\n getOrientation ,  getScale ,  getTranslation . This will be composed with layer's  modelMatrix . If an array is provided, it is used as the transform matrix for all objects. If a function is provided, it is called on each object to retrieve its transform matrix. sizeMinPixels  (Number, optional) Default:  0 The minimum size in pixels for one unit of the scene. sizeMaxPixels  (Number, optional) Default:  Number.MAX_SAFE_INTEGER The maximum size in pixels for one unit of the scene. Source modules/mesh-layers/src/scenegraph-layer","headings":[{"value":"ScenegraphLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Mesh","depth":3},{"value":"scenegraph (URL|Object|Promise)","depth":5},{"value":"loadOptions (Object, optional)","depth":5},{"value":"Render Options","depth":3},{"value":"sizeScale (Number, optional) transition-enabled","depth":5},{"value":"_animations (Object, optional)","depth":5},{"value":"getScene (Function, optional)","depth":5},{"value":"getAnimator (Function, optional)","depth":5},{"value":"_lighting (String, optional)","depth":5},{"value":"_imageBasedLightingEnvironment (Function or GLTFEnvironment, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional) transition-enabled","depth":5},{"value":"getColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getOrientation (Function|Array, optional)","depth":5},{"value":"getScale (Function|Array, optional)","depth":5},{"value":"getTranslation (Function|Array, optional)","depth":5},{"value":"getTransformMatrix (Function|Array, optional)","depth":5},{"value":"sizeMinPixels (Number, optional)","depth":5},{"value":"sizeMaxPixels (Number, optional)","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/mesh-layers/scenegraph-layer","title":"ScenegraphLayer"},{"excerpt":"SimpleMeshLayer The  SimpleMeshLayer  renders a number of instances of an arbitrary 3D geometry. For example, it can be used to visualize a fleet of 3d cars each with a position and an orientation over the map. loaders.gl  offers a  category  of loaders for loading meshes from standard formats. For example, the following code adds support for OBJ files: Installation To install the dependencies from NPM: To use pre-bundled scripts: Properties Inherits from all  Base Layer  properties. Mesh mesh  (String|Geometry|Object) The geometry to render for each data object. One of: An URL to a mesh description file in a format supported by  loaders.gl . The appropriate loader will have to be registered via the loaders.gl  registerLoaders  function for this usage. A luma.gl  Geometry  instance An object containing the following fields: positions  (Float32Array) - 3d vertex offset from the object center, in meters normals  (Float32Array) - 3d normals texCoords  (Float32Array) - 2d texture coordinates texture  (String|Texture2D|Image|ImageData|HTMLCanvasElement|HTMLVideoElement|ImageBitmap|Promise|Object, optional) Default  null . The texture of the geometries. If a string is supplied, it is interpreted as a URL or a  Data URL . One of the following, or a Promise that resolves to one of the following: One of the valid  pixel sources for WebGL texture A luma.gl  Texture2D  instance A plain object that can be passed to the  Texture2D  constructor, e.g.  {width: <number>, height: <number>, data: <Uint8Array>} . Note that whenever this object shallowly changes, a new texture will be created. The image data will be converted to a  Texture2D  object. See  textureParameters  prop for advanced customization. If  texture  is supplied, texture is used to render the geometries. Otherwise, object color obtained via the  getColor  accessor is used. textureParameters  (Object) Customize the  texture parameters . If not specified, the layer uses the following defaults to create a linearly smoothed texture from  texture : Render Options sizeScale  (Number, optional)  Default  1 . Multiplier to scale each geometry by. wireframe  (Boolean, optional) Default:  false Whether to render the mesh in wireframe mode. material  (Object, optional) Default:  true This is an object that contains material props for  lighting effect  applied on extruded polygons.\nCheck  the lighting guide  for configurable settings. _useMeshColors  (Boolean, optional) Default:  false Whether to color pixels using vertex colors supplied in the mesh (the  COLOR_0  or  colors  attribute). If set to  true , vertex colors will be used. If set to  false  (default) vertex colors will be ignored. Remarks: In the next major release of deck.gl, vertex colors are expected to always be used when supplied with a mesh. This property will then likely be removed and effectively default to true. Data Accessors getPosition  ( Function , optional)  Default:  object => object.position Method called to retrieve the center position for each object in the  data  stream. getColor  ( Function |Array, optional)  Default:  [0, 0, 0, 255] If  mesh  does not contain vertex colors, use this color to render each object. If  mesh  contains vertex colors, then the two colors are mixed together. Use  [255, 255, 255]  to use the original mesh colors. If  texture  is assigned, then both colors will be ignored. The color is in the format of  [r, g, b, [a]] . Each channel is a number between 0-255 and  a  is 255 if not supplied. If an array is provided, it is used as the color for all objects. If a function is provided, it is called on each object to retrieve its color. getOrientation  ( Function |Array, optional) Default:  [0, 0, 0] Object orientation defined as a vec3 of Euler angles,  [pitch, yaw, roll]  in degrees. This will be composed with layer's  modelMatrix . If an array is provided, it is used as the orientation for all objects. If a function is provided, it is called on each object to retrieve its orientation. getScale  ( Function |Array, optional) Default:  [1, 1, 1] Scaling factor on the mesh along each axis. If an array is provided, it is used as the scale for all objects. If a function is provided, it is called on each object to retrieve its scale. getTranslation  ( Function |Array, optional) Default:  [0, 0, 0] Translation of the mesh along each axis. Offset from the center position given by  getPosition .  [x, y, z]  in meters. This will be composed with layer's  modelMatrix . If an array is provided, it is used as the offset for all objects. If a function is provided, it is called on each object to retrieve its offset. getTransformMatrix  ( Function |Array, optional) Default:  null Explicitly define a 4x4 column-major model matrix for the mesh. If provided, will override\n getOrientation ,  getScale ,  getTranslation . If an array is provided, it is used as the transform matrix for all objects. If a function is provided, it is called on each object to retrieve its transform matrix. Source modules/mesh-layers/src/simple-mesh-layer","headings":[{"value":"SimpleMeshLayer","depth":1},{"value":"Installation","depth":2},{"value":"Properties","depth":2},{"value":"Mesh","depth":3},{"value":"mesh (String|Geometry|Object)","depth":5},{"value":"texture (String|Texture2D|Image|ImageData|HTMLCanvasElement|HTMLVideoElement|ImageBitmap|Promise|Object, optional)","depth":5},{"value":"textureParameters (Object)","depth":5},{"value":"Render Options","depth":3},{"value":"sizeScale (Number, optional) transition-enabled","depth":5},{"value":"wireframe (Boolean, optional)","depth":5},{"value":"material (Object, optional)","depth":5},{"value":"_useMeshColors (Boolean, optional)","depth":5},{"value":"Data Accessors","depth":3},{"value":"getPosition (Function, optional) transition-enabled","depth":5},{"value":"getColor (Function|Array, optional) transition-enabled","depth":5},{"value":"getOrientation (Function|Array, optional)","depth":5},{"value":"getScale (Function|Array, optional)","depth":5},{"value":"getTranslation (Function|Array, optional)","depth":5},{"value":"getTransformMatrix (Function|Array, optional)","depth":5},{"value":"Source","depth":2}],"slug":"docs/api-reference/mesh-layers/simple-mesh-layer","title":"SimpleMeshLayer"},{"excerpt":"DeckGL (React Component) DeckGL  is the main interface to deck.gl for React applications.  DeckGL  is a React component that takes a list of deck.gl layer instances and a view state, and renders those layers on a transparent canvas that can be used as an overlay over other components like maps. Make sure to read the  Using deck.gl with React  article. The  DeckGL  class is a React wrapper of the  Deck  JavaScript class which exposes essentially the same props. The  Deck  class should not be used directly in React applications. Usage Like any React component,  DeckGL  can accept child components. Child components are often maps (e.g. the  StaticMap  component from react-map-gl), but can be any React components. Properties DeckGL  accepts all  Deck  properties, with these additional semantics: React Context ContextProvider  (React.Component, optional) A  Context.Provider  component. If supplied, will be rendered as the ancestor to all children. The passed through context contains the following values: viewport  ( Viewport ) - the current viewport container  (DOMElement) - the DOM element containing the deck canvas eventManager  ( EventManager ) Children The following semantics of the standard React  children  property are considered experimental. JSX layers It is possible to use JSX syntax to create deck.gl layers as React children of the  DeckGL  React components, instead of providing them as ES6 class instances to the  layers  prop. Caveat: The JSX layer syntax is limited in that it only works when the layers are direct children of the  DeckGL  component. deck.gl layers are not true React components and cannot be rendered independently by React, and the JSX support depends on deck.gl intercepting the JSX generated child elements before React tries to render them. JSX views It is possible to use JSX syntax to create deck.gl views as React children of the  DeckGL  React components, instead of providing them as ES6 class instances to the  views  prop. If a certain view id is used in both JSX views and the  views  prop, the view instance in the  views  prop has priority. Position Children in Views To make it easy to use React components in combination with deck.gl views (e.g. to place a base map under a view, or add a label on top of a view), deck.gl can make such components automatically adjust as that view is added, removed or resized. Each child element of  DeckGL  is positioned inside a view. All children of a view is wrapped in a DOM container that: is offset to be relative to the deck.gl view that it corresponds to. is resized to match the extent of the deck.gl view with the corresponding view id. is hidden if the view id is missing from  DeckGL 's  views  prop. The containing view of each element is determined as follows: If the element is a direct child of  DeckGL , it is positioned inside the default (first) view. If the element is nested under a  <View id={id}>  tag, it is positioned inside the view corresponding to the  id  prop.  Render callbacks You may supply a function as a child to the  DeckGL  or  View  node (see  JSX views ). The function will be called to retrieve the React children when the viewport updates. The following arguments are passed: x  - the left offset of the current view, in pixels y  - the top offset of the current view, in pixels width  - the width of the current view, in pixels height  - the height of the current view, in pixels viewState  - the view state of the current view viewport  - the  Viewport  instance of the current view This is useful when you need to specify custom rendering logic for a child: Additional Notes: The DeckGL components own  canvas  element is added last to the child list, to sit on top of all the base components, however Z index can be used to override this. Child repositioning is done with CSS styling on a wrapper div. Children that do not belong to any  <View>  tag and are functions are called with the properties of the default view. Children that do not belong to any  <View>  tag and are valid React elements are rendered as is. Methods All  Deck  methods are available on the  DeckGL  component, but not all of them can be explicitly called. For example, to rerender your component, you can pass updated props to  DeckGL  component directly, while you should call  setProps  with new props in  Deck .  The public methods you can call explicitly list below: pickObject pickMultipleObjects pickObjects We do recommend you to use the pure JavaScript version of deck.gl if you are more comfortable with an imperative programming style (e.g.  deck.setProps() ). Source modules/react/src/deckgl.js","headings":[{"value":"DeckGL (React Component)","depth":1},{"value":"Usage","depth":2},{"value":"Properties","depth":2},{"value":"React Context","depth":3},{"value":"ContextProvider (React.Component, optional)","depth":5},{"value":"Children","depth":3},{"value":"JSX layers","depth":4},{"value":"JSX views","depth":4},{"value":"Position Children in Views","depth":4},{"value":"Render callbacks","depth":4},{"value":"Methods","depth":2},{"value":"Source","depth":2}],"slug":"docs/api-reference/react/deckgl","title":"DeckGL (React Component)"},{"excerpt":"InteractionTestRunner Client-side utility for browser-based deck.gl interaction tests. This class is intended to be used with  BrowserTestDriver  from  @probe.gl/test-utils . Together they support the following workflow: Launch a Puppeteer instance (headless or non-headless) to run a test application In the test application, create a deck.gl canvas. For each test case, dispatch a sequence of keyboard/mouse events, and check the updated state. Proceed to the next test case until done. Example See  SnapshotTestRunner  for Node side set up instructions. In your script that is run on the browser: Methods constructor(props: Object) Create a InteractionTestRunner instance. The  deckProps  argument is passed to the  Deck  constructor. add(testCase: Array|Object) Add one or a list of test cases. Each test case may contain the following fields: name  (String) - name of the test case. events  (Array) - a sequence of inputs to dispatch. See  Event  section below. onBeforeEvents  (Function, optional) - called before the events are dispatched. Receives the following arguments: deck  - the Deck instance. onAfterEvents  (Function, optional) - called after the events are dispatched. Receives the following arguments: deck  - the Deck instance. layers  - the rendered layers. context  - the return value of  onBeforeEvents . run(options: Object) Run all test cases. Options: timeout  (Number) - time to wait for each test case to resolve (by calling the  done  callback) before aborting, in milliseconds. Default  2000 . Returns: a  Promise  that resolves when all test cases are done. Members isHeadless Whether the test is being run in headless mode. In headless mode, Chromium uses software render which behaves slightly differently from non-headless. Image diffing tolerance may need to be adjusted accordingly. Event An event is a javascript descriptor of emulated user input. The following event types are supported: keypress Press a key on the keyboard. type: 'keypress' key  (String) - see  https://github.com/GoogleChrome/puppeteer/blob/master/lib/USKeyboardLayout.js delay  (Number) - the time between keydown and keyup. Default  0 . shiftKey  (Boolean) - whether to press the key with the shift key down. Default  false . ctrlKey  (Boolean) - whether to press the key with the control key down. Default  false . metaKey  (Boolean) - whether to press the key with the meta key down. Default  false . click Click the mouse at a given screen coordinate. type: 'click' x  (Number) - the screen x of the click. y  (Number) - the screen y of the click. button  (String) -  'left' ,  'right'  or  'middle' . delay  (Number) - the time between mousedown and mouse up. Default  0 . shiftKey  (Boolean) - whether to click with the shift key pressed. Default  false . ctrlKey  (Boolean) - whether to click with the control key pressed. Default  false . metaKey  (Boolean) - whether to click with the meta key pressed. Default  false . mousemove Move the mouse to a given screen coordinate. type: 'mousemove' x  (Number) - the screen x to move the pointer to. y  (Number) - the screen y to move the pointer to. steps  (Number) - how many intermediate mousemove events to generate, default  1 . drag Drag the mouse from a given screen coordinate to another. type: 'drag' startX  (Number) - the screen x to drag from. startY  (Number) - the screen y to drag from. endX  (Number) - the screen x to drag to. endY  (Number) - the screen y to drag to. button  (String) -  'left' ,  'right'  or  'middle' . steps  (Number) - how many intermediate mousemove events to generate, default  1 . shiftKey  (Boolean) - whether to click with the shift key pressed. Default  false . ctrlKey  (Boolean) - whether to click with the control key pressed. Default  false . metaKey  (Boolean) - whether to click with the meta key pressed. Default  false . wait Idle for a given period of time before the next event. wait  (Number) - the timeout in milliseconds.","headings":[{"value":"InteractionTestRunner","depth":1},{"value":"Example","depth":2},{"value":"Methods","depth":2},{"value":"constructor(props: Object)","depth":3},{"value":"add(testCase: Array|Object)","depth":3},{"value":"run(options: Object)","depth":3},{"value":"Members","depth":2},{"value":"isHeadless","depth":3},{"value":"Event","depth":2},{"value":"keypress","depth":3},{"value":"click","depth":3},{"value":"mousemove","depth":3},{"value":"drag","depth":3},{"value":"wait","depth":3}],"slug":"docs/api-reference/test-utils/interaction-test-runner","title":"InteractionTestRunner"},{"excerpt":"generateLayerTests This utility generates a series of test cases to be used with  testLayer  that checks the conformance of a layer class. Example Example of layer unit tests using  tape . The test utility itself is test framework agnostic. Usage Layer  (Object) - the layer component class to test sampleProps  (Object, Optional) - a list of props to use as the basis for all generated tests. Can be used to supply a meaningful set of  data . assert  (Function, optional) - callback when checking a condition. Receives two arguments: condition  - a value that is expected to be truthy comment  (String) - information about the check onBeforeUpdate  - custom callback to be added to each  test case . onAfterUpdate  - custom callback to be added to each  test case .","headings":[{"value":"generateLayerTests","depth":1},{"value":"Example","depth":2},{"value":"Usage","depth":2}],"slug":"docs/api-reference/test-utils/generate-layer-tests","title":"generateLayerTests"},{"excerpt":"@deck.gl/test-utils A set of utilities to facilitate testing deck.gl layers. Tests can be run: Completely in Node.js (lifecycle tests only). Completely in the Browser (lifecycle and rendering tests). From Node in a controlled Browser instance (with  probe.gl 's  BrowserTestDriver ). Installation The deck.gl test utilities are published as a separate npm module that is only intended to be used during development. Install it as as a \"dev dependency\" as follows: or You typically want the major and minor version of   @deck.gl/test-utils  to match the version of  @deck.gl/core  that you are using. i.e. you want to use  5.2.x  and  5.2.y  together. Check and if necessary edit your  package.json  to make sure things align. Layer Conformance Tests Layer conformance tests are designed to verify deck.gl that layers update their internal state correctly in response to various props and prop changes. The layer update test support includes test drivers to initialize a layer and then run a sequence of successive updates, with facilities for validating the layer after each change, and also provides functions to initialize, update and render layers in a test environment. Note that internally in deck.gl, updates are handled by the deck.gl layer \"lifecycle\" and these tests are therefore also called \"lifecycle tests\". Lifecycle tests are less demanding of the WebGL environment than rendering tests described below and are thus easily integrated in traditional Node.js unit test suites (e.g. based on  tape ,  jest  or similar unit test frameworks). Layer Rendering Tests Rendering tests are a key feature of deck.gl's test utils. Rendering tests involve rendering layers with known inputs and performing pixel-comparison between the results against \"golden images\". Currently, rendering tests requires running layers with predefined props and views in a controlled Chrome instance, reporting values back to Node.js. Testing Applications instead of Layers The current test utilities are focused on testing of layers. This might seem to make them less suited for testing deck.gl code in applications. Still, there are techniques that can be used to get parts of the application's rendering stack tested. Applications that render multiple layers can e.g. render them with mock application data, and compare the result against a golden image. More direct support for application testing is under consideration. Future support might include rendering layers directly in Node.js under headless gl, enabling apps to be tested in CI environments, as well as support for \"snapshotting\" deck.gl output inside live applications and comparing against golden images.","headings":[{"value":"@deck.gl/test-utils","depth":1},{"value":"Installation","depth":2},{"value":"Layer Conformance Tests","depth":2},{"value":"Layer Rendering Tests","depth":2},{"value":"Testing Applications instead of Layers","depth":2}],"slug":"docs/api-reference/test-utils/overview","title":"@deck.gl/test-utils"},{"excerpt":"SnapshotTestRunner Client-side utility for browser-based deck.gl render tests. This class is intended to be used with  BrowserTestDriver  from  @probe.gl/test-utils . Together they support the following workflow: Launch a Puppeteer instance (headless or non-headless) to run a test application In the test application, create a deck.gl canvas. For each test case, render a set of deck props including views and layers, take a screenshot, and perform pixel-diffing with a pre-defined \"golden image\". Report the matching result. Proceed to the next test case until done. Example In your node.js start script: In your script that is run on the browser: Methods constructor(props: Object) Create a SnapshotTestRunner instance. The  deckProps  argument is passed to the  Deck  constructor. add(testCase: Array|Object) Add one or a list of test cases. Each test case may contain the following fields: name  (String) - name of the test case. goldenImage  (String) - path to the golden image, relative to the root where the node script is executed. timeout  (Number) - time to wait for this test case to resolve (by calling the  done  callback) before aborting, in milliseconds. If not provided, fallback to the shared option that is passed to  SnapshotTestRunner.run . imageDiffOptions  (Object, optional) - image diffing options for this test case. See \"Image Diff Options\" section below. onBeforeRender  (Function, optional) - callback before each time deck rerenders. Receives the following arguments: deck  (Deck) - the  Deck  instance. layers  (Array) - the list of layers that were rendered. onAfterRender  (Function, optional) - callback after each time deck rerenders. Receives the following arguments: deck  (Deck) - the  Deck  instance. layers  (Array) - the list of layers that were rendered. done  (Function) - must be called when the test case is done rendering and ready for screen capture and comparison. The default  onAfterRender  calls  done  immediately, i.e. takes screenshot as soon as the canvas is rendered for the first time. If some resources are loaded asynchronously, you may need to provide an implementation of this callback to check whether all layers are fully loaded. Any other props that  Deck.setProps  accepts. run(options: Object) Run all test cases. Options: timeout  (Number) - time to wait for each test case to resolve (by calling the  done  callback) before aborting, in milliseconds. Default  2000 . imageDiffOptions  (Object) - image diffing options for all test cases. This will be overridden if a test case defines its own  imageDiffOptions . See \"Image Diff Options\" section below. onTestStart  (Function) - callback when a test starts. Receives the current test case. Default logs the test name to console. onTestPass  (Function) - callback when a test passes. Receives the current test case and the diffing result. Default logs the pixel matching percentage to console. onTestFail  (Function) - callback when a test fails, either because the matching rate is below threshold or a critical error. Receives the current test case. Default logs the error message or the pixel matching percentage to console. Returns: a  Promise  that resolves when all test cases are done. Members isHeadless Whether the test is being run in headless mode. In headless mode, Chromium uses software render which behaves slightly differently from non-headless. Image diffing tolerance may need to be adjusted accordingly. Image Diff Options The test renderer and each test case may choose to override the default image diffing options. The following options from  captureAndDiffScreen  are supported: tolerance threshold includeAA includeEmpty createDiffImage saveOnFail saveAs","headings":[{"value":"SnapshotTestRunner","depth":1},{"value":"Example","depth":2},{"value":"Methods","depth":2},{"value":"constructor(props: Object)","depth":3},{"value":"add(testCase: Array|Object)","depth":3},{"value":"run(options: Object)","depth":3},{"value":"Members","depth":2},{"value":"isHeadless","depth":3},{"value":"Image Diff Options","depth":2}],"slug":"docs/api-reference/test-utils/snapshot-test-runner","title":"SnapshotTestRunner"},{"excerpt":"Learning Resources API Documentation The documentation for the latest release can be found on deck.gl  website . The documentation for previous releases are in the  docs  directory on the  <version-release>  branch in this repo. Technical Deep Dive An in-depth view into the technical details and architectural decisions behind deck.gl.  Google Slides Live Demos The sources of deck.gl  website demos  can be found in the repo's  examples  directory. Most of the applications use React, although non-React templates are provided for developers from other ecosystems. Prototyping & Sharing PureJS examples in prototyping environments. These are great templates for feature testing and bug reporting: deck.gl  Codepen demos deck.gl  Observable demos RandomFractals   Observable DeckGL collection One-page scripting examples Community vis.gl's Medium blog   Join our  Slack workspace  for learning and discussions.","headings":[{"value":"Learning Resources","depth":1},{"value":"API Documentation","depth":2},{"value":"Technical Deep Dive","depth":2},{"value":"Live Demos","depth":2},{"value":"Prototyping & Sharing","depth":2},{"value":"Community","depth":2}],"slug":"docs/get-started/learning-resources","title":"Learning Resources"},{"excerpt":"testLayer The  testLayer  utility initializes a layer, test layer updates and draw calls on a series of new props, and allow test suites to inspect the result. The  testLayerAsync  utility is like  testLayer , but designed for layers that need to resolve resources asynchronously. Example Example of layer unit tests using  tape . The test utility itself is test framework agnostic. Usage Layer  (Object) - the layer component class to test testCases  (Array) - a list of test cases, as described below. viewport  ( Viewport , Optional) - a viewport instance to use for the tests. spies  (Array, Optional) - names of layer class methods to spy on. onError  (Function, Optional) - callback after each operation with potential errors. Called with two arguments: error  ( Error | null ) title  (String) - name of the operation. Test Cases Test cases specified as objects and are run sequentially. Each test case provided to  testLayer  specifies what properties are going to be updated. A test case is an object with the following fields: title  (String) - title of the test case props  (Object) - specifies a complete new set of props updateProps  (Object) - specifies an incremental prop change (overrides props from previous test case) spies  (Array, Optional) - names of layer class methods to spy on. Overrides the list that was sent to  testLayer . onBeforeUpdate  (Function, Optional) - callback invoked before the layer props are updated. Receives a single argument  info : info.testCase  (Object) - the current test case info.layer  ( Layer ) - the old layer onAfterUpdate  (Function, Optional) - callback invoked after the layer props have been updated. This allows the test case to verify that the layer's state has been correctly updated, or that certain functions (spies) have been called etc. Receives a single argument  info :\n {layer, oldState, subLayers, subLayer, spies: spyMap} . info.testCase  (Object) - the current test case info.layer  ( Layer ) - the updated layer info.oldState  (Object) - layer state before the update info.subLayers  (Array) - sub layers rendered, if the layer is composite info.subLayer  ( Layer ) - the first sub layer rendered, if the layer is composite info.spies  (Object) - key are layer method names and values are  spies . Note that  onAfterUpdate  is called immediately after the props are updated. If the layer contains asynchronous props, they may not have been loaded at this point. When using  TestLayerAsync ,  onAfterUpdate  is called multiple times until all resources are loaded. Source modules/test-utils/src/lifecycle-test.js","headings":[{"value":"testLayer","depth":1},{"value":"Example","depth":2},{"value":"Usage","depth":2},{"value":"Test Cases","depth":3},{"value":"Source","depth":2}],"slug":"docs/api-reference/test-utils/test-layer","title":"testLayer"},{"excerpt":"Installing and Running Examples Installation To install the deck.gl framework: or The  deck.gl  module includes all deck.gl features and their dependencies. If you want to selectively install a subset of the features, see the  Dependencies  section below. Running the Examples The deck.gl repository contains an  examples folder  with a selection of small, standalone examples that could be good starting points for your application. You should be able to copy these folders to your preferred locations, and get them running simply as follows: Clone the deck.gl repo, if you haven't already For most consistent results, it is recommended that you check out the latest release branch (e.g.  8.0-release ) instead of  master  when running examples. Change directory to the example you are interested in, e.g. Then install dependencies using the installer of your choice: and then running using: If the example uses a mapbox base map you need a  Mapbox access token If you want to build the example against the latest deck.gl source code in the cloned repo (rather than the published version of deck.gl listed in the examples  package.json ) The examples on the  master  branch are updated to use features from the latest, unreleased version of deck.gl. If some example doesn't work using  npm start  it can be worth trying  npm run start-local . While all examples support  npm run start-local , there are some caveats when running against local source. Most importantly, you must make sure to run  npm install  or  yarn  in the deck.gl root folder before running  npm run start-local  in an example folder. Selectively Install Dependencies A family of NPM modules are published as part of the deck.gl framework. The following tree shows their scope and dependencies: @deck.gl/core  - Core module that handles the WebGL rendering pipeline, data management, and user interaction @deck.gl/layers  - Primitive layers that are the building blocks of all visualizations @deck.gl/aggregation-layers  - Advanced layers that aggregate data into alternative representations, e.g. heatmap, contour, hex bins, etc. @deck.gl/geo-layers  - Additional layers that handle geospatial use cases and GIS formats. @deck.gl/mesh-layers  - Additional layers that render 3D meshes and  scene graphs . @deck.gl/json  - Declarative interface that supports specifying deck.gl layers and views using a JSON format. @deck.gl/mapbox  - An integration with the  Mapbox custom layer  API. @deck.gl/react  - React wrapper of deck.gl. @deck.gl/test-utils  - Testing utilities. For example, to render a  PointCloudLayer , you may install: To use the  HexagonLayer  with React, you need to install: While installing submodules separately affords applications the maximum control over the dependencies that it pulls in, the submodule versions are expected to be synchronized manually in order to produce consistent results. The  deck.gl  master module includes all submodules except for  @deck.gl/test-utils . Most bundling solutions (Webpack, Rollup etc.) offer tree-shaking capabilities that exclude unused exports from a production build.","headings":[{"value":"Installing and Running Examples","depth":1},{"value":"Installation","depth":2},{"value":"Running the Examples","depth":2},{"value":"Selectively Install Dependencies","depth":2}],"slug":"docs/get-started/getting-started","title":"Installing and Running Examples"},{"excerpt":"Base Maps While deck.gl works independently without any map component, when visualizing geospatial datasets, a base map can offer invaluable context for understanding the overlay layers. Base Maps Renderers deck.gl has been designed to work in tandem with popular JavaScript base map providers. Depending on your tech stack, deck.gl's support for a particular base map solution may come with different level of compatibility and limitations. There are two types of integration between deck.gl and a base map renderer: Overlaid : the Deck canvas is rendered over the base map as a separate DOM element. Deck's camera and the camera of the base map are synchronized so they pan/zoom together. This is the more robust option since the two libraries manage their renderings independently from each other. It is usually sufficient if the base map is 2D. Interleaved : Deck renders into the WebGL context of the base map. This allows for occlusion between deck.gl layers and the base map's labels and/or 3D features. The availability of this option depends on whether the base map solution exposes certain developer APIs, and may subject the user to bugs/limitations associated with such APIs. Library Pure JS React Overlaid Interleaved Docs ArcGIS API for JavaScript ✓ ✓ example link Google Maps JavaScript API ✓ ✓ example example link harp.gl ✓ example Leaflet ✓ example Mapbox GL JS ✓ ✓ example example link MapLibre GL JS ✓ ✓ example example link It is also important to understand the difference between the JS library that renders the map and the map data provider. For example, you can use Mapbox GL JS with the Mapbox service, but also with any other service that hosts Mapbox Vector Tiles. When using a base map, be sure to follow the terms and conditions, as well as the attribution requirements of both the JS library and the data provider.","headings":[{"value":"Base Maps","depth":1},{"value":"Base Maps Renderers","depth":2}],"slug":"docs/get-started/using-with-map","title":"Base Maps"},{"excerpt":"Using deck.gl without React The deck.gl core library and layers have no dependencies on React or Mapbox GL and can be used by any JavaScript application. Our  get-started examples  contains vanilla JavaScript templates that serve as a starting point for your application. Using @deck.gl/core  @deck.gl/core  is a submodule of deck.gl that contains no React dependency. The  Deck  class takes deck.gl layer instances and viewport parameters, and renders those layers as a transparent overlay. Using the Scripting API deck.gl also offers a standalone bundled version of the library - a native JavaScript scripting interface like that of d3.js. You can now use deck.gl in prototype environments such as  Codepen ,  JSFiddle  and  Observable . This effort aims to make it easier for designers, creative coders and data scientists everywhere to leverage WebGL for interactive visualizations. To use deck.gl in a scripting environment, include the standalone version in a  script  tag: It exposes two global objects  deck  and  luma . Any exports from the deck.gl core can be accessed by  deck.<Class> . The scripting API's  DeckGL  class extends the core  Deck  class with some additional features such as Mapbox integration. Check our codepen  showcase  and  observable profile  for examples.","headings":[{"value":"Using deck.gl without React","depth":1},{"value":"Using @deck.gl/core","depth":2},{"value":"Using the Scripting API","depth":2}],"slug":"docs/get-started/using-standalone","title":"Using deck.gl without React"},{"excerpt":"Using deck.gl with TypeScript Starting from v8.8, deck.gl publishes \"public preview\" TypeScript types via an opt-in only entry point. To use the official types in your application, find the following statements: and replace the package name with  @deck.gl/<module_name>/typed : You can also import additional type definitions: Note that the typed exports are a work in progress. They are not exposed by default to prevent any typing errors from breaking existing TypeScript applications. Help us improve them by reporting any issues or suggestions on GitHub! The typed exports will remain at the  typed  entry points throughout the rest of the 8.x releases. They will be exposed directly at the package roots starting in v9.0. Alternative Solution for Legacy Versions If you are using a version before v8.8, a third-party typings library is available. Find the compatible version of  @danmarshall/deckgl-typings  based on your  deck.gl  version: deck.gl version deckgl-typings version 5.x.x 1.x.x 6.x.x 2.x.x 7.x.x 3.x.x 8.x.x 4.x.x For example, for  deck.gl  7.x, install the following package: Create a new file like  deckgl.d.ts  in your source directory with the following code:","headings":[{"value":"Using deck.gl with TypeScript","depth":1},{"value":"Alternative Solution for Legacy Versions","depth":2}],"slug":"docs/get-started/using-with-typescript","title":"Using deck.gl with TypeScript"},{"excerpt":"Using deck.gl with React While not directly based on React, deck.gl is designed from ground up to work with  React  based applications. deck.gl layers fit naturally into React's component render flow and flux/redux based appications. deck.gl layers will be performantly rerendered whenever you rerender your normal JSX or React components. The DeckGL React Component To use deck.gl with React, simply import the  DeckGL  React component and render it as a child of another component, passing in your list of deck.gl layers as a property. Adding a Base Map An important companion to deck.gl is  react-map-gl . It is a React wrapper for  Mapbox  that can share the same web mercator viewport settings. Using JSX with deck.gl Layers It is possible to use JSX syntax to create deck.gl layers as React children of the  DeckGL  React components, instead of providing them as ES6 class instances to the  layers  prop. There are no performance advantages to this syntax but it can allow for a more consistent, React-like coding style. For more information on this syntax and its limitations, see  DeckGL API . Using JSX with deck.gl views It is possible to use JSX syntax to create deck.gl views as React children of the  DeckGL  React components, instead of providing them as ES6 class instances to the  views  prop. The following code renders the same set of layers in two viewports, splitting the canvas into two columns: For more information on this syntax, see  DeckGL API . Remarks The  DeckGL  component is typically rendered as a child of a\nmap component like  react-map-gl ,\nbut could be rendered as a child of any React component that you want to\noverlay your layers on top of. To achive the overlay effect, the  DeckGL  component creates a transparent\n canvas  DOM element, into which the deck.gl layers passed in the  layers \nprop will render (using WebGL). Since this canvas is transparent, any\nother component you have underneath (typically a map) will visible behind\nthe layers. When the deck.gl layer list is drawn to screen, it matches the new Layer\ninstances with the instances from the previous render call, intelligently\ncompares the new properties and only updates WebGL state when needed\n(just like React does for DOM components). Internally, the  DeckGL  component initializes a WebGL context\nattached to a canvas element, sets up the animation loop and calls provided\ncallbacks on initial load and for each rendered frame. The  DeckGL \ncomponent also handles events propagation across layers, and prevents\nunnecessary calculations using React and deck.gl lifecycle functions. See  full API doc  for the  DeckGL  component.","headings":[{"value":"Using deck.gl with React","depth":1},{"value":"The DeckGL React Component","depth":2},{"value":"Adding a Base Map","depth":2},{"value":"Using JSX with deck.gl Layers","depth":2},{"value":"Using JSX with deck.gl views","depth":2},{"value":"Remarks","depth":2}],"slug":"docs/get-started/using-with-react","title":"Using deck.gl with React"},{"excerpt":"Animations and Transitions This document was recently added and is still being finalized deck.gl provides several ways to implement animation and transitions. Camera Transitions  - (aka View State Transitions) when changing the view state, deck.gl can move the camera smoothly between the initial and final view state. Layer Transitions  - (aka Attribute Transitions) Property Animation  - Animation Drawing Constantly vs. When Needed While some 3D applications such as games often keep drawing to screen at a high frame rate, deck.gl avoids this by default. When not animating, deck.gl is optimized to only render to the screen when something changes (a layer's data or props, the viewState etc). This keeps the GPU and CPU load low and minimizes power consumption. However when animating properties, deck.gl needs to update the screen frequently. This does consume more power and can cause fans to spin up etc. However, even when animating deck.gl does not draw to the screen when the application's browser tab is not active. Property Animation Layer properties are divided into two categories. Accessors (that control \"attributes\" and only update when data changes or update triggers fire) and non-accessors that update every time the layer is rendered. Property animation refers to assigning functions as values to non-accessor layer props. The functions will be called every render frame, potentially generating new values every frame at 60 FPS. Advantages of Property Animation While it is certainly possible to implement deck.gl animation by supplying a \"freshly minted\" list of layers to the deck.gl component every frame, e.g. using  Deck.setProps({layers: [new ...Layer(...), ...]}) , this approach has a performance penalty as both your application logic and deck.gl's layer matching system must kick into gear each render frame. By setting property animation functions, properties will be evaluated by the underlying render loop system with considerably less overhead, both deck.gl and your application will essentially remain undisturbed as the layer properties are updated inside a tight inner animation loop. Transitions Transitions in deck.gl are short animations that are triggered when deck.gl detects a change of some property. Instead of immediately redrawing based on the new view value, deck.gl draws a number of frames, automatically interpolating the value over time. View State Transitions View state transitions provide smooth and visually appealing camera transitions when view states change. View state transitions are initiated by updating the  Deck.viewState  prop. Following fields of  viewState  can be used to achieve viewport transitions. transitionDuration  (Number, optional, default: 0) - Transition duration in milliseconds, default value 0, implies no transition. transitionEasing  (Function, optional, default:  t => t ) - Easing function that can be used to achieve effects like \"Ease-In-Cubic\", \"Ease-Out-Cubic\", etc. Default value performs Linear easing. (list of sample easing functions:  http://easings.net/ ) transitionInterpolator  (Object, optional, default:  LinearInterpolator ) - An interpolator object that defines the transition behavior between two viewports, deck.gl provides  LinearInterpolator  and  FlyToInterpolator . Default value,  LinearInterpolator , performs linear interpolation on  ViewState  fields.  FlyToInterpolator  animates  ViewStates  similar to MapBox  flyTo  API and applicable for  MapState , this is pretty useful when camera center changes by long distance. But a user can provide any custom implementation for this object using  TrasitionInterpolator  base class. transitionInterruption  (TRANSITION_EVENTS (Number), optional, default: BREAK) - This field controls how to process a new  ViewState  change that occurs while performing an existing transition. This field has no impact once transition is complete. Here is the list of all possible values with resulting behavior. TRANSITION_EVENTS Result BREAK Current transition will stop at the current state and next  ViewState  update is processed. SNAP_TO_END Current transition will skip remaining transition steps and  ViewState  is updated to final value, transition is stopped and next  ViewState  update is processed. IGNORE Any  ViewState  update is ignored until current transition is complete, this also includes  ViewState  changes due to user interaction. onTransitionStart  (Functional, optional) - Callback fires when requested transition starts. onTransitionInterrupt  (Functional, optional) - Callback fires when transition is interrupted. onTransitionEnd  (Functional, optional) - Callback fires when transition ends. TransitionInterpolators LinearInterpolator  -  Performs linear interpolation between two ViewStates. FlyToInterpolator  - This class is designed to perform  flyTo  style interpolation between two  MapState  objects. TransitionInterpolator  - Base interpolator class that provides common functionality required to interpolate between two ViewState props. This class can be subclassed to implement any custom interpolation: Examples Sample code that provides  flyTo  style transition to move camera from current location to NewYork city. Sample code to get continuous rotations along vertical axis until user interrupts by rotating the map by mouse interaction. It uses  LinearInterpolator  and restricts transitions for  bearing  prop. Continuous transitions are achieved by triggering new transitions using  onTranstionEnd  callback.","headings":[{"value":"Animations and Transitions","depth":1},{"value":"Animation","depth":2},{"value":"Drawing Constantly vs. When Needed","depth":3},{"value":"Property Animation","depth":3},{"value":"Advantages of Property Animation","depth":3},{"value":"Transitions","depth":2},{"value":"View State Transitions","depth":3},{"value":"TransitionInterpolators","depth":3},{"value":"Examples","depth":3}],"slug":"docs/developer-guide/animations-and-transitions","title":"Animations and Transitions"},{"excerpt":"Using Binary Data Binary data support in deck.gl is actively being developed. This article provides information on current state and some hints about what may come. Binary Data If you plan to work with binary data, you will want to make sure you are up to speed on JavaScript typed arrays as well as GPU buffers, both in terms of general concepts as well as a basic grasp of the API. JavaScript has a number of different ways to represent binary data (Browser  Blob , Node.js Buffers, base64 etc), however deck.gl primarily accepts typed arrays. deck.gl should accept GPU buffers ( WebGLBuffer  or luma.gl  Buffer  instances). CPU vs GPU memory Ultimately all deck.gl rendering is done on the GPU, and all memory must be available to the GPU by being \"uploaded\" into GPU memory  Buffers . By pre-creating GPU buffers and passing these to deck.gl layers you exercise the maximum amount of control of memory management. Note that GPU buffers have many advanced features. They can be interleaved etc. The luma.gl  Accessor  class lets you describe how GPU Buffers should be accessed. Endianness In most cases, when working with binary data, care must be taken to properly define and respect \"endianness\" which essentially describes the order of bytes when larger numbers are stored in memory. However, essentially all of the current web is little endian, so potential big-endian issues are ignored for now. Flattened vs. Nested Data Binary data is flat, whereas JavaScript Arrays can have structure Interleaved Data Binary data can be interleaved. Working directly with interleaved data requires working with  luma.gl  Buffer  instances and attribute accessor objects and is considered an advanced topic. Binary Table Formats deck.gl layers are designed to accept \"tables\" of data as input (the  data  prop). Tables can be organized in several different ways. For binary data you will be working with columnar tables. Row-Based Tables (non-Binary) Row-based tables are the most common and generally the easiest to work with (each row is typically a JavaScript object with fields representing the values of various columns at that row). Columnar Tables Organizing values by column instead of row creates a columnar table. Columnar tables can be significantly more efficient. In particular, because each value is of the same type, columnar tables can be stored as binary data. To use a columnar table as layer data, provide a bundle of typed arrays (a \"vector bundle\"?) as your  data  prop: Chunked Columnar Tables A disadvantage of columnar tables is that columns can get very long, blocking incremental reads/writes of tables and even exceeding platform's allocation limits. More advanced binary columnar table formats like Apache Arrow solves this by breaking logical arrays into chunks. An additional benefit of chunked arrays can support remarkably efficient data-frame operations (slicing/dicing and filtering multi-gigabyte data set with \"zero cost\"). Another complication when using binary columnar tables is that it may not be possible to represent e.g. the lack of a value. In some libraries (e.g. Apache Arrow) this is solved through an additional  null map . Thus, a downside of chunked arrays is that they are complex to work with that they typically require an API (such as Apache Arrow). Chunked Arrow Arrays follows a more complicated relationship with  Vector  instances representing chunks: Table ---* Column (Chunked) ---* Vector Note: These cannot currently be used in deck.gl without pre-concatenating the chunks. There is an RFC (chunked-data-rfc) that would enable chunked data tables (data frames) to be directly consumed by deck.gl (and then sliced and diced at zero cost). Using Binary Data It is sometimes desirable for applications to work directly with binary data and to be able to pass such binary data directly to layers. The motivation is often performance-related but it could just be that the application is able to load data directly in a binary format. Using typed arrays as layer input data  - Using The input data is in binary form, perhaps it is delivered this way from the back-end, and it would be preferable to not have to unpack it. Using typed arrays or GPU buffers directly as layer attributes  - The input data is already formatted in the memory format expected by the GPU and deck.gl's shaders. Using Binary Data directly in GPU The simplest way to supply binary data to deck.gl layers is to override normal attribute calculation and feed in a binary typed array to be used directly as the attribute. This requires that the binary data columns are formatted in exactly the way that the layer expects. This is often fairly straight forward for  fixed primitive layers  but not often practical for  variable primitive layers , as the number of vertices per primitive depends on the details of the tesselation algorithm which can be hard for the data provided to anticipate. Using Binary Data to Calculate Attributes in GPU/GLSL This would mean passing binary data into the vertex shader and there use it to calculate the values the layer needs (colors, elevations etc). This use case would involve writing custom accessor functions. It is currently not directly supported in deck.gl, but could be achieved by creating a custom layer. There are RFCs (glsl accessors, texture attributes) that if implemented, would dramatically improve deck.gl's ability to use provided binary data attributes without pre-processing them in JavaScript. Use Binary Data to Generate Attributes in CPU/JavaScript JavaScript iteration approaches for binary data bundles are under development for v7","headings":[{"value":"Using Binary Data","depth":1},{"value":"Binary Data","depth":2},{"value":"CPU vs GPU memory","depth":3},{"value":"Endianness","depth":3},{"value":"Flattened vs. Nested Data","depth":3},{"value":"Interleaved Data","depth":3},{"value":"Binary Table Formats","depth":2},{"value":"Row-Based Tables (non-Binary)","depth":3},{"value":"Columnar Tables","depth":2},{"value":"Chunked Columnar Tables","depth":2},{"value":"Using Binary Data","depth":2},{"value":"Using Binary Data directly in GPU","depth":2},{"value":"Using Binary Data to Calculate Attributes in GPU/GLSL","depth":2},{"value":"Use Binary Data to Generate Attributes in CPU/JavaScript","depth":2}],"slug":"docs/developer-guide/binary-data","title":"Using Binary Data"},{"excerpt":"Building Apps This article contains additional information on options for how to build deck.gl. Optimizing for Bundle Size deck.gl and luma.gl provide a lot of functionality and the amount of code these libraries contain will of course impact the size of your application bundle and your startup load time. There are multiple techniques used in JavaScript. Choosing an entry point When installed from npm, deck.gl and related libraries come with two separate distributions. Directory mainField Description dist/es5 main All code is transpiled to be compatible with the most commonly adopted evergreen browsers (see below). Exports/imports are transpiled into  commonjs  requires. The main reason to use this distribution is under Node.js (e.g. unit tests), or if your bundler does not support tree-shaking using  import / export . dist/esm module Same as  dist/es5 , except  export  and  import  statements are left untranspiled to enable tree shaking. You will have to check the documentation of your particular bundler to see what configuration options are available. Webpack picks  module  main field over  main  if it is available. You can also explicitly choose one distribution by specifying a  resolve.mainFields  array. The transpilation target is set to  >0.2%, maintained node versions, not ie 11, not dead, not chrome 49  resolved by  browserslist . To support older or less common browsers, you may use  @babel/preset-ev  in your babel settings and include  node_modules . About Tree-Shaking deck.gl was designed from the start to leverage tree-shaking. This technique has been talked about for quite some time but has been slow in actually providing the expected benefits. With the combination of webpack 4 and babel 7 we are finally starting to see significant results, so you may want to experiment with upgrading your bundler if you are not getting results. Note that tree-shaking still has limitations: At least in webpack, tree shaking is done by the uglifier, which is typically only run on production builds, so it is typically not possible to assess the benefits of tree shaking during development. In addition, this makes it even harder to make statements about bundle size impact from looking at bundle sizes in development builds. The recommendation is to always measure impact on your final production builds. Static dependency analyzers err on the side of safety and will still include any symbol it is not sure will never be used. This is compounded by the fact that there are side effects in various language feature that complicate or defeat current static dependency analysis techniques, causing \"dead code\" to still be bundled. The good news is that the analyzers are getting better. Naturally, an application that uses all the functionality offered by the library will benefit little from tree shaking, whereas a small app that only uses a few layers should expect bigger savings. Bundle Size Numbers So, what bundle size impact should you expect? When do you know if you have set up your bundler optimally. To help answer these questions, we provide some numbers you can compare against. deck.gl has scripts that measure the size of a minified bundle after each build, which allows us to provide comparison numbers between releases. Entry point 8.5 Bundle (Compressed) 8.4 Bundle (Compressed) Comments esm 398 KB (115 KB) 485 KB (128 KB) Transpiled, tree-shaking enabled es5 686 KB (178 KB) 812 KB (197 KB) Transpiled, no tree-shaking Notes: Numbers represent the bundle size of a minimal application, bundled with Webpack 4, which means that the untransipiled and the ESM distribution results benefit from some tree shaking. The number in parenthesis is the compressed bundle size. This is how much bigger you might expect your gzipped bundle to get by adding deck.gl as a dependency to your application. Future Work This is not the final word on deck.gl bundle size. More work is being done to reduce the size of deck.gl and we are confident that even as future releases will have more functionality, we will be able to keep the library code from growing and, more importantly, make deck.gl even more \"tree shakeable\", with the intention that apps should only \"pay for what they use\". Remarks Optimizing for minified code  - Due to inclusion of sourcemaps etc, the bundle size impact of deck.gl tends to look more significant in development builds than in the final production builds. While reducing the size of the development libraries is also desirable, the current goal is to ensure the impact of adding deck.gl on the final, minified/uglified application bundle is as small as possible. Compressed bundle sizes are calculated using  gzip -9 . Consider using slower  brotli  compression for static assets, it typically provides an additional 20% reduction.","headings":[{"value":"Building Apps","depth":1},{"value":"Optimizing for Bundle Size","depth":2},{"value":"Choosing an entry point","depth":3},{"value":"About Tree-Shaking","depth":3},{"value":"Bundle Size Numbers","depth":3},{"value":"Future Work","depth":3},{"value":"Remarks","depth":2}],"slug":"docs/developer-guide/building-apps","title":"Building Apps"},{"excerpt":"About 64-bit Layers deck.gl can leverage high precision GPU floating point using emulated 64-bit floating point. For supported layers (look for the 64-bit icon in the docs), 64-bit shaders are used when the  fp64  prop is set to true. With the improved precision 32 bit projection mode in deck.gl 6.1, the use of  fp64  is no longer required to achieve sub-centimeter precision. The new 32 bit projection mode has much better performance. This makes the  fp64  mode more of a niche technology that demonstrates how to use 64 bit calculations should you need to use them in your own applications. Precision With 64-bit floating point support in shader, deck.gl layers is able to visualize data with very high dynamic range. Points covering a whole city and accurate down to sub-centimeter level can be processed and rendered to canvas on-the-fly. Since WebGL does not support 64-bit floating point, deck.gl uses two 32-bit native floating point number to extend and preserve significant digits and uses algorithms similar to those used in many multiple precision math libraries to achieve the precision close to what IEEE-754 double precision floating point numbers provide. Generally speaking, this mechanism provide 46 significant digits in mantissa (48 overall) within the normal range of 32-bit single precision float point numbers. This transfers to ~  1x10^-15  relative error within ~  1.2x10^-38  and  1.7x10^+38 . The error bound as tested on 2015 MacBook Pro with AMD Radeon R9 M370X GPU: Operation Error Addition < 1 ulp Subtraction < 1 ulp Multiplication ~1.5 ulps Division ~2 ulps Square root ~2.6 ulps Exponential ~2.6 ulps Logarithm ~11.6 ulps Trigonometry ~5 ulps Note:  ulp  =  unit of least precision Performance Implications Since the 64-bit floating point maths are emulated using the multiple precision arithmetics, it costs more GPU cycles than native 32-bit\nmath (the shader execution time alone is about 10x slower). However, since 64-bit floating point maths are usually only required in vertex shader, the overall performance impact is usually less than 10x. There will be a memory impact too, in that all vertex attributes and uniform that uses 64-bit maths require double storage space in JavaScript. Same as mentioned above, since a layer usually has some attributes that do not require 64-bit maths, the total memory impact is normally significantly less than 2x. Shaders are more complex and can take time to compile on some systems, notably Windows. For more information regarding the performance of 64-bit layers, please check the performance benchmark layers in the layer-browser example in deck.gl repo. Other Considerations 64-bit shaders push the GPU drivers quite a bit, and workarounds are needed to prevent GPU drivers from optimizing away critical parts of the code. The fp64 shader module has been tested on a range of GPUs and drivers however every now and then we encounter a new driver that needs special treatment. If you mainly deploy into a know set of clients that you can test in advance, this is not a big issue, however if you expect your applications to work across a large set of devices you may want to stay with 32-bit calculations. References http://crd-legacy.lbl.gov/~dhbailey/mpdist https://gmplib.org","headings":[{"value":"About 64-bit Layers","depth":1},{"value":"Precision","depth":2},{"value":"Performance Implications","depth":2},{"value":"Other Considerations","depth":2},{"value":"References","depth":2}],"slug":"docs/developer-guide/64-bits","title":"About 64-bit Layers"},{"excerpt":"Controllers This page is a placeholder deck.gl supports several models of event handling and viewport controls Viewport Controls States ... Customizing Controls About Event Handling","headings":[{"value":"Controllers","depth":1},{"value":"Viewport Controls","depth":2},{"value":"States","depth":2},{"value":"Customizing Controls","depth":2},{"value":"About Event Handling","depth":2}],"slug":"docs/developer-guide/controllers","title":"Controllers"},{"excerpt":"Adding Interactivity Controlling the Camera Out of the box, deck.gl offers viewport controllers that map keyboard, mouse or touch input to camera state change. The easiest way to enable pan/zoom/rotate of the visualization is to set the  controller  prop on  Deck  or  <DeckGL>  to  true  along with an  initialViewState  object that defines the initial camera settings: You can also selectively enable/disable certain controller features: See  Controller  for all options. Reset Camera Position An application can reset the camera state by supplying a new  initialViewState  object at any time: To add a transition animation, see  view state transitions . Add Constraints to View State An application can optionally supply the  onViewStateChange  callback and manipulate the view state before it is used. The following example constrains the map in a bounding box: Externally Manage View State For more flexibility you can maintain the view state yourself and pass it in to deck.gl via the  viewState  parameter. This essentially makes  Deck / <DeckGL>  a stateless component, and allows you to share the view state between multiple components, e.g. via a Redux store. Note: Do not combine  initialViewState  and  viewState  props.  viewState  will always overwrite any internal state. The following example demonstrates how to do this with React: Advanced View Controls Alternative views such as OrbitView, FirstPersonView, and using multiple views such as VR, minimap:  Views and Projections Implement a custom controller:  Controller Picking deck.gl includes a powerful picking engine that enables the application to precisely determine what object and layer is rendered on a certain pixel on the screen. This picking engine can either be called directly by an application (which is then typically implementing its own event handling), or it can be called automatically by the basic built-in event handling in deck.gl What can be Picked? The \"picking engine\" identifies which object in which layer is at the given coordinates. While usually intuitive, what constitutes a pickable \"object\" is defined by each layer. Typically, it corresponds to one of the data entries that is passed in via  prop.data . For example, in  Scatterplot Layer , an object is an element in the  props.data  array that is used to render one circle. In  GeoJson Layer , an object is a GeoJSON feature in the  props.data  feature collection that is used to render one point, path or polygon. Enabling Picking Picking can be enabled or disabled on a layer-by-layer basis. To enable picking on a layer, set its  pickable  prop to  true . This value is  false  by default. The Picking Info Object The picking engine returns \"picking info\" objects which contains a variety of fields describing what layer and object was picked. Key Value layer The layer that the picked object belongs to. Only layers with the  pickable  prop set to true can be picked. index The index of the object in the layer that was picked. object The object that was picked. This is typically an entry in the layer's  props.data  array, but can vary from layer to layer. x Mouse position x relative to the viewport. y Mouse position y relative to the viewport. coordinate Mouse position in geospatial coordinates. Only applies if  layer.props.coordinateSystem  is a geospatial mode such as  COORDINATE_SYSTEM.LNGLAT . viewport The viewport that the picked object belongs to. Remarks: Specific deck.gl Layers may add additional fields to the picking  info  object. Check the documentation of each layer. Limitation when using multiple views:  viewport  could potentially be misidentified if two views that contain the picked layer also overlap with each other and do not clear the background. Example: Display a Tooltip for Hovered Object Using the Built-In Tooltip Deck  automatically renders a tooltip if the  getTooltip  callback is supplied: It receives a picking info object and returns the content of the tooltip. To custom the tooltip further, return an object instead: For a range of options, see  getTooltip  documentation. Using React Calling the Picking Engine Directly The picking engine is exposed through the  Deck.pickObject  and  Deck.pickObjects  methods. These methods allow you to query what layers and objects within those layers are under a specific point or within a specified rectangle. They return  Picking Info  objects as described below. pickObject  allows an application to define its own event handling. When it comes to how to actually do event handling in a browser, there are many options. In a React application, perhaps the simplest is to just use React's \"synthetic\" event handling together with  pickObject : Also note that by directly calling  queryObject , integrating deck.gl into an existing application often becomes easier since you don't have to change the application's existing approach to event handling. Under The Hood If you are using the core layers, all has been taken care of. If you are implementing a custom layer, read more about\n how picking is implemented . Built-in Events For applications that have basic event handling needs, deck.gl has built-in support for handling selected pointer events. When the application registers callbacks, deck.gl automatically tracks these events, runs the picking engine and calls application callbacks with a single parameter  info  which contains the resulting picking info object. The following event handlers are supported: onHover onClick onDragStart onDrag onDragEnd A event handler function is called with two parameters:  info  that contains the object being interacted with, and  event  that contains the pointer event. There are two ways to subscribe to the built-in picking event handling: Specify callbacks for each pickable layer by passing  event handler props : Specify callbacks for all pickable layers by setting  event handler props  of the  DeckGL  canvas: Behavior of Built-in Event Handling Picking events are triggered based on  pickable objects : A  click  event is triggered every time the pointer clicked on an object in a pickable layer. A  hover  event is triggered every time the hovered object of a pickable layer changes. When an event is fired, the  onHover  or  onClick  callback of the affected layer is called first. If the callback returns a truthy value, the event is marked as handled. Otherwise, the event will bubble up to the  DeckGL  canvas and be visible to its  onHover  and  onClick  callbacks.","headings":[{"value":"Adding Interactivity","depth":1},{"value":"Controlling the Camera","depth":2},{"value":"Reset Camera Position","depth":3},{"value":"Add Constraints to View State","depth":3},{"value":"Externally Manage View State","depth":3},{"value":"Advanced View Controls","depth":3},{"value":"Picking","depth":2},{"value":"What can be Picked?","depth":3},{"value":"Enabling Picking","depth":3},{"value":"The Picking Info Object","depth":3},{"value":"Example: Display a Tooltip for Hovered Object","depth":3},{"value":"Using the Built-In Tooltip","depth":4},{"value":"Using React","depth":4},{"value":"Calling the Picking Engine Directly","depth":3},{"value":"Under The Hood","depth":3},{"value":"Built-in Events","depth":2},{"value":"Behavior of Built-in Event Handling","depth":3}],"slug":"docs/developer-guide/interactivity","title":"Adding Interactivity"},{"excerpt":"Debugging deck.gl provides support for debugging applications and layers, which includes: deck.gl logging luma.gl debugging support deck.gl logging deck.gl (and luma.gl) are based on the probe.gl debugging library, providing user configurable console logging with advanced functions like the ability to log images and tables etc to the console. In your browser console, select the log level you would like: Log level Description 0 Critical logs only 1 Logs the reason for redraws and picking operations 2 Logs layer updates 3+ Additional logging around layer lifecycle, prop diffing etc Starting v8.0, deck.gl no longer bundles the debugging module in production mode. This includes the pre-bundled  dist.min.js , and any bundle built with the environment variable  NODE_ENV=production . To enable debugging in a production build, you may include the pre-bundled debug module  AFTER  the deck.gl bundle: WebGL debugging using luma.gl For lower level debugging, including debugging of layer rendering and picking, deck.gl is built on luma.gl which has extensive debugging and instrumentation support for WebGL level code and GPU input values (shader uniforms and attributes). To enable debug logging simply issue the following commands in your browser console: The following features are available: Automatic sanity checks are performed on uniforms and attributes. Passing an  undefined  value to a uniform is a common JavaScript mistake that will immediately generate a descriptive exception in deck.gl. This can be tracked from the console output. The  Deck  class and  DeckGL  react component have a debug flag which instructs luma.gl to instruments the gl context (with a performance cost) which allows tracing all WebGL call errors, see below on luma debug log levels. It also generates exceptions immediately when a WebGL operation fails, allowing you to pinpoint exactly where in the code the issue happened. Due to the asynchronous nature of the GPU, some WebGL execution errors are surfaced and caught later than the calls that generate them. In the browser console, setting  luma.log.level  to various values will enable increasing levels of debugging. Log level Description 0 Critical logs only 1 Minimal logging 2 and 3 Will display all uniforms and attributes before each draw call, allowing you to be confident in what values your shaders are actually working on. 4 Will trace every single gl call.","headings":[{"value":"Debugging","depth":1},{"value":"deck.gl logging","depth":2},{"value":"WebGL debugging using luma.gl","depth":2}],"slug":"docs/developer-guide/debugging","title":"Debugging"},{"excerpt":"Coordinate Systems In most deck.gl layers, every data object is expected to contain one or more  positions  (e.g. the center of a point, or the start and end of an arc, the vertices of a polygon, etc). Positions are expected to be supplied as two or three element arrays ( [x, y]  or  [x, y, z] ). Objects can also have  dimensions  (e.g. the radius of a circle, the width of a path, etc), most of which are specified as a single number. Positions and dimensions are used to construct a 3D world with your data. deck.gl supports a selection of coordinate systems, addressing diverse geospatial and non-geospatial use cases. Each layer can set its own  coordinateSystem  prop to specify how its positions should be interpreted. Layers using different coordinate systems can be composed together, which is very useful when dealing with datasets from different sources. Many layers also provide props for defining the units that dimensions are measured in, usually named as  *Units . A layer can leverage such props to control its appearance in a way that makes the most sense for the data and the desired user experience. Concepts Throughout this document you will find reference to the following  coordinate spaces  in deck.gl's projection system: World space The natural coordinate system of a dataset. It is usually determined by the source of the data, like the device it is generated on, and the format that it is stored as on disk or a cloud data warehouse. Some examples of different world space definitions include a  Shapefile  with any  standard geospatial reference ; WGS84 as used by GeoJSON or KML; GPS traces; LIDAR scans; info-vis values that do not map to real-world dimensions;  Slippy Map  tiles from services like OpenStreetMaps and Mapbox; 3D tiling standards such as  Cesium 3D Tiles  and  Esri I3S . Positions in different world spaces come with different scales and orientations, may be measured relative to static or dynamic reference points, and in many cases their scales are not linear. It is common for an application to overlay multiple datasets from different world spaces into the same 3D view. Common space To correctly compose data from various world spaces together, deck.gl transforms them into common space - a unified, intermediate 3D space that is a  right-handed Cartesian coordinate system . Once positions are in the common space, it is safe to add, substract, rotate, scale and extrude them as 3D vectors using standard linear algebra. This is the basis of all geometry processing in deck.gl layers. The transformation between the world space and the common space is referred to in deck.gl documentation as \"project\" (world space to common space) and \"unproject\" (common space to world space), a process controlled by both the specification of the world space, such as WGS84, and the  projection mode , such as Web Mercator. Projections are implemented as part of deck.gl's core. Screen space A top-left coordinate system that runs from  [0, 0]  to  [viewportWidth, viewportHeight] , measured in pixels. For a given dataset, positions in the common space normally do not change with user interaction, while their appearance in screen space can be frequently changing as the user pans, zooms and rotates the camera. Positions Each layer is expected to specify its  coordinateSystem  prop to match the world space of its  data . Within the data supplied to a single layer, all positions will be interpreted in the same coordinate system. By default, a layer's  coordinateSystem  is assumed to be  COORDINATE_SYSTEM.LNGLAT  if rendered in a geospatial view (e.g.  MapView ,  GlobeView ) and  COORDINATE_SYSTEM.CARTESIAN  if rendered in a non-geospatial view (e.g.  OrbitView ,  OrthographicView ). Some coordinate systems need to be used with the  coordinateOrigin  prop, which specifies where the positions are measured from. Supported coordinate systems Coordinate system Positions Coordinate origin Notes COORDINATE_SYSTEM.LNGLAT [longitude, latitude, altitude] ignored Longitude and latitude are specified as  WGS84  coordinates in degrees from Greenwich meridian / equator respectively, and altitude is specified in meters above sea level. COORDINATE_SYSTEM.METER_OFFSETS [Δx, Δy, Δz] [longitude, latitude, altitude] Positions are given in meter offsets from a reference geo-location that is specified by  coordinateOrigin . The  x  axis points map east, the  y  axis points map north, and  z  points up. Only works with geospatial views. COORDINATE_SYSTEM.LNGLAT_OFFSETS [Δlongitude, Δlatitude, Δaltitude] [longitude, latitude, altitude] Positions are given in degree offsets from a reference geo-location that is specified by  coordinateOrigin . Only works with geospatial views. COORDINATE_SYSTEM.CARTESIAN [x, y, z] [x, y, z]  (optional, default  [0, 0, 0] ) A linear system that measures equally on all 3 axes. Remarks: Although  Universal Transverse Mercator  uses similar notions as the  METER_OFFSETS  mode, be aware that the deck.gl offset system does not have the sophistication of the UTM spec and should not be used interchangeably. See the  limitations  section for details. The  CARTESIAN  mode describes positions that are identical in the world space and the common space. It is the default coordinate system when rendering into non-geospatial views. When combined with geospatial views, the positions are treated as common space coordinates for that particular projection mode. The latter can be seen used by the  MVTLayer , where the data decoded from the tiles are already pre-projected onto the Web Mercator plane. Limitations of the offset systems Most cartographic projections, including the  Web Mercator projection , are non-linear. The  METER_OFFSETS  and  LNGLAT_OFFSETS  coordinate systems trade accuracy for performance by approximating the projection with a linearized local projection system. When working on local scales, such as small cities, using meter offsets gives a  very high degree of precision . When visualizing data on large scales, such as countries and continents, projection will only be correct if you use the  LNGLAT  mode. Transforming positions Generally speaking, converting data from one coordinate system to another on the CPU is costly and should be avoided, especially when dealing with spherical coordinates. Whether your data comes in longitude/latitude or meter offsets, the best choice is to just configure any deck.gl layers displaying that data to use the corresponding  coordinateSystem . When dealing with data that come from different coordinate systems, the recommended approach is to render them on separate layers, for each you may specify a coordinate system respectively. Raw data do not always align cleanly with one of the provided coordinate systems. Here are some examples: Instead of meters, offsets and dimensions may come in millimeters, feet or miles. Instead of  x  aligning with map east and  y  aligning with map north, the offsets may be measured by a device with dynamic orientation. This is common in use cases such as a LIDAR scanner mounted on a moving vehicle. Again, converting raw data to match the coordinate system expectations can be very expensive if done on the CPU. This should be avoided whenever possible. Instead, in addition to specifying  coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS  and  coordinateOrigin , a layer could also specify the  modelMatrix  prop as a 4x4 transformation matrix. The  math.gl  library (a light wrapper of  gl-matrix ) can be used for this purpose, which is already a dependency of deck.gl. The  modelMatrix  prop is most useful with the  METER_OFFSETS  and  CARTESIAN  coordinate systems. It is usually the right solution for pre-processing (flipping, rotating, scaling etc) your data, since these operations will be done very performantly in the GPU. Note that these two coordinate systems are the only ones that are linear and uniform in all directions. Longitude and latitude based positions cannot be scaled/rotated/translated correctly with a 4x4 matrix. Dimensions Most deck.gl layers that deal with dimensions allow specifying the dimensions in one of the coordinate spaces, with props such as  radiusUnits  in  ScatterplotLayer ,  sizeUnits  in  IconLayer , and  widthUnits  in  PathLayer . Supported units meters The universal metric unit. Typically used when sizes should correspond with measurements in the physical world. For example, a  PathLayer  may draw the street network in a city from  GeoJSON LineString features, and each path with width that are calculated from the number of lanes. Or an  IconLayer  may draw traffic signs that match their physical dimensions. Exactly how big one meter will appear after projection subjects to the projection mode used. One should be aware that all cartographic projections come with some sort of distortion, for example one meter is projected to different pixel sizes at different latitudes in a  Mercator map . When used with non-geospatial views, this value does not have any tangible meaning and is treated as identical to  common . common One unit in the  common space . When zooming in and out, common sizes scale with the base map. When visualizing numeric values that do not have any cartographic meaning (e.g. population or income), layers often map them to the size of geometries (e.g. radius of circles). In this case, using  common  units may be preferrable as one common unit projects to the same size regardless of where it is on the map. It offers the visual consistency and comparability that  meters  lacks, especially when viewing data on a global scale. pixels One unit in the  screen space . When zooming in and out, pixel sizes remain the same on screen. For example,  PathLayer  evaluates  getWidth: 12, widthUnits: 'pixels'  to the same size as a DOM block with the CSS rule  width: 12px , regardless of the zoom level. This mode is typically used when legibility is important at all zoom levels, such as text labels. When pixel sizes are viewed from a perspective (e.g.  MapView  with  pitch ,  FirstPersonView  or  OrbitView ), the same size may appear bigger if the geometry is positioned closer to the camera, in order to preserve the sense of depth. In this case, one pixel at the focal point of the camera (usually the center of the viewport) is always rendered as one true CSS pixel. Transforming dimensions The most performant way to transform the dimensions for each object is to use an uniform multiplier. Most layers that deal with dimensions provide props such as  radiusScale ,  widthScale ,  sizeScale  etc. Check each layer's documentation for what's available. The conversion between meter sizes and common sizes depend on the projection mode: MapView  and  FirstPersonView : 512 common units equals  C / cos(phi)  where  C  is the circumference of earth, and  phi  is the latitude in radians. GlobeView : 512 common units equals the diameter of the earth. OrbitView  and  OrthographicView : 1 meter unit equals 1 common unit. The conversion between common sizes and pixel sizes: 1 common unit equals  2 ** z  pixel where  z  is the zoom of the current viewport. Comparison to Standard 3D Graphics Concepts If you are familiar with the traditional 3D graphics/game engine terminologies, here is how they map to deck.gl's coordinate spaces: deck.gl's world space maps to the standard \"model space\", i.e. the data that comes in before any transforms have been applied. deck.gl's common space plays the role of standard \"world space\", but there are a few important differences. To compensate for the lack of 64-bit floats in WebGL, deck.gl may apply a dynamic translation to common-space positions, determined by the viewport, to improve the precision of projection. Zoom levels are applied by scaling the view matrix with  Math.pow(2, zoom) .","headings":[{"value":"Coordinate Systems","depth":1},{"value":"Concepts","depth":2},{"value":"World space","depth":5},{"value":"Common space","depth":5},{"value":"Screen space","depth":5},{"value":"Positions","depth":2},{"value":"Supported coordinate systems","depth":3},{"value":"Limitations of the offset systems","depth":3},{"value":"Transforming positions","depth":3},{"value":"Dimensions","depth":2},{"value":"Supported units","depth":3},{"value":"meters","depth":5},{"value":"common","depth":5},{"value":"pixels","depth":5},{"value":"Transforming dimensions","depth":3},{"value":"Comparison to Standard 3D Graphics Concepts","depth":2}],"slug":"docs/developer-guide/coordinate-systems","title":"Coordinate Systems"},{"excerpt":"Tips and Tricks Rendering Tips Per Layer Control of WebGL parameters The base  Layer  class (which is inherited by all layers) supports a  parameters  property that allows applications to specify the state of WebGL parameters such as blending mode, depth testing etc. This can provide signigicant extra control over rendering. The new  parameters  prop leverages the luma.gl v4  setParameters  API, which allows all WebGL parameters to be specified as keys in a single parameter object. z-fighting and Depth Testing A common problem faced by 3D application developers is known as \"z fighting\". It relates to multiple objects being drawn at the same depth in the 3D scene, and due to rounding artifacts in the so called z buffer the GPU cannot accurately determine whether a pixel has already been drawn in a specific place. If you are not using 3D extrusions, the easiest way to get rid of z fighting is typically just to turn off depth testing. It can be done globally or per-layer. Also, if the z-fighting occurs between layers (rather than between elements within a single layers), deck.gl offers a slightly more sophisticated  polygonOffset  property. Browser Blending Modes Occasionally, the default blending in the browser does not give ideal results. In that case you may want to test the tips in this section. To understand why browser blending modes can matter, consider that deck.gl renders in a separate transparent div on top of the map div, so the final composition of the image a user see on the monitor is controlled by the browser according to CSS settings instead of the WebGL settings. One way to control this blending effect is by specifying the CSS property  mix-blend-mode  in modern browsers to be  multiply : multiply  blend mode usually gives the expected results, as it only darkens. This blend mode keeps the overlay colors, but lets map legends underneath remain black and legible. Note:  that there is a caveat with setting  mix-blend-mode , as it can affect other peer HTML elements, especially other map children (perhaps controls or legends that are being rendered on top of the map).\nIf this is an issue, set the  isolation  CSS prop on the  DeckGL  parent element. Optimization for Mobile Experimental Memory Usage Controls The  Deck  class supports the following experimental props to aggressively reduce memory usage on memory-restricted devices: _pickable _typedArrayManagerProps The app can sacrefice certain features and/or runtime performance in exchange for a smaller memory footprint:","headings":[{"value":"Tips and Tricks","depth":1},{"value":"Rendering Tips","depth":2},{"value":"Per Layer Control of WebGL parameters","depth":3},{"value":"z-fighting and Depth Testing","depth":3},{"value":"Browser Blending Modes","depth":3},{"value":"Optimization for Mobile","depth":2},{"value":"Experimental Memory Usage Controls","depth":3}],"slug":"docs/developer-guide/tips-and-tricks","title":"Tips and Tricks"},{"excerpt":"Loading Data deck.gl uses  loaders.gl , a framework-agnostic library to read data and resources. deck.gl core always includes loaders for JSON and standard image formats (e.g, png, jpeg, svg). Certain layers include additional loaders supporting their own use cases. It is easy for applications to provide options to configure the behavior of the default loaders or to add loaders to support for additional formats. Some examples of when loaders are used: JSON array or object from an URL passed to the  data  prop of a layer Texture from an image, such as  image  in  BitmapLayer ,  iconAtlas  in  IconLayer , and  texture  in  SimpleMeshLayer Geometries from a binary tile, e.g.  MVTLayer ,  TerrainLayer , and  Tile3DLayer Geometries from a standard 3D format, e.g.  scenegraph  in  ScenegraphLayer , and  mesh  in  SimpleMeshLayer Customize Data Loading Behavior All layers support a  loadOptions  prop that can be used to customize loading and parsing. Example: Fetch data with credentials In a production environment, deck.gl applications may need to load data from secure APIs that require special HTTP headers (such as  Authorization ) to be set. In order to access a secure API, the  loadOptions.fetch  option passes through additional parameters to  fetch , which deck.gl calls under the hood to load resources. Example: Override the default image loading options deck.gl uses  ImageLoader  to read common image formats. The default loader options are: The image is decoded into an  ImageBitmap  if the browser supports it (Firefox, Chrome, Edge) for better performance. You can override the default  options  for the  createImageBitmap  API as follows: If the image is a SVG that does not include width and height information,  createImageBitmap  will throw a  DOMException :  The image element contains an SVG image without intrinsic dimensions, and no resize options or crop region are specified . This can be fixed by explicitly setting its dimensions: Support Additional Formats All layers support a  loaders  prop that can be used to add  loaders.gl loaders  for parsing a specific input format. For example, the following code adds the  CSVLoader  to support CSV/TSV files: The following code adds the  LASLoader  to support LAS/LAZ files: Force Reload From an URL Usually, a layer refreshes its data when and only when the  data  prop changes.\nThe following code refreshes data from the same URL every 5 minutes by changing a query parameter: Loaders and Web Workers For the best performance, some specialized loaders parse data using web workers, for example  TerrainLoader  in the  TerrainLayer  and  MVTLoader  in the  MVTLayer . By default, the worker code is loaded from from the latest published NPM module on  unpkg.com . It might be desirable for some applications to serve the worker code itself without relying on the CDN. To do this, locate the worker bundle locally in  node_modules/@loaders.gl/<module>/dist/<name>-loader.worker.js  and serve it as a static asset with your server. Point the loader to use this alternative URL using  loadOptions.<name>.workerUrl : If the layer is used in an environment that does not support web workers, or you need to debug the loader code on the main thread, you may import the full loader like this: Refer to each specific layer's documentation to see which loaders are used. Load Resource Without an URL In some use cases, resources do not exist at a static URL. For example, some applications construct images dynamically based on user input. Some applications receive arbitrary binary blobs from a server via a WebSocket connection. Before reading on, remember that you don't have to use a loader if your app already knows how to interpret the content. For example, if you have the RGBA values of all pixels of an image. you can simply construct an  ImageData  object: If you have a custom-formatted binary, consider the techniques in  using binary data . The following examples only address the use cases where you need a loader/parser to interpret the incoming data. Example: Use image from a programmatically generated SVG string The following code dynamically generates SVG icons and convert them to  data URLs . Example: Parse glTF from a binary blob The following code shows how to parse a glTF model that is already loaded into an  ArrayBuffer  object. There are two ways for deck.gl to load it. One is to create a blob URL: Or more directly, import the  parse  utility from loaders.gl (already a dependency of deck.gl), which returns a promise:","headings":[{"value":"Loading Data","depth":1},{"value":"Customize Data Loading Behavior","depth":2},{"value":"Example: Fetch data with credentials","depth":3},{"value":"Example: Override the default image loading options","depth":3},{"value":"Support Additional Formats","depth":2},{"value":"Force Reload From an URL","depth":2},{"value":"Loaders and Web Workers","depth":2},{"value":"Load Resource Without an URL","depth":2},{"value":"Example: Use image from a programmatically generated SVG string","depth":3},{"value":"Example: Parse glTF from a binary blob","depth":3}],"slug":"docs/developer-guide/loading-data","title":"Loading Data"},{"excerpt":"Performance Optimization General Performance Expectations There are mainly two aspects that developers usually consider regarding the\nperformance of any computer programs: the time and the memory consumption, both of which obviously depends on the specs of the hardware deck.gl is ultimately running on. On 2015 MacBook Pros with dual graphics cards, most basic layers\n(like  ScatterplotLayer ) renders fluidly at 60 FPS during pan and zoom\noperations up to about 1M (one million) data items, with framerates dropping into low double digits (10-20FPS) when the data sets approach 10M items. Even if interactivity is not an issue, browser limitations on how big chunks of contiguous memory can be allocated (e.g. Chrome caps individual allocations at 1GB) will cause most layers to crash during WebGL buffer generation somewhere between 10M and 100M items. You would need to break up your data into chunks and use multiple deck.gl layers to get past this limit. Modern phones (recent iPhones and higher-end Android phones) are surprisingly capable in terms of rendering performance, but are considerably more sensitive to memory pressure than laptops, resulting in browser restarts or page reloads. They also tend to load data significantly slower than desktop computers, so some tuning is usually needed to ensure a good overall user experience on mobile. Layer Update Performance Layer update happens when the layer is first created, or when some layer props change. During an update, deck.gl may load necessary resources (e.g. image textures), generate WebGL buffers, and upload them to the GPU, all of which may take some time to complete, depending on the number of items in your  data  prop. Therefore, the key to performant deck.gl applications is to minimize layer updates wherever possible. Minimize data changes When the  data  prop changes, the layer will recalculate all of its WebGL buffers. The time required for this is proportional to the number of items in your\n data  prop.\nThis step is the most expensive operation that a layer does - also on CPU - potentially affecting the responsiveness of the application. It may take\nmultiple seconds for multi-million item layers, and if your  data  prop is updated\nfrequently (e.g. animations), \"stutter\" can be visible even for layers with just a few thousand items. Some good places to check for performance improvements are: Avoid unnecessary shallow change in data prop   The layer does a shallow comparison between renders to determine if it needs to regenerate buffers. If\n  nothing has changed, make sure you supply the  same  data object every time you render. If the data object has to change shallowly for some reason, consider using the  dataComparator  prop to supply a custom comparison logic. Use updateTriggers   So  data  has indeed changed. Do we have an entirely new collection of objects? Or did just certain fields changed in each row? Remember that changing  data  will update  all  buffers, so if, for example, object positions have not changed, it will be a waste of time to recalculate them.   In this case, it is more efficient to use  updateTriggers  to invalidate only the selected attributes: Handle incremental data loading   A common technique for handling big datasets on the client side is to load data in chunks. We want to update the visualization whenever a new chunk comes in. If we append the new chunk to an existing data array, deck.gl will recalculate the whole buffers, even for the previously loaded chunks where nothing have changed:   To avoid doing this, we instead generate one layer for each chunk:   Starting v7.2.0, support for async iterables is added to efficiently update layers with incrementally loaded data:   See  Layer properties  for details. Favor layer visibility over addition and removal   Removing a layer will lose all of its internal states, including generated buffers. If the layer is added back later, all the WebGL resources need to be regenerated again. In the use cases where layers need to be toggled frequently (e.g. via a control panel), there might be a significant perf penalty:   The  visible  prop is a cheap way to temporarily disable a layer: Optimize Accessors 99% of the CPU time that deck.gl spends in updating buffers is calling the accessors you supply to the layer. Since they are called on every data object, any performance issue in the accessors is amplified by the size of your data. Favor constants over callback functions   Most accessors accept constant values as well as functions. Constant props are extremely cheap to update in comparison. Use  ScatterplotLayer  as an example, the following two prop settings yield exactly the same visual outcome: getFillColor: [255, 0, 0, 128]  - deck.gl uploads 4 numbers to the GPU. getFillColor: d => [255, 0, 0, 128]  - deck.gl first builds a typed array of  4 * data.length  elements, call the accessor  data.length  times to fill it, then upload it to the GPU. Aside from accessors, most layers also offer one or more  *Scale  props that are uniform multipliers on top of the per-object value. Always consider using them before invoking the accessors: Use trivial functions as accessors   Whenever possible, make the accessors trivial functions and utilize pre-defined and/or pre-computed data. Use Binary Data When creating data-intensive applications, it is often desirable to offload client-side data processing to the server or web workers. The server can send data to the client more efficiently using binary formats, e.g.  protobuf ,  Arrow  or simply a custom binary blob. Some deck.gl applications use web workers to load data and generate attributes to get the processing off the main thread. Modern worker implementations allow ownership of typed arrays to be  transferred directly  between threads at virtually no cost, bypassing serialization and deserialization of JSON objects. Supply binary blobs to the data prop   Assume we have the data source encoded in the following format:   Upon receiving the typed arrays, the application can of course re-construct a classic JavaScript array:   However, in addition to requiring custom repacking code, this array will take valuable CPU time to create, and significantly more memory to store than its binary form. In performance-sensitive applications that constantly push a large volume of data (e.g. animations), this method will not be efficient enough.   Alternatively, one may supply a non-iterable object (not Array or TypedArray) to the  data  object. In this case, it must contain a  length  field that specifies the total number of objects. Since  data  is not iterable, each accessor will not receive a valid  object  argument, and therefore responsible of interpreting the input data's buffer layout:   Optionally, the accessors can utilize the pre-allocated  target  array in the second argument to further avoid creating new objects: Supply attributes directly   While the built-in attribute generation functionality is a major part of a  Layer s functionality, it can become a major bottleneck in performance since it is done on CPU in the main thread. If the application needs to push many data changes frequently, for example to render animations, data updates can block rendering and user interaction. In this case, the application should consider precalculated attributes on the back end or in web workers.    Deck.gl layers accepts external attributes as either a typed array or a WebGL buffer. Such attributes, if prepared carefully, can be directly utilized by the GPU, thus bypassing the CPU-bound attribute generation completely.   This technique offers the maximum performance possible in terms of data throughput, and is commonly used in heavy-duty, performance-sensitive applications.   To generate an attribute buffer for a layer, take the results returned from each object by the  get*  accessors and flatten them into a typed array. For example, consider the following layers:   Should we move the attribute generation to a web worker:   Note that instead of  getPosition , we supply a  data.attributes.getPosition  object. This object defines the buffer from which  PointCloudLayer  should access its positions data. See the base  Layer  class'  data prop  for details.   It is also possible to use interleaved or custom layout external buffers:   See full example in  examples/experimental/interleaved-buffer .   Note that external attributes only work with primitive layers, not composite layers, because composite layers often need to preprocess the data before passing it to the sub layers. Some layers that deal with variable-width data, such as  PathLayer ,  SolidPolygonLayer , require additional information passed along with  data.attributes . Consult each layer's documentation before use. Layer Rendering Performance Layer rendering time (for large data sets) is essentially proportional to: The number of vertex shader invocations,\nwhich corresponds to the number of items in the layer's  data  prop The number of fragment shader invocations, which corresponds to the total\nnumber of pixels drawn. Thus it is possible to render a scatterplot layer with 10M items with reasonable\nframe rates on recent GPUs, provided that the radius (number of pixels) of each\npoint is small. It is good to be aware that excessive overdraw (drawing many objects/pixels on top of each other) can generate very high fragment counts and thus hurt performance. As an example, a  Scatterplot  radius of 5 pixels generates ~ 100 pixels per point. If you have a  Scatterplot  layer with 10 million points, this can result in up to 1 billion fragment shader invocations per frame. While dependent on zoom levels (clipping will improve performance to some extent) this many fragments will certainly strain even a recent MacBook Pro GPU. Layer Picking Performance deck.gl performs picking by drawing the layer into an off screen picking buffer. This essentially means that every layer that supports picking will be drawn off screen when panning and hovering. The picking is performed using the same GPU code that does the visual rendering, so the performance should be easy to predict. Picking limitations: The picking system can only distinguish between 16M items per layer. The picking system can only handle 256 layers with the pickable flag set to true. Number of Layers The layer count of an advanced deck.gl application tends to gradually increase, especially when using composite layers. We have built and optimized a highly complex application using close to 100 deck.gl layers (this includes hierarchies of sublayers rendered by custom composite layers rendering other composite layers) without seeing any performance issues related to the number of layers. If you really need to, it is probably possible to go a little higher (a few hundred layers). Just keep in mind that deck.gl was not designed to be used with thousands of layers. Common Issues A couple of particular things to watch out for that tend to have a big impact on performance: If not needed disable Retina/High DPI rendering. It generates 4x the number of pixels (fragments) and can have a big performance impact that depends on which computer or monitor is being used. This feature can be controlled using  useDevicePixels  prop of  DeckGL  component and it is on by default. Avoid using luma.gl debug mode in production. It queries the GPU error status after each operation which has a big impact on performance. Smaller considerations: Enabling picking can have a small performance penalty so make sure the  pickable  property is  false  in layers that do not need picking (this is the default value).","headings":[{"value":"Performance Optimization","depth":1},{"value":"General Performance Expectations","depth":2},{"value":"Layer Update Performance","depth":2},{"value":"Minimize data changes","depth":3},{"value":"Avoid unnecessary shallow change in data prop","depth":4},{"value":"Use updateTriggers","depth":4},{"value":"Handle incremental data loading","depth":4},{"value":"Favor layer visibility over addition and removal","depth":4},{"value":"Optimize Accessors","depth":3},{"value":"Favor constants over callback functions","depth":4},{"value":"Use trivial functions as accessors","depth":4},{"value":"Use Binary Data","depth":3},{"value":"Supply binary blobs to the data prop","depth":4},{"value":"Supply attributes directly","depth":4},{"value":"Layer Rendering Performance","depth":2},{"value":"Layer Picking Performance","depth":2},{"value":"Number of Layers","depth":2},{"value":"Common Issues","depth":2}],"slug":"docs/developer-guide/performance","title":"Performance Optimization"},{"excerpt":"Using Layers The \"Layer\" is a core concept of deck.gl. A deck.gl layer is a packaged visualization type that takes a collection of datums, associate each with positions, colors, extrusions, etc., and renders them on a map. deck.gl provides an extensive  layer catalog  and is designed to compose many layers together to form complex visuals. Constructing a Layer Instance A layer is instantiated with a  properties  object: The  properties  are settings that the layer uses to build the visualization. Users of a layer typically specify the following types of props: Layer ID The  id  prop is the unique identifier of this layer among all layers. Constructing a new layer instance in its own does not have any performance impact, as deck.gl only does the expensive calculations when a layer is  created  (an id appearing for the first time) or  updated  (different props are passed in for the same id). Read more about this in  layer lifecycle . It is recommend that this prop is set explicitly to avoid collision. Data The  data  prop specifies data source of this layer's visualization. The value is expected to be a collection (typically a JavaScript array) of data objects with similar structure, such as rows in a table. deck.gl layers are able to handle millions of data objects very efficiently. The value of this prop can be  Array ,  Map ,  Set , any object that contains a  length  field, a  Promise  that resolves to any of the above, or an URL to a JSON array. See  data prop  documentation for details. Accessors An accessor is a prop that maps an object in  data  to its visual configuration, e.g. the radius of a circle, the color of a line, etc. All accessor prop names start with  get . If an accessor prop is set to a function, when the layer is about to be drawn on screen for the first time, the layer will traverse the  data  stream and call the accessor function with each element. The accessor function receives two arguments: object  - the current element in the data stream. If  data  is an array or an iterable, the element of the current iteration is used. If  data  is a non-iterable object, this argument is always  null . objectInfo  (Object) - contextual information of the current element. Contains the following fields: index  (Number) - the index of the current iteration data  - the value of the  data  prop target  (Array) - a pre-allocated array. The accessor function can optionally fill data into this array and return it, instead of creating a new array for every object. In some browsers this improves performance significantly by reducing garbage collection. The accessor function is typically expected to return either a number or an array. Some accessors also support constant values instead of functions. When a constant value is provided, it is applied to all objects in the data stream. Unlike a functional value, which is called once for every data object to fill a WebGL buffer proportional to the data size, constant accessors have CPU and memory cost of  O(1)  and are much more performant. Other Layer Props The rest of the props are typically numeric or boolean values that apply to the whole layer. These include props that define the render options (opacity, extrusion of the PolygonLayer, font family of the TextLayer, etc.),  coordinate system , and  interactivity . Rendering Layers deck.gl allows you to render multiple layers using the same or different data sets. You simply provide an array of layer instances and deck.gl will render them in order (and handle interactivity when hovering clicking etc). This allows you to compose visualizations using several primitive layers. FAQ Should I be Creating New Layers on Every Render? The Reactive Programming Paradigm deck.gl's architecture is based on the reactive programming paradigm: In a reactive application, a complete UI description is \"re-rendered\" every time something in the application state changes (in the case of a deck.gl application, a new list of layers is created whenever something changes). The UI framework (in this case, deck.gl) makes the choices about what to update, by comparing (or \"diffing\") the newly rendered UI description with the last rendered UI description. The framework then the makes minimal necessary changes to account for the differences, and then redraws. The required changes are made to \"WebGL state\" in case of deck.gl, and to the Browser's DOM (HTML element tree) in case of React. Creating Layer Instances Is Cheap The deck.gl model means that applications are expected to create a new set of layers every time application state changes, which can seem surprisingly inefficient to someone who hasn't done reactive programming before. The trick is that layers are just descriptor objects that are very cheap to instantiate, and internally, the new layers are efficiently matched against existing layers so that no updates are performed unless actually needed. So, even though the application creates new \"layers\", those layers are only \"descriptors\" containing props that specify what needs to be rendered and how. All calculated state (WebGL \"programs\", \"vertex attributes\" etc) are stored in a state object and this state object is moved forward to the newly matched layer on every render cycle.  The new layer ends up with the state of the old layer (and the props of the new layer), while the old layer is simply discarded for garbage collection. The application does not have to be aware about this, as long as it keeps rendering new layers with the same  id  they will be matched and the existing state of that layer will be updated accordingly. The constant creation and disposal of layer instances may seem wasteful, however the creation and recycling of JavaScript objects is quite efficient in modern JavaScript environments, and this is very similar to how React works where every render cycle generates a new tree of ReactElement instances, so the model is proven. For more details on layer creation, update and destruction, read about  Layer Lifecycle . Why Doesn't My Layer Update with New Props? Since the reactive programming frameworks conceptually render the entire UI every render cycle, and achieves efficiency by comparing and \"diffing\" changes between render cycles, it is important that comparisons are fast. Because of this, deck.gl uses shallow equality as the default comparison method for most props. An exception is the accessors. Changing the value of an accessor (i.e. supplying a different function to the accessor prop) will not in itself trigger an attribute update. This is because the function identity is a poor indicator of whether an update is needed, and the convenience of using local functions as prop values. Consider the code below,  getRadius  is shallowly changed every time  render()  is called, even if its execution result would not change: In another example,  getColor  is shallowly changed, so would its execution result: There is no way for deck.gl to know what the programmer intended just by looking at or comparing the functions that are supplied to a  Layer s accessor props. Because recalculating attributes can be potentially expensive, deck.gl by default ignores shallow changes in accessor props. This is designed to provide the best performance to the most common use cases without compromising convenience. Instead, the  updateTriggers  property gives you fine grained control, enabling you to tell deck.gl exactly which attributes need to change, and when. Read more about this behavior in  Performance Optimization .","headings":[{"value":"Using Layers","depth":1},{"value":"Constructing a Layer Instance","depth":2},{"value":"Layer ID","depth":3},{"value":"Data","depth":3},{"value":"Accessors","depth":3},{"value":"Other Layer Props","depth":3},{"value":"Rendering Layers","depth":2},{"value":"FAQ","depth":2},{"value":"Should I be Creating New Layers on Every Render?","depth":3},{"value":"The Reactive Programming Paradigm","depth":4},{"value":"Creating Layer Instances Is Cheap","depth":4},{"value":"Why Doesn't My Layer Update with New Props?","depth":3}],"slug":"docs/developer-guide/using-layers","title":"Using Layers"},{"excerpt":"Using Lighting A deck.gl lighting effect is a visual approximation of environment illumination based on simplified models to make rendering appear more realistic. To enable lighting in deck.gl, it is required that both the lighting effect and material instances are properly instantiated. Interactive demo of LightingEffect Constructing A Lighting Effect Instance A  LightingEffect  can be instantiated with a  lights  object: The  lights  has all the light sources that the lighting effect uses to build the visualization. Users typically specify the following types of light sources: AmbientLight PointLight DirectionalLight CameraLight SunLight Constructing A Material Instance A material is a plain JavaScript object representing a lighting model specified per layer. Properties are  ambient  (number 0-1),  diffuse  (number 0-1),  shininess  (number > 0),  specularColor  (array  0-255, 0-255, 0-255 ). Setting a material property to the value  true  will set all properties to their defaults, which are: Using Materials Refer to each layer's  documentation  to see if the material prop is supported. Using Effects Pure JS React Remarks A default lighting effect is created in deck when user doesn't provide one. A default material is created in layers which support material prop. Lighting is only applied to extruded polygons or point clouds.","headings":[{"value":"Using Lighting","depth":1},{"value":"Constructing A Lighting Effect Instance","depth":2},{"value":"Constructing A Material Instance","depth":2},{"value":"Using Materials","depth":2},{"value":"Using Effects","depth":2},{"value":"Pure JS","depth":3},{"value":"React","depth":3},{"value":"Remarks","depth":2}],"slug":"docs/developer-guide/using-lighting","title":"Using Lighting"},{"excerpt":"Testing Layers and Applications Testing WebGL code is much harder than testing regular JavaScript. GPU and browser dependent commands may not run under Node. Rendering behavior differs cross platforms and hardware. Since it draws into a canvas, there is also no precisely verifiable output. The  @deck.gl/test-utils  module is used to ensure the quality and stability of the deck.gl framework. It is also available for those who need to test their own custom layers and/or deck.gl applications. Unit Tests for deck.gl Layers Lifecycle test functions are designed to allow for integration with different unit test frameworks. Some of the details depend on the test framework you are using. deck.gl itself uses  tape  so the tests in the deck.gl repository contain extensive examples of  tape  integration, but it should also be straightforward to integrate with other unit testing frameworks. Example Using  testLayer  util to instantiate a layer and test a series of prop updates: The  generateLayerTests  utility automatically generates a series of test cases for  testLayers  based on the layer class' default props. It is useful for checking the conformance of a layer class: Integration Tests While unit tests are good at capturing issues in layer initialization and prop updates, they do not guarantee that the layer will be correctly rendered to screen. Some issues in e.g. the WebGL shaders can only be spotted in an integration test. The  @deck.gl/test-utils  module offers a  SnapshotTestRunner  that works with the  probe.gl  library's  BrowserTestDriver  class to perform this task. Together, they enable the following scenario: start a controlled Chromium browser instance start a server (we use a webpack-dev-server) that bundles a test script. the test script renders a set of tests (described below), compares the output against golden images and report the result back to the Node process closes down all processes and browser tabs. the node process exists with a  0  (success) or  1  if any test failed. Example In your node.js start script: In your script that is run on the browser:","headings":[{"value":"Testing Layers and Applications","depth":1},{"value":"Unit Tests for deck.gl Layers","depth":2},{"value":"Example","depth":3},{"value":"Integration Tests","depth":2},{"value":"Example","depth":3}],"slug":"docs/developer-guide/testing","title":"Testing Layers and Applications"},{"excerpt":"Viewports If you are new to deck.gl's  View  and  Viewport  classes it is suggested that you start by reading up on  Views  before learning about  Viewports . Most applications start by using  View  classes. Viewports deck.gl provides a hierarchy of  Viewport  classes. Unless an application needs to project or unproject coordinates in JavaScript, they typically do not directly create  Viewport  classes. Instead,  Viewport  classes are created under the hood based on the  View  class descriptors. Viewport  classes are focused on mathematical operations such as coordinate projection/unprojection and calculation of projection matrices and GLSL uniforms. As mentioned, the basic  Viewport  class is a generic geospatially enabled version of the typical 3D \"camera\" class you would find in most 3D/WebGL/OpenGL library, holding  view  and  projection  matrices and other uniforms needed by the WebGL vertex shaders. While the  Viewport  class can certainly be used directly if you need and are able to calculate your own projection matrices. it is often preferable to use a  Viewport  subclass that takes higher level parameters, such as camera position and viewing direction, or map coordinates, rather than working directly with matrices. In addition to generating WebGL uniforms, the  Viewport  class also offers JavaScript functions to project and unproject as well as getting local distance scales. Overview of Viewports Viewport Class Description Viewport The base viewport has to be supplied view and projection matrices. It is typically only instantiated directly if the application needs to work with viewports that have been supplied from external sources, such as the  WebVR  API. WebMercatorViewport While all  Viewport  subclasses are geospatially enabled, this class renders from a perspective that matches a typical top-down map and is designed to synchronize perfectly with a mapbox-gl base map (even in 3D enabled perspective mode). About Geospatial Positioning A special property of the  Viewport  classes that set them apart from a typical OpenGL Camera class is that it has the necessary plumbing to support non-linear Web Mercator projection. Like many things in deck.gl, Viewports can be positioned using a lng/lat \"anchor\" and a meter offset. See the article about coordinate systems for more information about this setup. Viewport Positioning Viewports allow the application to specify the position and extent of the viewport (i.e. the target rendering area on the screen). Viewport positions are specified in CSS coordinates (top left, non-retina, these coordinates are different from WebGL coordinates, see remarks below). It is expected that CSS coordinates are most natural to work with, as the rest of the UI layout with other HTML components is done in the CSS coordinate system. x,y coordinates  - Viewports allow specification of x,y coordinates in the viewport in addition to width and height. These are only used for positioning (and not for calculation of intrinsic viewport parameters). Remarks About viewport position and size coordinates: Internally,  gl.viewport  uses bottom-left, retina coordinates and normal CSS layout uses top left, non-retina coordinates. Translating between the two is surprisingly fiddly since both y coordinates and heights need to be stacked, and  devicePixelRatio  has to be matched to application settings, so having this translation taken care of by deck.gl was an explicit design goal. For the  project / unproject  JavaScript functions, the default pixel coordinate system of the viewport is defined with the origin in the top left, where the positive x-axis goes right, and the positive y-axis goes down. That is, the top left corner is  [0, 0]  and the bottom right corner is  [width - 1, height - 1] . The functions have a flag that can reverse this convention. Non-pixel projection matrices are bottom-left. Mercator coordinates are specified in \"lng-lat\" format  lng, lat, z  format (which naturally corresponds to  x, y, z ). It is possible to query the WebMercatorViewport for a meters per pixel scale. Note that that distance scales are latitude dependent under web mercator projection (see  http://wiki.openstreetmap.org/wiki/Zoom_levels  for more details), so scaling will depend on the viewport center and any linear scale factor should only be expected to be locally correct.","headings":[{"value":"Viewports","depth":1},{"value":"Viewports","depth":2},{"value":"Overview of Viewports","depth":2},{"value":"About Geospatial Positioning","depth":2},{"value":"Viewport Positioning","depth":2},{"value":"Remarks","depth":2}],"slug":"docs/developer-guide/viewports","title":"Viewports"},{"excerpt":"View State Transitions View state transitions provide smooth and visually appealing transitions when ViewState change from one state to the other. Transitions are supported by adding the following fields when setting  Deck 's  viewState  or  initialViewState  prop: transitionDuration  (Number|String, optional, default: 0) - Transition duration in milliseconds, default value 0, implies no transition.\nWhen using  FlyToInterpolator , it can also be set to  'auto'  where actual duration is auto calculated based on start and end viewports and is linear to the distance between them. This duration can be further customized using  speed  parameter to  FlyToInterpolator  constructor. transitionEasing  (Function, optional, default:  t => t ) - Easing function that can be used to achieve effects like \"Ease-In-Cubic\", \"Ease-Out-Cubic\", etc. Default value performs Linear easing. (list of sample easing functions:  http://easings.net/ ) transitionInterpolator  (Object, optional, default:  LinearInterpolator ) - An interpolator object that defines the transition behavior between two viewports, deck.gl provides  LinearInterpolator  and  FlyToInterpolator . Default value,  LinearInterpolator , performs linear interpolation on view state fields.  FlyToInterpolator  animates  ViewStates  similar to MapBox  flyTo  API and applicable for  MapState , this is pretty useful when camera center changes by long distance. But a user can provide any custom implementation for this object using  TrasitionInterpolator  base class.     transitionInterruption  (Enum, optional, default:  TRANSITION_EVENTS.BREAK ) - This field controls how to process a new view state change that occurs while performing an existing transition. This field has no impact once transition is complete. Here is the list of all possible values with resulting behavior. TRANSITION_EVENTS Result BREAK Current transition will stop at the current state and next view state update is processed. SNAP_TO_END Current transition will skip remaining transition steps and view state is updated to final value, transition is stopped and next view state update is processed. IGNORE Any view state update is ignored until current transition is complete, this also includes view state changes due to user interaction. onTransitionStart  (Functional, optional) - Callback fires when requested transition starts. onTransitionInterrupt  (Functional, optional) - Callback fires when transition is interrupted. onTransitionEnd  (Functional, optional) - Callback fires when transition ends. Usage Sample code that provides  flyTo  style transition to move camera from current location to NewYork city. Sample code to get continuous rotations along vertical axis until user interrupts by rotating the map by mouse interaction. It uses  LinearInterpolator  and restricts transitions for  bearing  prop. Continuous transitions are achieved by triggering new transitions using  onTranstionEnd  callback. Interpolators The following interpolator classes are available out-of-the-box: LinearInterpolator  - a generic interpolator that works with all view types. FlyToInterpolator  - a \"fly to\" style camera transition for geospatial views. You can also implement a custom interpolator. See  TransitionInterpolator . Remarks Deck's transition model is \"set and forget\": the values of the following props at the start of a transition carry through the entire duration of the transition: transitionDuration transitionInterpolator transitionEasing transitionInterruption The default transition behavior can always be intercepted and overwritten in the handler for  onViewStateChange . However, if a transition is in progress, the properties that are being transitioned (e.g. longitude and latitude) should not be manipulated, otherwise the change will be interpreted as an interruption of the transition.","headings":[{"value":"View State Transitions","depth":1},{"value":"Usage","depth":2},{"value":"Interpolators","depth":2},{"value":"Remarks","depth":2}],"slug":"docs/developer-guide/view-state-transitions","title":"View State Transitions"},{"excerpt":"Views and Projections The same data can be drawn differently to screen based on what projection method is used. deck.gl's view system defines how one or more cameras should be set up to look at your data objects. The default view used in deck.gl is the  MapView , which implements the  Web Mercator projection . \nThe view system is designed to be flexible and composable and can handle many different configurations such as side-by-side views, overlapping views etc. If you plan to work with non-geospatial data, or show more than a single standard viewport, it may be worth spending some time to get familiar with the  View  API. View classes enable applications to specify one or more rectangular viewports and control what should be rendered inside each view. View, View State and Viewport View A  View  instance defines the following information: A unique  id . The position and extent of the view on the canvas:  x ,  y ,  width , and  height . Certain camera parameters specifying how your data should be projected into this view, e.g. field of view, near/far planes, perspective vs. orthographic, etc. The  controller  to be used for this view. A controller listens to pointer events and touch gestures, and translates user input into changes in the view state. If enabled, the camera becomes interactive. To summarize, a  View  instance wraps the \"hard configuration\" of a camera. Once defined, it does not need to change frequently. deck.gl allows multiple views to be specified, allowing the application to divide the screen into multiple similar or different views. These views can be synchronized or separately controlled by the user or the application. View State A  View  instance must be used in combination with a  viewState  object. As the name suggests, the object describes the state of a  View  instance. The view state object defines the temporary properties of a view at runtime, like the camera position, orientation, zoom, etc. If the view is interactive, every time the user pans/rotates/zooms, the view state will be updated to reflect the change. To summarize, a  viewState  object describes the \"real-time properties\" of a camera. It may be updated continuously during interaction and/or transition. Viewport A  Viewport  instance is the camera itself. It is \"resolved\" from a  View  instance and its  viewState . It handles the mathematical operations such as coordinate projection/unprojection, the calculation of projection matrices, and other GLSL uniforms needed by the shaders. Whenever  viewState  updates, the view creates a new viewport under the hood. Typically, the deck.gl user does not need to work with viewports directly. In certain use cases, the JavaScript functions offered by a  Viewport  instance can be handy for projecting and unprojecting coordinates. Types of Views deck.gl offers a set of  View  classes that package the camera and controller logic that you need to visualize and interact with your data. You may choose one or multiple  View  classes based on the type of data (e.g. geospatial, 2D chart) and the desired perspective (top down, first-person, etc). Note that the set of view state parameters that will be used varies between Views. Consult each view class' documentation for a full list of parameters supported. View Class Use Case Status Description View The base view has to be supplied with raw view and projection matrices. It is typically only instantiated directly if the application needs to work with views that have been supplied from external sources, such as the  WebVR API . MapView  (default) geospatial full support This view renders data using the  Web Mercator projection  and is designed to match an external base map library such as Mapbox or Google Maps. GlobeView geospatial experimental This view renders data as a 3D globe. FirstPersonView geospatial full support The camera is positioned in a provided geolocation and looks in a provided direction, similar to that of a  first-person game . OrthographicView info-vis (2D) full support The camera looks at a target point from top-down. Does not rotate. OrbitView info-vis (3D) full support The camera looks at a target point from a provided direction. Rotates around the target. Examples Using a View Class If the  views  prop of  Deck  is not specified, deck.gl will automatically create a  MapView  that fills the whole canvas, so basic geospatial applications often do not have to specify any  View s. If using non-geospatial data, you will need to manually create a view that is appropriate for info-vis, e.g.: Using a View Class with View State If  initialViewState  is provided, deck.gl automatically tracks the view states of interactive views (used as a \"stateful\" component): If you need to manage and manipulate the view state outside of deck.gl, you may do so by providing an external  viewState  prop (used as a \"stateless\" component). In this case, you also need to listen to the  onViewStateChange  callback and update the  viewState  object yourself: Using Multiple Views deck.gl also supports multiple views by taking a  views  prop that is a list of  View  instances. Views allow the application to specify the position and extent of the viewport (i.e. the target rendering area on the screen) with  x  (left),  y  (top),  width  and  height . These can be specified in either numbers or CSS-like percentage strings (e.g.  width: '50%' ), which is evaluated at runtime when the canvas resizes. Common examples in 3D applications that render a 3D scene multiple times with different \"cameras\": To show views from multiple viewpoints (cameras), e.g. in a split screen setup. To show a detail view (e.g, first person), and an overlaid, smaller \"map\" view (e.g. third person or top down, zoomed out to show where the primary viewpoint is). To support stereoscopic rendering (e.g. VR), where left and right views are needed, providing the necessary parallax between left and right eye. For rendering into offscreen framebuffers, which can then be used for e.g. advanced visual effects, screen shot solutions, overlays onto DOM elements outside of the primary deck.gl canvas (e.g. a video). Example of using with the  WebVR API : Views can also overlap, (e.g. having a small \"mini\" map in the bottom middle of the screen overlaid over the main view) Using Multiple Views with View States When using multiple views, each  View  can either have its own independent view state, or share the same view state as other views. To define the view state of a specific view, add a key to the  viewState  object that matches its view id: Rendering Layers in Multiple Views By default, all visible layers are rendered into all the views. This may not be the case if certain layers are designed to go into one particular view. The  Deck  class'  layerFilter  prop has access to information of the view via the  viewport  argument. It can be used to determine which layers to draw in which view:  Some layers, including  TileLayer ,  HeatmapLayer  and  ScreenGridLayer , perform expensive operations (data fetching/aggregation) on viewport change. Therefore, it is generally NOT recommended to render them into multiple views. If you do need to show e.g. tiled base map in multiple views, create one layer instance for each view and limit their rendering with  layerFilter : Starting with v8.5,  Tile3DLayer  supports rendering in multiple views with a single tile cache. Picking in Multiple Views deck.gl's built-in picking support extends naturally to multiple viewports. The picking process renders all viewports. Note that the  pickInfo  object does not contain a viewport reference, so you will not be able to tell which viewport was used to pick an object. Similar to the above example, you may control which layer is pickable in which view by supplying a  layerFilter : Auto-Positioning React/HTML Components Behind Views This feature is currently only implemented in the React version of deck.gl. One of the core features of deck.gl is enabling perfectly synchronized visualization overlays on top other React components and DOM elements. When using a single  View , the child components of  DeckGL  are positioned to fill the entire canvas. In this example the  StaticMap  component gets automatically positioned under the default  MapView : When using multiple views, you can wrap component(s) in a  View  tag to align its position and size with a specific view. In the following example, the mapbox component is positioned and stretched to fit the \"minimap\" view: Performance Notes views  and  viewState  props are deep compared to determine if anything changed, so there is little performance cost if new view instances are constructed each render. When  views / viewState  do change, new viewports are constructed. At this point, layers can get a chance to update their state, with the  changeFlags  argument containing  viewportChanged: true . During interaction and transition, this may happen many times a second, raising performance concern if many layers need to recompute their states. By default, most layers ignore viewport changes, so the  updateState  lifecycle method do not get called if nothing else change. However, some layers do need to update state when viewport changes (e.g. the  TileLayer ). To make sure  updateState  is called, the layer needs to override  shouldUpdateState . Read more in  Layer Lifecycles .","headings":[{"value":"Views and Projections","depth":1},{"value":"View, View State and Viewport","depth":2},{"value":"View","depth":3},{"value":"View State","depth":3},{"value":"Viewport","depth":3},{"value":"Types of Views","depth":2},{"value":"Examples","depth":2},{"value":"Using a View Class","depth":3},{"value":"Using a View Class with View State","depth":3},{"value":"Using Multiple Views","depth":3},{"value":"Using Multiple Views with View States","depth":3},{"value":"Rendering Layers in Multiple Views","depth":3},{"value":"Picking in Multiple Views","depth":3},{"value":"Auto-Positioning React/HTML Components Behind Views","depth":3},{"value":"Performance Notes","depth":2}],"slug":"docs/developer-guide/views","title":"Views and Projections"},{"excerpt":"Using with ArcGIS Pure JS React Overlaid Interleaved ✓ ✓ example Starting with v8.1, deck.gl has support for ArcGIS with the  @deck.gl/arcgis  module. 2D integration with  MapView  is supported by the  DeckLayer  class, see  pure JS example . 3D integration with  SceneView  is experimental: see the  DeckRenderer  class.","headings":[{"value":"Using with ArcGIS","depth":1}],"slug":"docs/developer-guide/base-maps/using-with-arcgis","title":"Using with ArcGIS"},{"excerpt":"Using with Google Maps Platform Pure JS React Overlaid Interleaved ✓ ✓ example example Deck.gl has interleaved and overlaid support for Google Maps with the  @deck.gl/google-maps  module. It allows you to construct a Deck instance and apply it to a map using the Maps JavaScript API. See Google Maps documentation](/docs/api-reference/google-maps/overview.md) page for a full list of features. Google Maps Platform API key Note that to use deck.gl with the Google's basemap, you must load the Maps JavaScript API using a valid API key. For more information on getting an API key, see the  Google Maps Platform API key documentation  for the Maps JavaScript API. Using interleaved Starting with v8.6, deck.gl added interleaving support on Google's vector map, using the Maps JavaScript API  WebGLOverlayView class . When a Deck instance is applied to the map, deck.gl detects whether it is an instance of the vector map, then automatically enables interleaving. For information on how to enable the Google's vector map for the web, see the  Maps JavaScript API documentation .  By default, when a Deck instance is added to the map, deck.gl will detect if the map is an instance of the vector map and enable interleaved mode. If the vector map is not detected or the user's device does not support WebGL, deck.gl will automatically fallback to overlaid mode. Using overlaid Starting with v7.0, deck.gl added support to overlay visualizations on Google's raster map using the Maps JavaScript API  OverlayView class . In this mode, the Deck canvas can only be used as a overlay on top of Google Maps, see  pure JS example , and 3D features like tilt, rotation, and interleaving are not supported.","headings":[{"value":"Using with Google Maps Platform","depth":1},{"value":"Google Maps Platform API key","depth":2},{"value":"Using interleaved","depth":2},{"value":"Using overlaid","depth":2}],"slug":"docs/developer-guide/base-maps/using-with-google-maps","title":"Using with Google Maps Platform"},{"excerpt":"Using with Mapbox Pure JS React Overlaid Interleaved ✓ ✓ example example Mapbox GL JS  is a powerful open-source map renderer from  Mapbox . deck.gl's  MapView  is designed to sync perfectly with the camera of Mapbox, at every zoom level and rotation angle. When using deck.gl and Mapbox, there are three options you can choose from: Using the Deck canvas as a overlay on top of the Mapbox map, and Deck as the root element. In this option, deck.gl handles all user input, and holds the source of truth of the camera state. The  React get-started example  illustrates the basic pattern. This is the most tested and robust use case, as you can find in all the  examples on this website . It supports all the features of Deck. Using the Deck canvas as a overlay on top of the Mapbox map, and Mapbox as the root element. In this option, mapbox-gl handles all user input, and holds the source of truth of the camera state. The  vanilla JS get-started example  illustrates this pattern. The  MapboxOverlay  class in  @deck.gl/mapbox  implements the mapbox-gl control interface to insert deck into the map container. This is favorable if you need to use other mapbox-gl controls and plugins in addition to deck.gl. Using deck.gl layers interleaved with Mapbox layers in the same WebGL context, using either the  MapboxOverlay  or  MapboxLayer  from the  @deck.gl/mapbox  module. This allows you to mix deck.gl layers with base map layers, e.g. below text labels or occlude each other correctly in 3D. Be cautious that this feature subjects to bugs and limitations of mapbox-gl's custom layer interface. react-map-gl react-map-gl  is a React wrapper around mapbox-gl. If you'd like to use deck.gl with React, this component is the recommended companion. All the  examples on this website  are implemented using the React integration. The  DeckGL  React component works especially well as the parent of a react-map-gl  StaticMap , which automatically interprets the deck.gl view state (i.e. latitude, longitude, zoom etc). In this configuration your deck.gl layers will render as a perfectly synchronized geospatial overlay over the underlying map. Using Mapbox basemap service (with Mapbox token) The mapbox-gl library is open source and free to use. However, to load the map styles and tiles from Mapbox's data service, you will need to register on their website in order to retrieve an  access token  required by the map component, which will be used to identify you and start serving up map tiles. The service will be free until a  certain level  of traffic is exceeded. If you are using mapbox-gl without React, check out  Mapbox GL JS API  for how to apply the token. If you are using react-map-gl, there are several ways to provide a token to your app: Set the  MapboxAccessToken  environment variable. You may need to add additional set up to the bundler ( example ) so that  process.env.MapboxAccessToekn  is accessible at runtime. Provide it in the URL, e.g  ?access_token=TOKEN Pass it as a prop to the ReactMapGL instance  <ReactMapGL mapboxAccessToken={TOKEN} /> Compatibility with Mapbox GL JS forks As of v2.0, Mapbox GL JS  went proprietary  and requires a Mapbox account to use even if you don't load tiles from the Mapbox data service. Community forks of the v1 code base such as  MapLibre GL JS  can generally be used as a drop-in replacement of mapbox-gl. If you are using react-map-gl, follow  these instructions . If the forked libraries and Mapbox API diverge in the future, compatibility issues may arise. deck.gl intends to support open source efforts wherever reasonable. Please report any issue on GitHub. Using with other basemap services It is possible to use the map component without the Mapbox service, you need a URL that conforms to the  Mapbox Style Specification  and pass it to  ReactMapGL  using the  mapStyle  prop. You can use existing free vector tile services: CARTO free basemaps  for non commercial applications. Checkout  this guide  to start using it. Hosting your own basemap service If you host your own map tiles, you will need a custom Mapbox GL style that points to your own  vector tile source , this custom style must match the schema of your tile source. Open source tile schemas include: TileZen schema OpenMapTiles schema  Some useful resources for creating your own map service: Mapbox Vector Tile Spec Open source tools Maputnik Style editor","headings":[{"value":"Using with Mapbox","depth":1},{"value":"react-map-gl","depth":2},{"value":"Using Mapbox basemap service (with Mapbox token)","depth":2},{"value":"Compatibility with Mapbox GL JS forks","depth":2},{"value":"Using with other basemap services","depth":2},{"value":"Hosting your own basemap service","depth":3}],"slug":"docs/developer-guide/base-maps/using-with-mapbox","title":"Using with Mapbox"},{"excerpt":"Attribute Management Overview deck.gl layers' public API were designed to follow a Reactive programming\nparadigm. The challenge is that in the \"reactive\" model, every change to application state causes everything to be re-rendered. This is not an issue for UI rendering for general purpose apps, but for high performance, graphics intensive and sometime 3D contents to be rendered by WebGL, huge memory buffers (so called \"vertex attributes\", or just \"attributes\" for short) must be prepared and transferred to the GPUs before any draw calls got executed on the GPUs. WebGL Performance Challenges Creating and transferring new WebGL buffers before every draw call would result in unacceptable performance even for moderately complex models. Just like in React (which \"renders\" to the browser's slow-updating DOM), the challenge becomes to detect which part of the visualization is changed to limit both attributes recalculation and re-rendering to the minimum. Since the length of attributes are usually proportional of to the number of data elements being visualized (hundreds of thousands or even multiple millions of elements are not uncommon in big data visualizations), efficient attribute updates is critical. deck.gl alleviates the burden of layer developers by providing an  AttributeManager  class to manage the lifecycle of those WebGL attributes. Note that it is completely possible for a layer to use custom code to manage attribute updates, however most layers rely on the  AttributeManager  class to handle WebGL buffer management for them. Automatic Attribute Generation Automated attribute generation and management is suitable when a set of vertex shader attributes are generated by iteration over a data array, and updates to these attributes are needed either when the data itself changes, or when other data relevant to the calculations change. First the application registers descriptions of its dynamic vertex attributes using AttributeManager.add(). Then, when any change that affects attributes is detected by the application, the app will call AttributeManager.invalidate(). Finally before it renders, it calls AttributeManager.update() to ensure that attributes are automatically rebuilt if anything has been invalidated. The application provided update functions describe how attributes should be updated from a data array and are expected to traverse that data array (or iterable) and fill in the attribute's typed array. Note that the attribute manager intentionally does not do advanced change detection, but instead makes it easy to build such detection by offering the ability to \"invalidate\" each attribute separately. Accessors, Shallow Comparisons and updateTriggers The layer will expect each object to provide a number of \"attributes\" that it can use to set the GL buffers. By default, the layer will look for these attributes to be available as fields directly on the objects during iteration over the supplied data set. To gain more control of attribute access and/or to do on-the-fly calculation of attributes. Note : A layer only renders when a property change is detected. For performance reasons, property change detection uses shallow compare, which means that mutating an element inside a buffer or a mutable data array does not register as a property change, and thus does not trigger a re-render. To force trigger a render after mutating buffers, simply increment the  renderCount  property. To force trigger a buffer update after mutating data, increment the  updateCount  property. Advanced Topics Manual Buffer Management While most apps rely on their layers to automatically generate appropriate WebGL buffers from their props, it is possible for applications to take control of buffer generation and supply the buffers as properties. While this allows for ultimate performance and control of updates, as well as potential sharing of buffers between layers, the application will need to generate attributes in exactly the format that the layer shaders expect, creating a strong coupling between the application and the layer. Note:  The application can provide some buffers and let others be managed by the layer. As an example management of the  instancePickingColors  buffer is normally left to the layer. More information Introduction to Vertex Attributes deck.gl layers use the WebGL technology to render visualization elements. To have the WebGL drawing command work, multiple things need to be provided and configured beforehand and the geometric description of the to-be-rendered element is one of them. In WebGL, all geometry elements are made of a set of vertices, and each vertex has multiple attributes to determine how it will be rendered to the screen. These attributes are called  vertex attributes  and are provided by users using JavaScript typed arrays (e.g.  Float32Array  or  Uint8Array ). During rendering, these vertex attributes will become available in vertex shaders executing on the GPU. Part of designing a new WebGL layer is creating an elegant mapping from a set of data properties in JavaScript to a set of WebGL vertex attributes, and then implement the code that generates the typed arrays that represent the geometry so that GPU calls can be performed efficiently later when drawing the layer. Introduction to Instanced Vertex Attributes Even for high performance rendering API like WebGL, setting up draw calls and dispatching them to GPUs quick become a performance bottleneck for visualizing big data. Therefore, each deck.gl layer aspires to use as few GPU draw calls as possible to draw all everything contained in the data. Here the  Instanced Rendering  comes into play. While some vertex attributes will still describe the geometry of each object (or instance), some vertex attributes will describe what is different between each object or instance. The latter kind of attributes are called instanced attributes. Note:  While \"instanced rendering\" is technically an \"extension\" to WebGL, (meaning that it is not guaranteed to be present in all browsers), today the feature is supported by wide range of systems.\n WebGL Stats  for statistics on how big a percentage of systems support various WebGL features, particularly the  ANGLE_instanced_arrays  extension. In WebGL 2.0, instanced rendering becomes a core feature that needs to be implemented by all vendors. Learning More While you can certainly start consulting detailed WebGL/OpenGL resources to learn more about vertex attributes, be aware that many available resources can get quite technical, involving more concepts than you may need at this point. If you are new to these concepts, we have found that a great way to learn more is simply to copy an existing deck.gl layer and start extending/modifying its functionality.","headings":[{"value":"Attribute Management","depth":1},{"value":"Overview","depth":2},{"value":"WebGL Performance Challenges","depth":2},{"value":"Automatic Attribute Generation","depth":2},{"value":"Accessors, Shallow Comparisons and updateTriggers","depth":3},{"value":"Advanced Topics","depth":2},{"value":"Manual Buffer Management","depth":3},{"value":"More information","depth":2},{"value":"Introduction to Vertex Attributes","depth":3},{"value":"Introduction to Instanced Vertex Attributes","depth":3},{"value":"Learning More","depth":3}],"slug":"docs/developer-guide/custom-layers/attribute-management","title":"Attribute Management"},{"excerpt":"Composite Layers A composite layer is a special kind of layer that creates other layers. It enables the creation of new layers by careful composition of existing layers (a primary example being the  GeoJsonLayer ). In addition, it is often convenient to change the interface and behavior of an existing layer using a composite \"adaptor\" layer instead of modifying the layer itself (the sample  S2Layer  is a simple adaptor on top of the  PolygonLayer ). Use Cases Adaptor Layers Sometimes an existing layer renders the right thing, but it would be desirable that it accepts another data format, had another interface (different accessors), or performed aggregation on its data. Examples could be: A  LASPointCloudLayer  that accepts  data  as an URL pointing to a  LAS \nfile, and convert it to the format that  PointCloudLayer  consumes. A  TopoJSONLayer  that is like the  GeoJsonLayer , but accepts  TopoJSON  provided to the  data  prop. Adding aggregation to an existing layer. By default, deck.gl layers render one graphical element for each element in the  data  prop. But in some cases, e.g. heatmaps, the data needs to be aggregated (or \"binned\") into cells before rendering. An adaptor in the form of a composite layer is one way to add this functionality. The deck.gl layers  TextLayer ,  HexagonLayer ,  CPUGridLayer  and few others are written as composite \"adapter\" layers. Collection Layers Often a more complex visualization is composited from a number of layers that use a common set of props. For example: A  NodeLayer  that renders a text string inside a circle at each anchor position, by combining the  ScatterplotLayer  and the  TextLayer . A  MapLayer  that takes a custom map data format, breaks it down to sets of geometries by type, and render them with the  PathLayer ,  SolidPolygonLayer , and  TextLayer  respectively. Creating a collection layer have the following advantages: Collect the complex code that handles a specific data format or visual configuration into one class. This helps to create a cleaner, more abstract interface for the users of this layer, and control the complexity of the component that renders the  Deck  instance. Improve memory usage by sharing the same objects/buffers cross layers. Instead of each sublayer loading and storing their own copy of the raw data, the composite layer will manage the data source and pass it down to several layers. The deck.gl layers  GeoJsonLayer  and  PolygonLayer  are written as composite \"collection\" layers. Implementing A Composite Layer Consider the following example: we need a layer that is like the  IconLayer , but renders a text label alongside each icon. A composite layer can be created by extending the  CompositeLayer  class: Defining Composite Layer Properties We will need to define the layer-specific properties of the new layer. In this example, the new layer's interface is a combination of that of the  IconLayer  and the  TextLayer : Rendering Sublayers A composite layer should implement the  renderLayers()  method and return an array of layers (\"sublayers\"). In this example, the idea is to draw an  IconLayer  and a  TextLayer , which share the same source data: Mapping Properties Because the composite layer doesn't draw directly to the canvas, it controls the rendering result by setting props of its sublayers. Since the sublayers do not understand our custom layer's prop names, we will need to map the props of the  LabeledIconLayer  to the appropriate props of each sublayer: Something that needs special attention is that all layer ids must be unique, no matter whether they are nested inside other layers. This means the sublayer ids must be generated dynamically based on the id of their parent, otherwise when there are multiple instances of  LabeledIconLayer s their sublayer ids will collide. Finally, to make  updateTriggers  work when accessors need to be recalculated, we need to remap the user's  updateTriggers  from the parent layer's prop names to the sublayers' prop names. Forwarding Properties There are a number of base  Layer  class props that are usually expected to propagate down to all sublayers, such as  pickable ,  visible ,  coordinateSystem  and  opacity . It is desirable to just forward many of these props directly to the sublayers. There is a method  compositeLayer.getSubLayerProps  that handles a lot of these common compliance chore that were mentioned above. When calling it with a list of prop values that we care about, the list gets wrapped/populated with additional props that will help the sublayers align with deck.gl norms. The complete code looks like follows: Picking By default, the composite layer passes the picking info from its sublayers as-is to the callbacks. However, when we implement an adaptor layer that performs data conversion or aggregation, the data that the sublayer sees may not be the same data that the user passed in. In this case, The composite layer may intercept the event info and modify it by implementing the  getPickingInfo()  method: For more details, read about  how picking works . Transforming Data Because deck.gl's primitive layers expect input to be a flat iteratorable data structure, some composite layers need to transform user data into a different format before passing to sublayers. This transformation may consist converting a tree to an array, filtering, sorting, etc. For example, the  GeoJsonLayer  splits features by type and passes each to  ScatterplotLayer ,  PathLayer  or  SolidPolygonLayer  respectively. The  TextLayer  breaks each text string down to multiple characters and render them with a variation of  IconLayer . From the user's perspective, when they specify accessors such as  getColor , or callbacks such as  onHover , the functions should always interface with the original data that they give the top-level layer, instead of its internal implementations. For the sublayer to reference back to the original data, we can add a reference onto every transformed datum by calling  getSubLayerRow : When the sublayer receives data decorated by  getSubLayerRow , its accessors need to know how to read the data to access the original objects. In the above example,  getPosition: d => d.position  would fail if called with  {timestamp: 0} , while the user expects it to be called with  {position: [-122.45, 37.78], timestamps: [0, 1, 4, 7, 8]} . This can be solved by wrapping the user-provided accessor with  getSubLayerAccessor : The default implementations of lifecycle methods such as  getPickingInfo  also understand how to retrieve the original objects from the sublayer data if they are created using  getSubLayerRow .","headings":[{"value":"Composite Layers","depth":1},{"value":"Use Cases","depth":2},{"value":"Adaptor Layers","depth":3},{"value":"Collection Layers","depth":3},{"value":"Implementing A Composite Layer","depth":2},{"value":"Defining Composite Layer Properties","depth":3},{"value":"Rendering Sublayers","depth":3},{"value":"Mapping Properties","depth":3},{"value":"Forwarding Properties","depth":3},{"value":"Picking","depth":3},{"value":"Transforming Data","depth":3}],"slug":"docs/developer-guide/custom-layers/composite-layers","title":"Composite Layers"},{"excerpt":"Writing Your Own Layer Preparations Before creating a new layer, it is recommended that you verify that you can not achieve the desired effect either through layer subclassing or through using composite layers. There are a couple of ways to build a layer in deck.gl, and it is helpful to consider what approach will serve you best before starting: Create a composite layer  - A composite layer is a special kind of layer that creates other layers. This allows you to build e.g. a \"semantic layer\" - a layer that presents a different interface (set of props) than an existing layer, transforms those props into a format that fits and existing layer, etc. Subclass a layer  - Subclassed layer is a new layer created by subclassing another layers. This allows the developer to reuse all of the interfaces and implementations of an existing layer unless they are explicitly overridden. Implement a layer from scratch  - If you want to draw something completely different and you are comfortable with WebGL and shader programming, this option gives you the most flexibility. You have full control of the layer lifecycle, you can manage your own model(s) and directly manipulate the WebGL context. Creating The Layer class Your layer class must be a subclass of  Layer . It can be a direct subclass of  Layer , or extend another layer. Naming Your Layer Store the layer name in the  layerName  static property on your  Layer  subclass: The layer name will be used as the default id of layer instances and also during\ndebugging. Defining Layer Properties The list of properties is the main API your new layer will provide to\napplications. So it makes sense to carefully consider what properties\nyour layer should offer. You also need to define the default values of the layer's properties. The most efficient method of doing this is to define a static  defaultProps \nmember on your layer class. Also consider the properties of the base  Layer  class,\nas well as any other inherited properties if you are deriving.","headings":[{"value":"Writing Your Own Layer","depth":1},{"value":"Preparations","depth":2},{"value":"Creating The Layer class","depth":2},{"value":"Naming Your Layer","depth":3},{"value":"Defining Layer Properties","depth":3}],"slug":"docs/developer-guide/custom-layers","title":"Writing Your Own Layer"},{"excerpt":"Creating Layer Extensions It's recommended that you read  subclassing layers  before proceeding Sometimes we need to modify several deck.gl layers to add similar functionalities. If we create custom layer classes for each one of them, it will require multiple files that contain more or less the same code.  Layer extension  is a way to generalize, reuse, and share subclassed layer code. Example: Subclassing Is Not Enough Consider a hypothetical use case: in a  ScatterplotLayer , we inject a piece of custom code into the fragment shader to highlight every object that is red. If we want to do the same for  GeoJsonLayer , it becomes more complicated. We will need to subclass all of  ScatterplotLayer ,  PathLayer  and  SolidPolygonLayer , then tell the  GeoJsonLayer  to use our custom classes: We end up with copying and pasting a lot of code. The same functionality can be achieved by creating a layer extension. When we give an extension to a composite layer such as  GeoJsonLayer , it's automatically passed down to all its sublayers, including  ScatterplotLayer ,  PathLayer  and  SolidPolygonLayer . Now we can implement the red filter once and only once in the custom extension, and use it everywhere! LayerExtension Interface Constructor The base layer extension constructor optionally takes one argument  opts  and stores it in  this.opts . This object will be accessible to lifecycle methods via  extension.opts . Additional properties can also be attached to the extension instance in the constructor for future use. Note that if two extension instances are of the same class and have the same  opts  object, they are considered equal during layer updates. Creating a new extension instance with different options can potentially lead to the layers that use this extension to recompile their shaders, which may be an expensive operation.  opts  is generally only used for options that require shader updates. Methods When a layer extension is used, it injects itself into a layer. This means that you can implement most of the  layer lifecycle methods  as part of the extension, and they will be executed in addition to the layer's own. getShaders Called to retrieve the  additional  shader parameters. Returns an object that will be merged with the layer's own  getShaders  result before sending to luma.gl's  shader assembly . See  writing shaders  for deck.gl-specific modules and hooks. When this method is executed,  this  points to the layer. Receives one argument: extension  - the source extension instance. initializeState Called after the layer's own  initializeState . When this method is executed,  this  points to the layer. Arguments: context  - same context object passed to  layer.initializeState . extension  - the source extension instance. updateState Called after the layer's own  updateState . When this method is executed,  this  points to the layer. Arguments: params  - same object passed to  layer.updateState . extension  - the source extension instance. draw Called before the layer's own  draw . When this method is executed,  this  points to the layer. Arguments: params  - same object passed to  layer.draw . extension  - the source extension instance. finalizeState Called after the layer's own  finalizeState . When this method is executed,  this  points to the layer. Arguments: extension  - the source extension instance. getSubLayerProps Called by composite layers to retrieve the  additional  props that should be passed to its sublayers. Normally, a composite layer only passes through props that it recognizes. If an extension adds new props to a layer, then it is responsible of collecting these props by implementing this method. Arguments: extension  - the source extension instance. Example: Layer Extension Back to our example use case. We can implement the red filter with the following code that works with all deck.gl layers: This example is on  codepen .","headings":[{"value":"Creating Layer Extensions","depth":1},{"value":"Example: Subclassing Is Not Enough","depth":2},{"value":"LayerExtension Interface","depth":2},{"value":"Constructor","depth":3},{"value":"Methods","depth":3},{"value":"getShaders","depth":5},{"value":"initializeState","depth":5},{"value":"updateState","depth":5},{"value":"draw","depth":5},{"value":"finalizeState","depth":5},{"value":"getSubLayerProps","depth":5},{"value":"Example: Layer Extension","depth":2}],"slug":"docs/developer-guide/custom-layers/layer-extensions","title":"Creating Layer Extensions"},{"excerpt":"Layer Lifecycle Every deck.gl layer subclass can define certain methods that get called\nat certain points in its lifecycle. The layer can specify how its state\nis initialized and finalized, if and how it should react to property changes,\nand how it should draw and pick the layer. deck.gl Rendering Cycles Internally, deck.gl sets up the animation loop and calls provided\ncallbacks on initial load and for each rendered frame.\nWhen the deck.gl layer list is drawn to screen, it matches the new Layer\ninstances with the instances from the previous render call, uniquely identified\nby their  id  property.\nEvery time you create a new layer with the same  id  property as a layer you\nrendered last time, deck.gl consider the new layer instance an \"update\" of the\nold instance. layer.state  is an object that is internal to an instance of a layer.\nWhen a new layer instance is matched to an existing layer instance by  id ,\nthe state object of the old layer becomes accessible to the new layer.\nLayers can use the state object to store persistent information cross rendering cycles. Layer Lifecycle Stages Initialization Initialization happens only once for each layer that is being added, i.e. a layer from the\ncurrent rendering cycle whose  id  does not get matched with any layer in the previous\ncycle.\n layer.initializeState()  is called at\nthis stage. At the end of initialization,\n layer.updateState()  is called\nbefore the first render. Updating Updating happens when a new layer has been matched with a layer from the previous\nrendering cycle (resulting in new props being passed to that layer),\nor when context has changed and layers are about to be drawn. layer.shouldUpdateState() \nis called to determine if the layer needs an update. The default implementation updates on prop and data changes, but not on viewport changes, so screen-space based layers may want to override this (see e.g. ScreenGridLayer).\nUnder more complicated circumstances, additional checks can be supplied through the\n dataComparator \nprop. If the layer does need to be updated,\n layer.updateState() \nis called to perform any necessary operation before the layer is rendered.\nThis usually involves recalculating an attribute by calling\n state.attributeManager.invalidate \nand updating uniforms by calling  model.setUniforms .\nBy default, when  props.data  changes, all attributes are invalidated and recalculated. A composite layer may use\n compositeLayer.renderLayers() \nto insert one or more deck.gl layers after itself.\nThe generated layers will then be matched and updated,\nallowing the decomposition of the drawing of a complex data set\ninto \"primitive\" layers. Rendering Rendering happens during each rendering cycle to draw the layer to the WebGL context. For primitive layers,  layer.draw() \nis called at this stage, which invokes the layers'  model.render  calls.\nFor composite layers,  layer.renderLayers  is called to generate sublayers. Picking Happens when a pointer moves over or clicks on the deck.gl canvas. layer.draw()  of all pickable layers\nare called with special uniforms to draw into an off-screen picking buffer. When a layer is picked,\n layer.getPickingInfo() \nis called to generate the  info  object of information about what has been picked.\nThis object is then passed to the  onHover  or  onClick  callbacks of the layer. Read more about  how picking works . Finalization Happens for each layer that is being removed, i.e. a layer from the previous\nrendering cycle whose  id  did not get matched with any layer in the current\ncycle.\n layer.finalizeState() \nis called just before the reference to the state of that layer\nis released. Comparison with React's Lifecycle If you are familiar with React and the\n React component lifecycle \nyou will quickly understand the deck.gl layer lifecycle as it is based on\nsimilar ideas. In particular, experience with the React lifecycle should help\nyou understand property change management and how to use the\n shouldUpdateState  and  updateState  methods. Still, there are a couple of notable differences between the lifecycle\nmethods provided by the two frameworks: deck.gl performs preliminary analysis on certain props and context and\nprovides a  changeFlags  object to your  shouldUpdateState  and\n updateState . deck.gl's  updateState  method is called both on layer initialization and\non when props or context is updated. This is different from React's\n willReceiveProps  that is not called when the component is initially created,\nThe deck.gl model avoids requiring the same property checks to be performed\ntwice in both the constructor and  willReceiveProps . deck.gl separates rendering into the  draw  and  renderLayers  methods,\nwhere React just needs  render . deck.gl's  pick  and  pickInfo  methods have no correspondence in\nReact's lifecycle. Note : deck.gl uses a simpler component model than React.\n  While React backs instance with a separate component, deck.gl just transfers\n  the old layers' state objects to any new matched layers. Note : the data prop, attribute props and the viewport context are\n  central to deck.gl layers and get special handling. React is more generic\n  and leaves the interpretation of most props to the component.","headings":[{"value":"Layer Lifecycle","depth":1},{"value":"deck.gl Rendering Cycles","depth":2},{"value":"Layer Lifecycle Stages","depth":2},{"value":"Initialization","depth":3},{"value":"Updating","depth":3},{"value":"Rendering","depth":3},{"value":"Picking","depth":3},{"value":"Finalization","depth":3},{"value":"Comparison with React's Lifecycle","depth":2}],"slug":"docs/developer-guide/custom-layers/layer-lifecycle","title":"Layer Lifecycle"},{"excerpt":"Picking Make sure you have read  Interactivity  before reading this section. How It Works The Color Picking Technique Rather than doing traditional ray-casting or building octrees etc in JavaScript, deck.gl implements picking on the GPU using a technique we refer to as \"color picking\". When deck.gl needs to determine what is under the mouse (e.g. when the user moves or clicks the pointer over the deck.gl canvas), all pickable layers are rendered into an off-screen buffer, but in a special mode activated by a GLSL uniform. In this mode, the shaders of the core layers render picking colors instead of their normal visual colors. Each object in each layer gets its own picking color assigned. The picking color is determined using  layer.encodePickingColor()  that converts the index of a object of a given layer into a 3-byte color array (the color buffer allows us to distinguish between 16M unique colors per layer, and between 256 different layers). After the picking buffer is rendered, deck.gl looks at the color of the pixel under the pointer, and decodes it back to the index number using  layer.decodePickingColor() . Event Propagation Once an object is picked, deck.gl creates a  picking info  object that describes what is under the pointer. The  layer.getPickingInfo()  method is called first on the layer that directly rendered the picked object, to modify or add additional fields to the info. The info object is then passed to the  getPickingInfo()  of its parent layer, and then its grandparent, and so on. This is so that composite layers can further augment the  info  object after it is processed by the picked sublayer. This allows the composite layer to hide implementation details and expose only user-friendly information. When the processing chain is over, the event is invoked on the top-level layer. This means that only the top-level layer's  on<Event>  callbacks are invoked, and the final picking info's  layer  field will point to the top-level layer. The idea is that the user should only interface with the layer that they created, and not having to know the underlying implementation. When an event fires, the callback functions are executed in the following order: layer.on<Event>  (default implementation invokes  this.props.on<Event> ) layer.props.on<Event>  (only if the layer method is not defined) deck.props.on<Event> If any of the callback functions return  true , the event is marked handled and the rest of the callbacks will be skipped. Default Handling of Pointer Events Whenever the pointer moves over the canvas, deck.gl performs a new picking pass, yielding a picking info object describing the result. This object is used for multiple purposes: The  onHover  callbacks are called with it To update the picked layer if  autoHighlight  is enabled Saved for later use When other gestures (click, drag, etc.) are detected, deck.gl does not repeat picking. Instead, their callbacks are called with the last picked info from  hover . Implementing Custom Picking While deck.gl allows applications to implement picking however they want,\nspecial support is provided for the built-in \"picking color\" based picking\nsystem, which most layers use. To take full control of picking, a layer need to take the following steps: Creating A Picking Color Attribute Add an attribute for each vertex using the layer's  AttributeManager : Populate the attribute by providing a different picking color for every object that you need to differentiate. The default implementation of  layer.encodePickingColor()  and  layer.decodePickingColor()  is likely sufficient, but you may need to implement your own pair. By default, the  object  field of the picking  info  object is indexed from the layer's  data  prop. Custom layers often need to define on their own terms what constitutes meaningful information to the user's callbacks. A layer can achieve this by overriding  layer.getPickingInfo()  to add or modify fields to the  info  object. Model object creation If your layer creates its own  Model  object, add picking module to  modules  array. Implementing Picking in Custom Shaders All core layers (including composite layers) support picking using luma.gl's  picking module . If you are using custom shaders with any of the core layers or building custom layers with your own shaders, the following steps are needed to enable picking: Vertex Shader Vertex shader should set current picking color using  picking_setPickingColor  method provided by picking shader module. Fragment Shader Fragment shader should use  picking_filterPickingColor  to update  gl_FragColor , which outputs picking color if it is the picking pass. For more details refer to luma.gl's  Picking Module .","headings":[{"value":"Picking","depth":1},{"value":"How It Works","depth":2},{"value":"The Color Picking Technique","depth":3},{"value":"Event Propagation","depth":3},{"value":"Default Handling of Pointer Events","depth":3},{"value":"Implementing Custom Picking","depth":2},{"value":"Creating A Picking Color Attribute","depth":3},{"value":"Model object creation","depth":3},{"value":"Implementing Picking in Custom Shaders","depth":3},{"value":"Vertex Shader","depth":4},{"value":"Fragment Shader","depth":3}],"slug":"docs/developer-guide/custom-layers/picking","title":"Picking"},{"excerpt":"Primitive Layers If you want to draw something completely different and you are comfortable around WebGL, you may consider implementing a new layer by directly extending the  Layer  class. Implementing the Layer Lifecycle Functions To describe how a layer's properties relate to WebGL attributes and uniforms you need to implement the layer's  lifecycle functions . Initializing Layer initializeState()  - This is the one method that you must implement to create any WebGL resources you need for rendering your layer. Creating The Model A layer should create its model during this phase. A model is a  luma.gl   Model  instance that defines what will be drawn to the WebGL context. Most layers are  Single-model layers  - this is the predominant form among all core layers that deck.gl currently provides. In these layers, a single geometry model is created for each layer and saved to  state.model  during initialization. The default implementation of the rest of the lifecycle methods will then look for this model for rendering and picking etc., meaning that you don't have to do anything more to get a working layer. A choice to make is whether your WebGL primitives (draw calls) should be instanced, or use dynamic geometry: Instanced layer  - This type of layer renders the same geometry many times. Usually the simplest way to go when creating a layer that renders a lot of similar objects (think ScatterplotLayer, ArcLayers etc). Dynamic geometry layer  - This is needed when dealing with data that needs to be rendered using multiple similar but unique geometries, such as polygons (i.e. the geometries are not copies of each other that that only differ in terms of parameters). It is sometimes desirable to have a single layer render using multiple geometry primitives (e.g both circles and lines, or triangles and textured meshes etc), rather than creating separate layers. The custom  AxesLayer example  uses this technique to share attributes between grids and labels. Defining Attributes A layer should also define its attributes during initialization. This allows the  attribute manager  to do the heavy lifting for  Attribute Management . Define attributes by calling  attributeManager.add : Handling property updates updateState()  - This is the method that you may want to implement to handle property changes. The key to writing good, performant deck.gl layers lies in understanding how to minimize updates of any calculated data, such as WebGL. The ideas used here are very similar to (and directly inspired by) those used in the React/Redux/Flux/Immutable.js communities, and learning more about those frameworks can be helpful as a way to get a better understanding of how to use these concepts in the best way. data  - Typically if a layer is re-rendered with a changed  data  prop, all WebGL attributes must be regenerated and the layer needs to be redrawn. The default is to do exactly that, but sometimes a layer can be smarter and limit updates, or more work needs to be done. If the viewport has changed, the layer will automatically be re-rendered. Many layers can thus ignore viewport changes, however, if the layer has any dependencies on the viewport (such as a layer that calculates extents or positions in screen space rather than world space) it would need to update state or uniforms whenever the viewport changes. If other props change, it would typically mean that the layer needs to update some uniform or state so that rendering is affected appropriately. Rendering Layer draw()  - If you want to use custom uniforms or settings when drawing, you would typically implement the  draw  method and pass those to your render call. Note that  draw  is called with viewport uniforms that you need to pass to your shader, but you can of course add any layer specific uniforms to that. Note: the reason that the supplied uniforms need to be passed on to your shaders is to enable your shader to use deck.gl's GLSL shaderlibs (such as  project  or  project64  etc.). If you don't use these shaderlibs, you would obviously not need to supply these uniforms, but you would have to implement features like cartographic projection etc. on your own. Destroying Layer finalizeState()  - If implemented, this method is called when your layer state is discarded. This is a good time to destroy non-shared WebGL resources directly, rather than waiting for the garbage collector to do it. Handling Coordinate Systems While you have the freedom to create any type of layer you want, with any type of coordinate system that suits your application, a common characteristic of the layers provided by deck.gl is that they work seamlessly as map overlays, both with positions specified as longitude and latitude coordinates, as well as with positions specified in meters. Making Shaders Work with deck.gl's Coordinate Systems By supplying the  modules: ['project']  parameter when you create your layer's luma.gl  Model  you get access to deck.gl's  family of GLSL projection methods  that support all three deck.gl projection modes: latlon (default), meters and neutral. By always using the following shader functions for handling projections and scaling, a single layer class can support all projection modes for free: All positions must be passed through the  project_position  function (available both in JavaScript and GLSL) to convert non-linear web-mercator coordinates to linear mercator \"world\" or \"pixel\" coordinates, that can be passed to the projection matrix. All offsets must be passed through the  project_scale  function (available both in JavaScript and GLSL) to convert distances to world coordinates. Note that that distance scales are latitude dependent under web mercator projection (see  http://wiki.openstreetmap.org/wiki/Zoom_levels  for more details), so scaling will depend on the viewport center and should only be expected to be locally correct. Implement Picking If your layer is instanced ( data  prop is an array and each element is rendered as one primitive), then you may take advantage of the default implementation of the  layer picking methods . By default, each layer creates an  instancePickingColors  attribute and automatically calculates it using the length of the  data  array. For custom picking, read about  Implementing Custom Picking .","headings":[{"value":"Primitive Layers","depth":1},{"value":"Implementing the Layer Lifecycle Functions","depth":2},{"value":"Initializing Layer","depth":3},{"value":"Creating The Model","depth":4},{"value":"Defining Attributes","depth":4},{"value":"Handling property updates","depth":3},{"value":"Rendering Layer","depth":3},{"value":"Destroying Layer","depth":3},{"value":"Handling Coordinate Systems","depth":2},{"value":"Making Shaders Work with deck.gl's Coordinate Systems","depth":3},{"value":"Implement Picking","depth":2}],"slug":"docs/developer-guide/custom-layers/primitive-layers","title":"Primitive Layers"},{"excerpt":"Property Types This article documents the system that deck.gl offers to provide extra type annotations for layer properties. A number of deck.gl features are enabled by rich descriptions of the types of the properties in a layer: Asynchronous props (e.g. loading layer data from an URL) Type checking (during development) Improve render performance, see \"Prop Types and Performance\" section below Transitions and Animation Reflection  (e.g. dynamically creating UI controls for layer props) Declaring Layer Properties A layer class may supply a static member  defaultProps  that defines its default property types and values: When the user construct this layer, the props are resolved as such: Property Types The property types system enables layers to opt-in to specifying types, and also allows a certain amount of type auto-deduction to happen based on existing default values for layers that do not opt in. Each prop in  defaultProps  may be an object in the following shape: type  (string, required) value  (any, required) - the default value if this prop is not supplied async  (boolean, optional) - if  true , the prop can either be a  Promise  that resolves to its actual value, or an url string (loaded using the base Layer's  fetch  prop). transform  (function, optional) - transforms an asynchronously loaded value and returns a new form. Receives the following arguments: value  - the new value of this prop propType  - this prop type definition layer  - the owner of this prop release  (function, optional) - release a transformed value when it's no longer in use. Receives the following arguments: value  - the old value of this prop propType  - this prop type definition layer  - the owner of this prop validate  (function, optional) - returns  true  if the value is valid. Validation of layer props is only invoked in debug mode. This function is automatically populated if the prop has a built-in type. Receives the following arguments: value  - the value to be validated propType  - this prop type definition equal  (function, optional) - returns  true  if the two prop values should be considered equal. Comparison of layer props is invoked during layer update and the result is passed to  changeFlags.propsChanged . This function is automatically populated if the prop has a built-in type. Receives the following arguments: value  - the new value of this prop oldValue  - the previous value of this prop propType  - this prop type definition deprecatedFor  (string|array, optional) - mark this prop as deprecated. The value is the new prop name(s) that this prop has been deprecated for. If the old prop is supplied instead of the new one, its value will be transferred to the new prop. The user will get a warning about the deprecation. Any additional options, see individual types below. Built-in Types boolean Any value. Default  validate : always pass Default  equal : compared by truthiness number A numeric value. Options: min  (number, optional) - the minimum allowed value max  (number, optional) - the maximum allowed value Default  validate : value is finite and within bounds (if specified) Default  equal : strict equal color A RGBA color. Default  validate : value is an array of 3 or 4 elements Default  equal : deep equal image One of: URL string,  Texture2D  object,  Image ,  HTMLCanvasElement ,  HTMLVideoElement ,  ImageBitmap  or  ImageData . Default  transform : converts to a  Texture2D  object array An array of objects. Options: optional  (boolean, optional) - accept  null  or  undefined . Default  false . compare  (boolean, optional) - compare deeply during prop comparison. Default  false . Default  validate : value is an array of 3 or 4 elements Default  equal : shallow equal if  compare: false , otherwise deep equal accessor An accessor used to update shader attributes. Default  validate : value is either a function or the same type as the default value Default  equal :  true  if function, otherwise deep equal function A function. Options: optional  (boolean, optional) - accept  null  or  undefined . Default  false . compare  (boolean, optional) - compare strictly during prop comparison. Default  true . Default  validate : value is a function Default  equal :  true  if  compare: false , otherwise strict equal Prop Types and Performance The performance of a deck.gl application can be greatly improved by limiting the frequency of layer updates. Consider the following app: Each time the user interacts with the viewport, the app state is updated, and  render()  is called. Because  getElevation ,  getFillColor  and  getLineColor  are functions and arrays defined inline, they have changed from the previous render. Usually, any prop change results in updating a layer, that is, recomputing its internal states. Updating a layer could be expensive. In GeoJsonLayer's case, it creates ScatterplotLayer, PolygonLayer and PathLayer, and those layers also need to be updated recursively. In reality, we do not want to update GeoJsonLayer, because no layer props changed from the user's perspective. In GeoJsonLayer, these props are declared as such: The default comparator of the  access  prop type ignores shallow changes in functions. As a result, deck.gl decides that no props have changed between the two renders, and the GeoJsonLayer does not need to be updated.","headings":[{"value":"Property Types","depth":1},{"value":"Declaring Layer Properties","depth":2},{"value":"Property Types","depth":2},{"value":"Built-in Types","depth":3},{"value":"boolean","depth":5},{"value":"number","depth":5},{"value":"color","depth":5},{"value":"image","depth":5},{"value":"array","depth":5},{"value":"accessor","depth":5},{"value":"function","depth":5},{"value":"Prop Types and Performance","depth":2}],"slug":"docs/developer-guide/custom-layers/prop-types","title":"Property Types"},{"excerpt":"What's New This page contains highlights of each deck.gl release. Also check our  vis.gl blog  for news about new releases and features in deck.gl. deck.gl v8.8 Release date: June, 2022 TypeScript Official typings are now available in deck.gl for public preview. It was a tremendous effort converting the deck.gl code base into TypeScript. We did it not just for TypeScript users to easily consume this library, but also for the overall robustness and maintainability of our own code base. In v8.x, the types will not be exposed by default to prevent any typing errors from breaking existing TypeScript applications. You can opt in to using the typed version by switching your import statements to the  @deck.gl/*/typed  endpoints. Visit  getting started with TypeScript  to find out more. Custom Indexing System in TileLayer The  TileLayer  is fundamental when it comes to visualizing datasets so big that they cannot fit in the browser's memory. The idea is to only fetch and render content that is visible in the current viewport, and at the appropriate detail level. Up till now, the  TileLayer  has exclusively implemented  the OSM tile index . If you wish to use it with your dataset, you had to use an offline tool or an backend that partitioned geospatial data into OSM tiles. Starting from v8.8, the  TileLayer  supports custom indexing systems. Applications can now supply a custom implementation of  Tileset2D  to the  TilesetClass  prop. This makes it possible to use incremental loading with other indexing systems such as  H3  and  S2 . The immediate use case is to allow the client visualization to work with any geospatial partitioning algorithm available in a database solution. Due to this generalization, there is a breaking change affecting indexing properties ( x ,  y  and  z ) in the  TileLayer  API. See  upgrade guide  for details. MapboxOverlay The  @deck.gl/mapbox  module now exports a new class  MapboxOverlay . The class implements Mapbox GL JS's  IControl  API. When adding a  MapboxOverlay  control to an mapbox map, deck.gl layers are rendered in synchronization with the base map layers. This control supports both  overlaid and interleaved  rendering modes. See the new  get started example . If you are using react-map-gl v7, this is the only solution to use deck.gl with React map control components ( Navigationcontrol ,  GeolocateControl , etc.). See  example . @deck.gl/carto CartoLayer includes native support to work with spatial indexes like  H3  or  QuadBin . More info  here . Enhancements Views now accept a  padding  option to offset the focal point. Improved performance when there are many invisible layers Improved picking performance when using the  TileLayer deck.gl v8.7 Release date: February 25, 2022 MaskExtension The new  MaskExtension  allows layers to show/hide objects by a geofence. For example, a map may filter a list of user locations by the boundaries of a given country, or highlight part of a base map that is inside a user-drawn circle or lasso area. QuadkeyLayer The new  QuadkeyLayer  renders filled and/or stroked polygons, with geometry automatically calculated based on a quadkey (geospatial index). Enhancements TileLayer  reduced  refinementStrategy: 'no-overlap' . TileLayer   refinementStrategy  now accepts a callback function enabling customer refinement strategies. TerrainLayer  can now be used with non-geospatial views. ColumnLayer  adds  flatShading  prop. GlobeView  lighting in 3D layers is more consistent. GoogleMapsOverlay  supports camera tilt and bearing for raster maps. MVTLayer  now supports  pointType: 'text'  in  binary  mode. Picking with  project3D: true  now returns more accurate result in non-geospatial views. @deck.gl/carto fetchMap  -  fetchMap  is added to the  CARTO deck.gl submodule , streamlining the display of maps created using CARTO platform. Support for large tables and Databricks . See  CARTO documentation  for more details. deck.gl v8.6 Release date: October 11, 2021 Interleaving deck.gl layers with Google Maps vector rendering The  GoogleMapsOverlay class  supports Google Maps' new  vector map , providing the following advantages: Shared 3D space: objects drawn by the  GoogleMapsOverlay  class appear inside the Google Maps scene, correctly intersecting with 3D buildings and behind the contextual labels drawn by Google Maps. Tilting and rotating the view is supported. Rendering uses the same WebGL context as Google Maps, improving performance. See blog posts from  Google Cloud  and  our own  for the potentials of this feature. Visit the new  Google Maps integration example  to get started. OrthographicView It is now possible to independently control the zoom of the X and Y axes. The  zoom  prop of the  OrthographicView  now also supports an  [x, y]  Array to specify independent zoom levels. A  zoomAxis  option is added to the  OrthographicController  to restrict zooming to the X or Y axes. MapView Meter sizes are now correctly calculated based on the latitude of the point being drawn, whereas they previously were based on the center point of the viewport. This brings the view into full compliance with the Web Mercator projection. A new unit enum  common  is added for scaling geometries without the distortion of the projection method. See updated documentation about the  unit system . A new  projectionMatrix  option allows overriding of the matrix that would otherwise be created from the other view states. Layer Enhancements CartoLayer  adds new  geoColumn  and  columns  props, enables more granular data fetching from CARTO backend. ColumnLayer  and  GridCellLayer  add  radiusUnits  prop. H3HexagonLayer  now supports manually forcing low-precision, high-performance rendering with  highPrecision: false .  HeatmapLayer  adds  weightsTextureSize  and  debounceTimeout  props for fine-tuning performance. MVTLayer  now defaults to handling geometries in binary. Scatterplot  and  GeoJsonLayer  add option to turn off antialiasing to avoid artifacts in depth oclusion. TileLayer  no longer purges its cache when data changes, resulting in a smoother \"reload\" experience deck.gl v8.5 Release date: July 26, 2021 Layer Improvements MVTLayer Mapbox Vector Tiles parsing throughput is now 2-3x faster, due to MVT tiles being parsed directly into binary attributes rather than GeoJSON, and additional work (including  triangulation ) being performed on worker threads. Speed comparison on some example data sets (MVT tiles parsed per second): Data set binary: false binary: true Speed increase Block Groups 2.86/s 5.57/s 1.94x Census Layer 6.09/s 11.9/s 1.95x Counties Layer 72.5/s 141/s 1.94x USA Zip Code Layer 8.45/s 20.3/s 2.4x Benchmarks ran using scripts on a 2012 MacBook Pro, 2.3 GHz Intel Core i7, 8 GB, measuring parsing time of MVTLoader only (network time and rendering is not included) GeoJsonLayer GeoJSONLayer now supports rendering point features as icons and/or text labels in addition to circles. Use the new  pointType  prop: For a full list of new props, visit the updated  documentation . TextLayer The layer now supports automatically detecting the characters used in the data. Set  characterSet: 'auto'  to enable this feature. New props are added for more flexible styling of the texts: background backgroundPadding outlineWidth outlineColor getBackgroundColor getBorderWidth getBorderColor See  documentation  for details. Tile3DLayer Tile3DLayer can now be rendered in multiple views. Previously if you use multiple views it was required to create one Tile3DLayer for each view. Using a single layer is more efficient by sharing the tile cache. The layer now takes full advantage of new features in I3S 1.7 tile sets, including: Picking individual objects inside a tile Page nodes (improved performance) Draco compressed meshes (improved performance) Compressed textures (improved performance) PBR materials Vertex colors UVRegions Other layer improvements ScatterplotLayer  adds  billboard  mode TripLayer  adds  fadeTrail  mode PathLayer  now supports controlling  jointRounded  and  capRounded  separately. Dashed lines via  PathStyleExtension  also respects the cap type. PolygonLayer  and  GeoJsonLayer :  autoHighlight  now highlight both the outline and the fill of the hovered polygon, instead of either the outline or the fill. HeatmapLayer  now correctly renders  aggregation: 'MEAN'  with user-supplied  colorDomain . Default transpilation and bundle size The NPM distribution has dropped IE 11 support in exchange for an almost 20% reduction in size. Entry point 8.5 Bundle (gzipped) 8.4 Bundle (gzipped) Comments module (dist/esm) 398 KB (115 KB) 485 KB (128 KB) Transpiled, tree-shaking enabled main (dist/es5) 686 KB (178 KB) 812 KB (197 KB) Transpiled, no tree-shaking Measured as the footprint of @deck.gl/core, bundled and minified with Webpack 4 To support older or less common browsers, make sure that  node_modules  is included in your application's babel settings. For backward compatibility, the pre-built bundle ( dist.min.js ) is not affected by this change. @deck.gl/react The  DeckGL  React component is rewritten using functional component and hooks. @deck.gl/carto Integration with  CARTO 3 platform . With deck.gl and the CARTO 3 platform you can access directly your datasets and tilesets hosted in your current data warehouse (BigQuery, Snowflake, Redshift, Postgres). You don't need to move your data to CARTO plaform. A new  CartoLayer  is available to unify  CartoBQTilerLayer  and  CartoSQLLayer . There are migration guides for both:  CartoSQLLayer  and  CartoBQTilerLayer . New  getData  method in CARTO 3  to support other deck.gl layers .  deck.gl v8.4 Release date: Jan 31, 2021 Better Interaction Improved experience on mobile devices All controllers now support smooth easing at the end of dragging and pinching. This can be turned on via the new  inertia  option: In addition, a three-finger swipe gesture is added to support changing pitch on mobile. It is enabled via the  touchRotate  option. More customizable controller behavior New  dragMode  option for flipping pan/rotate modes The  keyboard  option now accepts an object for customizing movement speed The  scrollZoom  option now accepts an object for customizing wheel zoom speed and easing New Deck component API eventRecognizerOptions  for fine-tuning gesture recognition onInteractionStateChange  callback The  getCursor  now receives an  isHovering  argument that indicates whether the pointer is over a pickable object. MVT Layer TileJSON The  data  prop now accepts a  TileJSON  URL. The  onDataLoad  callback is fired when the TileJSON loads. Query rendered features A new method  getRenderedFeatures  is added for querying all visible features in the current viewport. Features in WGS84 coordinates onHover ,  onClick ,  onTileLoad ,  onTileError  and  onViewportLoad  callbacks can now access features in WGS84 coordinates. Binary mode A new prop  binary  is added to the MVTLayer. If set to  true , it removes the need for serialization and deserialization of data transferred by the worker back to the main process, as well as attribute packing in the main thread. The following numbers show the performance improvements in loading and rendering a full viewport: N Vertex  Binary Non-Binary Change Usa Admin States 12K  963ms 1109ms -13.16% Counties Layer 175K 1222ms 1956ms -37.52% Census Tract 988K  2713ms 6242ms -56.53% Block groups 1.57M 4261ms 9202ms -53.69% Usa Zip Code Layer 1.38M 2938ms 6564ms -55.24% Benchmark run on 2017 Macbook Pro, 3,1 GHz Dual-Core Intel Core i5, 16 GB memory, Intel Iris Plus Graphics 650 1536 MB. Resolution 1140x900. Network transfer time is not included Layer improvements All layers Add a new  loaders  prop to support additional data formats. See the  Data Loading Guide  for examples. Layers that use a texture (e.g.  BitmapLayer ,  IconLayer ,  SimpleMeshLayer ) now offer consistent support for a variety of input formats. Newly supported are plain object descriptors (e.g.  {data: <Uint8Array>, width, height} ) and  HTMLVideoElement  that continuously updates. A new prop  textureParameters  also allows easy customization of texture settings. HeatmapLayer  adds new prop  aggregation  which can be either  SUM  (default) or  MEAN . BitmapLayer picking callbacks now provide information on which pixel was picked. Adds experimental  _imageCoordinateSystem  prop, so that raster tiles may render correctly in  GlobeView . GlobeView  now works with  COORDINATE_SYSTEM.CARTESIAN  and  SunLight . TileLayer  now supports  modelMatrix . IconLayer  adds  onIconError  callback. OrthographicView  adds  flipY  option. ArcLayer  and  LineLayer  now render the shortest path with  wrapLongitude: true . Additionally, various layers received performance optimization, corrected lighting calculation, and API consistency improvements. See  upgrade guide  for a list breaking changes in this release. Functions in declarative language @@function  prefix is included to interpret a string as a JavaScript function.  @deck.gl/carto Adds  helper functions  to create data-driven map visualizations using  CARTOColors deck.gl v8.3 Release Date: Oct 12, 2020 New module: @deck.gl/carto Integration with the powerful geospatial analytics platform  CARTO . This new modules makes it easy to visualize regular Tables and vector tilesets in CARTO. It offers two new layers: CartoSQLLayer : a layer to visualize data hosted in your CARTO account and to apply custom SQL. CartoBQTilerLayer : a layer to visualize large datasets (millions or billions of rows) directly from  Google BigQuery . This effort enables applications to leverage CARTO's smart back-end capabilities, dynamic queries and much more. Visit the module's  documentation  to get started. TileLayer getTileData  now receives an additional argument  signal  that implements  AbortSignal . Tile requests may now be aborted if there are too many queued or ongoing requests. The  getTileData  function passed in to the current layer instance will be called rather than the first layer instance. This allows applications to progressively adjust loading behavior without having to reload all tiles. New  onTileUnload  callback URL templates now support  {-y}  for TMS indexing Experimental support for  GlobeView  in  TileLayer  and  MVTLayer Improved memory usage in tile caching General Performance Layers with  pickable  disabled (the default) skip generating picking attributes. This can improve initial loading time and memory usage if a large layer does not have to be interactive. If no layer is pickable, deck no longer creates the picking FrameBuffer to save memory. Deck  also added some experimental  optimization options  to allow more fine-grained control of memory usage on memory-restricted devices. pydeck 0.5 pydeck 0.5 includes new event handlers —  on_hover ,  on_click ,  on_view_state_change , and  on_resize  — which can be used to create rich interactive applications in Jupyter. This release works in sync with deck.gl 8.3. Other Improvements SimpleMeshLayer  adds  _useMeshColors  prop to use vertex colors from  mesh  instead of  getColor DataFilterExtension  adds a  countItems  option. It enables the GPU to report the number of objects that pass the filter criteria via the  onFilteredItemsChange  callback. PathStyleExtension  adds a  highPrecisionDash  option. It creates nicer dashes when used with small path segments, at the price of some CPU overhead. IconLayer  fixed an issue of visual artifacts rendering anti-aliased borders deck.gl v8.2 Release Date: June 28, 2020 Tiled Layers Many new features are added to  TileLayer ,  MVTLayer  and  TerrainLayer  to improve correctness, performance and ease of use. MVTLayer  projects more accurately at high zoom levels. autoHighlight  in the  MVTLayer  now works on features that are split across multiple tiles, identified by the new  uniqueIdProperty  prop. All geospatially tiled layers now handle high pitch angles better. Far away tiles from the camera are loaded at lower zoom levels, avoiding loading too many tiles. Tiled layers now use a request scheduler to prioritize loading the most recently visible tiles during viewport navigation. See the new  maxRequests  prop. TileLayer  may continue to display tiles when underzoomed. See the new  extent  prop. Fine-tune the tiles displayed by the  TileLayer  with the new  zRange  prop when dealing with 3D content. This is used by the  TerrainLayer  when viewing high-altitude regions. TileLayer 's  tileSize  prop can be used to fine-tune the zoom level at which tiles are loaded. TileLayer 's  renderSubLayers  is now always called after the tile layer is loaded, i.e.  props.data  is never a Promise. TileLayer  can now be used in multi-view applications, as long as each  TileLayer  instance is rendered into one view. See  documentation  for an example. GlobeView For geospatial data, a new projection mode -- globe projection is now available alongside Web Mercator projection. In this release, the feature is exposed via the experimental  GlobeView  class. Currently there is no base map provider under this view. You may use the  BitmapLayer  or  GeoJsonLayer  to render a backdrop for your data. Before getting started with  this example , make sure you check out the  docs  for the limitations of the current implementation. Antimeridian Handling GreatCircleLayer  now renders correctly across the 180th meridian. The  PathLayer ,  PolygonLayer  and  GeoJsonLayer  now support the  wrapLongitude  prop.When enabled, the connection between any two neighboring vertices is drawn on the shorter side of the world, and split into two if it crosses the 180th meridian. Note that this introduces CPU overhead at runtime. Pydeck Pydeck 0.4.0 introduces support for JupyterLab 2.0, support for a Google Maps base map, a new UI element for providing text descriptions of a map, and many of the new features of deck.gl 8.2, like the ability to render data to either a globe or a Mercator projection. See the new  website  for documentation and examples. Miscellaneous Multiple layers that share the same  data  URL now only download the data once. ScatterplotLayer  added  radiusUnits  prop New  FillStyleExtension  fills polygons with repeated pattern from a sprite image. ArcLayer  added  greatCircle  prop.  GreatCircleLayer  is now a special case of the  ArcLayer  and support rendering an elevated curve by supplying  getHeight . @deck.gl/test-utils  added new  testLayerAsync  API. When using auto-highlight,  highlightColor  now accepts a callback that returns a color based on which object is picked. deck.gl v8.1 Release Date: Mar 17, 2020 Growing Tile Solutions The  @deck.gl/geo-layers  module added many new features to address popular tiled data use cases. TileLayer Multiple bugs have been fixed in the  TileLayer  regarding data fetching and tree traversal. The layer now supports non-geospatial views. Check out this  example  by  @ilan-gold  that renders a 576 Megapixel image of the moon. New props are added to better control the layer's behavior: maxCacheByteSize : for precise management of memory usage refinementStrategy : to reduce flashing/overlapping during loading tileSize  (non-geospatial only) MVTTileLayer Based on the  TileLayer ,  MVTTileLayer  loads and renders tiles in the  Mapbox Vector Tiles specification . This new layer make it easier to leverage the many great  open source tools  in use with deck.gl. This effort is led by contributors from  CARTO . TerrainLayer TerrainLayer  loads color-encoded heightmap and reconstructs 3D mesh surfaces. Check out our  example . ESRI + deck.gl In collaboration with GIS industry leader  ESRI , we are releasing new experimental features that work with ArcGIS basemap and I3S tiles. @deck.gl/arcgis You can now use ArcGIS basemaps with deck.gl. This new module lets apps render deck.gl layers into the WebGL context of  ArcGIS API for JavaScript . 3D scene view support is experimental in this initial release. To get started, check out  the example  and  the documentation . Tile3DLayer and I3S format Tile3DLayer  is adding preliminary support for the  OGC Indexed 3d Scene (I3S)  format. See  documentation  for details. World Repeating in Web Mercator Maps The  MapView  now supports repeating worlds at low zoom levels. For backward compatibility, this feature is opt-in. Apps may turn it on by setting  views: new MapView({repeat: true})  on  Deck  or  DeckGL . Repeating is always on when using  MapboxLayer  and  GoogleMapsOverlay . As a result,  GoogleMapsOverlay  now supports all Google Maps zoom levels. pydeck 0.3.0 pydeck now uses the  binary attribute API  to communicate between Python and JavaScript. This greatly increases the speed and the amount of data that it can render. pydeck now supports external layer modules via a new  custom_libraries  setting. Other Improvements When using  Deck  as a stateful component, you can now update its  initialViewState  prop to reset the camera. A new prop  onError  is added to  Deck  to handle errors, instead of crashing the app. Layer  instances now expose a new member  isLoaded . PathLayer 's joint calculation is improved when using with short line segments and extreme angles. BrushingExtension  supports a new  brushingTarget  mode  source_target . PathStyleExtension  now has a new mode  offset . This feature can be used for positioning polygon strokes inside/outside, or rendering overlapped paths in opposite directions. TextLayer  now supports  binary attributes . deck.gl v8.0 Release Date: Dec 20, 2019 Performance Performance is one of the biggest focus of this update. Layer updates (data change) is 1.5x the speed of the last release, and redraw (viewport change) is 2.5x. Benchmark of using 1000 ScatterplotLayers on 2016 Macbook Pro, 2.8 GHz Intel Core i7, 16 GB memory, AMD Radeon R9 M370X 2 GB v7.3 v8.0 Change Initialize 298ms 235ms -21% Update 112ms 72ms -36% Redraw (CPU Time) 76ms 26ms -66% Redraw (GPU Time) 17ms 10ms -41% In addition to runtime performance, deck.gl also added a production mode to optimize bundle size. The v8.0 minified bundle of  @deck.gl/core  is 50kb lighter than that of v7.3. Better Binary Data Support It is now possible to replace a layer's accessors with binary data attributes. This technique offers the maximum performance in terms of data throughput in applications where a lot of data is loaded and/or frequently updated: This use case is discussed in detail in the  performance developer guide . GPU Data Filter in Aggregation Layers DataFilterExtension  now supports the following layers from  @deck.gl/aggregation-layers : HeatMapLayer GPUGridLayer ScreenGridlayer  (GPU aggregation only) ContourLayer  (GPU aggregation only) GridLayer  (GPU aggregation only) pydeck pydeck now supports JupyterLab. The Jupyter widget now allows users to click multiple objects in a visualization and pass them to the Python backend. JavaScript errors are now surfaced in the Jupyter UI. Support for non-Mercator visualizations. The JSON parser has introduced syntactic identifiers in an effort to become more generic and robust. It is able to work with a wider range of data formats and layer types. See upgrade guide for details. Other New Features and Improvements Render to a frame buffer by specifying the  _framebuffer  prop of  Deck . Pick a 3d surface point in the scene by passing  unproject3D: true  to  deck.pickObject  or  deck.pickMultipleObjects . ArcLayer  supports drawing arcs between two 3D positions. TextLayer  adds a new prop  backgroundColor . Picking works when the cursor is over an empty pixel in the text. TextLayer  adds  maxWidth  and  wordBreak  props to support text wrapping. ScenegraphLayer  adds props  sizeMinPixels  and  sizeMaxPixels . 64-bit positions are now 3D instead of 2D. This improves render precision when using  OrbitView . FirstPersonView  now supports pitch; controller works more intuitively; graduates from experimental status. FlyToInterpolator  now supports  duration: 'auto' . deck.gl v7.3 Release Date: Sep 26, 2019 Tile3DLayer deck.gl has partnered with  Cesium  to implement support for the OGC  3D Tiles specification . This makes it possible to to render city-scale (billions of points/features) and country-scale (trillions of features) datasets in the browser. In this initial release, the layer has full support for point clouds and experimental support for glTF tiles. Try the  demo  for yourself. pydeck: deck.gl for Python and Jupyter Notebooks We have released a python module  pydeck  for Python developers to interact with deck.gl via a native Python API: pydeck  is also integrated with Jupyter Notebook, enabling you to interactively create deck.gl visualizations right in your notebooks. See  documentation  for details. Transition System Improvements Generic prop transition: the layer  transitions  prop now supports many more props than just accessors! Any prop of type  number  or  array  can now also use the built-in transition system. New transition type: spring-based transition support is added to the transition settings. See  documentation  for details. @deck.gl/json The  JSONConverter  class has been generalized and can now be used independently of deck.gl to \"hydrate\" JavaScript from JSON text specifications. This supports its use a foundation technology for providing non-JavaScript bindings such as  pydeck . This has caused some breaking changes to this experimental module. For details and work-arounds see the upgrade guide. Under the Hood We have introduced a new resource management system to luma.gl and deck.gl core. This significantly reduces the initial loading time if an app uses multiple layers of the same type. It is now easier to supply external buffers to layer attributes as deck.gl no longer requires them to match the default buffer type. For custom layer authors: the attribute system is simplified. One may now use  type: GL.DOUBLE  when adding an attribute to the  AttributeManager . the attribute will automatically be mapped to two 32-bit shader attributes  <attrbName>  and  <attrbName>64xyLow . Auto Tooltip A new prop  getTooltip  is added to the  Deck  class. By supplying this callback, an app may specify the content and styling of a built-in tooltip. Other Features/Improvements OrbitController  now supports 360 degree rotation on both axis. Relax  minRotationX  and  maxRotationX  to use this feature. Customizable device pixel ratio :  Deck 's  useDevicePixels  prop now accepts a number as well as boolean values. SimpleMeshLayer  and  ScenegraphLayer  now respect the  opacity  prop. IconLayer  has added a new prop  alphaCutoff  for customizing picking behavior. HeatmapLayer  is out of  Experimental  phase and can now be rendered using  WebGL1  context. A new prop  colorDomain  added for custom domain specification. deck.gl v7.2 Release Date: Aug 10, 2019 Layer Extensions A new module  @deck.gl/extensions  has joined the deck.gl family.\nLayer extensions are bonus features that you can optionally add to the core deck.gl layers. As a start, this module offers the following extensions: BrushingExtension : GPU-based data brushing, see \"examples\" section of this website DataFilterExtension : GPU-based data filtering, see \"examples\" section of this website Fp64Extension : See  upgrade guide  if you are using the deprecated  fp64  mode. For instructions on authoring your own layer extensions, visit  developer guide . HeatmapLayer The   @deck.gl/aggregation-layers  module now offers  HeatmapLayer  as an experimental layer. It performs density distribution on the GPU to provide fast dynamic heatmaps. The layer currently only supports WebGL2-enabled browsers. A fallback solution for WebGL1 will be added later. Shadows in LightingEffect As an experimental feature, the  LightingEffect  can now render shadows from up to two directional light sources. To enable shadows, set  _shadow: true  when constructing a\n DirectionalLight  or  SunLight . New Ways to Supply and Update Layer Data Streaming Data Support Layers now have built-in streaming support. The  data  prop now accepts an  async iterable  object. As new batches of data are resolved, the layer is updated incrementally. This eliminates the need to manually merge chunks of data or manage multiple layer instances.\nSee details in the  data prop  documentation and the updated  performance optimization  examples. Partial Data Update By default, when the  data  prop value of a layer changes shallowly, all of its attributes are recalculated and re-uploaded to the GPU. You may now compare the old and new data arrays and only update the range of elements that have actually changed. This can lead to significant performance improvement if a few rows in a large data table need to change frequently. See the  _dataDiff prop  documentation. Using External Buffers It is now easier to build attributes as typed arrays outside of a layer, e.g. in a web worker or on the server. See the \"Supplying attributes directly\" section in  performance optimization . Other Layer Features and Optimizations BitmapLayer 's  image  prop now accepts a  HTMLVideoElement . TextLayer  now supports line breaks in the text string. A new prop  lineHeight  is added. Layer matching performance is improved. This affects applications with a large number of layers. HeatmapLayer  now supports WebGL1. deck.gl v7.1 Release Date: 2019 Post-processing Effects A new  PostProcessEffect  class, working with   @luma.gl/effects  module,  offers screen-space post-processing effects such as blur, noise, halftone, ink, etc. Layer Enhancements GridLayer GridLayer  is enhanced to support GPU Aggregation. By default GPU Aggregation is disabled, and can be enabled using  gpuAggregation  prop. For more details check  GridLayer . Two new layers  GPUGridLayer  and  CPUGridLayer  are also offered, which perform aggregation on CPU and GPU respectively. The following table compares the performance between CPU and GPU aggregations using random data points: #points CPU #iternations/sec GPU #iterations/sec Notes 25K 535 359 GPU is  33%  slower 100K 119 437 GPU is  267%  faster 1M 12.7 158 GPU is  1144%  faster Numbers are collected on a 2018 15-inch Macbook Pro (CPU: 2.6 GHz Intel Core i7 and GPU: Radeon Pro 560X 4 GB) ColumnLayer & H3HexagonLayer Now support drawing outline. In 3D mode (extruded), set  wireframe: true . In 2D mode, enable stroke by setting  stroked: true  with  getLineWidth ,  getLineColor  among other stroke options. Improved the performance of  H3HexagonLayer . PathLayer Added  billboard  prop for screen space extrusion when rendering 3D paths Improved precision of joint calculation TripsLayer Now support 3D paths by adding a  getTimestamps  accessor. See layer documentation for details. ScenegraphLayer Added  getScene  and  getAnimator  to allow more flexibility when loading models. Experimental  _lighting  property for PBR lighting. Experimental  _imageBasedLightingEnvironment  property for image-based lighting. 64-bit Precision in Info-vis OrthographicView  and  OrbitView  now also support 64-bit projection, with no extra code changes required. This greatly improves the visual quality when rendering very large and/or dense graphs. Use react-map-gl Components with DeckGL For React users, it is now easy to use  react-map-gl  components with DeckGL, including DOM-based  marker ,  popup ,  navigation control  and  fullscreen control . This can be done by supplying the  ContextProvider  prop on  DeckGL : Performance Metrics Added a  metrics  property to  Deck  instances that tracks performance statistics like fps, CPU/GPU render time and memory usage. See  Deck  class documentation for details. deck.gl v7.0 Release Date: April 19, 2019 New Layer Catalog As the number of deck.gl layers grow, we are splitting existing and new layers into multiple submodules for better dependency management. These new layer modules are:  @deck.gl/layers  - Primitive layers that are the building blocks of all visualizations ArcLayer BitmapLayer   New ColumnLayer   New GeoJsonLayer GridCellLayer IconLayer LineLayer PathLayer PointCloudLayer PolygonLayer ScatterplotLayer SolidPolygonLayer TextLayer  @deck.gl/aggregation-layers  - Advanced layers that aggregate data into alternative representations, e.g. heatmap, contour, hex bins, etc. ContourLayer GPUGridLayer GridLayer HexagonLayer ScreenGridLayer  @deck.gl/geo-layers  - Additional layers that handle geospatial use cases and GIS formats. GreatCircleLayer   New H3ClusterLayer   New H3HexagonLayer   New S2Layer   New TileLayer   New TripsLayer   New  @deck.gl/mesh-layers  - Additional layers that render 3D meshes and  scene graphs . SimpleMeshLayer   New ScenegraphLayer   New glTF Support and Loaders.gl The new  ScenegraphLayer  and  SimpleMeshLayer  support loading 3D models and scenegraphs in the popular  glTF™  asset format.  glTF is a royalty-free specification for the efficient transmission and loading of 3D assets, with a rich ecosystem of tools and extensions.  All variants of glTF 2.0 are supported, including binary  .glb  files as well as JSON  .gltf  files with binary assets in base64 encoding or in separate files. We are releasing  loaders.gl  as a major new companion framework to deck.gl and luma.gl. Loaders.gl provides a suite of 3D file format loaders.  See  What's New in luma.gl v7.0  for more details. New Effects System A new effects system is written from the ground up for v7.0. This opens the possibilities for many exciting visual effect features down the road. As a start, we're introducing  LightingEffect  - an easier, more comprehensive way to control the lighting for your layers. See  Using Lighting  for details. Layer API Binary data support : In v7.0 we are making binary data a first-class citizen of deck.gl. Whereas the  data  prop of layers only accepted JavaScript arrays in the past, you may now provide a non-iterable object to  data . See  example . Size units : In the past, some deck.gl layers use pixel sizes (e.g.  IconLayer ,  TextLayer ,  LineLayer  and  ArcLayer ) and some layers use meter sizes (e.g.  ScatterplotLayer ,  PathLayer ). In v7.0 we are introducing new props  sizeUnits  and  widthUnits  that allow users to tweak these behaviors.  *MinPixels  and  *MaxPixels  props are also added for layers that previously only support pixel sizes. Billboard : Prior this v7.0,  IconLayer  and  TextLayer  are rendered as billboards (i.e. always facing the camera). A prop  billboard  is added to these layers so that you can place icons and texts relative to the world. Google Maps Integration Starting v7.0, deck.gl has experimental support for Google Maps with the  @deck.gl/google-maps  module. It allows you to construct a Deck instance as a custom Google Maps  OverlayView . See module documentation page for a full list of supported features. Improved Test Utilities The   @deck.gl/test-utils  module is revamped with two new exports: generateLayerTests  - automatically create test cases for use with  testLayer  to test layer conformance. SnapshotTestRunner  - automated integration test for WebGL. Renders deck.gl layers, takes screenshot and compare with golden images in headless Chromium. Read more in  Developer Guide: Testing . deck.gl v6.4 Release Date: Jan 29, 2019 Layer API Improvements ScatterplotLayer  now supports drawing both stroke and fill, and outline width can be controlled per-instance. ContourLayer  now supports isoband - filling between two thresholds. ScreenGridLayer  now supports aggregating by min/max/mean. TextLayer  adds new props that allow better control of the font rendering quality, including font weight and raster size. The layer can also optionally generate a font atlas with  Signed Distance Fields , which yields a much crisper look when rendering large font sizes. IconLayer  supports dynamically packed icon atlas. Users can now load programmatically generated image urls as icons, for example Facebook profile images. PathLayer 's  getPath  and  PolygonLayer 's  getPolygon  props now support flattened coordinates instead of nested arrays, making it easier for these layers to use binary data. See each layer's documentation for full API changes. Composite Layer Customization (experimental) It is now possible to fine-tune sublayer appearances by passing a new experimental prop  _subLayerProps  to a composite layer. For example, in a  GeoJsonLayer , one may wish to make only the point features interactive, or replace the circles with icons. This offers a light alternative to overriding composite layer behaviors without creating a custom class. See  CompositeLayer  for details. deck.gl v6.3 Release Date: Nov 19, 2018 Prop Types System Layers can now supply rich definitions to their default props. This enables prop validation in debug mode and aggressively blocks unnecessary layer update to boost rendering performance. Complex composite layers such as the GeoJsonLayer can be up to 2x faster in certain React applications. See  upgrade guide  if you are an author of custom layers. New Interaction Callbacks onDragStart ,  onDrag  and  onDragEnd  callback props are added to  Deck  and base  Layer  class. GPUAggregator Improvements The experimental  GPUAggregator  class now supports Min/Max/Mean in addition to Sum. Also added the ability to specify multiple weights with custom aggregation operation. deck.gl v6.2 Release Date: Oct 15, 2018 Mapbox Custom Layer API A new experimental module   @deck.gl/mapbox  makes deck.gl work with the custom layers API in the latest Mapbox release. Using this feature, mapbox and deck.gl layers can be freely \"interleaved\", enabling a number of layer mixing effects, such as drawing behind map labels, z-occlusion between deck.gl 3D objects and Mapbox buildings, etc. For usage and limitations, see  module documentation . 32-bit High-Precision Projection First introduced in v6.1 as  COORDINATE_SYSTEM.LNGLAT_EXPERIMENTAL , the new projection system offers high-precision results similar to that of the old  fp64  mode without the compatibility issues or performance hit of running the much heavier 64-bit shader. Starting v6.2, this coordinate system becomes the default for all layers. See  upgrade guide  if you still need the old  fp64  mode. CPU/GPU Parity in Projection The  layer.project()  method now supports all coordinate systems including METER_OFFSETS, LNGLAT_OFFSETS and IDENTITY. deck.gl v6.1 Release date: Sep 7, 2018 High-Precision Geospatial Projection (Experimental) The projection algorithm used for geospatial coordinates (layers with  coordinateSystem: COORDINATE_SYSTEM.LNGLAT ) has supplemented with a \"hybrid\" projection/offset based implementation ( COORDINATE_SYSTEM.LNGLAT_EXPERIMENTAL ) that rivals 64-bit precision at 32-bit speeds. This mode is expected to make the use of  fp64  precision unnecessary for most applications, which in turn should increase application performance and avoid issues on untested graphics drivers. Dynamic Meridian LNGLAT  projection modes can automatically wrap coordinates over the 180th meridian for the best placement in the current viewport. Set the  wrapLongitude  prop in a layer to  true  to enable this behavior. This mode will be helpful when visualizing data close to the ante-meridian (e.g. New Zealand, Australia etc). JSON API (Experimental) A new experimental module  @deck.gl/json  provides a set of classes that allows deck.gl layers and views to be specified using JSON-formatted text files. To facilitate experimentation, a JSON layer browser is available on  http://deck.gl/playground . Enhanced Multiview Support deck.gl's multiview support has been significantly enhanced. New  View  properties give applications more control over rendering, making it possible to implement e.g. overlapping views, partially synchronized views (share some but not all view state props), views with different background colors etc. ContourLayer deck.gl's layer catalog is extended by adding new  ContourLayer , this layer can be used to render contours, also called iso-lines for given set of threshold values.  ContourLayer  supports both WebMercator projection (geospatial applications) and Orthographic projection (infovis applications). IconLayer When the  mask  of the icon is  false , the opacity of the icon can be controlled by  getColor  while still keeping the pixel color from image. When  mask  is  true , user defined color is applied. GPU Aggregation Enhancements (Experimental) Several under the hood changes in GPU Aggregation flow to support multiple layer coordinate systems (LNGLAT and IDENTITY). deck.gl v6.0 Release date: July 18, 2018 Attribute Transitions (WebGL2-compatible browsers only) Attribute transitions enable applications to simultaneously animate changes in positions, colors and other attributes of all objects in a layer. GPU acceleration to  All core deck.gl layers now support attribute transitions, including  HexagonLayer ,  GridLayer  and  GeoJsonLayer . GPU Accelerations allow millions of objects to be animated. Transition settings also support  enter  callback to customize instance entrance behavior. See documentation of the  transitions prop . View State Transitions View State Transitions (aka Viewport Transitions) are now officially supported. Transitions are provided through the  DeckGL.viewState  prop. For more details check  ViewState Transitions  documentation. ScreenGridLayer: GPU accelerated aggregation ScreenGridLayer is updated to support aggregation on GPU. GPU aggregation can be 10x faster and is capable of aggregating large data sets (millions of points). Two new props  gpuAggregation  for selecting CPU or GPU aggregation and  cellMarginPixels  to control cell margin size have been added. Finally, picking information now contains aggregated details. Controllers: Simplified Usage deck.gl can now infer appropriate  Controller  types from the types of your  View . For example, when using the default geospatial view ( MapView ), a  MapController  can now be requested simply by setting the view's  controller  props to  true . You may also pass an object with additional controller options to this prop, for example  controller={{doubleClickZoom: false}} . See documentation of  View . Pixel Sizes aligned with HTML/CSS deck.gl pixel sizes (e.g. in  LineLayer ,  IconLayer  and  TextLayer ) now match their HTML/SVG counterparts. WebGL parameters can now be set declaratively It is now possible to set global WebGL parameters (controlling how the GPU renders) by supplying a  Deck.parameters  property object. This gives applications a simple declarative way to control things like blend modes and depth testing, without having to define an  onWebGLInitialized()  callback. Note that  parameters  can still be supplied to individual layers, overriding any global parameters for that layer only. React API Enhancements The  DeckGL  React component now provides a more powerful API to create sophisticated visualizations, highlights including: DeckGL  can be used as a \"stateful\" component providing automatic interactivity You can now specify deck.gl views (in addition to layers) directly using JSX Adds \"render callbacks\" for dynamically rendering React children based on deck.gl view states, providing more control over synchronization of positions and sizes between deck.gl's WebGL view layouts and React's DOM components. See  Use with React  for more details. deck.gl v5.3 Release date: June 01, 2018 Automatic Interactivity A new  Deck.initialViewState  property allows the application to enable map or view interactivity simply by supplying an initial view state, e.g.  {longitude, latitude, zoom} . deck.gl will automatically initialize a Controller class and listen to view state changes, without the application having to implement callbacks to track the view state. Automatic Data Loading The  Layer.data  prop now accepts URLs (i.e. strings). deck.gl will automatically start loading such URLs, parse them as JSON and once loaded, use the resulting data to render the layer. This can e.g. remove the need for applications to set up callbacks to handle load completion. Deep Picking deck.gl can now pick occluded objects using the new  Deck.pickMultipleObjects  method, which returns a list of all objects under the mouse, instead of just the top-most object. Switch between Perspective and Orthographic mode The  View  classes can now build an orthographic projection matrix from the same \"field of view\" parameter it uses to create perspective mode (rather than requiring a separate set of parameters). This makes switching between perspective and orthographic projection modes easier then ever (simply set the new  View.orthographic  prop to  true  to activate orthographic projection). Per-instance stroke width in LineLayer and ArcLayer LineLayer and ArcLayer added a new accessor  getStrokeWidth  to replace the old  strokeWidth  prop. When specified with a function, you can control the width of each arc/line segment dynamically. Constant Accessors Many layer accessor props now accept constant values. For example, when constructing a ScatterplotLayer, what used to be  getColor: d => [255, 200, 0]  can now be written as  getColor: [255, 200, 0] . This is not only a convenience: constant values of accessors don't use GPU memory and can be updated very quickly and thus do not require an  updateTrigger . Consult the documentation for each layer to see which accessors are supported. @deck.gl/layers submodule Core layers are broken out from   @deck.gl/core  to a new submodule   @deck.gl/layers . Users of  deck.gl  are not affected by this change. deck.gl v5.2 Release date: April 24, 2018 Use deck.gl without React deck.gl can now be used in non-React applications. A new top-level JavaScript class  Deck  is provided as an alternative to the traditional top-level  DeckGL  React component, and the core deck.gl npm module no longer has any React dependencies. This allows deck.gl to be used in any JavaScript application or framework. The new non-React API is officially supported, however since it is not yet extensively battle-tested in applications there may be some rough corners, so to help developers set expectations we are labeling this as a \"pre release\" intended for early adopters. Scripting Support deck.gl now publishes a bundle that can be imported using a simple  <script>  statement in HTML to give access to the deck.gl API. This makes deck.gl easy to use in e.g. \"codepens\" and for casual programming and visualizations. See our  scripting blog post . Multiple Modules deck.gl is now published as multiple npm modules allowing applications to choose which features to import. The basic modules are: @deck.gl/core  - the core deck.gl API (JavaScript classes, including the  Deck  top-level class). @deck.gl/react  - React bindings for deck.gl (i.e. the top-level  DeckGL  React class). deck.gl  - The classic module is still supported for backwards compatibility with React applications. Multi-Viewport Support deck.gl allows you to divide your screen into multiple viewports and render layers from different perspectives. It is e.g. possible to render a top-down map view next to a first person view and allow your users to \"walk around\" in the city onto which your data is overlaid. The  Deck.views  property accepts instances of  View  classes, such as  MapView  and  FirstPersonView : MapController It is now possible to specify a  MapController  as a  controller  for the  Deck  or  DeckGL  classes, instead of relying on e.g.  react-map-gl  or experimental classes to drive event handling. Automatic Resize Handling It is no longer necessary for deck.gl applications to track screen size and manage the exact  width  and  height  of the  Deck  or  DeckGL  components.  width  and  height  can now be specified using CSS descriptors (e.g.  width = 100% ): Layers TextLayer (New) A  TextLayer  has been added to the core layer catalog for rendering labels with WebGL. ScreenGridLayer Color Scale Support  (Experimental) - New experimental props  colorRange  and  colorDomain  are added to ScreenGridLayer. These props provide more fine tune control over how grid cells are colored, and brings the ScreenGridLayer into parity with other aggregation layers (i.e. HexagonLayer and GridLayer). Experimental Layers A number of experimental deck.gl layers are published in a new module  @deck.gl/experimental-layers . Be aware that use of these layers come with caveats and are mainly intended for early adopters. Please refer to  roadmap  for more information. Test Utilities deck.gl now provides a suite of  test utilities  that make it easy to test both layers and applications. The utilities support visual regression testing against \"golden\" images, as well as utilities for traditional unit testing of layers. The utilities come pre-integrated with tools that help automate the running of browser based render tests from the console. To start using the utilities, install the new ( @deck.gl/test-utils ) module. Dist Size Reduction Work on bundle size reduction continues. In this release, the focus has been on leveraging the tree-shaking abilities of the Babel 7 and Webpack 4 combination. In addition, new article about  Application Bundling and Tree Shaking  has been added to the docs. Shader Modules project32 (New) Unified 32/64-bit projection  - A new common API for projection is implemented in both the  project64  shader module and a new  project32  shader module allowing the same vertex shader can be used for both 32-bit and 64-bit projection. This simplifies adding fp64 support to layers and reduces bundle size. See  docs  for more details. deck.gl v5.1 Release date: Feb 16, 2018 Layer Improvements Layer Transitions Many layers now support smooth visual transitions of e.g. positions and colors of layer elements, animating the update of the layers element to match a new data set. The animations are done on the GPU and can thus support very large number of elements. Use the new  transitions  prop on the  Layer  class to specify things like  transition duration ,  easing function  and  callbacks . Transitions are only supported on WebGL2-capable browsers such as Chrome and Firefox. The  transitions  prop will simply be ignored on WebGL1 browsers. React Improvements Use JSX to render deck.gl Layers It is now possible to use JSX syntax to create (or \"render\") deck.gl layers. Many React users feel that this results in a more natural coding style. There are limitations (deck.gl layers are  not  React components), for more information see  Using deck.gl with React . deck.gl v5 Release date: Dec 21, 2017 All new additions to the official deck.gl 5.0 API are listed here. Note that in addition to the official new features in this release, deck.gl 5.0 also contains a number of significant under the hoods changes to prepare for new features and optimizations. Some of these are available as experimental APIs, see below. As always, for information on deprecations and how to update your code in response to any API changes, please read the deck.gl  upgrade Guide . DeckGL Component DeckGL: Control over DevicePixelRatio The new  useDevicePixels  prop on the  DeckGL  React component can be used to disable usage of full resolution on retina/HD displays. Disabling deck.gl's default behavior of always rendering at maximum device resolution can reduce the render buffer size with a factor of 4x on retina devices and lead to significant performance improvements on typical fragment shader bound rendering. This option can be especially interesting on \"retina\" type mobile phone displays where pixels are so small that the visual quality loss may be largely imperceptible. DeckGL: Layer Filtering A new  DeckGL  prop  layerFilter  gives the application an opportunity to filter out layers from the layer list during rendering and/or picking. Filtering can be done per layer or per viewport (experimental) or both. This enables techniques like adding helper layers that work as masks during picking but do not show up during rendering, or rendering different additional information in different viewports (experimental). DeckGL: Allow overriding canvas component style Users can now override the canvas size, position and offset via the style prop passed to the DeckGL component. Layer Improvements Layer: Automatic Highlighting of Hovered Elements Three new  Layer  props ( autoHighlight ,  highlightColor  and  highlightedObjectIndex ) have been added to enable simple and efficient highlighting of a single object in a layer. Highlighting is either automatic on hover, or programmatically controlled through specifying the index of the selected object. The actual highlighting is done on the GPU and this feature is thus very performant, in particular as it lets applications avoid cumbersome techniques like modifying data or using a secondary layer for highlighting. See our  blog post CompositeLayer: Property Forwarding Support A new method  CompositeLayer.getSubLayerProps()  simplifies forwarding base layer props to sub layers, removing code clutter and reducing the risk of forgetting to forward an important base layer property. PathLayer & GeoJsonLayer: Dashed Line Support Added new props ( getDashArray  and  dashJustified ) enabling you render paths as dashed lines. Naturally these props are also accessible in composite layers built on top of the  PathLayer , such as the  GeoJsonLayer . PolygonLayer & GeoJsonLayer: Elevation Scale Added new prop  elevationScale  to enable fast scaling elevation of all extruded polygons. HexagonLayer / GridLayer: Elevation by Value Support Add  getElevationValue  to  HexagonLayer  and  GridLayer  to enable elevation aggregation by value. This allow both color and elevation to be calculated based on customized aggregation function. Seer Improvements The  Seer  Chrome Debug Extension now remembers its \"on/off\" setting across application reloads. This is significant because it means that the Seer extension can be left installed even in heavy deck.gl applications with lots of layers, and turned on only during debugging, without any performance impact during normal usage. Shader Modules Note: This change is mainly relevant to developers who write custom deck.gl layers. Shader module documentation is much improved, both in deck.gl and luma.gl. In the deck.gl docs, shader modules are listed in the \"API Reference\" section, after the JavaScript classes. The  project  module provides a new function  project_pixel_to_clipspace  for screen space calculations that takes variables like  useDevicePixels  and \"focal distance\" into account, making pixel space calculation simpler and less prone to fail when parameters change. The core deck.gl shader modules ( project  etc) now conform to the luma.gl shadertools conventions for naming uniforms and functions, making this module easier to describe and use. In spite of these changes, backwards compatible uniforms are provided to ensure that existing layers do not break. React Integration React 16 Support deck.gl v5 now supports React 16 and the  package.json  dependencies of all React-based examples have updated to React 16. Experimental Features As usual, deck.gl 5.0 contains a number of experimental features, e.g. \"multi viewport\", \"first person viewport\" and \"viewport transitions\". These features are still being finalized and the APIs have not been frozen, but can still be accessed by early adopters. See the roadmap article for more information on these. deck.gl v4.1 Release date: July 27th, 2017 WebGL2 Support (provided by luma.gl v4) deck.gl v4.1 is based on luma.gl v4, a major release that adds full WebGL2 support as well as powerful features like WebGL state management and an improve GLSL shader module system. On all browsers that supports WebGL2 (e.g. recent Chrome and Firefox browsers), deck.gl will obtain WebGL2 context and utilize WebGL2 functionalities. To know more about WebGL2, please check  here . Query Methods Two new functions -  DeckGL.queryObject  and  DeckGL.queryVisibleObjects  allow developers to directly query the picking results, in addition to handling picking via built-in click and hover callbacks. This allows applications to build more advanced event handling and makes deck.gl easier to integrate with existing applications that have already implemented their own event handling. In addition, the  queryObject  offers a much requested  radius  parameter, allowing the application to specify how close an object needs to be to the specified coordinate to be considered a match (in deck.gl v4.0, picking will only trigger if an object is actually visible on the queried pixel, making it hard for users to select small features and thin lines). Shader Assembly For developers that write their own custom layers, the  shadertools  shader assembly system is now in place to replace the existing  assembleShaders  function in deck.gl. The new shader assembler system supports organizing shader code into modules and is integrated with luma.gl's  Model  so users no longer need to call  assembleShaders  before creating the  Model  for the layer. Per-Layer Control of WebGL Parameters The base  Layer  class (which is inherited by all layers) supports a new property  parameters  that allows applications to specify the state of WebGL parameters such as blending mode, depth testing etc. This provides applications with significant control over the detailed rendering of layers. Note that the new  parameters  prop directly leverages the luma.gl v4  setParameters  API, which allows all WebGL parameters to be specified as keys in a single parameter object. Layer Attribute Control Pre-calculated \"Vertex Attributes\" can now be passed as props, meaning that developers that are willing to learn how a deck.gl layer's vertex attributes are structured can pass in typed arrays as props to the layer and have these directly passed to the GPU. This prevents the layer's internal  AttributeManager  from generating the attributes from your data, allowing you to optimize by e.g. directly passing in binary data from calculations or a binary file load without having deck.gl do any transformation on your data. CompositeLayer Composite layers, which were introduced in v4.0, have received some polish and performance improvements. In subclassed  CompositeLayer s, the  renderLayers  function can now return a nested array that could contain  null  values, and deck.gl will automatically flatten, filter and render all layers in the array. This is a small convenience that can make your  renderLayers  methods in complex composite layers a little more readable. Also, as a performance improvements, deck.gl now avoids \"rerendering\" sublayers of  CompositeLayer  whose props haven't changed. New Examples Several new examples have been added to illustrate the wide applicability of deck.gl. To name a few: Wind visualization in US. This example is featured on  OpenVIS 2017 by @philogb . This example shows how new features in WebGL2 can be used to accelerate compute intensive tasks through GPU computing right in the browsers Tagmap - This example by @rivulet-zhang shows some novel approching in placing and rendering text symbols in deck.gl Point cloud example - The point cloud example shows how deck.gl could be used to render large amount of 3D point cloud data without any basemap context. Node-link Graph - This is another example showing how deck.gl could be extended to the info-vis domain. Touch Support deck.gl's default event handling now includes support for multitouch gestures to zoom and rotate the view. In addition, a new  EventManager  class solidifies deck.gl's support for event handling. Seer Integration deck.gl is now integrated with the new  Seer Chrome extension . Simply installing Seer and rerunning your application opens up a new tab in the Chrome developer tools, providing you with the ability to see all your deck.gl layers, inspect (and edit) their properties and attributes and check per layer timings, such as the latest GPU draw calls or attribute updates. And note that since luma.gl v4 also has a Seer integration, it is possible to follow links from deck.gl layer to luma.gl models inside Seer, enabling you to further drill down and understand what data is ultimately being generated and processed by the GPU. deck.gl v4.0 Release date: March 31, 2017 Highlights New Geospatial Layers  GeoJsonLayer, PathLayer, PolygonLayer, IconLayer, GridCellLayer, HexagonCellLayer, PointCloudLayer. New Aggregating Layers  GridLayer and HexagonLayer now join the ScreenGridLayer in a growing family of layers that automatically \"bin\" your point data, in this case into grid cells or hexagons. New Examples  deck.gl now provides multiple stand-alone examples, with minimal configuration files ( package.json ,  webpack.config.js  etc) intended to make it easy to just copy an example folder and get an app up and running in minutes. Unified 64-bit Layers  - 64-bit Layers are now unified with 32-bit layers, controlled via a new  fp64  prop. Library Size Reduction  - A number of npm package dependencies have been trimmed from deck.gl, and the distribution has initial support for \"tree-shaking\" bundlers like webpack2 and rollup. Performance  A number of improvements across the core library and layers improves rendering and picking performance. Model Matrix Support  - Model matrix support for the  METER_OFFSET  projection mode enables arbitrary coordinate transforms (translations, rotations, scaling etc) to be applied on individual layer enabling scene graph like layer composition and animation. Documentation  Improved and reorganized in response to user feedback. Experimental Features  Experimental support for non-Mercator projections and rendering effects (e.g. Reflections) New Layers GeoJsonLayer A layer that parses and renders GeoJson. Supports all GeoJson primitives (polygons, lines and points).\nThe GeoJsonLayer is an example of a composite layer that instantiates other layers (in this case  PathLayer ,  PolygonLayer  and  ScatterplotLayer ) to do the actual rendering. This layer replaces the now deprecated family of  ChoroplethLayer s. PathLayer Takes a sequence of coordinates and renders them as a thick line with mitered or rounded end caps. PolygonLayer Each object in data is expected to provide a \"closed\" sequence of coordinates and renders them as a polygon, optionally extruded or in wireframe mode. Supports polygons with holes. IconLayer Allows the user to provide a texture atlas and a JSON configuration specifying where icons are located in the atlas. GridLayer A layer that draws rectangular, optionally elevated cells. A typical grid based heatmap layer. Differs from the  ScreenGridLayer  in that the cells are in world coordinates and pre aggregated. HexagonLayer A layer that draws hexagonal, optionally elevated cells. Point Cloud Layer Draws a LiDAR point cloud. Supports point position/normal/color. Improvements to all Layers Support for Per-Layer Model Matrix Each layer now supports a  modelMatrix  property that can be used to specify a local coordinate system for the data in that layer: Model matrices can dramatically simplify working with data in different coordinate systems, as the data does not need to be pre-transformed into a common coordinate system. Model matrices also enable interesting layer animation and composition possibilities as individual layers can be scaled, rotated, translated etc with very low computational cost (i.e. without modifying the data). UpdateTriggers now accept Accessor Names updateTriggers  now accept Accessor Names. The  updateTriggers  mechanism in deck.gl v3 required the user to know the name of the vertex attribute controlled by an accessor. It is now possible to supply names of  accessors . More intuitive mouse events onHover  is now only fired on entering/exiting an object instead of on mouse move. onClick  is now only fired on the picked layer instead of all pickable layers. New Features for Layer Subclassing Overridable Shaders All layers now have a  getShaders  method that can be overridden by subclasses, enables reuse of all layer code while just replacing one or both shaders, often dramatically reducing the amount of code needed to add a small feature or change to en existing layers. New Features for Layer Writers defaultProps Layers are now encouraged to define a  defaultProps  static member listing their props and default values, rather than programmatically declaring the props in constructor parameters etc. Using  defaultProps  means that many layer classes no longer need a constructor. AttributeManager now accepts new  accessor  field Can be a string or a an array of strings. Will be used to match  updateTriggers  accessor names with instance attributes. getPickingInfo() This method replaces the old  pick()  method and is expected to return an info object. Layers can block the execution of callback functions by returning  null . Performance A number of performance improvements and fixes have been gradually introduced since deck.gl v3.0 was launched. While many are not new in v4.0, cumulatively they enable noticeably better framerates and a lighter footprint when big data sets are loaded, compared to the initial v3.0.0 version. The  AttributeManager  class now supports default logging of timings for attribute updates. This logging can be activated by simply setting  deck.log.priority=2  in the console (levels 1 and 2 provide different amounts of detail). This can be very helpful in verifying that your application is not triggering unnecessary attribute updates. In addition, the new function  AttributeManager.setDefaultLogFunctions  allows the app to install its own custom logging functions to take even more control over logging of attribute updates. Library Improvements JavaScript build tooling continues to evolve and efforts have been made to ensure deck.gl supports several popular new tooling setups: Dependency Reduction  The number of npm dependencies (both in  deck.gl ,  luma.gl  and  react-map-gl ) have been reduced considerably, meaning that installing deck.gl and related modules will bring in less additional JavaScript code into your app, and your app will build and run faster. Tree-shaking support : deck.gl and related libraries now publish a \"module\" entry point in package.json which points to a parallel distribution ( deck.gl/dist-es6 ) that preserves the  import  and  export  statements. This should allow tree shaking bundlers such as webpack 2 and rollup to further reduce bundle size. Pure ES6 source code : With few exceptions (e.g some JSX usage in examples), the source code of deck.gl and related modules are now all restricted to conformant ES6 (i.e. no ES2016 or ES2017, flow or similar syntax is used). This means that the source code can run directly (ie. without transpilation) in Node.js and modern browsers. You could potentially import code directly from  deck.gl/src  to experiment with this. Buble support  in examples.  Buble  is a nice alternative to babel if you have a simple app and don't need all the power of babel. Many of the examples now use buble for faster and smaller builds. Examples Code examples have been improved in several ways: Multiple Examples  deck.gl now provides multiple different examples in an  examples  folder, showing various interesting uses of deck.gl. Stand Alone Examples  Examples are now stand alone, each with its own minimal  package.json  and configuration files, enabling them to be easily copied and modified. Hello World Examples  Minimal examples for building with webpack 2 and browserify (previously called \"exhibits\") are still provided, and have been further simplified. Layer Browser  The main  layer-browser  example has been expanded into a full \"layer and property browser\" allowing for easy testing of layers. Deprecations The various Choropleth layers have been deprecated since deck.gl has new and better layers ( GeoJsonLayer ,  PathLayer ,  PolygonLayer ) that fill the same roles. The choropleth layers are still available but will not be maintained beyond critical bug fixes and will likely be removed in the next major version of deck.gl. A careful API audit has also been done to align property names between old and\nnew layers. While this will makes the layers more consistent and the combined API easier to learn and work with, it does mean that some properties have been renamed, with the old name being deprecated, and in some very few cases, default values have changed. For more information on deprecations and how to update your code in response to these changes, please consult the deck.gl  Upgrade Guide . deck.gl v3.0 Release date: November, 2016 Highlights New website Comprehensive documentation All Core Layers updated (API, features, performance) 64-bit Layers (High Precision) METERS projection mode (High Precision) Multi-Primitive Layer Support Composite Layer Support React Integration DeckGL  ( DeckGLOverlay  in v2) component now requires a separate import ( import DeckGL from 'deck.gl/react' ). This allows the core deck.gl library to be imported by non-React applications without pulling in React. Adds  onLayerClick  and  onLayerHover  props to the  DeckGL  React component. The  DeckGL  component now cancels animation loop on unmount, important when repeatedly creating/destroying deck.gl components. The  DeckGL  component no longer manages WebGL blending modes, as this is better done directly by layers. Layers All layers now support accessors, removing the need for applications to transform data before passing it to deck.gl. Layer props and accessors now always expect arrays (e.g. colors are expected as  [r,g,b,a]  instead of  {r,g,b,a}  etc). line widths now takes device pixel ratio into account for more consistent look between displays METERS projection mode allows specifying positions in meter offsets in addition to longitude/latitude. Layers now receive viewport information from the  DeckGL  component. This implies that apps no longer need to pass the  width ,  height ,  longitude ,  latitude ,  zoom ,  pitch ,  bearing  and  bearing  props to each layer. These properties only need to be passed to the  DeckGL  react component. Base Layer deepCompare  prop replaced with more flexible  dataComparator ArcLayer Specify separate start and end color for each arc. Renders smoother arcs, especially for bottom arc segments close to map Fixes flickering last segments ScatterplotLayer Adds drawOutline option. ScreenGridLayer New name for deck.gl v2 GridLayer Now have accessors (getPosition, getWeight) Custom color ramps (minColor, maxColor) ChoroplethLayer Now renders MultiPolygons and Polygons with holes HexagonLayer (REMOVED) The v2 HexagonLayer has not yet been ported to v3. 64bit layers A set of new high precision layers that support extreme zoom levels ArcLayer64 (NEW) ChoroplethLayer64 (NEW) ScatterplotLayer64 (NEW) 64 bit ExtrudedChoroplethLayer (NEW) Great for rendering 3D buildings on top of maps Includes a basic shading model GeoJsonLayer (NEW, EXPERIMENTAL) Initial composite layer, only Polygons for now. Sample Layers Sample layers now available through  import 'deck.gl/samples'; Changes affecting Custom Layers Streamlined life cycle methods The Layer life cycle methods are now optimized for deck.gl's needs and no longer try to mimic React. Limited compatibility with deck.gl v2 is provided but it is strongly recommended to update layers to the new methods Optimizations Uint8Array  encoding is now supported for color and picking color attributes, which provides significant GPU memory savings. GLSL package manager and modules All layers now use  assembleShaders  to inject GLSL packages and platform\nfixes GLSL  project  package GLSL  fp64  emulated double precision floating point package GLSL  fp32  package - 32bit improved precision library Adds high precision version of trigonometry functions and  tan Especially for Intel GPUs deck.gl v2 Release date: May 2016 Highlights 3D Perspective Mode Performance: Huge under the hood refactor of layer update logic Automatic attribute management ( AttributeManager  class) Linux fixes - deck.gl and luma.gl now work on Linux. Adopts  luma.gl  as default WebGL framework. Retina display support Support for disabling mercator project (experimental) React Integration Ability to specify canvas ID and customize styles Layers Added data deep comparison support ScatterplotLayer Add per point radius support for the scatterplot-layer Added per point color support for the scatterplot-layer Fixed primitive distortion bug LineLayer (NEW) deck.gl v1 Original release date: December 2015 Initial open-source version of deck.gl, with five sample layers.","headings":[{"value":"What's New","depth":1},{"value":"deck.gl v8.8","depth":2},{"value":"TypeScript","depth":3},{"value":"Custom Indexing System in TileLayer","depth":3},{"value":"MapboxOverlay","depth":3},{"value":"@deck.gl/carto","depth":3},{"value":"Enhancements","depth":3},{"value":"deck.gl v8.7","depth":2},{"value":"MaskExtension","depth":3},{"value":"QuadkeyLayer","depth":3},{"value":"Enhancements","depth":3},{"value":"@deck.gl/carto","depth":3},{"value":"deck.gl v8.6","depth":2},{"value":"Interleaving deck.gl layers with Google Maps vector rendering","depth":3},{"value":"OrthographicView","depth":3},{"value":"MapView","depth":3},{"value":"Layer Enhancements","depth":3},{"value":"deck.gl v8.5","depth":2},{"value":"Layer Improvements","depth":3},{"value":"MVTLayer","depth":4},{"value":"GeoJsonLayer","depth":4},{"value":"TextLayer","depth":4},{"value":"Tile3DLayer","depth":4},{"value":"Other layer improvements","depth":4},{"value":"Default transpilation and bundle size","depth":3},{"value":"@deck.gl/react","depth":3},{"value":"@deck.gl/carto","depth":3},{"value":"deck.gl v8.4","depth":2},{"value":"Better Interaction","depth":3},{"value":"Improved experience on mobile devices","depth":4},{"value":"More customizable controller behavior","depth":4},{"value":"New Deck component API","depth":4},{"value":"MVT Layer","depth":3},{"value":"TileJSON","depth":4},{"value":"Query rendered features","depth":4},{"value":"Features in WGS84 coordinates","depth":4},{"value":"Binary mode","depth":4},{"value":"Layer improvements","depth":3},{"value":"Functions in declarative language","depth":3},{"value":"@deck.gl/carto","depth":3},{"value":"deck.gl v8.3","depth":2},{"value":"New module: @deck.gl/carto","depth":3},{"value":"TileLayer","depth":3},{"value":"General Performance","depth":3},{"value":"pydeck 0.5","depth":3},{"value":"Other Improvements","depth":3},{"value":"deck.gl v8.2","depth":2},{"value":"Tiled Layers","depth":3},{"value":"GlobeView","depth":3},{"value":"Antimeridian Handling","depth":3},{"value":"Pydeck","depth":3},{"value":"Miscellaneous","depth":3},{"value":"deck.gl v8.1","depth":2},{"value":"Growing Tile Solutions","depth":3},{"value":"TileLayer","depth":4},{"value":"MVTTileLayer","depth":4},{"value":"TerrainLayer","depth":4},{"value":"ESRI + deck.gl","depth":3},{"value":"@deck.gl/arcgis","depth":4},{"value":"Tile3DLayer and I3S format","depth":4},{"value":"World Repeating in Web Mercator Maps","depth":3},{"value":"pydeck 0.3.0","depth":3},{"value":"Other Improvements","depth":3},{"value":"deck.gl v8.0","depth":2},{"value":"Performance","depth":3},{"value":"Better Binary Data Support","depth":3},{"value":"GPU Data Filter in Aggregation Layers","depth":3},{"value":"pydeck","depth":3},{"value":"Other New Features and Improvements","depth":3},{"value":"deck.gl v7.3","depth":2},{"value":"Tile3DLayer","depth":3},{"value":"pydeck: deck.gl for Python and Jupyter Notebooks","depth":3},{"value":"Transition System Improvements","depth":3},{"value":"@deck.gl/json","depth":3},{"value":"Under the Hood","depth":3},{"value":"Auto Tooltip","depth":3},{"value":"Other Features/Improvements","depth":3},{"value":"deck.gl v7.2","depth":2},{"value":"Layer Extensions","depth":3},{"value":"HeatmapLayer","depth":3},{"value":"Shadows in LightingEffect","depth":3},{"value":"New Ways to Supply and Update Layer Data","depth":3},{"value":"Streaming Data Support","depth":4},{"value":"Partial Data Update","depth":4},{"value":"Using External Buffers","depth":4},{"value":"Other Layer Features and Optimizations","depth":3},{"value":"deck.gl v7.1","depth":2},{"value":"Post-processing Effects","depth":3},{"value":"Layer Enhancements","depth":3},{"value":"GridLayer","depth":4},{"value":"ColumnLayer & H3HexagonLayer","depth":4},{"value":"PathLayer","depth":4},{"value":"TripsLayer","depth":4},{"value":"ScenegraphLayer","depth":4},{"value":"64-bit Precision in Info-vis","depth":3},{"value":"Use react-map-gl Components with DeckGL","depth":3},{"value":"Performance Metrics","depth":3},{"value":"deck.gl v7.0","depth":2},{"value":"New Layer Catalog","depth":3},{"value":"glTF Support and Loaders.gl","depth":3},{"value":"New Effects System","depth":3},{"value":"Layer API","depth":3},{"value":"Google Maps Integration","depth":3},{"value":"Improved Test Utilities","depth":3},{"value":"deck.gl v6.4","depth":2},{"value":"Layer API Improvements","depth":3},{"value":"Composite Layer Customization (experimental)","depth":3},{"value":"deck.gl v6.3","depth":2},{"value":"Prop Types System","depth":3},{"value":"New Interaction Callbacks","depth":3},{"value":"GPUAggregator Improvements","depth":3},{"value":"deck.gl v6.2","depth":2},{"value":"Mapbox Custom Layer API","depth":3},{"value":"32-bit High-Precision Projection","depth":3},{"value":"CPU/GPU Parity in Projection","depth":3},{"value":"deck.gl v6.1","depth":2},{"value":"High-Precision Geospatial Projection (Experimental)","depth":3},{"value":"Dynamic Meridian","depth":3},{"value":"JSON API (Experimental)","depth":3},{"value":"Enhanced Multiview Support","depth":3},{"value":"ContourLayer","depth":3},{"value":"IconLayer","depth":3},{"value":"GPU Aggregation Enhancements (Experimental)","depth":3},{"value":"deck.gl v6.0","depth":2},{"value":"Attribute Transitions (WebGL2-compatible browsers only)","depth":4},{"value":"View State Transitions","depth":4},{"value":"ScreenGridLayer: GPU accelerated aggregation","depth":4},{"value":"Controllers: Simplified Usage","depth":4},{"value":"Pixel Sizes aligned with HTML/CSS","depth":4},{"value":"WebGL parameters can now be set declaratively","depth":4},{"value":"React API Enhancements","depth":4},{"value":"deck.gl v5.3","depth":2},{"value":"Automatic Interactivity","depth":4},{"value":"Automatic Data Loading","depth":4},{"value":"Deep Picking","depth":4},{"value":"Switch between Perspective and Orthographic mode","depth":4},{"value":"Per-instance stroke width in LineLayer and ArcLayer","depth":4},{"value":"Constant Accessors","depth":4},{"value":"@deck.gl/layers submodule","depth":4},{"value":"deck.gl v5.2","depth":2},{"value":"Use deck.gl without React","depth":3},{"value":"Scripting Support","depth":3},{"value":"Multiple Modules","depth":3},{"value":"Multi-Viewport Support","depth":3},{"value":"MapController","depth":3},{"value":"Automatic Resize Handling","depth":3},{"value":"Layers","depth":3},{"value":"TextLayer (New)","depth":4},{"value":"ScreenGridLayer","depth":4},{"value":"Experimental Layers","depth":4},{"value":"Test Utilities","depth":3},{"value":"Dist Size Reduction","depth":3},{"value":"Shader Modules","depth":3},{"value":"project32 (New)","depth":4},{"value":"deck.gl v5.1","depth":2},{"value":"Layer Improvements","depth":3},{"value":"Layer Transitions","depth":4},{"value":"React Improvements","depth":3},{"value":"Use JSX to render deck.gl Layers","depth":4},{"value":"deck.gl v5","depth":2},{"value":"DeckGL Component","depth":3},{"value":"DeckGL: Control over DevicePixelRatio","depth":4},{"value":"DeckGL: Layer Filtering","depth":4},{"value":"DeckGL: Allow overriding canvas component style","depth":4},{"value":"Layer Improvements","depth":3},{"value":"Layer: Automatic Highlighting of Hovered Elements","depth":4},{"value":"CompositeLayer: Property Forwarding Support","depth":4},{"value":"PathLayer & GeoJsonLayer: Dashed Line Support","depth":4},{"value":"PolygonLayer & GeoJsonLayer: Elevation Scale","depth":4},{"value":"HexagonLayer / GridLayer: Elevation by Value Support","depth":4},{"value":"Seer Improvements","depth":3},{"value":"Shader Modules","depth":3},{"value":"React Integration","depth":3},{"value":"React 16 Support","depth":4},{"value":"Experimental Features","depth":3},{"value":"deck.gl v4.1","depth":2},{"value":"WebGL2 Support (provided by luma.gl v4)","depth":3},{"value":"Query Methods","depth":3},{"value":"Shader Assembly","depth":3},{"value":"Per-Layer Control of WebGL Parameters","depth":3},{"value":"Layer Attribute Control","depth":3},{"value":"CompositeLayer","depth":3},{"value":"New Examples","depth":3},{"value":"Touch Support","depth":3},{"value":"Seer Integration","depth":3},{"value":"deck.gl v4.0","depth":2},{"value":"Highlights","depth":3},{"value":"New Layers","depth":3},{"value":"GeoJsonLayer","depth":4},{"value":"PathLayer","depth":4},{"value":"PolygonLayer","depth":4},{"value":"IconLayer","depth":4},{"value":"GridLayer","depth":4},{"value":"HexagonLayer","depth":4},{"value":"Point Cloud Layer","depth":4},{"value":"Improvements to all Layers","depth":3},{"value":"Support for Per-Layer Model Matrix","depth":4},{"value":"UpdateTriggers now accept Accessor Names","depth":4},{"value":"More intuitive mouse events","depth":4},{"value":"New Features for Layer Subclassing","depth":3},{"value":"Overridable Shaders","depth":4},{"value":"New Features for Layer Writers","depth":3},{"value":"defaultProps","depth":4},{"value":"AttributeManager now accepts new accessor field","depth":4},{"value":"getPickingInfo()","depth":4},{"value":"Performance","depth":3},{"value":"Library Improvements","depth":3},{"value":"Examples","depth":3},{"value":"Deprecations","depth":3},{"value":"deck.gl v3.0","depth":2},{"value":"Highlights","depth":3},{"value":"React Integration","depth":3},{"value":"Layers","depth":3},{"value":"Base Layer","depth":4},{"value":"ArcLayer","depth":4},{"value":"ScatterplotLayer","depth":4},{"value":"ScreenGridLayer","depth":5},{"value":"ChoroplethLayer","depth":5},{"value":"HexagonLayer (REMOVED)","depth":5},{"value":"64bit layers","depth":4},{"value":"ArcLayer64 (NEW)","depth":5},{"value":"ChoroplethLayer64 (NEW)","depth":5},{"value":"ScatterplotLayer64 (NEW)","depth":5},{"value":"64 bit ExtrudedChoroplethLayer (NEW)","depth":5},{"value":"GeoJsonLayer (NEW, EXPERIMENTAL)","depth":5},{"value":"Sample Layers","depth":4},{"value":"Changes affecting Custom Layers","depth":3},{"value":"Streamlined life cycle methods","depth":4},{"value":"Optimizations","depth":4},{"value":"GLSL package manager and modules","depth":4},{"value":"deck.gl v2","depth":2},{"value":"Highlights","depth":3},{"value":"React Integration","depth":3},{"value":"Layers","depth":3},{"value":"ScatterplotLayer","depth":4},{"value":"LineLayer (NEW)","depth":4},{"value":"deck.gl v1","depth":2}],"slug":"docs/whats-new","title":"What's New"},{"excerpt":"Subclassed Layers deck.gl layers are designed to be easy to extend in order to add features.\nSubclassing allows redefining both layer life cycle methods as well as\nthe vertex and/or fragment shaders. If a small feature is missing from a layer, subclassing can often be a\ngood technique to add it. Overriding Attribute Calculation Courtesy  of  @dcposch . Overriding Shaders You can replace the shaders used in a layer by overriding the  getShaders() \nmethod. Every core layer calls this method during initialization. It\nreturns the shaders and modules used by the layer in an object: vs : string, GLSL source of the vertex shader fs : string, GLSL source of the fragment shader modules : Array, list of shader modules to be used inject : Object, map from injection points to custom GLSL code to be injected Read about  writing your own shaders . When you are implementing your own custom layers, and want to change the shaders\nit is encouraged that you also define a  getShaders()  function and selectively\noverwrite required shader(s) with custom shaders.\nThis makes it much easier for others to subclass your layer and make small\nchanges to the shaders. Note: When overwriting  getShaders()  you should pass down any unmodified shader(s)\nand  modules  as is. See code example below. Defining Additional Uniforms The best way to pass additional uniforms to your custom shader is to override\nthe  draw()  method: Modified fragment shader that uses this uniform (learn more in  writing your own shaders ): Defining Additional Attributes During initialization, you may define additional attributes by accessing the\nlayer's  attribute manager : Modified vertex shader that uses this attribute (learn more in  writing your own shaders ): Layer Extensions Sometimes we need to subclass multiple layers to add similar functionalities.\n Layer extension  is a way to generalize, reuse, and share subclassed layer code.  Read on  about how to package up a subclassed layer code into a layer extension.","headings":[{"value":"Subclassed Layers","depth":1},{"value":"Overriding Attribute Calculation","depth":2},{"value":"Overriding Shaders","depth":2},{"value":"Defining Additional Uniforms","depth":2},{"value":"Defining Additional Attributes","depth":2},{"value":"Layer Extensions","depth":2}],"slug":"docs/developer-guide/custom-layers/subclassed-layers","title":"Subclassed Layers"},{"excerpt":"Layer Attributes This section explains how the data in deck.gl layers are mapped to and accessed by the GPU during rendering. Overview A central concept of deck.gl is that every  Layer  accepts a \"table of data\" (through the  data  prop) and maps into visual elements that are then rendered efficiently on the GPU. For purposes of GPU computation, there are two separate types of layers and two types of attributes. We'll use the following terminology: Geometric Attribute per row Descriptive Attribute per row Shared-Primitive Layer N/A (Use shared primitive) 1  value (instance) per row Variable-Primitive Layer Variable # of vertices ( Ni ) Ni  duplicate values per row Fixed vs Variable Primitive Layers Fixed Primitive Layer  - (Sometimes called  instanced layers ). These layers map each data row to a fixed primitive (set of vertices). Because of this simple mapping, these layers can naturally use instanced rendering, in the sense that the unique attributes for each row (instance) can be described by a single value in an instanced attribute array. Variable Primitive Layer  - (Sometimes called  tesselated layers ). These layers require custom primitive for each row in the data table. The process of generating a custom primitive is referred to as tesselation, and requires extra work during generation. In this case it is not possible to use instancing to represent the unique attributes Examples of  fixed primitive layers  are  CircleLayer ,  PointCloudLayer ,  LineLayer  etc. Examples of  variable primitive layers  are  PathLayer ,  PolygonLayer  etc. Remarks: The primitive in a  fixed primitive layer  can be arbitrarily complex (from a single triangle, through more complex primitives like an extruded hexagon, to an entire mesh or scenegraph loaded from e.g. a glTF file). As the glTF example hints at, there can even be multiple primitives per table row (in multi-model layers). The defining characteristic is just that the primitive(s) are identical for each row. As mentioned,  Fixed primitive layers  are sometimes called  instanced layers , however the term is not precise as it is possible for a tesselated/variable primitive layer to use instanced rendering (e.g. the  PathLayer  currently does this as a performance micro-optimization to reduce the amount of custom geometry generated during tesselation). This use of instancing is not related to efficiently storing the unique values for each table row. Geometric vs Descriptive Attributes Geometric Attributes Positions, Normals, Tangents, Co-Tangents etc. For fixed primitive layers, these attributes are all pre-defined as part of the Layer's reference primitive. For  variable primitive layers , these attributes are normally all generated as a result of the tesselation process, and it is normal to have a unique value for each of these attributes in each vertex. Descriptive Attributes Descriptive Attributes are used to share (non-geometrical) attributes (colors, ...) related to the data in each table row. The big difference between the two layer types is how descriptive attributes are handled. For  fixed primitive layers  the standard setup is very simple: each descriptive attribute is an instanced attribute, with one value for each table row. For  variable primitive layers  there are two options: 2) Copy each descriptive attribute  N  times ( N  being the number of vertices generated for that row during tesselation). This is the method that is used in deck.gl today. 3) Add a single  rowIndex  attribute and copy the same index  N  times as above. In this approach, descriptive values could then be read from textures where they are stored a single time. This provides flexibility at the price of performance (texture access latency) and complexity (working with data in textures). Remarks: In tesselated layers it is of course possible to use the fact that each vertex has a unique value for each descriptive attribute value to achieve certain effects. One could for instance make a custom  PathLayer  that defines a gradient of colors along the path. This technique tends to get harder to use for layers that tesselate triangles in 2D or 3D as the order of vertices is less predictable. Also, if indices are generated in this phase, in which case extra care must be taken since some vertices can be repeated in the geometry. Because of these complications, this is not a promoted customization technique for layers.","headings":[{"value":"Layer Attributes","depth":1},{"value":"Overview","depth":2},{"value":"Fixed vs Variable Primitive Layers","depth":3},{"value":"Geometric vs Descriptive Attributes","depth":2},{"value":"Geometric Attributes","depth":3},{"value":"Descriptive Attributes","depth":3}],"slug":"docs/developer-guide/writing-layers/layer-attributes","title":"Layer Attributes"},{"excerpt":"Writing Shaders A shader library facilitates creating shaders that work seamlessly with deck.gl. The  modules  parameter passed to the  Model  class can dynamically include parts from this library into your own GLSL code: Shader Assembly Your shaders will be run through the luma.gl  shader assembler , which injects code from various module dependencies, The generated shader always contains a prologue of platform defines, and then the modules (see below), and finally your shader code is added. Platform defines This \"virtual\" module is a dynamically generated prologue containing #defines describing your graphics card and platform. It is designed to work around certain platform-specific issues to allow the same rendering results are different GPUs and platforms. It is automatically injected by  assembleShaders  before any modules are included. Shader Modules projection The  project  shader module is part of the core of deck.gl. It makes it easy to write shaders that support all of deck.gl's projection modes and it supports some advanced rendering techniques such as pixel space rendering etc. The  project  module also has two extensions,  project32  and  project64 . lighting A simple lighting package is provided in deck.gl, supporting a single directional light in addition to ambient light. Turning on lighting requires normals to be provided for each vertex. There are two flavors: gouraudLighting  - for lighting calculated in the vertex shader phongLighting  - for lighting calculated in the fragment shader fp64 The fp64 shader math library can be used leveraged by developers to conduct numerical computations that requires high numerical accuracy. This shader math library uses \"multiple precision\" algorithms to emulate 64-bit double precision floating point numbers, with some limitations, using two 32-bit single precision floating point numbers. To use it, just set the \"fp64\" key to \"true\" when calling  assembleShaders . Please refer to the \"64-bit layers\" section in the document for more information. Note that for geospatial projection, deck.gl v6.1 introduced a \"hybrid\" 32-bit projection mode that provides the precision of 64-bit projection with the performance of 32-bit calculations, so it is recommended that any use of  fp64  be used for non-position-projection related use cases. picking Picking is supported using luma.gl  picking shader module . Standard Shader Hooks When  subclassing  an official deck.gl layer with minor feature additions, it is possible to inject custom code into predefined locations into the original shaders. These hooks are considered the public API of layers that will work consistently cross minor releases. vs:#decl Inject into the top of the vertex shader (declarations). vs:#main-start Inject into the the very beginning of the main function in the vertex shader. vs:#main-end Inject into the the very end of the main function in the vertex shader. vs:DECKGL_FILTER_SIZE Inject into a function in the vertex shader to manipulate the size of a geometry. Called before projection. Arguments: inout vec3 size  - offset of the current vertex from  geometry.worldPosition  in common space. VertexGeometry geometry  - descriptor of the current geometry vs:DECKGL_FILTER_GL_POSITION Inject into a function in the vertex shader to manipulate the projected position of the current vertex. Called after projection. Arguments: inout vec4 position  - position of the current vertex in clipspace VertexGeometry geometry  - descriptor of the current geometry vs:DECKGL_FILTER_COLOR Inject into a function in the vertex shader to manipulate the color of the current geometry. Called after projection. Arguments: inout vec4 color  - color of the current geometry, RGBA in the  [0, 1]  range VertexGeometry geometry  - descriptor of the current geometry fs:#decl Inject into the top of the fragment shader (declarations). fs:#main-start Inject into the the very beginning of the main function in the fragment shader. fs:#main-end Inject into the the very end of the main function in the fragment shader. fs:DECKGL_FILTER_COLOR Inject into a function in the vertex shader to manipulate the color of the current geometry. Called after projection. Arguments: inout vec4 color  - color of the current geometry, RGBA in the  [0, 1]  range FragmentGeometry geometry  - descriptor of the current geometry VertexGeometry struct vec3 worldPosition  - The world position of the current geometry, usually populated from a  getPosition  accessor. vec3 worldPositionAlt  - The secondary world position of the current geometry. This property is populated if the geometry is instanced between a source position and a target position, for example  ArcLayer . vec3 normal  - The normal at the current vertex in common space. Only populated for 3D layers. vec2 uv  - The uv position at the current vertex. vec4 position  - The position of the current vertex in common space. Populated during projection. vec3 pickingColor  - The picking color of the current vertex. FragmentGeometry struct vec2 uv  - The uv position at the current vertex. Shader Techniques and Ideas Filtering and Brushing (Vertex and Fragment Shaders) When rendering large data sets (especially a lot of intersecting lines or arcs) it can be hard to see the structure in the data in the resulting visualization. A useful technique in these cases is to use \"brushing\". Sometimes, being able to filter out a specific color, or range of colors, from the data without modifying the data container itself can be helpful for performance or just code simplification reasons. This is also a feature that can easily be added to a deck.gl shader. Tip:  Use  discard  in the fragment shader instead of 0 alpha. Faster and leaves the depth buffer unaffected. Animation (Vertex Shader) A powerful capability of deck.gl is to render layers with thousands of animated and/or interactive objects with the computing power of GPUs. Creating an animated layer can be as easy as having the application supply start and end positions for every object, and a time interval over which to animate, and have the vertex shader interpolate the positions for every frame using a simple  mix  GLSL instruction. Uniforms Layer prop uniforms float layerIndex The layerIndex is a small integer that starts at zero and is incremented for each layer that is rendered. It can be used to add small offsets to the z coordinate of layers to resolve z-fighting between overlapping layers. float opacity In the fragment shader, multiply the fragment color with the opacity uniform. Shader Module Uniforms The luma.gl/deck.gl shader modules provide javascript functions to set their uniforms but the actual GLSL uniforms are typically considered implementation dependent. The intention is that you should use the public functions exposed by each shader module. That said, some uniforms from the  project  module are considered special and are documented. Remarks Use With Other GLSL Code Assemblers  - Your shader code can be run through another GLSL code assembler like  glslify  before you pass it to  assembleShaders . This means that you are not forced to work with only luma.gl shader modules, you can use multiple techniques to organize your shader code to fit your project needs.","headings":[{"value":"Writing Shaders","depth":1},{"value":"Shader Assembly","depth":2},{"value":"Platform defines","depth":3},{"value":"Shader Modules","depth":3},{"value":"projection","depth":4},{"value":"lighting","depth":4},{"value":"fp64","depth":4},{"value":"picking","depth":4},{"value":"Standard Shader Hooks","depth":3},{"value":"vs:#decl","depth":5},{"value":"vs:#main-start","depth":5},{"value":"vs:#main-end","depth":5},{"value":"vs:DECKGL_FILTER_SIZE","depth":5},{"value":"vs:DECKGL_FILTER_GL_POSITION","depth":5},{"value":"vs:DECKGL_FILTER_COLOR","depth":5},{"value":"fs:#decl","depth":5},{"value":"fs:#main-start","depth":5},{"value":"fs:#main-end","depth":5},{"value":"fs:DECKGL_FILTER_COLOR","depth":5},{"value":"VertexGeometry struct","depth":3},{"value":"FragmentGeometry struct","depth":3},{"value":"Shader Techniques and Ideas","depth":2},{"value":"Filtering and Brushing (Vertex and Fragment Shaders)","depth":3},{"value":"Animation (Vertex Shader)","depth":3},{"value":"Uniforms","depth":2},{"value":"Layer prop uniforms","depth":3},{"value":"float layerIndex","depth":5},{"value":"float opacity","depth":5},{"value":"Shader Module Uniforms","depth":3},{"value":"Remarks","depth":2}],"slug":"docs/developer-guide/custom-layers/writing-shaders","title":"Writing Shaders"},{"excerpt":"@deck.gl/core These are deck.gl's core library classes. See  deck.gl  for documentation.","headings":[{"value":"@deck.gl/core","depth":1}],"slug":"modules/core","title":"@deck.gl/core"},{"excerpt":"@deck.gl/extensions Optional functionalities for deck.gl layers. See  deck.gl  for documentation.","headings":[{"value":"@deck.gl/extensions","depth":1}],"slug":"modules/extensions","title":"@deck.gl/extensions"},{"excerpt":"@deck.gl/google-maps Use deck.gl as a custom Google Maps overlay. See  deck.gl  for documentation.","headings":[{"value":"@deck.gl/google-maps","depth":1}],"slug":"modules/google-maps","title":"@deck.gl/google-maps"},{"excerpt":"@deck.gl/json JSON support for deck.gl. Provides deck.gl classes that support specifying deck.gl layers and views (and their props) using a JSON format. See  deck.gl  for documentation.","headings":[{"value":"@deck.gl/json","depth":1}],"slug":"modules/json","title":"@deck.gl/json"},{"excerpt":"@deck.gl/jupyter-widget Jupyter widget for rendering deck.gl in a Jupyter notebook See  deck.gl  for documentation.","headings":[{"value":"@deck.gl/jupyter-widget","depth":1}],"slug":"modules/jupyter-widget","title":"@deck.gl/jupyter-widget"},{"excerpt":"@deck.gl/layers This is the core layer catalog for deck.gl. See  deck.gl  for documentation.","headings":[{"value":"@deck.gl/layers","depth":1}],"slug":"modules/layers","title":"@deck.gl/layers"},{"excerpt":"deck.gl A WebGL2-powered, highly performant framework for large-scale data visualization. API Documentation Installation Using deck.gl deck.gl offers an extensive catalog of pre-packaged visualization \"layers\", including  ScatterplotLayer ,  ArcLayer ,  TextLayer ,  GeoJsonLayer , etc. The input to a layer is usually an array of JSON objects. Each layer offers highly-flexible API to customize how the data should be rendered. Example constructing a deck.gl ScatterplotLayer:  Using deck.gl with React Using deck.gl with Pure JS Questions? Submit an issue on our  GitHub page .","headings":[{"value":"deck.gl","depth":1},{"value":"Installation","depth":2},{"value":"Using deck.gl","depth":2},{"value":"Using deck.gl with React","depth":2},{"value":"Using deck.gl with Pure JS","depth":2}],"slug":"modules/main","title":"deck.gl"},{"excerpt":"@deck.gl/mapbox Use deck.gl layers as custom mapbox layers, enabling seamless interleaving of mapbox and deck.gl layers. See  deck.gl  for documentation.","headings":[{"value":"@deck.gl/mapbox","depth":1}],"slug":"modules/mapbox","title":"@deck.gl/mapbox"},{"excerpt":"@deck.gl/react React Components for deck.gl See  deck.gl  for documentation.","headings":[{"value":"@deck.gl/react","depth":1}],"slug":"modules/react","title":"@deck.gl/react"},{"excerpt":"@deck.gl/test-utils Test utilities for deck.gl See  deck.gl  for documentation.","headings":[{"value":"@deck.gl/test-utils","depth":1}],"slug":"modules/test-utils","title":"@deck.gl/test-utils"},{"excerpt":"Transport The  Transport  base class is intended to abstract a number of client-host communication mechanisms. The basic pattern is that the application registers callbacks to listen for connections, messages and disconnections. Note that the application should not assume that there is only a single connection. There can be multiple remote connections at one time (i.e. multiple cells in a Jupyter Notebook, or multiple UIWebWidgets in an iOS app), which can be tracked by listening to the  onInitialize  and  onFinalize  events. Some examples of communication mechanisms that could be managed via the  Transport  API: Jupyter Widget based communication between a browser and a notebook Browser:  postMessage  based communication between tabs and iframes Android: Communication between Java application and JavaScript running in a  WebView  component iOS: Communication between Swift and JavaScript running in a  UIWebView  component Usage Listening to transport connections, disconnections and messages Static Members Transport.setCallbacks(callbacks: object): void The following callbacks can be set: callbacks.onInitialize callbacks.onMessage callbacks.onFinalize Methods constructor Note: The  Transport  class should not be instantiated explicitly by JavaScript applications.  Transport  instances are automatically created. Remarks Longer term goals: WebSocket  based transport Possibly add additional transports such as Colab notebook specific APIs. Binary data Back-channel: Events Back-channel: Errors","headings":[{"value":"Transport","depth":1},{"value":"Usage","depth":2},{"value":"Static Members","depth":2},{"value":"Transport.setCallbacks(callbacks: object): void","depth":3},{"value":"Methods","depth":2},{"value":"constructor","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/json/docs/transport","title":"Transport"}]}},"staticQueryHashes":["484347790"]}